https://bugs.webkit.org/show_bug.cgi?id=41948
Registerfile can be unwound too far following an exception

Index: JavaScriptCore/interpreter/Interpreter.cpp
===================================================================
--- JavaScriptCore/interpreter/Interpreter.cpp	(revision 70492)
+++ JavaScriptCore/interpreter/Interpreter.cpp	(working copy)
@@ -676,7 +676,15 @@ NEVER_INLINE HandlerInfo* Interpreter::t
     }
 
     // Shrink the JS stack, in case stack overflow made it huge.
-    m_registerFile.shrink(callFrame->registers() + callFrame->codeBlock()->m_numCalleeRegisters);
+    Register* highWaterMark = 0;
+    for (CallFrame* callerFrame = callFrame; callerFrame; callerFrame = callerFrame->callerFrame()->removeHostCallFrameFlag()) {
+        CodeBlock* codeBlock = callerFrame->codeBlock();
+        if (!codeBlock)
+            continue;
+        Register* callerHighWaterMark = callerFrame->registers() + codeBlock->m_numCalleeRegisters;
+        highWaterMark = max(highWaterMark, callerHighWaterMark);
+    }
+    m_registerFile.shrink(highWaterMark);
 
     // Unwind the scope chain within the exception handler's call frame.
     ScopeChainNode* scopeChain = callFrame->scopeChain();
@@ -1001,7 +1009,6 @@ CallFrameClosure Interpreter::prepareFor
         m_registerFile.shrink(oldEnd);
         return CallFrameClosure();
     }
-    // a 0 codeBlock indicates a built-in caller
     newCallFrame->init(codeBlock, 0, scopeChain, callFrame->addHostCallFrameFlag(), argc, function);  
     CallFrameClosure result = { callFrame, newCallFrame, function, FunctionExecutable, scopeChain->globalData, oldEnd, scopeChain, codeBlock->m_numParameters, argc };
     return result;
@@ -1121,7 +1128,6 @@ JSValue Interpreter::execute(EvalExecuta
 
     CallFrame* newCallFrame = CallFrame::create(m_registerFile.start() + globalRegisterOffset);
 
-    // a 0 codeBlock indicates a built-in caller
     ASSERT(codeBlock->m_numParameters == 1); // 1 parameter for 'this'.
     newCallFrame->init(codeBlock, 0, scopeChain, callFrame->addHostCallFrameFlag(), codeBlock->m_numParameters, 0);
     newCallFrame->r(newCallFrame->hostThisRegister()) = JSValue(thisObj);
Index: JavaScriptCore/jit/JITOpcodes32_64.cpp
===================================================================
--- JavaScriptCore/jit/JITOpcodes32_64.cpp	(revision 70492)
+++ JavaScriptCore/jit/JITOpcodes32_64.cpp	(working copy)
@@ -198,6 +198,8 @@ JIT::Label JIT::privateCompileCTINativeC
 
     Label nativeCallThunk = align();
 
+    emitPutImmediateToCallFrameHeader(0, RegisterFile::CodeBlock);
+
 #if CPU(X86)
     // Load caller frame's scope chain into this callframe so that whatever we call can
     // get to its global data.
@@ -312,6 +314,8 @@ JIT::CodePtr JIT::privateCompileCTINativ
     Call nativeCall;
     Label nativeCallThunk = align();
 
+    emitPutImmediateToCallFrameHeader(0, RegisterFile::CodeBlock);
+
 #if CPU(X86)
     // Load caller frame's scope chain into this callframe so that whatever we call can
     // get to its global data.
Index: JavaScriptCore/jit/JITOpcodes.cpp
===================================================================
--- JavaScriptCore/jit/JITOpcodes.cpp	(revision 70492)
+++ JavaScriptCore/jit/JITOpcodes.cpp	(working copy)
@@ -198,6 +198,8 @@ JIT::Label JIT::privateCompileCTINativeC
     int executableOffsetToFunction = isConstruct ? OBJECT_OFFSETOF(NativeExecutable, m_constructor) : OBJECT_OFFSETOF(NativeExecutable, m_function);
 
     Label nativeCallThunk = align();
+    
+    emitPutImmediateToCallFrameHeader(0, RegisterFile::CodeBlock);
 
 #if CPU(X86_64)
     // Load caller frame's scope chain into this callframe so that whatever we call can
