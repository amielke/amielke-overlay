diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIControlFactory.cpp XBMC/guilib/GUIControlFactory.cpp
--- XBMC-unpatched/guilib/GUIControlFactory.cpp	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIControlFactory.cpp	2009-04-13 21:49:00.000000000 +0200
@@ -51,6 +51,8 @@
 #include "GUIListContainer.h"
 #include "GUIFixedListContainer.h"
 #include "GUIWrappingListContainer.h"
+#include "GUIEPGGridContainer.h"
+#include "GUIEPGGridContainer.h"
 #include "GUIPanelContainer.h"
 #include "GUIMultiSelectText.h"
 #include "GUIListLabel.h"
@@ -653,6 +655,8 @@
 
   int focusPosition = 0;
   int scrollTime = 200;
+  int timeBlocks = 36;
+  int rulerUnit = 12;
   bool useControlCoords = false;
   bool renderFocusedLast = false;
 
@@ -901,6 +905,8 @@
   GetAspectRatio(pControlNode, "aspectratio", aspect);
   XMLUtils::GetBoolean(pControlNode, "scroll", bScrollLabel);
   XMLUtils::GetBoolean(pControlNode,"pulseonselect", bPulse);
+  XMLUtils::GetInt(pControlNode, "timeblocks", timeBlocks);
+  XMLUtils::GetInt(pControlNode, "rulerunit", rulerUnit);
 
   GetInfoTexture(pControlNode, "imagepath", texture, texturePath);
 
@@ -1220,6 +1226,12 @@
     ((CGUIWrappingListContainer *)control)->SetType(viewType, viewLabel);
     ((CGUIWrappingListContainer *)control)->SetPageControl(pageControl);
   }
+  else if (strType == "epggrid")
+  {
+    control = new CGUIEPGGridContainer(dwParentId, id, posX, posY, width, height, scrollTime, timeBlocks, rulerUnit);
+    ((CGUIEPGGridContainer *)control)->LoadLayout(pControlNode);
+//    ((CGUIEPGGridContainer *)control)->LoadContent(pControlNode); ///
+  }
   else if (strType == "fixedlist")
   {
     control = new CGUIFixedListContainer(dwParentId, id, posX, posY, width, height, orientation, scrollTime, focusPosition);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIControl.h XBMC/guilib/GUIControl.h
--- XBMC-unpatched/guilib/GUIControl.h	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIControl.h	2009-04-04 20:52:44.000000000 +0200
@@ -243,6 +243,7 @@
     GUICONTAINER_LIST,
     GUICONTAINER_WRAPLIST,
     GUICONTAINER_FIXEDLIST,
+	GUICONTAINER_EPGGRID,
     GUICONTAINER_PANEL
   };
   GUICONTROLTYPES GetControlType() const { return ControlType; }
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIEPGGridContainer.cpp XBMC/guilib/GUIEPGGridContainer.cpp
--- XBMC-unpatched/guilib/GUIEPGGridContainer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/guilib/GUIEPGGridContainer.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,1446 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "include.h"
+#include "stdafx.h"
+#include "GUIEPGGridContainer.h"
+#include "PVRManager.h"
+#include "GUIControlFactory.h"
+#include "GUIListItem.h"
+#include "GUIFontManager.h"
+
+#define SHORTGAP     5 // how many blocks is considered a short-gap in nav logic
+#define MINSPERBLOCK 5 /// would be nice to offer zooming of busy schedules /// performance cost to increase resolution 5 fold?
+#define BLOCKJUMP    4 // how many blocks are jumped with each analogue scroll action
+
+CGUIEPGGridContainer::CGUIEPGGridContainer(DWORD dwParentID, DWORD dwControlId, float posX, float posY,
+    float width, float height, int scrollTime, int timeBlocks, int rulerUnit)
+    : CGUIControl(dwParentID, dwControlId, posX, posY, width, height)
+{
+  ControlType           = GUICONTAINER_EPGGRID;
+  m_blocksPerPage       = timeBlocks;
+  m_blockSize           = 0;
+  m_rulerUnit           = rulerUnit;
+  m_rulerWidth          = 0;
+  m_channelCursor       = 0;
+  m_blockCursor         = 0;
+  m_channelOffset       = 0;
+  m_blockOffset         = 0;
+  m_vertScrollOffset    = 0;
+  m_vertScrollSpeed     = 0;
+  m_vertScrollLastTime  = 0;
+  m_horzScrollOffset    = 0;
+  m_horzScrollSpeed     = 0;
+  m_horzScrollLastTime  = 0;
+  m_scrollTime          = scrollTime ? scrollTime : 1;
+  m_renderTime          = 0;
+  m_item.reset();
+  m_lastItem            = NULL;
+  m_lastChannel         = NULL;
+  m_layout              = NULL;
+  m_focusedLayout       = NULL;
+  m_channelWrapAround   = true; /// get from settings?
+}
+
+CGUIEPGGridContainer::~CGUIEPGGridContainer(void)
+{
+  //Reset();
+}
+
+bool CGUIEPGGridContainer::OnAction(const CAction &action)
+{
+  switch (action.wID)
+  {
+  case ACTION_MOVE_LEFT:
+  case ACTION_MOVE_RIGHT:
+  case ACTION_MOVE_DOWN:
+  case ACTION_MOVE_UP:
+    { // use base class implementation
+
+      return CGUIControl::OnAction(action);
+    }
+
+    break;
+  case ACTION_PAGE_UP:
+    {
+      if (m_channelOffset == 0)
+      { // already on the first page, so move to the first item
+        SetChannel(0);
+      }
+      else
+      { // scroll up to the previous page
+        VerticalScroll(-m_channelsPerPage);
+      }
+
+      return true;
+    }
+
+    break;
+  case ACTION_PAGE_DOWN:
+    {
+      if (m_channelOffset == m_channels - m_channelsPerPage || m_channels < m_channelsPerPage)
+      { // already at the last page, so move to the last item.
+        SetChannel(m_channels - m_channelOffset - 1);
+      }
+      else
+      { // scroll down to the next page
+        VerticalScroll(m_channelsPerPage);
+      }
+
+      return true;
+    }
+
+    break;
+    // smooth scrolling (for analog controls)
+  case ACTION_SCROLL_UP: // left horizontal scrolling
+    {
+      m_analogScrollCount += action.fAmount1 * action.fAmount1;
+      bool handled = false;
+
+      while (m_analogScrollCount > 0.4)
+      {
+        handled = true;
+        m_analogScrollCount -= 0.4f;
+
+        if (m_blockOffset > 0 && m_blockCursor <= m_blocksPerPage / 2)
+        {
+          HorizontalScroll(-BLOCKJUMP);
+        }
+        else if (m_blockCursor > BLOCKJUMP)
+        {
+          SetBlock(m_blockCursor - BLOCKJUMP);
+        }
+      }
+
+      return handled;
+    }
+
+    break;
+  case ACTION_SCROLL_DOWN: // right horizontal scrolling
+    {
+      m_analogScrollCount += action.fAmount1 * action.fAmount1;
+      bool handled = false;
+
+      while (m_analogScrollCount > 0.4)
+      {
+        handled = true;
+        m_analogScrollCount -= 0.4f;
+
+        if (m_blockOffset + m_blocksPerPage < m_blocks && m_blockCursor >= m_blocksPerPage / 2)
+        {
+          HorizontalScroll(BLOCKJUMP);
+        }
+        else if (m_blockCursor < m_blocksPerPage - BLOCKJUMP && m_blockOffset + m_blockCursor < m_blocks - BLOCKJUMP)
+        {
+          SetBlock(m_blockCursor + BLOCKJUMP);
+        }
+      }
+
+      return handled;
+    }
+
+    break;
+
+  default:
+
+    if (action.wID)
+    {
+      return OnClick(action.wID);
+    }
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnMessage(CGUIMessage& message)
+{
+  if (message.GetControlId() == GetID())
+  {
+    if (message.GetMessage() == GUI_MSG_ITEM_SELECTED)
+    {
+      message.SetParam1(GetSelectedItem());
+      return true;
+    }
+    else if (message.GetMessage() == GUI_MSG_LABEL_BIND && message.GetLPVOID())
+    {
+      // bind our items
+      Reset();
+      CFileItemList *items = (CFileItemList *)message.GetLPVOID();
+
+      for (int i = 0; i < items->Size(); i++)
+      {
+        m_items.push_back(items->Get(i));
+      }
+
+      m_gridStart = (time_t)message.GetParam1();
+
+      m_gridEnd   = (time_t)message.GetParam2();
+      UpdateLayout(true); // true to refresh all items
+      UpdateChannels();
+      UpdateItems();
+      //SelectItem(message.GetParam1());
+      return true;
+    }
+  }
+
+  return CGUIControl::OnMessage(message);
+}
+
+void CGUIEPGGridContainer::RenderItem(float posX, float posY, CGUIListItem *item, bool focused)
+{
+  if (!m_focusedLayout || !m_layout) return;
+
+  if (!item)
+    return; /// why are there duff pointers here? should be Unknowns
+
+  // set the origin
+  g_graphicsContext.SetOrigin(posX, posY);
+
+  if (m_bInvalidated)
+    item->SetInvalid();
+
+  if (focused)
+  {
+    if (!item->GetFocusedLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_focusedLayout);
+      item->SetFocusedLayout(layout);
+    }
+
+    if (item->GetFocusedLayout())
+    {
+      if (item != m_lastItem || !HasFocus())
+      {
+        item->GetFocusedLayout()->SetFocusedItem(0);
+      }
+
+      if (item != m_lastItem && HasFocus())
+      {
+        item->GetFocusedLayout()->ResetAnimation(ANIM_TYPE_UNFOCUS);
+        unsigned int subItem = 1;
+
+        if (m_lastItem && m_lastItem->GetFocusedLayout())
+          subItem = m_lastItem->GetFocusedLayout()->GetFocusedItem();
+
+        item->GetFocusedLayout()->SetFocusedItem(subItem ? subItem : 1);
+      }
+
+      item->GetFocusedLayout()->Render(item, m_dwParentID, m_renderTime);
+    }
+
+    m_lastItem = item;
+  }
+  else
+  {
+    if (item->GetFocusedLayout())
+      item->GetFocusedLayout()->SetFocusedItem(0);  // focus is not set
+
+    if (!item->GetLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_layout);
+      item->SetLayout(layout);
+    }
+
+    if (item->GetFocusedLayout() && item->GetFocusedLayout()->IsAnimating(ANIM_TYPE_UNFOCUS))
+      item->GetFocusedLayout()->Render(item, m_dwParentID, m_renderTime);
+    else if (item->GetLayout())
+      item->GetLayout()->Render(item, m_dwParentID, m_renderTime);
+  }
+
+  g_graphicsContext.RestoreOrigin();
+}
+
+void CGUIEPGGridContainer::RenderChannel(float posX, float posY, CGUIListItem *item, bool focused)
+{
+
+  if (!m_focusedChannelLayout || !m_channelLayout) return;
+
+  // set the origin
+  g_graphicsContext.SetOrigin(posX, posY);
+
+  if (m_bInvalidated)
+    item->SetInvalid();
+
+  if (focused)
+  {
+    if (!item->GetFocusedLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_focusedChannelLayout);
+      item->SetFocusedLayout(layout);
+    }
+
+    if (item->GetFocusedLayout())
+    {
+      if (item != m_lastChannel || !HasFocus())
+      {
+        item->GetFocusedLayout()->SetFocusedItem(0);
+      }
+
+      if (item != m_lastChannel && HasFocus())
+      {
+        item->GetFocusedLayout()->ResetAnimation(ANIM_TYPE_UNFOCUS);
+        unsigned int subItem = 1;
+
+        if (m_lastChannel && m_lastChannel->GetFocusedLayout())
+          subItem = m_lastChannel->GetFocusedLayout()->GetFocusedItem();
+
+        item->GetFocusedLayout()->SetFocusedItem(subItem ? subItem : 1);
+      }
+
+      item->GetFocusedLayout()->Render(item, m_dwParentID, m_renderTime);
+    }
+
+    m_lastChannel = item;
+  }
+  else
+  {
+    if (item->GetFocusedLayout())
+      item->GetFocusedLayout()->SetFocusedItem(0);  // focus is not set
+
+    if (!item->GetLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_channelLayout);
+      item->SetLayout(layout);
+    }
+
+    if (item->GetFocusedLayout() && item->GetFocusedLayout()->IsAnimating(ANIM_TYPE_UNFOCUS))
+      item->GetFocusedLayout()->Render(item, m_dwParentID, m_renderTime);
+    else if (item->GetLayout())
+      item->GetLayout()->Render(item, m_dwParentID, m_renderTime);
+  }
+
+  g_graphicsContext.RestoreOrigin();
+}
+
+void CGUIEPGGridContainer::Render()
+{
+
+  ValidateOffset();
+
+  if (m_bInvalidated)
+    UpdateLayout();
+
+  if (!m_layout || !m_focusedLayout || !m_focusedChannelLayout || !m_channelLayout)
+    return;
+
+  m_vertScrollOffset += m_vertScrollSpeed * (m_renderTime - m_vertScrollLastTime);
+
+  if ((m_vertScrollSpeed < 0 && m_vertScrollOffset < m_channelOffset * m_layout->Size(VERTICAL)) ||
+      (m_vertScrollSpeed > 0 && m_vertScrollOffset > m_channelOffset * m_layout->Size(VERTICAL)))
+  {
+    m_vertScrollOffset = m_channelOffset * m_layout->Size(VERTICAL);
+    m_vertScrollSpeed = 0;
+  }
+
+  m_vertScrollLastTime = m_renderTime;
+
+  m_horzScrollOffset += m_horzScrollSpeed * (m_renderTime - m_horzScrollLastTime);
+
+  if ((m_horzScrollSpeed < 0 && m_horzScrollOffset < m_blockOffset * m_blockSize) ||
+      (m_horzScrollSpeed > 0 && m_horzScrollOffset > m_blockOffset * m_blockSize))
+  {
+    m_horzScrollOffset = m_blockOffset * m_blockSize;
+    m_horzScrollSpeed = 0;
+  }
+
+  m_horzScrollLastTime = m_renderTime;
+
+  int chanOffset = (int)(m_vertScrollOffset / m_layout->Size(VERTICAL));
+  int blockOffset = (int)(m_horzScrollOffset / m_blockSize);
+
+  // we offset our draw position to take into account scrolling and whether or not our focused
+  // item is offscreen "above" the list.
+  float vertDrawOffset = chanOffset * m_channelHeight - m_vertScrollOffset;
+  float horzDrawOffset = blockOffset * m_blockSize - m_horzScrollOffset;
+
+  float posY = m_channelPosY;
+  posY += vertDrawOffset;
+
+  RenderItems(horzDrawOffset, posY, chanOffset, blockOffset); // first render the grid
+
+  RenderChannels(posY, chanOffset); // then the channel items column
+
+  RenderRuler(horzDrawOffset, blockOffset); // finally the timeline
+
+  CGUIControl::Render();
+}
+
+void CGUIEPGGridContainer::RenderItems(float horzDrawOffset, float posY, int chanOffset, int blockOffset)
+{
+
+  g_graphicsContext.SetClipRegion(m_gridPosX, m_channelPosY, m_gridWidth, m_gridHeight);
+
+  int channel = chanOffset;
+  float focusedPosX = 0;
+  float focusedPosY = 0;
+
+  CGUIListItemPtr focusedItem;
+
+  while (posY < m_channelPosY + m_gridHeight && m_gridItems.size())  // FOR EACH ROW ///////////////
+  {
+    if (channel >= (int)m_gridItems.size())
+      break;
+
+    int block = blockOffset;
+
+    float posX = m_gridPosX + horzDrawOffset;
+
+    CGUIListItemPtr item;
+
+    item = m_gridIndex[channel][block];
+
+    if (item == m_gridIndex[channel][blockOffset-1] && blockOffset != 0)
+    {
+      /* first program starts before current view */
+      int startBlock = blockOffset - 1;
+
+      while (m_gridIndex[channel][startBlock] == item)
+        startBlock--;
+
+      block = startBlock + 1;
+
+      int missingSection = blockOffset - block;
+
+      posX -= missingSection * m_blockSize;
+    }
+
+    while (posX < m_gridPosX + m_gridWidth && m_gridItems[channel].size())   // FOR EACH ITEM ///////////////
+    {
+
+      item = m_gridIndex[channel][block];
+
+      if (item == NULL)
+      {
+        break;
+      }
+
+      bool focused = (channel == m_channelOffset + m_channelCursor) && (item == m_gridIndex[m_channelOffset + m_channelCursor][m_blockOffset + m_blockCursor]);
+
+      // render our item
+
+      if (focused)
+      {
+        focusedPosX = posX;
+        focusedPosY = posY;
+        focusedItem = item;
+      }
+      else
+        RenderItem(posX, posY, item.get(), focused);
+
+      // increment our X position
+      block += (int)(item->GetLayout()->Size(HORIZONTAL) / m_blockSize);
+
+      posX += item->GetLayout()->Size(HORIZONTAL); // assumes focused & unfocused layouts have equal length
+    }
+
+    // increment our Y position
+    channel++;
+
+    posY += m_channelHeight;
+  }
+
+  // and render the focused item last (for overlapping purposes)
+  if (focusedItem)
+  {
+    //focusedItem->GetLayout()->SetWidth(focusedWidth);
+    RenderItem(focusedPosX, focusedPosY, focusedItem.get(), true);
+  }
+
+  g_graphicsContext.RestoreClipRegion();
+}
+
+void CGUIEPGGridContainer::RenderChannels(float posY, int chanOffset)
+{
+
+  g_graphicsContext.SetClipRegion(m_posX, m_channelPosY, m_channelWidth, m_gridHeight);
+
+  int channel = chanOffset;
+  float focusedChannelPosY = 0;
+  CGUIListItemPtr focusedChannel;
+  CGUIListItemPtr item;
+
+  while (posY < m_channelPosY + m_gridHeight && m_channelItems.size())
+  {
+    if (channel >= (int)m_channelItems.size())
+      break;
+
+    item = m_channelItems[channel];
+
+    //CStdString name = item->GetLabel();
+    //CLog::Log(LOGDEBUG, "Channel Number %u, Name %s", channel, name.c_str());
+    bool focused = (channel == m_channelOffset + m_channelCursor);
+
+    if (focused)
+    {
+      focusedChannelPosY = posY;
+      focusedChannel = item;
+    }
+    else
+      RenderChannel(m_posX, posY, item.get(), focused);
+
+    // increment our Y position
+    channel++;
+
+    posY += m_channelHeight;
+  }
+
+  /* finally, render the currently focused channel last*/
+  if (focusedChannel)
+    RenderChannel(m_posX, focusedChannelPosY, focusedChannel.get(), true);
+
+  g_graphicsContext.RestoreClipRegion();
+}
+
+void CGUIEPGGridContainer::RenderRuler(float horzDrawOffset, int blockOffset)
+{
+
+  if (!m_rulerLayout) return;
+
+  g_graphicsContext.SetClipRegion(m_gridPosX, m_posY, m_gridWidth, m_rulerHeight);
+
+  float posX = m_gridPosX + horzDrawOffset;
+
+  if (blockOffset % m_rulerUnit != 0)
+  {
+    /* first ruler marker starts before current view */
+    int startBlock = blockOffset - 1;
+
+    while (startBlock % m_rulerUnit != 0)
+      startBlock--;
+
+    int missingSection = blockOffset - startBlock;
+
+    posX -= missingSection * m_blockSize;
+  }
+
+  CGUIListItemPtr item;
+
+  while (posX < m_gridPosX + m_gridWidth && m_rulerItems.size())
+  {
+    item = m_rulerItems[blockOffset/m_rulerUnit];
+    // set the origin
+    g_graphicsContext.SetOrigin(posX, m_posY);
+    // render the item
+    item->GetLayout()->Render(item.get(), m_dwParentID, m_renderTime);
+    // restore the origin
+    g_graphicsContext.RestoreOrigin();
+    // increment our X position
+    blockOffset += m_rulerUnit;
+    posX += m_rulerWidth;
+  }
+
+  g_graphicsContext.RestoreClipRegion();
+
+}
+
+void CGUIEPGGridContainer::UpdateRuler()
+{
+
+  if (!m_rulerItems.empty())
+    m_rulerItems.clear();
+
+  CDateTime marker;
+
+  CDateTimeSpan unit;
+
+  marker = m_gridStart;
+
+  unit.SetDateTimeSpan(0, 0, m_rulerUnit * MINSPERBLOCK, 0);
+
+  for (; marker < m_gridEnd; marker += unit)
+  {
+    CGUIListItemLayout *pRulerLayout = new CGUIListItemLayout(*m_rulerLayout);
+    CGUIListItemPtr markerItem(new CGUIListItem(marker.GetAsLocalizedTime("", false)));
+    pRulerLayout->SetWidth(m_rulerWidth);
+    markerItem->SetLayout(pRulerLayout);
+    m_rulerItems.push_back(markerItem);
+  }
+}
+
+void CGUIEPGGridContainer::UpdateChannels()
+{
+
+  if (!m_channelItems.empty())
+  {
+    m_channelItems.clear();
+    m_epgItemsPtr.clear();
+  }
+
+  int lastChannel = -1;
+
+  for (unsigned int i = 0; i < m_items.size(); ++i)
+  {
+    if (m_items[i]->GetTVEPGInfoTag()->m_channelNum != lastChannel)
+    {
+      lastChannel = m_items[i]->GetTVEPGInfoTag()->m_channelNum;
+
+      CGUIListItemLayout *pChannelLayout = new CGUIListItemLayout(*m_channelLayout);
+      CGUIListItemLayout *pChannelFocusedLayout = new CGUIListItemLayout(*m_focusedChannelLayout);
+      pChannelLayout->SetWidth(m_channelWidth);
+      pChannelFocusedLayout->SetWidth(m_channelWidth);
+
+      CGUIListItemPtr item(new CGUIListItem(m_items[i]->GetTVEPGInfoTag()->m_strChannel));
+      item->SetLabel2(m_items[i]->GetTVEPGInfoTag()->m_strChannel);
+      item->SetThumbnailImage(m_items[i]->GetTVEPGInfoTag()->m_IconPath);
+      item->SetLayout(pChannelLayout);
+      item->SetFocusedLayout(pChannelFocusedLayout);
+      m_channelItems.push_back(item);
+      m_epgItemsPtr.push_back(i);
+    }
+  }
+}
+
+void CGUIEPGGridContainer::UpdateItems()
+{
+  if (!m_gridItems.empty())
+    m_gridItems.clear();
+
+  CDateTimeSpan blockDuration, gridDuration;
+
+  gridDuration = m_gridEnd - m_gridStart;
+
+  m_blocks = (gridDuration.GetDays()*24*60 + gridDuration.GetHours()*60 + gridDuration.GetMinutes()) / MINSPERBLOCK;
+
+  /* if less than one page, can't display grid */
+  if (m_blocks < m_blocksPerPage)
+  {
+    CLog::Log(LOGERROR, "(%s) - Less than one page of data available.", __FUNCTION__);
+    CGUIMessage msg(GUI_MSG_LABEL_RESET, GetID(), GetParentID()); // message the window
+    SendWindowMessage(msg);
+    return;
+  }
+
+  blockDuration.SetDateTimeSpan(0, 0, MINSPERBLOCK, 0);
+
+  DWORD tick(timeGetTime());
+
+  for (unsigned int row = 0; row < m_channelItems.size(); ++row)
+  {
+    CDateTime gridCursor = m_gridStart; //reset cursor for new channel
+    CFileItemPtr programme;
+    unsigned long progIdx = m_epgItemsPtr[row];
+
+    if (!m_items[progIdx]->IsTVEPG())
+      continue;
+    if (m_items[progIdx]->GetTVEPGInfoTag() == NULL)
+      continue;
+
+    unsigned int channelnum = m_items[progIdx]->GetTVEPGInfoTag()->m_channelNum;
+
+    /** FOR EACH BLOCK **********************************************************************/
+
+    for (int block = 0; block < m_blocks; block++)
+    {
+      unsigned long lastIdx;
+
+      if (row < m_channelItems.size()-1)
+        lastIdx = m_epgItemsPtr[row+1];
+      else
+        lastIdx = m_items.size();
+
+      while (progIdx < lastIdx)
+      {
+        if (m_items[progIdx]->GetTVEPGInfoTag()->m_channelNum != channelnum)
+          break;
+
+        programme = m_items[progIdx];
+
+        if (programme == NULL)
+          progIdx++;
+
+        if (programme->GetTVEPGInfoTag() == NULL)
+          progIdx++;
+
+        if (m_gridEnd <= programme->GetTVEPGInfoTag()->m_startTime)
+        {
+          break;
+        }
+        else if (gridCursor >= programme->GetTVEPGInfoTag()->m_endTime)
+        {
+          progIdx++;
+        }
+        else if (gridCursor < programme->GetTVEPGInfoTag()->m_endTime)
+        {
+          m_gridIndex[row][block] = programme;
+          break;
+        }
+        else
+        {
+          progIdx++;
+        }
+      }
+
+      gridCursor += blockDuration;
+    }
+
+    /** FOR EACH BLOCK **********************************************************************/
+    int itemSize = 1; // size of the programme in blocks
+
+    std::vector< CGUIListItemPtr > items; // this channel's items
+
+    for (int block = 0; block < m_blocks; block++)
+    {
+      if (m_gridIndex[row][block] != m_gridIndex[row][block+1])
+      {
+        GenerateItemLayout(row, itemSize, block);
+        items.push_back(m_gridIndex[row][block]);
+        itemSize = 1;
+      }
+      else
+      {
+        itemSize++;
+      }
+    }
+
+    m_gridItems.push_back(items);  // store this channel's gridItems
+  }
+
+  /******************************************* END ******************************************/
+
+  if (m_gridItems.size() < 1)
+  {
+    CLog::Log(LOGDEBUG, "%s No data found", __FUNCTION__);
+    return;
+  }
+
+  CLog::Log(LOGDEBUG, "%s completed successfully in %u ms", __FUNCTION__, timeGetTime()-tick);
+
+  m_channels = (int)m_gridItems.size();
+  m_item = GetItem(m_channelCursor);
+  m_blockCursor = GetBlock(m_item, m_channelCursor);
+
+  UpdateRuler();
+  SetInvalid();
+}
+
+void CGUIEPGGridContainer::VerticalScroll(int amount)
+{
+  // increase or decrease the vertical offset
+  int offset = m_channelOffset + amount;
+
+  if (offset > m_channels - m_channelsPerPage)
+  {
+    offset = m_channels - m_channelsPerPage;
+  }
+
+  if (offset < 0) offset = 0;
+
+  ScrollToChannelOffset(offset);
+}
+
+void CGUIEPGGridContainer::HorizontalScroll(int amount)
+{
+  // increase or decrease the horizontal offset
+  int offset = m_blockOffset + amount;
+
+  if (offset > m_blocks - m_blocksPerPage)
+  {
+    offset = m_blocks - m_blocksPerPage;
+  }
+
+  if (offset < 0) offset = 0;
+
+  ScrollToBlockOffset(offset);
+}
+
+void CGUIEPGGridContainer::OnUp()
+{
+  if (m_channelCursor > 0)
+  {
+    SetChannel(m_channelCursor - 1);
+  }
+  else if (m_channelCursor == 0 && m_channelOffset)
+  {
+    ScrollToChannelOffset(m_channelOffset - 1);
+    SetChannel(0);
+  }
+  else if (m_channelWrapAround)
+  {
+    int offset = m_channels - m_channelsPerPage;
+
+    if (offset < 0) offset = 0;
+
+    SetChannel(m_channels - offset - 1);
+
+    ScrollToChannelOffset(offset);
+  }
+  else
+    CGUIControl::OnUp();
+}
+
+void CGUIEPGGridContainer::OnDown()
+{
+
+  if (m_channelOffset + m_channelCursor + 1 < m_channels)
+  {
+    if (m_channelCursor + 1 < m_channelsPerPage)
+    {
+      SetChannel(m_channelCursor + 1);
+    }
+    else
+    {
+      ScrollToChannelOffset(m_channelOffset + 1);
+      SetChannel(m_channelsPerPage - 1);
+    }
+  }
+  else if (m_channelWrapAround)
+  {
+    SetChannel(0);
+    ScrollToChannelOffset(0);
+  }
+  else
+    CGUIControl::OnDown();
+}
+
+void CGUIEPGGridContainer::OnLeft()
+{
+
+  if (m_item != m_gridIndex[m_channelCursor + m_channelOffset][m_blockOffset])
+  {
+    // this is not first item on page
+    m_item = GetPrevItem(m_channelCursor);
+    m_blockCursor = GetBlock(m_item, m_channelCursor);
+  }
+  else if (m_blockCursor == 0 && m_blockOffset)
+  {
+    // we're at the left edge and offset
+    int itemSize = GetItemSize(m_item);
+    int block = GetRealBlock(m_item, m_channelCursor);
+
+    if (block < m_blockOffset) /* current item begins before current offset, keep selected */
+    {
+      if (itemSize > m_blocksPerPage) /* current item is longer than one page, scroll one page left */
+      {
+        m_blockOffset < m_blocksPerPage ? block = 0 : block = m_blockOffset - m_blocksPerPage; // number blocks left < m_blocksPerPAge
+        ScrollToBlockOffset(block);
+        SetBlock(0);
+      }
+      else /* current item is shorter than one page, scroll left to start of item */
+      {
+        ScrollToBlockOffset(block); // -1?
+        SetBlock(0); // align cursor to left edge
+      }
+    }
+    else /* current item starts on this page's edge, select the previous item */
+    {
+      m_item = GetPrevItem(m_channelCursor);
+      itemSize = GetItemSize(m_item);
+
+      if (itemSize > m_blocksPerPage) // previous item is longer than one page, scroll left to last page of item */
+      {
+        ScrollToBlockOffset(m_blockOffset - m_blocksPerPage); // left one whole page
+        //SetBlock(m_blocksPerPage -1 ); // helps navigation by setting cursor to far right edge
+        SetBlock(0); // align cursor to left edge
+      }
+      else /* previous item is shorter than one page, scroll left to start of item */
+      {
+        ScrollToBlockOffset(m_blockOffset - itemSize);
+        SetBlock(0); //should be zero
+      }
+    }
+  }
+
+  /*else if (m_channelWrapAround) ///
+  {
+    int offset = m_blocks - m_blocksPerPage;
+    if (offset < 0)
+      offset = 0;
+    ScrollToBlockOffset(offset);
+  }*/
+  else
+    CGUIControl::OnLeft();
+
+  /* call CGUIWindowEPG::OnLeft(); to load previous range of dates*/
+}
+
+void CGUIEPGGridContainer::OnRight()
+{
+
+  if (m_item != m_gridIndex[m_channelCursor + m_channelOffset][m_blocksPerPage + m_blockOffset - 1])
+  {
+    // this is not last item on page
+    m_item = GetNextItem(m_channelCursor);
+    m_blockCursor = GetBlock(m_item, m_channelCursor);
+  }
+  else if ((m_blockOffset != m_blocks - m_blocksPerPage) && m_blocks > m_blocksPerPage)
+  {
+    // at right edge, more than one page and not at maximum offset
+    int itemSize = GetItemSize(m_item);
+    int block = GetRealBlock(m_item, m_channelCursor);
+
+    if (itemSize > m_blocksPerPage - m_blockCursor) // current item extends into next page, keep selected
+    {
+      if (itemSize > m_blocksPerPage) // current item is longer than one page, scroll one page right
+      {
+        if (m_blockOffset && m_blockOffset + m_blocksPerPage > m_blocks)
+          block = m_blocks - m_blocksPerPage;
+        else
+          block = m_blockOffset + m_blocksPerPage;
+
+        ScrollToBlockOffset(block);
+
+        SetBlock(0);
+      }
+      else // current item is shorter than one page, scroll so end of item sits on end of grid
+      {
+        ScrollToBlockOffset(block + itemSize - m_blocksPerPage);
+        SetBlock(GetBlock(m_item, m_channelCursor)); /// change to middle block of item?
+      }
+    }
+    else // current item finishes on this page's edge, select the next item
+    {
+      m_item = GetNextItem(m_channelCursor);
+      itemSize = GetItemSize(m_item);
+
+      if (itemSize > m_blocksPerPage) // next item is longer than one page, scroll to first page of this item
+      {
+        ScrollToBlockOffset(m_blockOffset + m_blocksPerPage);
+        SetBlock(0);
+      }
+      else // next item is shorter than one page, scroll so end of item sits on end of grid
+      {
+        ScrollToBlockOffset(m_blockOffset + itemSize);
+        SetBlock(m_blocksPerPage - itemSize); /// change to middle block of item?
+      }
+    }
+  }
+  else
+    CGUIControl::OnRight();
+
+  /// call parent handler CGUIWindowEPG::OnRight(); to load next range of dates
+}
+
+void CGUIEPGGridContainer::SetChannel(int channel)
+{
+
+  if (m_blockCursor + m_blockOffset == 0 || m_blockOffset + m_blockCursor + GetItemSize(m_item) == m_blocks)
+  {
+    m_item = GetItem(channel);
+    m_blockCursor = GetBlock(m_item, channel);
+    m_channelCursor = channel;
+    return;
+  }
+
+  /* basic checks failed, need to correctly identify nearest item */
+  m_item = GetClosestItem(channel);
+
+  m_channelCursor = channel;
+
+  m_blockCursor = GetBlock(m_item, m_channelCursor);
+}
+
+void CGUIEPGGridContainer::SetBlock(int block)
+{
+
+  m_blockCursor = block;
+  m_item = GetItem(m_channelCursor);
+}
+
+CGUIListItemLayout *CGUIEPGGridContainer::GetFocusedLayout() const
+{
+
+  CGUIListItemPtr item = GetListItem(0);
+
+  if (item.get()) return item->GetFocusedLayout();
+
+  return NULL;
+}
+
+bool CGUIEPGGridContainer::SelectItemFromPoint(const CPoint &point)
+{
+  /* point has already had origin set to m_posX, m_posY */
+
+  if (!m_focusedLayout || !m_layout)
+    return false;
+
+  int channel = (int)(point.y / m_channelHeight);
+
+  int block   = (int)(point.x / m_blockSize);
+
+  if (channel > m_channelsPerPage) channel = m_channelsPerPage - 1;
+
+  if (channel < 0) channel = 0;
+
+  if (block > m_blocksPerPage) block = m_blocksPerPage - 1;
+
+  if (block < 0) block = 0;
+
+  SetChannel(channel);
+
+  SetBlock(block);
+
+  return true;
+}
+
+bool CGUIEPGGridContainer::OnMouseOver(const CPoint &point)
+{
+  // select the item under the pointer
+  SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight));
+  return CGUIControl::OnMouseOver(point);
+}
+
+bool CGUIEPGGridContainer::OnMouseClick(DWORD dwButton, const CPoint &point)
+{
+  if (SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight)))
+  { // send click message to window
+    OnClick(ACTION_MOUSE_CLICK + dwButton);
+    return true;
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnMouseDoubleClick(DWORD dwButton, const CPoint &point)
+{
+  if (SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight)))
+  { // send double click message to window
+    OnClick(ACTION_MOUSE_DOUBLE_CLICK + dwButton);
+    return true;
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnClick(DWORD actionID)
+{
+  int subItem = 0;
+
+  if (actionID == ACTION_SELECT_ITEM || actionID == ACTION_MOUSE_LEFT_CLICK)
+  {
+    // grab the currently focused subitem (if applicable)
+    CGUIListItemLayout *focusedLayout = GetFocusedLayout();
+
+    if (focusedLayout)
+      subItem = focusedLayout->GetFocusedItem();
+  }
+
+  // Don't know what to do, so send to our parent window.
+  CGUIMessage msg(GUI_MSG_CLICKED, GetID(), GetParentID(), actionID, subItem);
+
+  return SendWindowMessage(msg);
+}
+
+bool CGUIEPGGridContainer::OnMouseWheel(char wheel, const CPoint &point)
+{
+  ///doesn't work while an item is selected?
+  HorizontalScroll(-wheel);
+  return true;
+}
+
+CFileItemPtr CGUIEPGGridContainer::GetSelectedItemPtr() const
+{
+  return m_gridIndex[m_channelCursor + m_channelOffset][m_blockCursor + m_blockOffset]; ///
+}
+
+CGUIListItemPtr CGUIEPGGridContainer::GetListItem(int offset) const
+{
+  if (!m_gridItems.size())
+    return CGUIListItemPtr();
+
+  return m_item;
+}
+
+CGUIListItemPtr CGUIEPGGridContainer::GetClosestItem(const int &channel)
+{
+  CGUIListItemPtr closest = GetItem(channel);
+  int block = GetBlock(closest, channel);
+  int left;   // num blocks to start of previous item
+  int right;  // num blocks to start of next item
+
+  if (block == m_blockCursor)
+    return closest; // item & m_item start together
+
+  if (block + GetItemSize(closest) == m_blockCursor + GetItemSize(m_item))
+    return closest; // closest item ends when current does
+
+  if (block > m_blockCursor)  // item starts after m_item
+  {
+    left = m_blockCursor - GetBlock(closest, channel);
+    right = block - m_blockCursor;
+  }
+  else
+  {
+    left  = m_blockCursor - block;
+    right = GetBlock(GetNextItem(channel), channel) - m_blockCursor;
+  }
+
+
+  if (right <= SHORTGAP && right <= left && m_blockCursor + right < m_blocksPerPage)
+    return m_gridIndex[channel + m_channelOffset][m_blockCursor + right + m_blockOffset];
+  else
+    return m_gridIndex[channel + m_channelOffset][m_blockCursor - left  + m_blockOffset];
+}
+
+int CGUIEPGGridContainer::GetItemSize(CGUIListItemPtr item)
+{
+  if (!item)
+    return 0; /// stops it crashing
+
+  return (int)(item->GetLayout()->Size(HORIZONTAL) / m_blockSize);
+}
+
+///*************** could store this value as a CGUIListItem property **********************/
+int CGUIEPGGridContainer::GetBlock(const CGUIListItemPtr &item, const int &channel)
+{
+  return GetRealBlock(item, channel) - m_blockOffset;
+}
+
+int CGUIEPGGridContainer::GetRealBlock(const CGUIListItemPtr &item, const int &channel)
+{
+  int block = 0;
+
+  while (m_gridIndex[channel + m_channelOffset][block] != item && block < m_blocks)
+    block++;
+
+  return block;
+}
+
+/******************************************************************************************/
+
+void CGUIEPGGridContainer::GenerateItemLayout(int row, int itemSize, int block)
+{
+  CGUIListItemLayout *pItemLayout = new CGUIListItemLayout(*m_layout);
+  CGUIListItemLayout *pItemFocusedLayout = new CGUIListItemLayout(*m_focusedLayout);
+  pItemLayout->SetWidth(itemSize*m_blockSize);
+  pItemFocusedLayout->SetWidth(itemSize*m_blockSize);
+
+  if (!m_gridIndex[row][block])
+  {
+    CTVEPGInfoTag broadcast(NULL);
+
+    broadcast.m_strChannel        = g_localizeStrings.Get(18074);
+    broadcast.m_strTitle          = g_localizeStrings.Get(18074);
+    broadcast.m_strPlotOutline    = "";
+    broadcast.m_strPlot           = "";
+    broadcast.m_GenreType         = 0;
+    broadcast.m_GenreSubType      = 0;
+    broadcast.m_strGenre          = "";
+
+    CFileItemPtr unknown(new CFileItem(broadcast));
+
+    for (int i = block ; i > block - itemSize; i--)
+    {
+      m_gridIndex[row][i] = unknown;
+    }
+  }
+
+  switch (m_gridIndex[row][block]->GetTVEPGInfoTag()->m_GenreType)
+  {
+  case EVCONTENTMASK_MOVIEDRAMA:
+    pItemLayout->SetVisible(1);
+    break;
+  case EVCONTENTMASK_NEWSCURRENTAFFAIRS:
+    pItemLayout->SetVisible(2);
+    break;
+  case EVCONTENTMASK_SHOW:
+    pItemLayout->SetVisible(3);
+    break;
+  case EVCONTENTMASK_SPORTS:
+    pItemLayout->SetVisible(4);
+    break;
+  case EVCONTENTMASK_CHILDRENYOUTH:
+    pItemLayout->SetVisible(5);
+    break;
+  case EVCONTENTMASK_MUSICBALLETDANCE:
+    pItemLayout->SetVisible(6);
+    break;
+  case EVCONTENTMASK_ARTSCULTURE:
+    pItemLayout->SetVisible(7);
+    break;
+  case EVCONTENTMASK_SOCIALPOLITICALECONOMICS:
+    pItemLayout->SetVisible(8);
+    break;
+  case EVCONTENTMASK_EDUCATIONALSCIENCE:
+    pItemLayout->SetVisible(9);
+    break;
+  case EVCONTENTMASK_LEISUREHOBBIES:
+    pItemLayout->SetVisible(10);
+    break;
+  case EVCONTENTMASK_SPECIAL:
+    pItemLayout->SetVisible(11);
+    break;
+  case EVCONTENTMASK_USERDEFINED:
+  default:
+    pItemLayout->SetVisible(12);
+    break;
+  }
+
+  m_gridIndex[row][block]->SetFocusedLayout(pItemFocusedLayout);
+
+  m_gridIndex[row][block]->SetLayout(pItemLayout);
+
+  //m_lastItem = m_gridIndex[row][block]; ///?
+  //m_lastChannel = m_channelItems[row];
+}
+
+/// store numerical position in m_gridData[channel] as a property of CGUIListItem
+CGUIListItemPtr CGUIEPGGridContainer::GetNextItem(const int &channel)
+{
+  int i = m_blockCursor;
+
+  while (m_gridIndex[channel + m_channelOffset][i + m_blockOffset] == m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset] && i < m_blocksPerPage)
+    i++;
+
+  return m_gridIndex[channel + m_channelOffset][i + m_blockOffset];
+}
+
+CGUIListItemPtr CGUIEPGGridContainer::GetPrevItem(const int &channel)
+{
+  return m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset - 1];
+}
+
+CGUIListItemPtr CGUIEPGGridContainer::GetItem(const int &channel)
+{
+  return m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset];
+}
+
+void CGUIEPGGridContainer::SetFocus(bool bOnOff)
+{
+  if (bOnOff != HasFocus())
+  {
+    SetInvalid();
+    /*m_lastItem.reset();
+    m_lastChannel.reset();*/
+  }
+
+  CGUIControl::SetFocus(bOnOff);
+}
+
+void CGUIEPGGridContainer::DoRender(DWORD currentTime)
+{
+  m_renderTime = currentTime;
+  CGUIControl::DoRender(currentTime);
+  m_wasReset = false;
+}
+
+void CGUIEPGGridContainer::ScrollToChannelOffset(int offset)
+{
+  float size = m_layout->Size(VERTICAL);
+  int range = m_channelsPerPage / 4;
+
+  if (range <= 0) range = 1;
+
+  if (offset * size < m_vertScrollOffset &&  m_vertScrollOffset - offset * size > size * range)
+  { // scrolling up, and we're jumping more than 0.5 of a screen
+    m_vertScrollOffset = (offset + range) * size;
+  }
+
+  if (offset * size > m_vertScrollOffset && offset * size - m_vertScrollOffset > size * range)
+  { // scrolling down, and we're jumping more than 0.5 of a screen
+    m_vertScrollOffset = (offset - range) * size;
+  }
+
+  m_vertScrollSpeed = (offset * size - m_vertScrollOffset) / m_scrollTime;
+
+  m_channelOffset = offset;
+}
+
+void CGUIEPGGridContainer::ScrollToBlockOffset(int offset)
+{
+  float size = m_blockSize;
+  int range = m_blocksPerPage / 1;
+
+  if (range <= 0) range = 1;
+
+  if (offset * size < m_horzScrollOffset &&  m_horzScrollOffset - offset * size > size * range)
+  { // scrolling left, and we're jumping more than 0.5 of a screen
+    m_horzScrollOffset = (offset + range) * size;
+  }
+
+  if (offset * size > m_horzScrollOffset && offset * size - m_horzScrollOffset > size * range)
+  { // scrolling right, and we're jumping more than 0.5 of a screen
+    m_horzScrollOffset = (offset - range) * size;
+  }
+
+  m_horzScrollSpeed = (offset * size - m_horzScrollOffset) / m_scrollTime;
+
+  m_blockOffset = offset;
+}
+
+void CGUIEPGGridContainer::ValidateOffset()
+{
+  if (!m_layout)
+    return;
+
+  if (m_channelOffset > m_channels - m_channelsPerPage)
+  {
+    m_channelOffset = m_channels - m_channelsPerPage;
+    m_vertScrollOffset = m_channelOffset * m_channelHeight;
+  }
+
+  if (m_channelOffset < 0)
+  {
+    m_channelOffset = 0;
+    m_vertScrollOffset = 0;
+  }
+
+  if (m_blockOffset > m_blocks - m_blocksPerPage)
+  {
+    m_blockOffset = m_blocks - m_blocksPerPage;
+    m_horzScrollOffset = m_blockOffset * m_blockSize;
+  }
+
+  if (m_blockOffset < 0)
+  {
+    m_blockOffset = 0;
+    m_horzScrollOffset = 0;
+  }
+}
+
+void CGUIEPGGridContainer::LoadLayout(TiXmlElement *layout)
+{
+  TiXmlElement *itemElement;
+
+  /* layout for the timeline above the grid */
+  itemElement = layout->FirstChildElement("rulerlayout");
+
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, true);
+    m_rulerLayout = new CGUIListItemLayout(itemLayout);
+    itemElement = itemElement->NextSiblingElement("rulerlayout");
+  }
+
+  /* layouts for the channel column */
+  itemElement = layout->FirstChildElement("channellayout");
+
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, false);
+    m_channelLayout = new CGUIListItemLayout(itemLayout);
+    itemElement = itemElement->NextSiblingElement("channellayout");
+  }
+
+  itemElement = layout->FirstChildElement("focusedchannellayout");
+
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, true);
+    m_focusedChannelLayout = new CGUIListItemLayout(itemLayout);
+    itemElement = itemElement->NextSiblingElement("focusedchannellayout");
+  }
+
+  /* layouts for the grid items */
+  itemElement = layout->FirstChildElement("itemlayout");
+
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, false);
+    m_layout = new CGUIListItemLayout(itemLayout);
+    itemElement = itemElement->NextSiblingElement("itemlayout");
+  }
+
+  itemElement = layout->FirstChildElement("focusedlayout");
+
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, true);
+    m_focusedLayout = new CGUIListItemLayout(itemLayout);
+    itemElement = itemElement->NextSiblingElement("focusedlayout");
+  }
+
+  CalculateLayout(); /// why do I need to call this
+}
+
+void CGUIEPGGridContainer::UpdateLayout(bool updateAllItems)
+{
+  // if container is invalid, either new data has arrived, or m_blockSize has changed
+  //  need to run UpdateItems rather than CalculateLayout?
+  if (updateAllItems)
+  { // free memory of items
+    for (iChannels itC = m_gridItems.begin(); itC != m_gridItems.end(); itC++)
+    {
+      for (iShows itS = itC->begin(); itS != itC->end(); itS++)
+      {
+        (*itS)->FreeMemory();
+      }
+    }
+  }
+
+  // and recalculate the layout
+  CalculateLayout();
+}
+
+void CGUIEPGGridContainer::CalculateLayout()
+{
+  assert(m_focusedLayout && m_layout && m_focusedChannelLayout && m_channelLayout && m_rulerLayout);
+
+  if (!m_focusedLayout || !m_layout || !m_focusedChannelLayout || !m_channelLayout || !m_rulerLayout)
+  {
+    UpdateLayout(true);
+    return;
+  }
+
+  m_channelHeight = m_channelLayout->Size(VERTICAL);
+
+  m_channelWidth  = m_channelLayout->Size(HORIZONTAL);
+  m_rulerHeight   = m_rulerLayout->Size(VERTICAL);
+
+  /* EPG grid */
+  m_gridPosX   = m_posX + m_channelWidth;
+  m_gridWidth  = m_width - m_channelWidth;
+  m_gridHeight = m_height - m_rulerHeight;
+  m_blockSize  = m_gridWidth / m_blocksPerPage;
+
+  /* ruler */
+  m_rulerWidth  = m_rulerUnit * m_blockSize;
+
+  /* channel column */
+  m_channelPosY   = m_posY + m_rulerHeight;
+  m_channelsPerPage = (int)((m_gridHeight - m_channelHeight) / m_channelHeight) + 1;
+
+
+  // ensure that the scroll offsets are a multiple of our sizes
+  m_vertScrollOffset = m_channelOffset * m_layout->Size(VERTICAL);
+  m_horzScrollOffset = m_blockOffset * m_blockSize;
+}
+
+CStdString CGUIEPGGridContainer::GetDescription() const
+{
+  CStdString strLabel;
+  //unsigned item = GetSelectedItem();
+  //if (item >= 0 && item < GetNumItems())
+  //{
+  //  /*CGUIListItem pItem = m_gridItems[0][item];*/
+  //  //strLabel = pItem.GetLabel(); // get ptr
+  //}
+  return strLabel;
+}
+
+void CGUIEPGGridContainer::Reset()
+{
+  m_wasReset = true;
+
+  for (iChannels itC = m_gridItems.begin(); itC != m_gridItems.end(); itC++)
+  {
+    itC->clear();
+  }
+
+  m_lastItem = NULL;
+
+  m_lastChannel = NULL;
+  m_items.clear();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIEPGGridContainer.h XBMC/guilib/GUIEPGGridContainer.h
--- XBMC-unpatched/guilib/GUIEPGGridContainer.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/guilib/GUIEPGGridContainer.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,172 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DateTime.h"
+#include "FileItem.h"
+#include "GUIControl.h"
+#include "GUIListItemLayout.h"
+
+#define MAXCHANNELS 500
+#define MAXBLOCKS   1152 //! !!_FOUR_!! days of 5 minute blocks
+
+class CGUIEPGGridContainer : public CGUIControl
+{
+public:
+  CGUIEPGGridContainer(DWORD dwParentID, DWORD dwControlId, float posX, float posY,
+                       float width, float height, int scrollTime, int minutesPerPage,
+                       int rulerUnit);
+  virtual ~CGUIEPGGridContainer(void);
+  virtual CGUIEPGGridContainer *Clone() const { return new CGUIEPGGridContainer(*this); };
+
+  virtual bool OnAction(const CAction &action);
+  virtual void OnDown();
+  virtual void OnUp();
+  virtual void OnLeft();
+  virtual void OnRight();
+  virtual bool OnMouseOver(const CPoint &point);
+  virtual bool OnMouseClick(DWORD dwButton, const CPoint &point);
+  virtual bool OnMouseDoubleClick(DWORD dwButton, const CPoint &point);
+  virtual bool OnMouseWheel(char wheel, const CPoint &point);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual void SetFocus(bool bOnOff);
+
+  CStdString GetDescription() const;
+  const int GetNumChannels()   { return m_channels; };
+  virtual int GetSelectedItem() const { return 0; }; /// doesn't currently store last position
+  CFileItemPtr GetSelectedItemPtr() const;
+  const int GetSelectedChannel() { return m_channelCursor + m_channelOffset; }
+
+  void DoRender(DWORD currentTime);
+  void Render();
+  void LoadLayout(TiXmlElement *layout);
+  void LoadContent(TiXmlElement *content);
+
+  virtual bool IsContainer() const { return true; };
+  CGUIListItemPtr GetListItem(int offset) const;
+
+protected:
+  bool OnClick(DWORD actionID);
+  bool SelectItemFromPoint(const CPoint &point);
+
+  void UpdateRuler();
+  void UpdateItems();
+  void UpdateChannels();
+
+  void RenderRuler(float horzDrawOffset, int blockOffset);
+  void RenderChannels(float posY, int chanOffset); //! render the column of channels
+  void RenderItems(float horzDrawOffset, float posY, int chanOffset, int blockOffset); //! render the grid of items
+
+  void RenderChannel(float posX, float posY, CGUIListItem *item, bool focused); //! render an individual channel layout
+  void RenderItem(float posX, float posY, CGUIListItem *item, bool focused); //! render an individual gridItem layout
+
+  void SetChannel(int channel);
+  void SetBlock(int block);
+  void VerticalScroll(int amount);
+  void HorizontalScroll(int amount);
+  void ValidateOffset();
+  void UpdateLayout(bool refreshAllItems = false);
+  void CalculateLayout();
+  void GenerateItemLayout(int row, int itemSize, int block);
+  void Reset();
+
+  CGUIListItemPtr GetItem(const int &channel);
+  CGUIListItemPtr GetNextItem(const int &channel);
+  CGUIListItemPtr GetPrevItem(const int &channel);
+  CGUIListItemPtr GetClosestItem(const int &channel);
+
+  int  GetItemSize(CGUIListItemPtr item);
+  int  GetBlock(const CGUIListItemPtr &item, const int &channel);
+  int  GetRealBlock(const CGUIListItemPtr &item, const int &channel);
+  void MoveToRow(int row);
+  void FreeMemory(int keepStart, int keepEnd);
+  void GetCurrentLayouts();
+
+  CGUIListItemLayout *GetFocusedLayout() const;
+
+  void ScrollToBlockOffset(int offset);
+  void ScrollToChannelOffset(int offset);
+
+private:
+  int   m_rulerUnit; //! number of blocks that makes up one element of the ruler
+  int   m_channels;
+  int   m_channelsPerPage;
+  int   m_channelCursor;
+  int   m_channelOffset;
+  int   m_blocks;
+  int   m_blocksPerPage;
+  int   m_blockCursor;
+  int   m_blockOffset;
+
+  float m_channelPosY; //! Y position of first channel row
+  float m_gridPosX; //! X position of first grid item
+  float m_gridWidth;
+  float m_gridHeight;
+  float m_rulerHeight; //! height of the scrolling timeline above the grid items
+  float m_rulerWidth; //! width of each element of the ruler
+  float m_channelHeight;  //! height of each channel row (& every grid item)
+  float m_channelWidth; //! width of the channel item
+  float m_blockSize; //! a block's width in pixels
+  float m_analogScrollCount;
+
+  CDateTime m_gridStart;
+  CDateTime m_gridEnd;
+
+  std::vector< CGUIListItemPtr > m_rulerItems;
+  std::vector< CGUIListItemPtr > m_channelItems;
+  std::vector< long > m_epgItemsPtr;
+  std::vector< CFileItemPtr > m_items;
+  typedef std::vector<CFileItemPtr> ::iterator iItems;
+  CGUIListItemPtr m_channel;
+
+  CFileItemPtr m_gridIndex[MAXCHANNELS][MAXBLOCKS];
+  std::vector< std::vector< CGUIListItemPtr > > m_gridItems;
+  typedef std::vector< std::vector< CGUIListItemPtr > >::iterator iChannels;
+  typedef std::vector< CGUIListItemPtr >::iterator iShows;
+  CGUIListItemPtr  m_item;
+  CGUIListItem *m_lastItem;
+  CGUIListItem *m_lastChannel;
+
+  DWORD m_renderTime;
+
+
+  CGUIListItemLayout *m_rulerLayout;
+  CGUIListItemLayout *m_channelLayout;
+  CGUIListItemLayout *m_focusedChannelLayout;
+  CGUIListItemLayout *m_layout;
+  CGUIListItemLayout *m_focusedLayout;
+
+  int   m_scrollTime;
+  bool  m_channelWrapAround;
+  bool  m_gridWrapAround; //! only when no more data available should this be true
+
+  DWORD m_horzScrollLastTime;
+  float m_horzScrollSpeed;
+  float m_horzScrollOffset;
+
+  DWORD m_vertScrollLastTime;
+  float m_vertScrollSpeed;
+  float m_vertScrollOffset;
+
+  CStdString m_label;
+  bool m_wasReset;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIListGroup.cpp XBMC/guilib/GUIListGroup.cpp
--- XBMC-unpatched/guilib/GUIListGroup.cpp	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIListGroup.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -130,6 +130,38 @@
   }
 }
 
+void CGUIListGroup::ShowIdOnly(int id)
+{
+  for (iControls it = m_children.begin(); it != m_children.end(); it++)
+  {
+    CGUIControl *child = *it;
+    if (child->GetID() >= 1 && child->GetID() <= 12)
+    {
+      if (child->GetID() == id) // label
+        child->SetVisible(true);
+      else
+        child->SetVisible(false);
+    }
+  }
+  SetInvalid();
+}
+
+void CGUIListGroup::EnlargeWidth(float difference)
+{
+  // Alters the width of the controls that have an ID of 1
+  for (iControls it = m_children.begin(); it != m_children.end(); it++)
+  {
+    CGUIControl *child = *it;
+    if (child->GetID() >= 1 && child->GetID() <= 13)
+    {
+      child->SetWidth(child->GetWidth() + difference);
+      if (child->GetID() == 13) // label
+        child->SetVisible(child->GetWidth() > 10); ///
+    }
+  }
+  SetInvalid();
+}
+
 void CGUIListGroup::SetFocusedItem(unsigned int focus)
 {
   for (iControls it = m_children.begin(); it != m_children.end(); it++)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIListGroup.h XBMC/guilib/GUIListGroup.h
--- XBMC-unpatched/guilib/GUIListGroup.h	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIListGroup.h	2009-04-04 20:52:44.000000000 +0200
@@ -47,6 +47,8 @@
   virtual void UpdateVisibility(const CGUIListItem *item = NULL);
   virtual void UpdateInfo(const CGUIListItem *item);
 
+  void ShowIdOnly(int id);
+  void EnlargeWidth(float difference);
   void SetFocusedItem(unsigned int subfocus);
   unsigned int GetFocusedItem() const;
   bool MoveLeft();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIListItemLayout.cpp XBMC/guilib/GUIListItemLayout.cpp
--- XBMC-unpatched/guilib/GUIListItemLayout.cpp	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIListItemLayout.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -102,6 +102,19 @@
   return m_group.GetFocusedItem();
 }
 
+void CGUIListItemLayout::SetWidth(float width)
+{
+  m_group.EnlargeWidth(width - m_width);
+  m_width = width;
+  SetInvalid();
+}
+
+void CGUIListItemLayout::SetVisible(int id)
+{
+  m_group.ShowIdOnly(id);
+  SetInvalid();
+}
+
 void CGUIListItemLayout::SelectItemFromPoint(const CPoint &point)
 {
   m_group.SelectItemFromPoint(point);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/GUIListItemLayout.h XBMC/guilib/GUIListItemLayout.h
--- XBMC-unpatched/guilib/GUIListItemLayout.h	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/GUIListItemLayout.h	2009-04-04 20:52:44.000000000 +0200
@@ -46,6 +46,8 @@
   void CreateListControlLayouts(float width, float height, bool focused, const CLabelInfo &labelInfo, const CLabelInfo &labelInfo2, const CTextureInfo &texture, const CTextureInfo &textureFocus, float texHeight, float iconWidth, float iconHeight, int nofocusCondition, int focusCondition);
 //#endif
 
+  void SetWidth(float width);
+  void SetVisible(int id);
   void SelectItemFromPoint(const CPoint &point);
   bool MoveLeft();
   bool MoveRight();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/Key.h XBMC/guilib/Key.h
--- XBMC-unpatched/guilib/Key.h	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/Key.h	2009-04-05 19:09:13.000000000 +0200
@@ -261,10 +261,13 @@
 #define ACTION_FIRST_PAGE             159
 #define ACTION_LAST_PAGE              160
 
+#define ACTION_RECORD                 170
+
 #define ACTION_TOGGLE_FULLSCREEN      199 // switch 2 desktop resolution
 #define ACTION_TOGGLE_WATCHED         200 // Toggle watched status (videos)
 #define ACTION_SCAN_ITEM              201 // scan item
 #define ACTION_TOGGLE_DIGITAL_ANALOG  202 // switch digital <-> analog
+#define ACTION_CHANNEL_SWITCH         203
 
 // Window ID defines to make the code a bit more readable
 #define WINDOW_INVALID                     9999
@@ -287,8 +290,8 @@
 #define WINDOW_SETTINGS_MYVIDEOS          10017
 #define WINDOW_SETTINGS_NETWORK           10018
 #define WINDOW_SETTINGS_APPEARANCE        10019
+#define WINDOW_SETTINGS_MYTV              10020
 
-#define WINDOW_SCRIPTS                    10020
 #define WINDOW_VIDEO_GENRE                10021
 #define WINDOW_VIDEO_ACTOR                10022
 #define WINDOW_VIDEO_YEAR                 10023
@@ -297,8 +300,11 @@
 #define WINDOW_VIDEO_PLAYLIST             10028
 
 #define WINDOW_LOGIN_SCREEN               10029
+#define WINDOW_SCRIPTS                    10030
 #define WINDOW_SETTINGS_PROFILES          10034
 
+#define WINDOW_TV                         10040
+
 #define WINDOW_DIALOG_YES_NO              10100
 #define WINDOW_DIALOG_PROGRESS            10101
 #define WINDOW_DIALOG_KEYBOARD            10103
@@ -332,17 +338,30 @@
 #define WINDOW_DIALOG_SMART_PLAYLIST_RULE   10137
 #define WINDOW_DIALOG_BUSY                10138
 #define WINDOW_DIALOG_PICTURE_INFO        10139
-#define WINDOW_DIALOG_PLUGIN_SETTINGS     10140
+#define WINDOW_DIALOG_ADDON_SETTINGS      10140
 #define WINDOW_DIALOG_ACCESS_POINTS       10141
 #define WINDOW_DIALOG_FULLSCREEN_INFO     10142
 #define WINDOW_DIALOG_KARAOKE_SONGSELECT  10143
 #define WINDOW_DIALOG_KARAOKE_SELECTOR    10144
 
+#define WINDOW_DIALOG_ADDON_BROWSER       10160
+
 #define WINDOW_MUSIC_PLAYLIST             10500
 #define WINDOW_MUSIC_FILES                10501
 #define WINDOW_MUSIC_NAV                  10502
 #define WINDOW_MUSIC_PLAYLIST_EDITOR      10503
 
+#define WINDOW_DIALOG_PVRCLIENT_SETTINGS  10600
+#define WINDOW_DIALOG_TV_GUIDE_INFO       10601
+#define WINDOW_DIALOG_TV_RECORDING_INFO   10602
+#define WINDOW_DIALOG_TV_TIMER_SETTING    10603
+#define WINDOW_DIALOG_TV_GROUP_MANAGER    10604
+#define WINDOW_DIALOG_TV_CHANNEL_MANAGER  10605
+#define WINDOW_DIALOG_TV_OSD_CHANNELS     10606
+#define WINDOW_DIALOG_TV_OSD_GUIDE        10607
+#define WINDOW_DIALOG_TV_OSD_TELETEXT     10608
+#define WINDOW_DIALOG_TV_OSD_DIRECTOR     10609
+
 //#define WINDOW_VIRTUAL_KEYBOARD           11000
 #define WINDOW_DIALOG_SELECT              12000
 #define WINDOW_MUSIC_INFO                 12001
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/Makefile XBMC/guilib/Makefile
--- XBMC-unpatched/guilib/Makefile	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/Makefile	2009-04-04 20:52:44.000000000 +0200
@@ -16,6 +16,7 @@
      GUIControlGroupList.cpp \
      GUIDialog.cpp \
      GUIEditControl.cpp \
+     GUIEPGGridContainer.cpp \
      GUIFadeLabelControl.cpp \
      GUIFixedListContainer.cpp \
      GUIFont.cpp \
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/guilib/system.h XBMC/guilib/system.h
--- XBMC-unpatched/guilib/system.h	2009-04-22 19:14:24.000000000 +0200
+++ XBMC/guilib/system.h	2009-04-08 15:16:02.000000000 +0200
@@ -53,6 +53,7 @@
 #define HAS_WEB_SERVER
 #undef HAS_TIME_SERVER
 #undef HAS_VISUALISATION
+#define HAS_PVRCLIENTS
 #define HAS_KARAOKE
 #undef HAS_CREDITS
 #undef HAS_MODPLAYER
@@ -125,6 +126,7 @@
 #define HAS_VIDEO_PLAYBACK
 #undef  HAS_MPLAYER
 #define HAS_VISUALISATION
+#define HAS_PVRCLIENTS
 #define HAS_DVDPLAYER
 #define HAS_DVD_DRIVE
 #define HAS_WMA_CODEC
@@ -177,6 +179,7 @@
 #define HAS_FILESYSTEM_VTP
 #define HAS_DVD_DRIVE
 #define HAS_VISUALISATION
+#define HAS_PVRCLIENTS
 #define HAS_CCXSTREAM
 #define HAS_EVENT_SERVER
 #define HAS_SHOUTCAST
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/language/English/strings.xml XBMC/language/English/strings.xml
--- XBMC-unpatched/language/English/strings.xml	2009-04-22 19:09:56.000000000 +0200
+++ XBMC/language/English/strings.xml	2009-04-18 09:17:52.000000000 +0200
@@ -1507,6 +1507,202 @@
   <string id="16314">Inverse Telecine</string>
   <string id="17500">Display sleep timeout</string> 
 
+
+  <string id="17997">%i MByte</string>
+  <string id="17998">%i hours</string>
+  <string id="17999">%i days</string>
+
+  <!-- strings 18000 thru 18999 used for tv interface -->
+  <string id="18000">TV</string>
+  <string id="18001">Manage clients...</string>
+  <string id="18002">Connect timeout</string>
+  <string id="18003">Command timeout</string>
+  <string id="18004">Menu/OSD</string>
+  <string id="18005">Days to display in TV Guide</string>
+  <string id="18006">TV Guide linger time</string>
+  <string id="18007">Show Free-To-Air only Channels</string>
+  <string id="18008">Show Radio Channels</string>
+  <string id="18009">Channel info time</string>
+  <string id="18010">Info on channel switch</string>
+  <string id="18011">Timeout requested channel info</string>
+  <string id="18012">Channel Icons Folder</string>
+  <string id="18013">EPG</string>
+  <string id="18014">EPG scan timeout</string>
+  <string id="18015">EPG update timeout</string>
+  <string id="18016">Days to save EPG inside Database</string>
+  <string id="18017">Recording</string>
+  <string id="18018">Instant record time</string>
+  <string id="18019">Default priority</string>
+  <string id="18020">Default lifetime</string>
+  <string id="18021">Margin at start</string>
+  <string id="18022">Margin at stop</string>
+  <string id="18023">Replay</string>
+  <string id="18024">Hide Video-Length info box</string>
+  <string id="18025">Scan Timeout before channel playback</string>
+
+  <string id="18028">Manage PVR clients</string>
+
+  <string id="18048">Edit Channel Settings</string>
+  <string id="18049">New Channel</string>
+  <string id="18050">TV Guide</string>
+  <string id="18051">TV Channels</string>
+  <string id="18052">Radio Channels</string>
+  <string id="18053">Can not start recording</string>
+  <string id="18054">Timer</string>
+  <string id="18055">Size:</string>
+  <string id="18056">Used:</string>
+  <string id="18057">Add Timer...</string>
+  <string id="18058">Switch</string>
+  <string id="18059">Not Supported at the moment!</string>
+  <string id="18060">Page</string>
+  <string id="18061">Add Channel...</string>
+  <string id="18062">No.:</string>
+  <string id="18063">Name:</string>
+  <string id="18064">Now Playing:</string>
+  <string id="18065">Channels</string>
+  <string id="18066">Recordings</string>
+  <string id="18067">From:</string>
+  <string id="18068">Edit Timer</string>
+  <string id="18069">Recording running</string>
+  <string id="18070">On/Off Timer</string>
+  <string id="18071">Delete timer?</string>
+  <string id="18072">New Timer</string>
+  <string id="18073">Recording information</string>
+  <string id="18074">No Information available!</string>
+  <string id="18075">On</string>
+  <string id="18076">Timer</string>
+  <string id="18077">At:</string>
+  <string id="18078">from</string>
+  <string id="18079">to</string>
+  <string id="18080">Mo</string>
+  <string id="18081">Tu</string>
+  <string id="18082">We</string>
+  <string id="18083">Th</string>
+  <string id="18084">Fr</string>
+  <string id="18085">Sa</string>
+  <string id="18086">Su</string>
+  <string id="18087">from</string>
+  <string id="18088">Next Recording</string>
+  <string id="18089">Now Recording</string>
+  <string id="18090">Warning</string>
+  <string id="18091">No connection to PVR-Server</string>
+  <string id="18092">Check your settings or Backend-Server</string>
+  <string id="18093">Lost connection to PVR-Server</string>
+  <string id="18094">Try to reconnect?</string>
+  <string id="18095">Timer present</string>
+  <string id="18096">Delete Channel and Timer?</string>
+  <string id="18097">Channel is playing</string>
+  <string id="18098">Please switch to another Channel!</string>
+  <string id="18099">Channel</string>
+  <string id="18100">Information</string>
+  <string id="18101">Now</string>
+  <string id="18102">Next</string>
+  <string id="18103">Timeline</string>
+  <string id="18104">Channel encrypted</string>
+  <string id="18105">Channel not available</string>
+  <string id="18106">PVR-Server is not compatible!</string>
+  <string id="18107">Activate Timeshifted TV</string>
+  <string id="18108">Timshift Cache</string>
+  <string id="18109">Switch to channel</string>
+  <string id="18110">Movie/Drama</string>
+  <string id="18111">News/Current Affairs</string>
+  <string id="18112">Show</string>
+  <string id="18113">Sports</string>
+  <string id="18114">Children</string>
+  <string id="18115">Music</string>
+  <string id="18116">Arts</string>
+  <string id="18117">Educational/Science</string>
+  <string id="18118">Leisure/Hobbies</string>
+  <string id="18119">Other/Unknown</string>
+  <string id="18120">Science</string>
+  <string id="18121">Social/Political/Economics</string>
+  <string id="18122">Special</string>
+  <string id="18123">Folder for Timeshift recording</string>
+  <string id="18124">Timeshift activated</string>
+  <string id="18125">But no cache folder defined!</string>
+  <string id="18126">Group Managment</string>
+  <string id="18127">No Groups</string>
+  <string id="18128">Grouped</string>
+  <string id="18129">Groups</string>
+  <string id="18130">New Groupname</string>
+  <string id="18131">All Channels</string>
+  <string id="18132">Group</string>
+  <string id="18133">XBMC synchronize TV-Data with Backend-Server</string>
+  <string id="18134">Channel blocked or encrypted</string>
+  <string id="18135">No Groups defined</string>
+  <string id="18136">Please create first one</string>
+
+  <string id="18150">Now</string>
+  <string id="18151">Hidden</string>
+
+  <string id="18161">Set Channel Icon</string>
+  <string id="18162">Timer still recording - really delete?</string>
+  <string id="18163">Title-Information</string>
+
+  <string id="18190">Next timer on</string>
+  <string id="18191">at</string>
+  <string id="18192">Recording</string>
+  <string id="18193">Show Channel</string>
+  <string id="18194">Show normal Channels</string>
+  <string id="18195">Show hidden Channels</string>
+  <string id="18196">Confirm Channel hide</string>
+  <string id="18197">Move channel to:</string>
+  <string id="18198">Hide Channel</string>
+  <string id="18199">Press OK to Enter TV Settings!</string>
+  <string id="18200">Backend:</string>
+  <string id="18201">Version:</string>
+  <string id="18202">Address:</string>
+  <string id="18203">Disksize:</string>
+  <string id="18204">Channels:</string>
+  <string id="18205">Recordings:</string>
+  <string id="18206">Timers:</string>
+  <string id="18207">Enter the Timer Name</string>
+
+  <string id="18300">Mo-__-__-__-__-__-__</string>
+  <string id="18301">__-Tu-__-__-__-__-__</string>
+  <string id="18302">__-__-We-__-__-__-__</string>
+  <string id="18303">__-__-__-Th-__-__-__</string>
+  <string id="18304">__-__-__-__-Fr-__-__</string>
+  <string id="18305">__-__-__-__-__-Sa-__</string>
+  <string id="18306">__-__-__-__-__-__-Su</string>
+  <string id="18307">Mo-Tu-We-Th-Fr-__-__</string>
+  <string id="18308">Mo-Tu-We-Th-Fr-Sa-__</string>
+  <string id="18309">Mo-Tu-We-Th-Fr-Sa-Su</string>
+  <string id="18310">__-__-__-__-__-Sa-Su</string>
+
+  <string id="18399">Rename recording?</string>
+  <string id="18400">Rename timer?</string>
+  <string id="18401">Active:</string>
+  <string id="18402">Channel:</string>
+  <string id="18403">Day:</string>
+  <string id="18404">Begin:</string>
+  <string id="18405">End:</string>
+  <string id="18406">Priority:</string>
+  <string id="18407">Lifetime (days):</string>
+  <string id="18408">First day:</string>
+  <string id="18409">Radio:</string>
+
+  <string id="18414">Stop Recording</string>
+  <string id="18415">Delete Timer</string>
+  <string id="18416">Add Timer</string>
+  <string id="18417">No automatic Switch</string>
+
+  <string id="18800">Timers not in sync!</string>
+  <string id="18801">Server error!</string>
+  <string id="18802">Couldn't delete timer!</string>
+  <string id="18803">Try again...</string>
+  <string id="18804">Recordings not in sync!</string>
+  <string id="18805">Couldn't delete recording!</string>
+  <string id="18806">Couldn't save timer!</string>
+  <string id="18807">Channels not in sync!</string>
+  <string id="18808">Couldn't delete channel!</string>
+  <string id="18809">Couldn't save channel!</string>
+  <string id="18810">Recordings not in sync!</string>
+  <string id="18811">Couldn't delete recording!</string>
+  <string id="18812">No Icon Folder defined!</string>
+  <string id="18813">Please adjust settings.</string>
+  <string id="18814">Timer already set for this event</string>
+
   <string id="20000">CDDA rip folder</string>
   <string id="20001">Use external DVD player</string>
   <string id="20002">External DVD player</string>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/language/German/strings.xml XBMC/language/German/strings.xml
--- XBMC-unpatched/language/German/strings.xml	2009-04-22 19:09:54.000000000 +0200
+++ XBMC/language/German/strings.xml	2009-04-17 04:54:41.000000000 +0200
@@ -1432,6 +1432,201 @@
   <string id="16313">(VDPAU)Schrfe</string>
   <string id="16314">Inverse Telecine</string>
   <string id="17500">Bildschirm Sleep Timeout</string>
+
+  <string id="17997">%i MByte</string>
+  <string id="17998">%i Stunden</string>
+  <string id="17999">%i Tage</string>
+
+  <!-- strings 18000 thru 18999 used for tv interface -->
+  <string id="18000">TV</string>
+  <string id="18001">Klienten verwalten...</string>
+  <string id="18002">Verbindungs-Zeitberlauf</string>
+  <string id="18003">Kommando-Zeitberlauf</string>
+  <string id="18004">Men/OSD</string>
+  <string id="18005">Tage fr TV-Programm Anzeige</string>
+  <string id="18006">Alte EPG-Daten anzeigen</string>
+  <string id="18007">Zeige nur frei empfangbare Kanle</string>
+  <string id="18008">Zeige Radio Kanle</string>
+  <string id="18009">Anzeigedauer fr Kanalinfo</string>
+  <string id="18010">Info beim Kanalwechsel</string>
+  <string id="18011">Angeforderte Kanalinfo schlieen</string>
+  <string id="18012">Ordner fr Kanallogos</string>
+  <string id="18013">EPG</string>
+  <string id="18014">Zeit bis zur EPG-Suche</string>
+  <string id="18015">Zeit bis zur EPG-Aktualisierung</string>
+  <string id="18016">Tage fr alte EPG Daten in Datenbank</string>
+  <string id="18017">Aufnahmen</string>
+  <string id="18018">Dauer der Direktaufzeichnung</string>
+  <string id="18019">Standart-Prioritt</string>
+  <string id="18020">Standart-Lebensdauer</string>
+  <string id="18021">Vorlauf zum Timer-Beginn</string>
+  <string id="18022">Nachlauf am Timer-Ende</string>
+  <string id="18023">Wiedergabe</string>
+  <string id="18024">Infobox fr Videolnge verbergen</string>
+  <string id="18025">Suchberlauf vor Kanalwiedergabe</string>
+
+  <string id="18028">PVR Klienten verwalten</string>
+
+  <string id="18048">Kanaleinstellungen bearbeiten</string>
+  <string id="18049">Neuer Kanal</string>
+  <string id="18050">Programm</string>
+  <string id="18051">TV Kanle</string>
+  <string id="18052">Radio Kanle</string>
+  <string id="18053">Konnte Aufnahme nicht starten</string>
+  <string id="18054">Timer</string>
+  <string id="18055">Gre:</string>
+  <string id="18056">Benutzt:</string>
+  <string id="18057">Timer hinzufgen...</string>
+  <string id="18058">Umschalten</string>
+  <string id="18059">Wird derzeit nicht untersttzt!</string>
+  <string id="18060">Seite</string>
+  <string id="18061">Kanal hinzufgen...</string>
+  <string id="18062">Nr.:</string>
+  <string id="18063">Name:</string>
+  <string id="18064">Jetzt luft:</string>
+  <string id="18065">Kanle</string>
+  <string id="18066">Aufnahmen</string>
+  <string id="18067">Vom:</string>
+  <string id="18068">Timer bearbeiten</string>
+  <string id="18069">Aufnahme luft</string>
+  <string id="18070">Timer aktivieren/deaktivieren</string>
+  <string id="18071">Timer lschen?</string>
+  <string id="18072">Neuer Timer</string>
+  <string id="18073">Aufnahme-Informationen</string>
+  <string id="18074">Keine Informationen verfgbar!</string>
+  <string id="18075">Auf</string>
+  <string id="18076">Timer</string>
+  <string id="18077">Am:</string>
+  <string id="18078">von</string>
+  <string id="18079">bis</string>
+  <string id="18080">Mo</string>
+  <string id="18081">Di</string>
+  <string id="18082">Mi</string>
+  <string id="18083">Do</string>
+  <string id="18084">Fr</string>
+  <string id="18085">Sa</string>
+  <string id="18086">So</string>
+  <string id="18087">ab</string>
+  <string id="18088">Nchste Aufnahme</string>
+  <string id="18089">Jetzige Aufnahme</string>
+  <string id="18090">Warnung</string>
+  <string id="18091">Keine Verbindung zum PVR-Server</string>
+  <string id="18092">berprfen sie ihre Einstellungen oder den Backend-Server</string>
+  <string id="18093">Verbindung zum PVR-Server verloren</string>
+  <string id="18094">Versuchen wieder zu verbinden?</string>
+  <string id="18095">Timer vorhanden</string>
+  <string id="18096">Kanal und Timer lschen?</string>
+  <string id="18097">Kanalwiedergabe luft</string>
+  <string id="18098">Bitte schalten Sie auf einen anderen Kanal!</string>
+  <string id="18099">Kanal</string>
+  <string id="18100">Information</string>
+  <string id="18101">Jetzt</string>
+  <string id="18102">Nchstes</string>
+  <string id="18103">Zeitleiste</string>
+  <string id="18104">Kanal verschlsselt</string>
+  <string id="18105">Kanal nicht verfgbar</string>
+  <string id="18106">PVR-Server ist nicht kompatibel!</string>
+  <string id="18107">Aktiviere zeitverseztes Fernsehen</string>
+  <string id="18108">Zwischenspeicher Gre</string>
+  <string id="18109">Zum Kanal schalten</string>
+  <string id="18110">Film/Drama</string>
+  <string id="18111">Aktuelles/Nachrichten</string>
+  <string id="18112">Show</string>
+  <string id="18113">Sport</string>
+  <string id="18114">Kinder</string>
+  <string id="18115">Musik</string>
+  <string id="18116">Kunst</string>
+  <string id="18117">Bildung/Wissenschaft</string>
+  <string id="18118">Freizeit/Hobbies</string>
+  <string id="18119">Andere/Unbekannt</string>
+  <string id="18120">Wissenschaft</string>
+  <string id="18121">Social/Political/Economics</string>
+  <string id="18122">Special</string>
+  <string id="18123">Ordner fr zeitversetzte Aufnahme</string>
+  <string id="18124">Zeitverseztes Fernsehen aktviert</string>
+  <string id="18125">Aber kein Zwischenspeicher-Ordner festgelegt!</string>
+  <string id="18126">Gruppenverwaltung</string>
+  <string id="18127">Ungruppiert</string>
+  <string id="18128">Keine Gruppen</string>
+  <string id="18129">Gruppen</string>
+  <string id="18130">Neuer Gruppenname</string>
+  <string id="18131">Alle Kanle</string>
+  <string id="18132">Gruppe</string>
+  <string id="18133">XBMC synchronisiert TV-Daten mit Backend-Server</string>
+  <string id="18134">Kanal blockiert oder verschlsselt</string>
+  <string id="18135">Keine Gruppen definiert</string>
+  <string id="18136">Bitte erstellen Sie zuerst eine</string>
+
+  <string id="18150">Jetzt</string>
+  <string id="18151">Versteckt</string>
+
+  <string id="18161">Kanallogo festlegen</string>
+  <string id="18162">Timer zeichnet auf - trotzdem lschen?</string>
+  <string id="18163">Titel-Informationen</string>
+
+  <string id="18190">Nchster Timer am</string>
+  <string id="18191">um</string>
+  <string id="18192">Aufnahme</string>
+  <string id="18193">Zeige Kanal</string>
+  <string id="18194">Zeige normale Kanle</string>
+  <string id="18195">Zeige versteckte Kanle</string>
+  <string id="18196">Verstecken besttigen</string>
+  <string id="18197">Kanal verschieben nach:</string>
+  <string id="18198">Kanal verstecken</string>
+  <string id="18199">Drcken sie OK um zu den Einstellungen zu gelangen!</string>
+  <string id="18200">Backend:</string>
+  <string id="18201">Version:</string>
+  <string id="18202">Addresse:</string>
+  <string id="18203">Festplattengre:</string>
+  <string id="18204">Kanle:</string>
+  <string id="18205">Aufnahmen:</string>
+  <string id="18206">Timers:</string>
+  <string id="18207">Bitte geben Sie den Timer Namen ein</string>
+
+  <string id="18300">Mo-__-__-__-__-__-__</string>
+  <string id="18301">__-Di-__-__-__-__-__</string>
+  <string id="18302">__-__-Mi-__-__-__-__</string>
+  <string id="18303">__-__-__-Do-__-__-__</string>
+  <string id="18304">__-__-__-__-Fr-__-__</string>
+  <string id="18305">__-__-__-__-__-Sa-__</string>
+  <string id="18306">__-__-__-__-__-__-So</string>
+  <string id="18307">Mo-Di-Mi-Do-Fr-__-__</string>
+  <string id="18308">Mo-Di-Mi-Do-Fr-Sa-__</string>
+  <string id="18309">Mo-Di-Mi-Do-Fr-Sa-So</string>
+  <string id="18310">__-__-__-__-__-Sa-So</string>
+
+  <string id="18399">Aufnahme umbenennen?</string>
+  <string id="18400">Timer umbenennen?</string>
+  <string id="18401">Aktiv:</string>
+  <string id="18402">Kanal:</string>
+  <string id="18403">Tag:</string>
+  <string id="18404">Anfang:</string>
+  <string id="18405">Ende:</string>
+  <string id="18406">Prioritt:</string>
+  <string id="18407">Lebensdauer (Tage):</string>
+  <string id="18408">Erster Tag:</string>
+  <string id="18409">Radio:</string>
+
+  <string id="18414">Aufnahme abbrechen</string>
+  <string id="18415">Timer lschen</string>
+  <string id="18416">Timer hinzufgen</string>
+  <string id="18417">Nicht automatisch umschalten</string>
+
+  <string id="18800">Timers nicht synchron!</string>
+  <string id="18801">Server Fehler!</string>
+  <string id="18802">Konnte Timer nicht lschen!</string>
+  <string id="18803">Erneut versuchen...</string>
+  <string id="18804">Aufnahmen nicht synchron!</string>
+  <string id="18805">Konnte Aufnahme nicht lschen!</string>
+  <string id="18806">Konnte Timer nicht speichern!</string>
+  <string id="18807">Kanle nicht synchron!</string>
+  <string id="18808">Konnte Kanal nicht lschen!</string>
+  <string id="18809">Konnte Kanal nicht speichern!</string>
+  <string id="18810">Aufnahmen nicht synchron!</string>
+  <string id="18811">Konnte Aufnahme nicht lschen!</string>
+  <string id="18812">Kein Ordner fr Logos definiert!</string>
+  <string id="18813">Bitte aktualisieren sie ihre Einstellungen.</string>
+
   <string id="20000">Ordner fr CD-Kopien</string>
   <string id="20001">Externen DVD-Player verwenden</string>
   <string id="20002">Externer DVD-Player</string>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/Makefile.in XBMC/Makefile.in
--- XBMC-unpatched/Makefile.in	2009-04-22 19:16:28.000000000 +0200
+++ XBMC/Makefile.in	2009-04-15 05:11:39.000000000 +0200
@@ -41,6 +41,7 @@
 	xbmc/lib/UnrarXLib \
 	xbmc/visualizations \
 	xbmc/screensavers \
+	xbmc/pvrclients \
 	xbmc/utils \
 	xbmc/settings \
 	xbmc/linux \
@@ -93,11 +94,14 @@
 	xbmc/visualizations/XBMCProjectM \
 	xbmc/visualizations/Goom
 
+PVR_DIRS=\
+	xbmc/pvrclients/vdr
+
 PM3_MEDIA=skin/Project\ Mayhem\ III/media
 PM3HD_MEDIA=skin/PM3.HD/media
 
 DIRS= $(BIN_DIRS) $(EC_DIRS) $(XBMCTEX_DIRS) $(DVDPCODECS_DIRS) $(PAPCODECS_DIRS) \
-	$(LIB_DIRS) $(SS_DIRS) $(VIS_DIRS)
+	$(LIB_DIRS) $(SS_DIRS) $(VIS_DIRS) $(PVR_DIRS)
 
 DEBUG_FLAGS=@DEBUG_FLAGS@
 LIBS=@LIBS@
@@ -112,7 +116,7 @@
 
 include Makefile.include
 
-.PHONY : guilib xbmc filesystem cores paplayer dllloader exports osx xbox linux visualization-interface visualizations screensaver-interface screensavers utils common tinyxml sqllite libscrobbler unrarxlib libpython libgoahead compile dvdplayer libupnp libcmyth eventclients librtmp papcodecs dvdpcodecs imagelib codecs externals cdrip externalplayer libkaraoke settings
+.PHONY : guilib xbmc filesystem cores paplayer dllloader exports osx xbox linux pvrclient-interface visualization-interface visualizations screensaver-interface screensavers utils common tinyxml sqllite libscrobbler unrarxlib libpython libgoahead compile dvdplayer libupnp libcmyth eventclients librtmp papcodecs dvdpcodecs imagelib codecs externals cdrip externalplayer libkaraoke settings
 
 $(PM3_MEDIA)/Textures.xpr: tools/XBMCTex/XBMCTex $(PM3_MEDIA)/*.png $(PM3_MEDIA)/*/*.png
 	 tools/XBMCTex/XBMCTex -input \"$(PM3_MEDIA)\" -output \"$(PM3_MEDIA)/Textures.xpr\"
@@ -157,6 +161,10 @@
 	$(MAKE) -C xbmc/visualizations/WaveForm
 	$(MAKE) -C xbmc/visualizations/XBMCProjectM
 	$(MAKE) -C xbmc/visualizations/Goom
+pvrclient-interface:
+	$(MAKE) -C xbmc/pvrclients
+pvrclients: exports
+	$(MAKE) -C xbmc/pvrclients/vdr
 screensaver-interface: 
 	$(MAKE) -C xbmc/screensavers
 screensavers: exports
@@ -256,14 +264,14 @@
 
 libs: libhdhomerun libid3tag imagelib libexif python
 	
-externals: codecs libs python visualizations screensavers
+externals: codecs libs python visualizations screensavers pvrclients
 more_libs: librtmp libxbms librtv libxdaap libshout libgoahead
 
 compile: guilib xbmc filesystem cores audiorenderers cdrip \
 	paplayer dllloader exports osx xbox linux utils common tinyxml sqllite \
 	libscrobbler libgoahead unrarxlib libpython dvdplayer libupnp libcmyth \
 	librtmp libxbms librtv libxdaap libshout screensaver-interface \
-	visualization-interface externalplayer libkaraoke libhts settings 
+	visualization-interface pvrclient-interface externalplayer libkaraoke libhts settings
 
 # platform independend objects
 OBJSXBMC=	\
@@ -308,6 +316,7 @@
 	xbmc/lib/sqLite/sqllite.a \
 	xbmc/lib/UnrarXLib/UnrarXLib.a \
 	xbmc/linux/linux.a \
+	xbmc/pvrclients/pvrclient.a \
 	xbmc/screensavers/screensaver.a \
 	xbmc/settings/settings.a \
 	xbmc/utils/utils.a \
@@ -387,10 +396,10 @@
 
 install-datas:
 	@echo "Creating target directories in $(prefix)/share/xbmc"
-	@find language media screensavers scripts skin sounds userdata visualisations system -type d -not -iregex ".*svn.*" -exec mkdir -p $(prefix)/share/xbmc/"{}" \; -printf " -- %f                           \r"
+	@find language media screensavers scripts skin sounds userdata visualisations pvrclients system -type d -not -iregex ".*svn.*" -exec mkdir -p $(prefix)/share/xbmc/"{}" \; -printf " -- %f                           \r"
 	@echo "Copying system files to $(prefix)/share/xbmc"
 	@# Arch independent files
-	@find language media screensavers scripts sounds userdata visualisations system -regextype posix-extended -type f -not -iregex ".*svn.*|.*\.so|.*\.dll|.*win32\.vis|.*osx\.vis" -exec cp "{}" $(prefix)/share/xbmc/"{}" \; -printf " -- %f                           \r"
+	@find language media screensavers scripts sounds userdata visualisations pvrclients system -regextype posix-extended -type f -not -iregex ".*svn.*|.*\.so|.*\.dll|.*win32\.vis|.*osx\.vis" -exec cp "{}" $(prefix)/share/xbmc/"{}" \; -printf " -- %f                           \r"
 	@# Arch dependent files
 	@find system -regextype posix-extended -type f -not -iregex ".*svn.*" -iregex ".*@ARCH@.*" -exec cp "{}" $(prefix)/share/xbmc/"{}" \; -printf " -- %f                           \r"
 	@# Skins
@@ -450,9 +459,11 @@
 	for d in $(SS_DIRS); do if test -f $$d/Makefile; then $(MAKE) -C $$d clean; fi; done
 clean-visualisations:
 	for d in $(VIS_DIRS); do if test -f $$d/Makefile; then $(MAKE) -C $$d clean; fi; done
+clean-pvrclients:
+	for d in $(PVR_DIRS); do if test -f $$d/Makefile; then $(MAKE) -C $$d clean; fi; done
 
 clean-codecs: clean-dvdpcodecs clean-papcodecs
 
 clean-externals: clean-codecs clean-eventclients clean-xbmctex clean-libs \
-	clean-screensavers clean-visualisations
+	clean-pvrclients clean-screensavers clean-visualisations clean-pvrclients
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/project/VS2008Express/guilib.vcproj XBMC/project/VS2008Express/guilib.vcproj
--- XBMC-unpatched/project/VS2008Express/guilib.vcproj	2009-04-22 19:14:20.000000000 +0200
+++ XBMC/project/VS2008Express/guilib.vcproj	2009-04-18 10:41:42.000000000 +0200
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9.00"
+	Version="9,00"
 	Name="guilib"
 	ProjectGUID="{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}"
 	RootNamespace="guilib"
@@ -246,6 +246,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\guilib\GUIEPGGridContainer.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\..\guilib\GUIFadeLabelControl.cpp"
 				>
 			</File>
@@ -624,6 +628,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\guilib\GUIEPGGridContainer.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\guilib\GUIFadeLabelControl.h"
 				>
 			</File>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/project/VS2008Express/XBMC for Windows.sln XBMC/project/VS2008Express/XBMC for Windows.sln
--- XBMC-unpatched/project/VS2008Express/XBMC for Windows.sln	2009-04-22 19:14:20.000000000 +0200
+++ XBMC/project/VS2008Express/XBMC for Windows.sln	2009-04-18 11:52:05.000000000 +0200
@@ -1,5 +1,5 @@
 Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual C++ Express 2008
+# Visual Studio 2008
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XBMC", "XBMC.vcproj", "{3A68081D-E8F9-4523-9436-530DE9E5530A}"
 	ProjectSection(ProjectDependencies) = postProject
 		{B2975495-FBE4-4F94-AAC5-B21A9842BF50} = {B2975495-FBE4-4F94-AAC5-B21A9842BF50}
@@ -16,28 +16,62 @@
 		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4} = {510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}
 	EndProjectSection
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XBMC_VDR", "..\..\xbmc\pvrclients\vdr\XBMC_VDR.vcproj", "{D450FE9A-CE56-4496-B4AB-379094E642F2}"
+	ProjectSection(ProjectDependencies) = postProject
+		{3A68081D-E8F9-4523-9436-530DE9E5530A} = {3A68081D-E8F9-4523-9436-530DE9E5530A}
+		{B2975495-FBE4-4F94-AAC5-B21A9842BF50} = {B2975495-FBE4-4F94-AAC5-B21A9842BF50}
+		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4} = {510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}
+		{FE0A91C0-E30A-47CD-8A92-A508C9292452} = {FE0A91C0-E30A-47CD-8A92-A508C9292452}
+	EndProjectSection
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug (SDL)|Win32 = Debug (SDL)|Win32
+		Debug|Win32 = Debug|Win32
 		Release (SDL)|Win32 = Release (SDL)|Win32
+		Release|Win32 = Release|Win32
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Debug (SDL)|Win32.ActiveCfg = Debug (SDL)|Win32
 		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Debug (SDL)|Win32.Build.0 = Debug (SDL)|Win32
+		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Debug|Win32.ActiveCfg = Debug (SDL)|Win32
+		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Debug|Win32.Build.0 = Debug (SDL)|Win32
 		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Release (SDL)|Win32.ActiveCfg = Release (SDL)|Win32
 		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Release (SDL)|Win32.Build.0 = Release (SDL)|Win32
+		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Release|Win32.ActiveCfg = Release (SDL)|Win32
+		{3A68081D-E8F9-4523-9436-530DE9E5530A}.Release|Win32.Build.0 = Release (SDL)|Win32
 		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Debug (SDL)|Win32.ActiveCfg = Debug (SDL)|Win32
 		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Debug (SDL)|Win32.Build.0 = Debug (SDL)|Win32
+		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Debug|Win32.ActiveCfg = Debug (SDL)|Win32
+		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Debug|Win32.Build.0 = Debug (SDL)|Win32
 		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Release (SDL)|Win32.ActiveCfg = Release (SDL)|Win32
 		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Release (SDL)|Win32.Build.0 = Release (SDL)|Win32
+		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Release|Win32.ActiveCfg = Release (SDL)|Win32
+		{510441AC-B9E1-4B31-9C0C-EB3AD39D90C4}.Release|Win32.Build.0 = Release (SDL)|Win32
 		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Debug (SDL)|Win32.ActiveCfg = Debug (SDL)|Win32
 		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Debug (SDL)|Win32.Build.0 = Debug (SDL)|Win32
+		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Debug|Win32.Build.0 = Debug|Win32
 		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Release (SDL)|Win32.ActiveCfg = Release (SDL)|Win32
 		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Release (SDL)|Win32.Build.0 = Release (SDL)|Win32
+		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Release|Win32.ActiveCfg = Release|Win32
+		{B2975495-FBE4-4F94-AAC5-B21A9842BF50}.Release|Win32.Build.0 = Release|Win32
 		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Debug (SDL)|Win32.ActiveCfg = Debug (SDL)|Win32
 		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Debug (SDL)|Win32.Build.0 = Debug (SDL)|Win32
+		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Debug|Win32.ActiveCfg = Debug (SDL)|Win32
+		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Debug|Win32.Build.0 = Debug (SDL)|Win32
 		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Release (SDL)|Win32.ActiveCfg = Release (SDL)|Win32
 		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Release (SDL)|Win32.Build.0 = Release (SDL)|Win32
+		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Release|Win32.ActiveCfg = Release (SDL)|Win32
+		{FE0A91C0-E30A-47CD-8A92-A508C9292452}.Release|Win32.Build.0 = Release (SDL)|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug (SDL)|Win32.ActiveCfg = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug (SDL)|Win32.Build.0 = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug|Win32.Build.0 = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release (SDL)|Win32.ActiveCfg = Release|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release (SDL)|Win32.Build.0 = Release|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release|Win32.ActiveCfg = Release|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/project/VS2008Express/XBMC.vcproj XBMC/project/VS2008Express/XBMC.vcproj
--- XBMC-unpatched/project/VS2008Express/XBMC.vcproj	2009-04-22 19:14:20.000000000 +0200
+++ XBMC/project/VS2008Express/XBMC.vcproj	2009-04-18 10:04:48.000000000 +0200
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9.00"
+	Version="9,00"
 	Name="XBMC"
 	ProjectGUID="{3A68081D-E8F9-4523-9436-530DE9E5530A}"
 	RootNamespace="XBMC_PC"
@@ -861,6 +861,14 @@
 						>
 					</File>
 					<File
+						RelativePath="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamPVRManager.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamPVRManager.h"
+						>
+					</File>
+					<File
 						RelativePath="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamRTMP.cpp"
 						>
 					</File>
@@ -2090,11 +2098,23 @@
 				Name="Settings"
 				>
 				<File
-					RelativePath="..\..\xbmc\GUIDialogPluginSettings.cpp"
+					RelativePath="..\..\xbmc\settings\AddonSettings.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\settings\AddonSettings.h"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\settings\DllAddonSettings.h"
 					>
 				</File>
 				<File
-					RelativePath="..\..\xbmc\GUIDialogPluginSettings.h"
+					RelativePath="..\..\xbmc\GUIDialogAddonSettings.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogAddonSettings.h"
 					>
 				</File>
 				<File
@@ -2126,14 +2146,6 @@
 					>
 				</File>
 				<File
-					RelativePath="..\..\xbmc\PluginSettings.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\..\xbmc\PluginSettings.h"
-					>
-				</File>
-				<File
 					RelativePath="..\..\xbmc\ScraperSettings.cpp"
 					>
 				</File>
@@ -2598,6 +2610,14 @@
 				Name="Utils"
 				>
 				<File
+					RelativePath="..\..\xbmc\utils\Addon.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\utils\Addon.h"
+					>
+				</File>
+				<File
 					RelativePath="..\..\xbmc\utils\AlarmClock.cpp"
 					>
 				</File>
@@ -3134,6 +3154,14 @@
 					>
 				</File>
 				<File
+					RelativePath="..\..\xbmc\TVDatabase.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\TVDatabase.h"
+					>
+				</File>
+				<File
 					RelativePath="..\..\xbmc\VideoDatabase.cpp"
 					>
 				</File>
@@ -3154,6 +3182,14 @@
 				Name="GUI Dialog"
 				>
 				<File
+					RelativePath="..\..\xbmc\GUIDialogAddonBrowser.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogAddonBrowser.h"
+					>
+				</File>
+				<File
 					RelativePath="..\..\xbmc\GUIDialogAudioSubtitleSettings.cpp"
 					>
 				</File>
@@ -4774,6 +4810,94 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="PVR"
+				>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVChannels.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVEPGProgInfo.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVGroupManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVGuide.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVRecordingInfo.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIDialogTVTimerSettings.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\GUIWindowTV.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\PVRManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\utils\TVChannelInfoTag.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\utils\TVEPGInfoTag.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\utils\TVRecordInfoTag.cpp"
+					>
+				</File>
+				<File
+					RelativePath="..\..\xbmc\utils\TVTimerInfoTag.cpp"
+					>
+				</File>
+				<Filter
+					Name="Clients"
+					>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\DllPVRClient.h"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\IPVRClient.h"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\PVRClient.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\PVRClient.h"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\PVRClientFactory.cpp"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\PVRClientFactory.h"
+						>
+					</File>
+					<File
+						RelativePath="..\..\xbmc\pvrclients\PVRClientTypes.h"
+						>
+					</File>
+					<File
+						RelativePath="..\..\pvrclients\xbmc_pvr.h"
+						>
+					</File>
+				</Filter>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Header Files"
@@ -4971,6 +5095,30 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\xbmc\GUIDialogTVChannels.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\GUIDialogTVEPGProgInfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\GUIDialogTVGroupManager.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\GUIDialogTVGuide.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\GUIDialogTVRecordingInfo.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\GUIDialogTVTimerSettings.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\xbmc\GUIDialogVolumeBar.h"
 				>
 			</File>
@@ -5079,6 +5227,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\xbmc\GUIWindowTV.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\xbmc\GUIWindowVideoBase.h"
 				>
 			</File>
@@ -5275,6 +5427,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\xbmc\PVRManager.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\xbmc\utils\RegExp.h"
 				>
 			</File>
@@ -5347,6 +5503,22 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\xbmc\utils\TVChannelInfoTag.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\utils\TVEPGInfoTag.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\utils\TVRecordInfoTag.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\xbmc\utils\TVTimerInfoTag.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\xbmc\utils\UdpClient.h"
 				>
 			</File>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/VDR/info.xml XBMC/pvrclients/VDR/info.xml
--- XBMC-unpatched/pvrclients/VDR/info.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/VDR/info.xml	2009-04-08 20:33:37.000000000 +0200
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addoninfo>
+  <!-- guid: unique identifier of this addon 	!-->
+  <guid>3ebaeda3-80d5-4447-9514-0de7a586a9d7</guid>
+
+  <!-- 	type:
+    1:  visualization
+    2:  skin
+    3:  pvrdll
+    4:  script
+    5:  scraper
+    6:  screensaver
+    7:  plugin-pvr
+    8:  plugin-video
+    9:  plugin-music
+    10: plugin-program
+    11: plugin-pictures !-->
+  <type>3</type>
+
+  <!-- name: name of the addon !-->
+  <name>VDRClient</name>
+
+  <!-- library: file name of the library !-->
+  <library>vdr.pvr</library>
+
+  <!-- icon: icon name of the library !-->
+  <icon>vdr.tbn</icon>
+
+  <!-- version:  version number in the following format major[.minor[.release[.build]]] !-->
+  <version>1.0.1</version>
+
+  <!-- platform: xbmc platform this addon is compatible with: 
+    atv|osx|xbox|windows|linux|all !-->
+  <platform>linux</platform>
+
+  <!-- minversion: earliest xbmc revision that this addon supports !-->
+  <minversion>
+    <xbmc>18656</xbmc>
+  </minversion>
+
+  <!-- summary: short summary of addon !-->
+  <summary>XBMC's frontend for VDR</summary>
+
+  <!-- description: more verbose description of addon !-->
+  <description>VDR frontend; supporting streaming of Live TV &amp; Recordings, EPG, Timers</description>
+
+  <!-- creator: name of devloper/organisation !-->
+  <creator>Alwin Esch / TEAMXBMC</creator>
+
+  <!-- disclaimer: if required, will be shown once to user upon installation !-->
+  <disclaimer>This is unstable software! The authors are in no way responsible for failed recordings, incorrect timers, wasted hours, or any other undesirable effects..</disclaimer>
+</addoninfo>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/VDR/resources/language/English/strings.xml XBMC/pvrclients/VDR/resources/language/English/strings.xml
--- XBMC-unpatched/pvrclients/VDR/resources/language/English/strings.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/VDR/resources/language/English/strings.xml	2009-04-10 00:32:01.000000000 +0200
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<strings>
+    <!-- settings labels -->
+    <string id="30000">VDR Hostname</string>
+    <string id="30001">Streamdev Port</string>
+		<string id="30002">Free-to-air only</string>
+		<string id="30003">Include Radio</string>
+		<string id="30004">Character Set Conversion</string>
+</strings>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/VDR/resources/language/German/strings.xml XBMC/pvrclients/VDR/resources/language/German/strings.xml
--- XBMC-unpatched/pvrclients/VDR/resources/language/German/strings.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/VDR/resources/language/German/strings.xml	2009-04-10 00:33:03.000000000 +0200
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<strings>
+    <!-- settings labels -->
+    <string id="30000">VDR Hostname oder IP</string>
+    <string id="30001">Streamdev Port</string>
+    <string id="30002">Nur frei empfangbare Kanle</string>
+    <string id="30003">Zeige Radiokanle</string>
+    <string id="30004">Textkonvertierung (UTF-8)</string>
+</strings>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/VDR/resources/settings.xml XBMC/pvrclients/VDR/resources/settings.xml
--- XBMC-unpatched/pvrclients/VDR/resources/settings.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/VDR/resources/settings.xml	2009-04-10 00:31:20.000000000 +0200
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<settings>
+    <setting id="host" type="ipaddress" label="30000" default="127.0.0.1" />
+    <setting id="port" type="integer" label="30001" default="2004" />
+    <setting id="ftaonly" type="bool" label="30002" default="false" />
+    <setting id="useradio" type="bool" label="30003" default="true" />
+    <setting id="convertchar" type="bool" label="30004" default="true" />
+</settings>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/VDR/vdr.tbn XBMC/pvrclients/VDR/vdr.tbn
--- XBMC-unpatched/pvrclients/VDR/vdr.tbn	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/VDR/vdr.tbn	2009-03-26 16:37:04.000000000 +0100
@@ -0,0 +1,52 @@
+ JFIF  H H   Created with The GIMP C  C  d "             
+	                 Lf;Q@G$/nmEi$]$[\$oirYWAo._-s_~
+m2|v0Sqag4jL .VvSj+5C6Eer	(q^R(k,w)q4_], lXc*t|e06dhieia1GjT)}5A9VFVWm+r!}3YlUgrqRS0SKM
+e,#&+GJ71mtuI-oK}'P6~#j5]&a~hN~0#4yvDtEo                  *          457@  M%(dZQ,K#8< O^=&y.HBsOO^={5OJ{i,N"-)Nt3x<
+<)t B\o')kJ,)7@'W[bJo-8T*Kz2GWE|XP;">S?UU4S{$. w#,R1d|O[bM,Ua
+S%&%+	>[?M"|;%^_.&?T)xR6!yvZ#Wgl$v?.6f#IatOlQ9XvkM&VvL]Q=mnF(yn=.9-D-XEtsrA~SF
+mLP"{=4w<%|ixmp$O"Q=&8ImdwaXmDv
+Xq?ISM3c|#;H
+iK8o'j@^p7-:M@H~o@D I$17m+M!:Hv;fB1k.A%`-v]]	4p6prga@dk%GOGnjXLR6@>aeqy#UFd$@dN$j
+^o^FD	6(:QXla]K8]ElbM
+PV4"-;"FYb<6v7Ybl3bmhFMK)"K`lF[0"X*3o  ? 	      ! 1A"2QaqB$RSbcr #034D ?Ju))5vO9InVhj{"tnV%%>F|WU~*A xIJ+
+~<A5J#AXL'aUSz}g0h|<"FgES
+R+J(=EG7YR?T)r5_XxqV@vl%GqiVy*QKQN-70&&fTu:j.jh/QeBkOT '@)43mgBOZ ,e8<GV36-P'qQ=_3005/1 iS2w-w6K#hTq:i;g<o:Fh!HJ'#XdaT-
+Tsb{dDJ_Q84*h}]RAiV@*<{q@H3hiKBu. ADZz]#BTIiNugnaMU.m8eCn("" YSBP;)"P&
+Lx3YH!&@: 7q@6I10bw0F')$ 6JA=Y7WHt;"
+HmH%\mk,mhRZ nZ L'b$8L|{#]`8ZT{ F 	      !1"AQa#$2RqBbt%&036DUc ?gY"VE.Av \88nV7C"f<nRJ!RA,4'BgaTP+wR~R@7z(cB|&oA^Sn2J&FW\GWUe=1P+2~5)eJ)q1Y5vJiry0*|8 ag6U@,IdXG6:G9x0^{9heHeNO<KKFRP5>5q?|o#TUp9;_rddFRI*	qy
+P)jVi %*7&0x &s$W>	f'R#]$=3nvTK*01(`Jp?jgX#UDwcR|YZUT:zf3O@3tDD{%SNv)Kyn=%L8 eyW;GokLO14U\Ru=ah=V3/)9X6vn'0tGT0*1}ad$G^m=HI9zxOGvs%EoNX f=RWZK0Y=hi6iUv)GY;Q! On3i2(xl3Z.qM|+@8fTG%NXT+E$vUGuU},O*y+%-l=EB0/E)"zWjTU!jib()1N8jK=ohnJhWIOQ|kerz\eHdpF=}NUj+|S"&=Mbq=lR.RR^O!n\> o#?{WKUEMuX|#VZE2BG91T\^j
+ir`*"\ 2hbKLH;{dc^ $W5Z+^J=KEBE"USNmA?Ev[eu5SIK<UH$Tf:9h^M3TO+M5Ul."C
+4G)dMA*)NGto%e-%DE$5q("t'Lu{t=I#rXSKdYKrHA,nN[$$ GLyIQHKh~+9^(m	(aJDpcxv)OXuaOQJ%8b4Q.ys4cRT|[cvJ&z/c"'l}"q!)&!bwG-\a[r8\m<DmfL!]zm:dZ`o1K8(+}~v9~n<5]+z6"]P&epk"7-mMV\Pn`cIQX6I	>? Q 	    !"1AQa #4B2Rbqrs$Stu%3@C6Ucd  ? Ig9P\Bim=9i7DZic67X
+l6zln=i[^tAx%=b%f"s<A0#(VK?X1%~~V]}gbFG>T}'qe 6.|t th&kdiAmjbg=*^"~^Lf#IYZ(rgcp_7I~_}'q=?XpL}W]moxI\F=P.fD_b@ac1l~dIG}[ -EQF8%llxr^fi,^ZzmvZ><9ugfyr9jgq<V~H>qs})c\ffJfg7!EvO1Ve'pY]"[@X6|q3s^1 X |q{a:7BD~gp<6Bo)9;'Iu5SNI`LaBz<r#B'cGAdw\_;S?F7 njn;@w`'%>J}&FrTPzG@clLLi/<[FPv[>SgOeyl1kKMu<#3*=!N2R|;&Vn&s91"V'\|!G/~dZa5u,So@$vw"1gCef7/kH^k0?
+a3TYKu^-)8f=Cu>YY3gJ)eq0sOe+|m3y jY^#f.DvmQ)3]B=(=K+.V1?4orE?}k'`qxf|
+W9L~Ov5!l4HBa~ O8su2'+.Tk +z|s1{.qK[|~?O3?<_IHBfA=A?\y,mb)Q\t-[fnnG#eFQDj	`na[.e$WY/xiuix) rm"S	bG/#qH'.}#1E1X1]M4KA0]On.Z~^29:l^~
+ { a F=\esvW+}T8b}^IYaJxFx}b>d|qo^nbg?o
+dDvN!/M."t(1`*LN$uG:g
+Jc1O7?\m9+ql/]i;z `}nQB,a\fP+153n0`@:RJ0])o+'\?0>g3? gk## 3jiwbgbCqQ!a:Y&xkEtai}e>f~U^enr(1br2Z4Z3e`Ztejt8?j1CDOo. |e"L_qaN+~}?l<9o(rkFFg/}['gK;XU*#;Oyy}q=^9cA?	d>7ij\r]>@}^3x2\R;nigg9Q0;2KyB"XZ4a\Z~"nc
+LH|DjS385 [czmjcyxK c l_,^6Wd112,1#pYSW0':sK#g}Pv5y[]!JrL}Oa2N6I=F}<_:IYUGz=qd#!W.V&t"&m#{'t}ni"s#v?V*P8:5Cunf8USrFg u<bYV1aal}T:]`bXGQfq!1"Q11xr	
+{j@JHw'ftcO	_-.R-bmOa MW/*QvV|/?/>[JZKFmSD{L15[>{/][DZ:Fp9K<OZ,/dj^gEZ'N>>^;m^bLGhcCRDH)o?PLG^kM|QsgXuL'u3rGeA"m95+P}UL+IF'XIfyj[x1]@xv@$fGq5(a9Gr`h;EYE
+3lqy{!fY2Ht+HlX@` "0<i*qc'~KDPxf#d?^5}P)ol ^XSd3}}&KlGu}OA0glhQbx_qKIr8u.[wBe#f(W['bF4W(n#Hk+UF&6=fe:"z's*(;6ZWn"g=C>}>Fog]LezU)(^tSJ!-^cg6^Z<)|&%naBGDF-'To1'GY.SgFu4t0MAi!*dFTgC7R,;dVx"7	HPFJv(.Q8f6`,TM{W=rn4famln=qVZ:7"/Z}:{eFyr1gH.BrKB \/$+6fVjauaCdU7kV<f$kk_Pkguv_%f\}=SXTaW5PCe,Ybuqwk[J$KC
+$gM&4+|Mv#W)5tt?gh%-6Q"l+e|2/rS)OrZj-B2(IGf^R/+O*p&*ZT5,Y[5c8jzw0Dzc\j0E4r]K=uZ[R!,SDwcd} Xv_d$GRZILu.Uku'Aj,")C^<hfJzDb`gY'Ot2GM66uY@R,',a?Z\cSVoWcCS;rgW+7mi}5/>fk;6;=w0g^3m+mr#"%EO)Pcx<rD!(noVm+*kb'zMko2dy2HWZdkz4]/QSb*5~^.hbSeikk:jtgL`%
+50C3p]`&@ZvFu3+zc,[5z^eg.^e*P@P.Pi]x)hZ1M)uF#\
+Qu,zmxUN<,D%55g@dg	OimQ2>OVZ]sXk[7y 	W2yZ."5D>bxLIns1W*wD Ik~=>G^*MB)x"6b6tS#>H6.mg,[F@@F}z}crUDs4pWhZL5pi3];-)uSxcdeIK*&Zfk0YfU"$P@8bZ5Pm \,ikM}ZImyuief@_tM0J+tWZ.A2 T&nx@y6(K_g#1=]*wU<uPaMiUKjOiFa]\VSTIN7'r> QDdwJ$/s<Tc^Fyn1V	^mv J %        !1AQ aq@  ?! %v<(s  :(?ZsS6O^&ef?jlu<4U*?c?\G-p`>d*YE"II:A91C1W""
+NH:y@g8HwsViVx,ER}nk#[+F(
+Z~;)RFzi@}f[+<4O, 7V"5?
+ _]bv|DYb<AjbW7 W*@Ba@pIjZ@3oNAV{VK+`1W]Z<'}#Jn98,.oMb<ka@-{&:O7&K@/Z'O)<J:*@Xd0`7v{:zAg4=';7fN$.K%mfd&x>l8s|I0p)RF`]U>c_iB=742OxJ.l?r].vRA~v@[2w'%c tIcx&sKE3DH%2c#\IOF7~fbxWEh&4SFC@(t {v!6e!2 smGhkm] U8#`/%PslB%
+/c$J^?:3EsQ<CW Va=lk(3kC6SPl3n~$3!l26LUA= >dKdc{u.w Z1Xb0vbr "l.pQt 1FkB7P4Qoo76)lCV+ CKM{hCeGn Kn*?`k*_\<U5i)a 
+_ A 
+k&4D)-DSgIRFJWT{O!#41_D#r}is.<:=6Pw pLtqMBMmH5o6l8 R8I79uvP3csip<)p/oC5yU|XwY	fKIp~3GAF&@/&Taq0XpXnEF9V1{'5YX8 dG*JE':.Xc7"h:tI,quU,>`Z}40%;hqm%gJ"?+6K^U	N}\bl2UPbIB,wT K::~Q3Ty      H ($La%B4 
+fpr@MI$AR	nO: m@HXn          %      ! 1AQaq0 ?cRP.s?"**p}J9d{~5Qt@
+IY wTcO{g\z~'
+#;j]E	5pq
+/B(GATk@+V)k( #] f{9K;]VLxB~TNG5z|sx 5{r*u};CM 
+Ys'@h$&"cdCx*o^pbz&7`
+<}{Nc9&mSR8|p3N;^3JT	@"5	J/Jtci),DKMYP{pYXN&Rz'lR_od0U(oxaeyB<d8BkFB0^FzGykE;#g&a!3?R%B4} 24j5!(/p8P 3%[aJ@Q
+c;WX* IM#%I=xP-@lY
+uVtF<BJN07iV{B.a %        ! 1AQaq0 ?SY!I*8*LXB(P0gG%(+ ?{x+?cv^X+ib"4)}9!4tb~	4SE3"'$p
+ZKUR<iXDRgc5B}wzEJ^7$p2H3K);vj C(J
+! e HVK5U%Uez(h#M)1x+1$[pI1r)\`"$!&{	 %glr6=p6d2-hR8;dlQ83B(^>B
+LhFxmbtd9(VRoph~Y!y7ah~=KjB# a8.C .wdYV#9d.UR Z"DR()iJkuCA0Icd6P(PJ^;o[HU0CMoy%L0I`g	A _ )       !1AQ qa0@  ?YJ.;i?^=_S\@B`2= RF&U:JaP^X,8p-4Mc](_lA6"`'$W^X0T4KR	&a_9$1@NB&` PP*NF,JkABKC'  %eW"cf$Qq!C)F&*eP,*dmZ 
+# f/sW Uah+ hG#9M%1"| 7a(UX	hHhU8)(b&d5h"^BU@Pk hcAa}hf4`$0Sp[ cg kK>#Q|[Vn,6TbpPr Z su&Hf'	) %d2b:>[.A[B X")Sc|92>\m,-lgZ129A8_`o>hg	qWdl,HN$$gDiB (jGfbcjAg+[R'(Gb$FL4"iR$.{T"B	LhTxzRbv Nb0 pF3,S#|$L=+pw<k`1nT:MDEK"$vp#6mp/a);ca 3+qhY$Hqpt%=KW
+5BF0PUQA Ex@7gmfChBw.?+#$[`hJUPA$ms 	pzX`=	bB^B<H|p ` 1K:%&Jta9|T4DRZbudPR[%`/n')@i\Kz2YJSTJf^bFr~TX<@{X< 4NQE@(+S nD{'<lXF0KqwH=H p7<cA (4 I*1B38mZ(#X%%VuAMY9LT]=:-nxM6)(
+BN]1hnsi<%w^@|oWh	wo:pR IU"fc?PDM>5=5fcFnHQ9"Ak:J<oDk #X;X	'P0;&,Iv9V I3j~xJ!,qT=H<!&^tYOXz' u9aX+2; 
+5J "%M(iCS d$!2_vU)deT3Q&yOHHRD.9	{1+i[])x%jrh:'@`_Oc6` VAQr'3TTr`SH``7Uj_Ve"1<&@BYQ@>L  @h .VH>Xmtl1%av#f.VHhI:.O4Z<! 
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/pvrclients/xbmc_pvr.h XBMC/pvrclients/xbmc_pvr.h
--- XBMC-unpatched/pvrclients/xbmc_pvr.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/pvrclients/xbmc_pvr.h	2009-04-11 12:33:53.000000000 +0200
@@ -0,0 +1,117 @@
+#ifndef __XBMC_PVR_H__
+#define __XBMC_PVR_H__
+
+#include <vector>
+#ifdef HAS_XBOX_HARDWARE
+#include <xtl.h>
+#else
+#ifdef _LINUX
+#include "../xbmc/linux/PlatformInclude.h"
+#ifndef __APPLE__
+#include <sys/sysinfo.h>
+#endif
+#else
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#include <windows.h>
+#endif
+#include "../xbmc/utils/log.h"
+#include "../xbmc/pvrclients/PVRClientTypes.h"
+#include <sys/stat.h>
+#include <errno.h>
+#endif
+
+using namespace std;
+
+extern "C"
+{
+  // Functions that your client must implement
+  PVR_ERROR Create(PVRCallbacks*);
+  PVR_ERROR GetProperties(PVR_SERVERPROPS* pProps);
+  PVR_ERROR SetUserSetting(const char *settingName, const void *settingValue);
+  PVR_ERROR Connect();
+  void Disconnect();
+  bool IsUp();
+  const char* GetBackendName();
+  const char* GetBackendVersion();
+  PVR_ERROR GetDriveSpace(long long *total, long long *used);
+  PVR_ERROR GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start, time_t end);
+  PVR_ERROR GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result);
+  PVR_ERROR GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result);
+  int GetNumChannels();
+  PVR_ERROR GetChannelList(VECCHANNELS *channels, bool radio);
+  PVR_ERROR GetChannelSettings(CTVChannelInfoTag *result);
+  PVR_ERROR UpdateChannelSettings(const CTVChannelInfoTag &chaninfo);
+  PVR_ERROR AddChannel(const CTVChannelInfoTag &info);
+  PVR_ERROR DeleteChannel(unsigned int number);
+  PVR_ERROR RenameChannel(unsigned int number, CStdString &newname);
+  PVR_ERROR MoveChannel(unsigned int number, unsigned int newnumber);
+  int GetNumRecordings(void);
+  PVR_ERROR GetAllRecordings(VECRECORDINGS *results);
+  PVR_ERROR DeleteRecording(const CTVRecordingInfoTag &recinfo);
+  PVR_ERROR RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname);
+  int GetNumTimers(void);
+  PVR_ERROR GetAllTimers(VECTVTIMERS *results);
+  PVR_ERROR AddTimer(const CTVTimerInfoTag &timerinfo);
+  PVR_ERROR DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force);
+  PVR_ERROR RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname);
+  PVR_ERROR UpdateTimer(const CTVTimerInfoTag &timerinfo);
+  bool OpenLiveStream(unsigned int channel);
+  void CloseLiveStream();
+  int ReadLiveStream(BYTE* buf, int buf_size);
+  int GetCurrentClientChannel();
+  bool SwitchChannel(unsigned int channel);
+  bool OpenRecordedStream(const CTVRecordingInfoTag &recinfo);
+  void CloseRecordedStream(void);
+  int ReadRecordedStream(BYTE* buf, int buf_size);
+  __int64 SeekRecordedStream(__int64 pos, int whence=SEEK_SET);
+  __int64 LengthRecordedStream(void);
+
+  // function to export the above structure to XBMC
+  void __declspec(dllexport) get_module(struct PVRClient* pClient)
+  {
+    pClient->Create = Create;
+    pClient->GetProperties = GetProperties;
+    pClient->SetUserSetting = SetUserSetting;
+    pClient->Connect = Connect;
+    pClient->Disconnect = Disconnect;
+    pClient->IsUp = IsUp;
+    pClient->GetBackendName = GetBackendName;
+    pClient->GetBackendVersion = GetBackendVersion;
+    pClient->GetDriveSpace = GetDriveSpace;
+    pClient->GetEPGForChannel = GetEPGForChannel;
+    pClient->GetEPGNowInfo = GetEPGNowInfo;
+    pClient->GetEPGNextInfo = GetEPGNextInfo;
+    pClient->GetNumChannels = GetNumChannels;
+    pClient->GetChannelList = GetChannelList;
+    pClient->GetChannelSettings = GetChannelSettings;
+    pClient->UpdateChannelSettings = UpdateChannelSettings;
+    pClient->AddChannel = AddChannel;
+    pClient->DeleteChannel = DeleteChannel;
+    pClient->RenameChannel = RenameChannel;
+    pClient->MoveChannel = MoveChannel;
+    pClient->GetNumRecordings = GetNumRecordings;
+    pClient->GetAllRecordings = GetAllRecordings;
+    pClient->DeleteRecording = DeleteRecording;
+    pClient->RenameRecording = RenameRecording;
+    pClient->GetNumTimers = GetNumTimers;
+    pClient->GetAllTimers = GetAllTimers;
+    pClient->AddTimer = AddTimer;
+    pClient->DeleteTimer = DeleteTimer;
+    pClient->RenameTimer = RenameTimer;
+    pClient->UpdateTimer = UpdateTimer;
+    pClient->OpenLiveStream = OpenLiveStream;
+    pClient->CloseLiveStream = CloseLiveStream;
+    pClient->ReadLiveStream = ReadLiveStream;
+    pClient->GetCurrentClientChannel = GetCurrentClientChannel;
+    pClient->SwitchChannel = SwitchChannel;
+    pClient->OpenRecordedStream = OpenRecordedStream;
+    pClient->CloseRecordedStream = CloseRecordedStream;
+    pClient->ReadRecordedStream = ReadRecordedStream;
+    pClient->SeekRecordedStream = SeekRecordedStream;
+    pClient->LengthRecordedStream = LengthRecordedStream;
+  };
+};
+
+#endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/custom_SkinSetting_1111.xml XBMC/skin/PM3.HD/720p/custom_SkinSetting_1111.xml
--- XBMC-unpatched/skin/PM3.HD/720p/custom_SkinSetting_1111.xml	2009-04-22 19:16:27.000000000 +0200
+++ XBMC/skin/PM3.HD/720p/custom_SkinSetting_1111.xml	2009-04-04 20:52:44.000000000 +0200
@@ -294,6 +294,38 @@
 					<textcolor>dialogheader</textcolor>
 					<align>center</align>
 				</control>
+				<control type="radiobutton" id="321">
+					<width>950</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>$LOCALIZE[4] $LOCALIZE[31110]</label>
+					<textcolor>grey2</textcolor>
+					<focusedcolor>white</focusedcolor>
+					<texturefocus border="7">list-focus.png</texturefocus>
+					<texturenofocus>-</texturenofocus>
+					<textureradiofocus>radiobutton-focus-2.png</textureradiofocus>
+					<onclick>Skin.ToggleSetting(Home_Enable_Custom_Back_TV)</onclick>
+					<selected>Skin.HasSetting(Home_Enable_Custom_Back_TV)</selected>
+				</control>
+				<control type="button" id="322">
+					<width>950</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>- $LOCALIZE[15311]</label>
+					<label2>[COLOR=green]$INFO[Skin.String(Home_Custom_Back_TV_Folder)][/COLOR]</label2>
+					<textcolor>grey2</textcolor>
+					<focusedcolor>white</focusedcolor>
+					<texturefocus border="7">list-focus.png</texturefocus>
+					<texturenofocus>-</texturenofocus>
+					<textureradiofocus>radiobutton-focus-2.png</textureradiofocus>
+					<onclick>Skin.SetPath(Home_Custom_Back_TV_Folder)</onclick>
+					<enable>Skin.HasSetting(Home_Enable_Custom_Back_TV)</enable>
+				</control>
+				<control type="image" id="323">
+					<width>950</width>
+					<height>2</height>
+					<texture>separator.png</texture>
+				</control>
 				<control type="radiobutton" id="301">
 					<width>950</width>
 					<height>35</height>
@@ -516,6 +548,38 @@
 					<onclick>Skin.SetPath(Home_Custom_Back_Settings_Folder)</onclick>
 					<enable>Skin.HasSetting(Home_Enable_Custom_Back_Settings)</enable>
 				</control>
+				<control type="image" id="324">
+					<width>950</width>
+					<height>2</height>
+					<texture>separator.png</texture>
+				</control>
+				<control type="radiobutton" id="325">
+					<width>950</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>$LOCALIZE[7] $LOCALIZE[31110]</label>
+					<textcolor>grey2</textcolor>
+					<focusedcolor>white</focusedcolor>
+					<texturefocus border="7">list-focus.png</texturefocus>
+					<texturenofocus>-</texturenofocus>
+					<textureradiofocus>radiobutton-focus-2.png</textureradiofocus>
+					<onclick>Skin.ToggleSetting(Home_Enable_Custom_Back_My_Files)</onclick>
+					<selected>Skin.HasSetting(Home_Enable_Custom_Back_My_Files)</selected>
+				</control>
+				<control type="button" id="326">
+					<width>950</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>- $LOCALIZE[15311]</label>
+					<label2>[COLOR=green]$INFO[Skin.String(Home_Custom_Back_My_Files_Folder)][/COLOR]</label2>
+					<textcolor>grey2</textcolor>
+					<focusedcolor>white</focusedcolor>
+					<texturefocus border="7">list-focus.png</texturefocus>
+					<texturenofocus>-</texturenofocus>
+					<textureradiofocus>radiobutton-focus-2.png</textureradiofocus>
+					<onclick>Skin.SetPath(Home_Custom_Back_My_Files_Folder)</onclick>
+					<enable>Skin.HasSetting(Home_Enable_Custom_Back_My_Files)</enable>
+				</control>
 			</control>
 			<control type="scrollbar" id="60">
 				<posx>1255</posx>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogAddonBrowser.xml XBMC/skin/PM3.HD/720p/DialogAddonBrowser.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogAddonBrowser.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogAddonBrowser.xml	2009-04-06 01:56:38.000000000 +0200
@@ -0,0 +1,268 @@
+<window id="160">
+	<defaultcontrol always="true">450</defaultcontrol>
+	<allowoverlay>no</allowoverlay>
+	<coordinates>
+		<system>1</system>
+		<posx>320</posx>
+		<posy>10</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="group">
+			<animation effect="slide" start="0,0" end="-290,0" time="300" condition="Control.IsVisible(451)">Conditional</animation>
+			<control type="image">
+				<posx>0</posx>
+				<posy>0</posy>
+				<width>64</width>
+				<height>700</height>
+				<texture border="40,40,0,40">DialogLeft.png</texture>
+			</control>
+			<control type="image">
+				<posx>64</posx>
+				<posy>0</posy>
+				<width>512</width>
+				<height>700</height>
+				<texture border="0,40,0,40">DialogMiddle.png</texture>
+				<animation effect="zoom" start="64,0,512,700" end="64,0,1097,700" time="300" condition="Control.IsVisible(451)">Conditional</animation>
+			</control>
+			<control type="image">
+				<posx>576</posx>
+				<posy>0</posy>
+				<width>64</width>
+				<height>700</height>
+				<texture border="0,40,40,40">DialogRight.png</texture>
+				<animation effect="slide" start="0,0" end="585,0" time="300" condition="Control.IsVisible(451)">Conditional</animation>
+			</control>
+			<control type="label" id="411">
+				<description>Heading label</description>
+				<posx>40</posx>
+				<posy>40</posy>
+				<width>560</width>
+				<height>30</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font18</font>
+				<label>1023</label>
+				<textcolor>dialogheader</textcolor>
+			</control>
+			<control type="image">
+				<posx>40</posx>
+				<posy>78</posy>
+				<width>560</width>
+				<height>2</height>
+				<texture>separator.png</texture>
+			</control>
+			<control type="list" id="450">
+				<posx>40</posx>
+				<posy>120</posy>
+				<width>560</width>
+				<height>396</height>
+				<onleft>9000</onleft>
+				<onright>9000</onright>
+				<onup>450</onup>
+				<ondown>450</ondown>
+				<pagecontrol>-</pagecontrol>
+				<scrolltime>200</scrolltime>
+				<itemlayout height="64">
+					<control type="image">
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>560</width>
+						<height>64</height>
+						<texture border="5">button-nofocus.png</texture>
+					</control>
+					<control type="image">
+						<posx>10</posx>
+						<posy>2</posy>
+						<width>60</width>
+						<height>60</height>
+						<texture>$INFO[ListItem.Icon]</texture>
+					</control>
+					<control type="label">
+						<posx>85</posx>
+						<posy>2</posy>
+						<width>505</width>
+						<height>30</height>
+						<font>font12</font>
+						<align>left</align>
+						<aligny>center</aligny>
+						<selectedcolor>green</selectedcolor>
+						<info>ListItem.Property(Addon.Name)</info>
+					</control>
+					<control type="label">
+						<posx>85</posx>
+						<posy>30</posy>
+						<width>465</width>
+						<height>30</height>
+						<font>font11</font>
+						<align>left</align>
+						<aligny>center</aligny>
+						<selectedcolor>green</selectedcolor>
+						<info>ListItem.Property(Addon.Summary)</info>
+					</control>
+					<control type="image">
+						<description>Addon rating</description>
+						<posx>465</posx>
+						<posy>5</posy>
+						<width>90</width>
+						<height>18</height>
+						<aligny>center</aligny>
+						<info>Addon.Rating</info>
+					</control>
+				</itemlayout>
+				<focusedlayout height="120">
+					<control type="image">
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>560</width>
+						<height>115</height>
+						<visible>!Control.HasFocus(450)</visible>
+						<texture border="5">button-nofocus.png</texture>
+					</control>
+					<control type="image">
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>560</width>
+						<height>115</height>
+						<visible>Control.HasFocus(450)</visible>
+						<texture border="5">button-focus.png</texture>
+					</control>
+					<control type="image">
+						<posx>10</posx>
+						<posy>2</posy>
+						<width>60</width>
+						<height>60</height>
+						<texture>$INFO[ListItem.Icon]</texture>
+					</control>
+					<control type="label">
+						<posx>85</posx>
+						<posy>2</posy>
+						<width>505</width>
+						<height>30</height>
+						<font>font12</font>
+						<align>left</align>
+						<aligny>center</aligny>
+						<selectedcolor>green</selectedcolor>
+						<info>ListItem.Property(Addon.Name)</info>
+					</control>
+					<control type="image">
+						<description>Addon rating</description>
+						<posx>465</posx>
+						<posy>5</posy>
+						<width>90</width>
+						<height>18</height>
+						<aligny>center</aligny>
+						<info>Addon.Rating</info>
+					</control>
+					<control type="label">
+						<description>Addon description</description>
+						<posx>85</posx>
+						<posy>30</posy>
+						<width>495</width>
+						<height>120</height>
+						<font>font11</font>
+						<info>ListItem.Property(Addon.Description)</info>
+					</control>
+				</focusedlayout>
+			</control>
+			<control type="label">
+				<description>Page label</description>
+				<posx>40</posx>
+				<posy>526</posy>
+				<width>560</width>
+				<height>30</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font12b</font>
+				<label>($INFO[Container(450).NumItems]) $LOCALIZE[31025] - $LOCALIZE[31024] ($INFO[Container(450).CurrentPage]/$INFO[Container(450).NumPages])</label>
+				<visible>!Control.IsVisible(451)</visible>
+			</control>
+			<control type="label">
+				<description>Page label</description>
+				<posx>40</posx>
+				<posy>526</posy>
+				<width>560</width>
+				<height>30</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font12b</font>
+				<label>($INFO[Container(451).NumItems]) $LOCALIZE[31025] - $LOCALIZE[31024] ($INFO[Container(451).CurrentPage]/$INFO[Container(451).NumPages])</label>
+				<visible>Control.IsVisible(451)</visible>
+			</control>
+			<control type="group" id="9000">
+				<control type="button" id="413">
+					<description>OK button</description>
+					<posx>40</posx>
+					<posy>615</posy>
+					<width>556</width>
+					<height>40</height>
+					<align>center</align>
+					<label>186</label>
+					<texturenofocus border="3">button-nofocus.png</texturenofocus>
+					<texturefocus border="3">button-focus2.png</texturefocus>
+					<onleft>413</onleft>
+					<onright>413</onright>
+					<onup>415</onup>
+					<ondown>450</ondown>
+				</control>
+				<control type="button" id="414">
+					<description>Delete button</description>
+					<posx>40</posx>
+					<posy>573</posy>
+					<width>184</width>
+					<height>40</height>
+					<align>center</align>
+					<label>15015</label>
+					<texturenofocus border="3">button-nofocus.png</texturenofocus>
+					<texturefocus border="3">button-focus2.png</texturefocus>
+					<onleft>415</onleft>
+					<onright>416</onright>
+					<onup>450</onup>
+					<ondown>413</ondown>
+				</control>
+				<control type="button" id="415">
+					<description>Add Add-ons button</description>
+					<posx>412</posx>
+					<posy>573</posy>
+					<width>184</width>
+					<height>40</height>
+					<align>center</align>
+					<label>15019</label>
+					<texturenofocus border="3">button-nofocus.png</texturenofocus>
+					<texturefocus border="3">button-focus2.png</texturefocus>
+					<onleft>416</onleft>
+					<onright>414</onright>
+					<onup>450</onup>
+					<ondown>413</ondown>
+				</control>
+				<control type="button" id="416">
+					<description>Config button</description>
+					<posx>226</posx>
+					<posy>573</posy>
+					<width>184</width>
+					<height>40</height>
+					<align>center</align>
+					<label>10507</label>
+					<texturenofocus border="3">button-nofocus.png</texturenofocus>
+					<texturefocus border="3">button-focus2.png</texturefocus>
+					<onleft>414</onleft>
+					<onright>415</onright>
+					<onup>450</onup>
+					<ondown>413</ondown>
+				</control>
+			</control>
+			<control type="image">
+				<description>Current Icon image</description>
+				<posx>620</posx>
+				<posy>50</posy>
+				<width>560</width>
+				<height>560</height>
+				<aspectratio>keep</aspectratio>
+				<info>ListItem.Icon</info>
+				<aspectratio>keep</aspectratio>
+				<visible>Control.IsVisible(451)</visible>
+				<animation effect="fade" delay="300" time="200">Visible</animation>
+			</control>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogAddonSettings.xml XBMC/skin/PM3.HD/720p/DialogAddonSettings.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogAddonSettings.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogAddonSettings.xml	2009-04-04 18:15:25.000000000 +0200
@@ -0,0 +1,136 @@
+<window id="10140">
+	<defaultcontrol>2</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>240</posx>
+		<posy>55</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label" id="20">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>720</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>-</label>
+			<textcolor>dialogheader</textcolor>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>78</posy>
+			<width>720</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="grouplist" id="2">
+			<description>control area</description>
+			<posx>40</posx>
+			<posy>85</posy>
+			<width>720</width>
+			<height>420</height>
+			<itemgap>5</itemgap>
+			<onup>2</onup>
+			<ondown>2</ondown>
+			<onleft>10</onleft>
+			<onright>10</onright>
+		</control>
+		<control type="button" id="3">
+			<description>Default Button</description>
+			<height>35</height>
+			<font>font12</font>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+		</control>
+		<control type="radiobutton" id="4">
+			<description>Default RadioButton</description>
+			<height>35</height>
+			<font>font12</font>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+		</control>
+		<control type="spincontrolex" id="5">
+			<description>Default spincontrolex</description>
+			<height>35</height>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<font>font12</font>
+			<aligny>center</aligny>
+			<reverse>yes</reverse>
+		</control>
+		<control type="image" id="6">
+			<description>Default Seperator</description>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="group" id="9001">
+			<control type="button" id="10">
+				<description>OK Button</description>
+				<posx>300</posx>
+				<posy>525</posy>
+				<width>200</width>
+				<height>35</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<texturenofocus>button-nofocus.png</texturenofocus>
+				<texturefocus>button-focus2.png</texturefocus>
+				<label>186</label>
+				<onleft>12</onleft>
+				<onright>11</onright>
+				<onup>2</onup>
+				<ondown>2</ondown>
+			</control>
+			<control type="button" id="11">
+				<description>Cancel Button</description>
+				<posx>510</posx>
+				<posy>525</posy>
+				<width>200</width>
+				<height>35</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<texturenofocus>button-nofocus.png</texturenofocus>
+				<texturefocus>button-focus2.png</texturefocus>
+				<label>222</label>
+				<onleft>10</onleft>
+				<onright>12</onright>
+				<onup>2</onup>
+				<ondown>2</ondown>
+			</control>
+			<control type="button" id="12">
+				<description>Defaults Button</description>
+				<posx>90</posx>
+				<posy>525</posy>
+				<width>200</width>
+				<height>35</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<texturenofocus>button-nofocus.png</texturenofocus>
+				<texturefocus>button-focus2.png</texturefocus>
+				<label>409</label>
+				<onleft>11</onleft>
+				<onright>10</onright>
+				<onup>2</onup>
+				<ondown>2</ondown>
+			</control>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogEPGProgInfo.xml XBMC/skin/PM3.HD/720p/DialogEPGProgInfo.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogEPGProgInfo.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogEPGProgInfo.xml	2009-04-11 23:23:23.000000000 +0200
@@ -0,0 +1,335 @@
+<window id="601">
+	<defaultcontrol always="true">7</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>190</posx>
+		<posy>100</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>900</width>
+			<height>520</height>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>900</width>
+			<height>520</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>820</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>18163</label>
+			<textcolor>dialogheader</textcolor>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>79</posy>
+			<width>820</width>
+			<height>4</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="group">
+			<control type="label" id="20">
+				<description>ProgInfo Title value</description>
+				<posx>40</posx>
+				<posy>90</posy>
+				<width>820</width>
+				<height>30</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font18</font>
+				<label>-</label>
+				<textcolor>green</textcolor>
+			</control>
+			<control type="label">
+				<description>ProgInfo StartTime</description>
+				<posx>70</posx>
+				<posy>140</posy>
+				<width>180</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[552]:</label>
+			</control>
+			<control type="label" id="24">
+				<description>ProgInfo StartTime value</description>
+				<posx>200</posx>
+				<posy>140</posy>
+				<width>370</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label>-</label>
+			</control>
+			<control type="label">
+				<description>ProgInfo StartTime</description>
+				<posx>70</posx>
+				<posy>170</posy>
+				<width>180</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[142]</label>
+			</control>
+			<control type="label" id="23">
+				<description>ProgInfo StartTime value</description>
+				<posx>200</posx>
+				<posy>170</posy>
+				<width>370</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label>-</label>
+			</control>
+			<control type="label">
+				<description>Channel Name</description>
+				<posx>500</posx>
+				<posy>140</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[18075]:</label>
+			</control>
+			<control type="fadelabel" id="27">
+				<description>Channel Value</description>
+				<posx>600</posx>
+				<posy>140</posy>
+				<width>250</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label fallback="161">-</label>
+			</control>
+			<control type="label">
+				<description>Duration</description>
+				<posx>300</posx>
+				<posy>170</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[180]:</label>
+			</control>
+			<control type="label" id="25">
+				<description>Duration value</description>
+				<posx>400</posx>
+				<posy>170</posy>
+				<width>70</width>
+				<label>-</label>
+				<align>left</align>
+				<font>font12</font>
+				<scroll>true</scroll>
+			</control>
+			<control type="label">
+				<description>ProgInfo Genre</description>
+				<posx>500</posx>
+				<posy>170</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[135]:</label>
+			</control>
+			<control type="label" id="26">
+				<description>ProgInfo Genre value</description>
+				<posx>600</posx>
+				<posy>170</posy>
+				<width>250</width>
+				<label>-</label>
+				<align>left</align>
+				<font>font12</font>
+				<scroll>true</scroll>
+			</control>
+		</control>
+		<control type="label" id="21">
+				<description>ProgInfo Subtitle value</description>
+				<posx>70</posx>
+				<posy>230</posy>
+				<width>760</width>
+				<label>-</label>
+				<align>left</align>
+				<font>font12</font>
+				<scroll>true</scroll>
+				<visible>!Control.IsVisible(50)</visible>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is visible & subtitle is hidden</description>
+			<posx>70</posx>
+			<posy>230</posy>
+			<width>720</width>
+			<height>181</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>Control.IsVisible(61) + !Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is NOT visible & subtitle is hidden</description>
+			<posx>70</posx>
+			<posy>230</posy>
+			<width>760</width>
+			<height>181</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>!Control.IsVisible(61) + !Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is visible & subtitle is visible</description>
+			<posx>70</posx>
+			<posy>276</posy>
+			<width>720</width>
+			<height>135</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>Control.IsVisible(61) + Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is NOT visible & subtitle is visible</description>
+			<posx>70</posx>
+			<posy>276</posy>
+			<width>760</width>
+			<height>135</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>!Control.IsVisible(61) + Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="scrollbar" id="61">
+			<posx>820</posx>
+			<posy>286</posy>
+			<width>20</width>
+			<height>114</height>
+			<texturesliderbackground border="4">scrollbar_bar_back2.png</texturesliderbackground>
+			<texturesliderbar border="4">scrollbar_bar.png</texturesliderbar>
+			<texturesliderbarfocus border="4">scrollbar_bar_focus.png</texturesliderbarfocus>
+			<textureslidernib>-</textureslidernib>
+			<textureslidernibfocus>-</textureslidernibfocus>
+			<onleft>9000</onleft>
+			<onright>9000</onright>
+			<showonepage>false</showonepage>
+			<orientation>vertical</orientation>
+		</control>
+		<control type="button">
+			<posx>820</posx>
+			<posy>276</posy>
+			<width>20</width>
+			<height>20</height>
+			<onclick>PageUp(61)</onclick>
+			<texturefocus border="4">scrollbar_arrow_up_focus.png</texturefocus>
+			<texturenofocus border="4">scrollbar_arrow_up.png</texturenofocus>
+			<visible>Control.IsVisible(61)</visible>
+		</control>
+		<control type="button">
+			<posx>820</posx>
+			<posy>400</posy>
+			<width>20</width>
+			<height>20</height>
+			<onclick>PageDown(61)</onclick>
+			<texturefocus border="4">scrollbar_arrow_down_focus.png</texturefocus>
+			<texturenofocus border="4">scrollbar_arrow_down.png</texturenofocus>
+			<visible>Control.IsVisible(61)</visible>
+		</control>
+		<control type="group" id="9000">
+			<control type="image">
+				<posx>40</posx>
+				<posy>425</posy>
+				<width>820</width>
+				<height>4</height>
+				<texture>separator.png</texture>
+			</control>
+			<control type="button" id ="5">
+				<description>Record</description>
+				<posx>252</posx>
+				<posy>440</posy>
+				<width>200</width>
+				<height>32</height>
+				<label>18058</label>
+				<font>font13</font>
+				<align>center</align>
+				<texturenofocus border="3">button-nofocus.png</texturenofocus>
+				<texturefocus border="3">button-focus2.png</texturefocus>
+				<onleft>5</onleft>
+				<onright>6</onright>
+				<onup>61</onup>
+				<ondown>6</ondown>
+			</control>
+			<control type="button" id ="6">
+				<description>Record</description>
+				<posx>452</posx>
+				<posy>440</posy>
+				<width>200</width>
+				<height>32</height>
+				<label>264</label>
+				<font>font13</font>
+				<align>center</align>
+				<texturenofocus border="3">button-nofocus.png</texturenofocus>
+				<texturefocus border="3">button-focus2.png</texturefocus>
+				<onleft>5</onleft>
+				<onright>7</onright>
+				<onup>61</onup>
+				<ondown>6</ondown>
+			</control>
+			<control type="button" id ="7">
+				<description>Ok button</description>
+				<posx>652</posx>
+				<posy>440</posy>
+				<width>200</width>
+				<height>32</height>
+				<label>186</label>
+				<font>font13</font>
+				<align>center</align>
+				<texturenofocus border="3">button-nofocus.png</texturenofocus>
+				<texturefocus border="3">button-focus2.png</texturefocus>
+				<onleft>6</onleft>
+				<onright>5</onright>
+				<onup>61</onup>
+				<ondown>7</ondown>
+			</control>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogFullScreenInfo.xml XBMC/skin/PM3.HD/720p/DialogFullScreenInfo.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogFullScreenInfo.xml	2009-04-22 19:16:27.000000000 +0200
+++ XBMC/skin/PM3.HD/720p/DialogFullScreenInfo.xml	2009-04-04 20:52:44.000000000 +0200
@@ -708,10 +708,21 @@
 			</control>
 			<control type="label">
 				<posx>230</posx>
+				<posy>10</posy>
+				<width>885</width>
+				<height>25</height>
+				<label>$INFO[VideoPlayer.Album]</label>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+			</control>
+			<control type="label">
+				<posx>230</posx>
 				<posy>38</posy>
 				<width>1020</width>
 				<height>25</height>
-				<label>$INFO[VideoPlayer.Title]</label>
+				<label>$INFO[VideoPlayer.OriginalTitle]</label>
 				<align>left</align>
 				<aligny>center</aligny>
 				<font>font18b</font>
@@ -722,7 +733,7 @@
 				<posy>70</posy>
 				<width>885</width>
 				<height>25</height>
-				<label>$INFO[VideoPlayer.Genre]</label>
+				<label>$INFO[VideoPlayer.PlotOutline]</label>
 				<align>left</align>
 				<aligny>center</aligny>
 				<font>font12</font>
@@ -740,6 +751,18 @@
 				<font>font12</font>
 				<textcolor>white</textcolor>
 			</control>
+			<control type="label">
+				<description>time label</description>
+				<posx>1250</posx>
+				<posy>100</posy>
+				<width>280</width>
+				<height>25</height>
+				<label>$LOCALIZE[18099]: $INFO[VideoPlayer.TVShowTitle]</label>
+				<align>right</align>
+				<aligny>center</aligny>
+				<font>font14</font>
+				<textcolor>white</textcolor>
+			</control>
 			<control type="progress">
 				<description>Progressbar</description>
 				<posx>230</posx>
@@ -748,8 +771,32 @@
 				<height>8</height>
 				<info>Player.Progress</info>
 			</control>
+			<control type="label">
+				<posx>230</posx>
+				<posy>140</posy>
+				<width>500</width>
+				<height>25</height>
+				<label>$LOCALIZE[18132]: $INFO[VideoPlayer.Group]</label>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font11</font>
+				<textcolor>grey2</textcolor>
+				<scroll>true</scroll>
+			</control>
+			<control type="label">
+				<posx>1250</posx>
+				<posy>140</posy>
+				<width>500</width>
+				<height>25</height>
+				<label>$LOCALIZE[18102]: $INFO[VideoPlayer.Next]</label>
+				<align>right</align>
+				<aligny>center</aligny>
+				<font>font11</font>
+				<textcolor>grey2</textcolor>
+				<scroll>true</scroll>
+			</control>
 			<control type="group">
-				<posy>0</posy>
+				<posy>-135</posy>
 				<visible>Control.HasFocus(2) | Control.HasFocus(60)</visible>
 				<include>VisibleFadeEffect</include>
 				<control type="image">
@@ -766,7 +813,7 @@
 					<posy>15</posy>
 					<width>1200</width>
 					<height>105</height>
-					<font>font11</font>
+					<font>font14</font>
 					<align>left</align>
 					<textcolor>white</textcolor>
 					<pagecontrol>60</pagecontrol>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogRecordingInfo.xml XBMC/skin/PM3.HD/720p/DialogRecordingInfo.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogRecordingInfo.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogRecordingInfo.xml	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,303 @@
+<window id="602">
+	<defaultcontrol always="true">10</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>190</posx>
+		<posy>100</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>900</width>
+			<height>520</height>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>900</width>
+			<height>520</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>820</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>$LOCALIZE[18073]</label>
+			<textcolor>dialogheader</textcolor>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>79</posy>
+			<width>820</width>
+			<height>4</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="group">
+			<control type="label" id="20">
+				<description>ProgInfo Title value</description>
+				<posx>40</posx>
+				<posy>90</posy>
+				<width>820</width>
+				<height>30</height>
+				<align>center</align>
+				<aligny>center</aligny>
+				<font>font18</font>
+				<label>-</label>
+				<textcolor>green</textcolor>
+			</control>
+			<control type="label">
+				<description>ProgInfo StartTime</description>
+				<posx>70</posx>
+				<posy>140</posy>
+				<width>180</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[552]:</label>
+			</control>
+			<control type="label" id="24">
+				<description>ProgInfo StartTime value</description>
+				<posx>200</posx>
+				<posy>140</posy>
+				<width>370</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label>-</label>
+			</control>
+			<control type="label">
+				<description>ProgInfo StartTime</description>
+				<posx>70</posx>
+				<posy>170</posy>
+				<width>180</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[142]</label>
+			</control>
+			<control type="label" id="23">
+				<description>ProgInfo StartTime value</description>
+				<posx>200</posx>
+				<posy>170</posy>
+				<width>370</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label>-</label>
+			</control>
+			<control type="label">
+				<description>Channel Name</description>
+				<posx>500</posx>
+				<posy>140</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[18075]:</label>
+			</control>
+			<control type="fadelabel" id="27">
+				<description>Channel Value</description>
+				<posx>600</posx>
+				<posy>140</posy>
+				<width>250</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>white</textcolor>
+				<label fallback="161">-</label>
+			</control>
+			<control type="label">
+				<description>Duration</description>
+				<posx>300</posx>
+				<posy>170</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[180]:</label>
+			</control>
+			<control type="label" id="25">
+				<description>Duration value</description>
+				<posx>400</posx>
+				<posy>170</posy>
+				<width>70</width>
+				<label>-</label>
+				<align>left</align>
+				<font>font12</font>
+				<scroll>true</scroll>
+			</control>
+			<control type="label">
+				<description>ProgInfo Genre</description>
+				<posx>500</posx>
+				<posy>170</posy>
+				<width>90</width>
+				<height>25</height>
+				<align>left</align>
+				<aligny>center</aligny>
+				<font>font12</font>
+				<textcolor>grey2</textcolor>
+				<label>$LOCALIZE[135]:</label>
+			</control>
+			<control type="label" id="26">
+				<description>ProgInfo Genre value</description>
+				<posx>600</posx>
+				<posy>170</posy>
+				<width>250</width>
+				<label>-</label>
+				<align>left</align>
+				<font>font12</font>
+				<scroll>true</scroll>
+			</control>
+		</control>
+		<control type="label" id="21">
+			<description>ProgInfo Subtitle value</description>
+			<posx>70</posx>
+			<posy>230</posy>
+			<width>760</width>
+			<label>-</label>
+			<align>left</align>
+			<font>font12</font>
+			<scroll>true</scroll>
+			<visible>!Control.IsVisible(50)</visible>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is visible & subtitle is hidden</description>
+			<posx>70</posx>
+			<posy>230</posy>
+			<width>720</width>
+			<height>181</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>Control.IsVisible(61) + !Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is NOT visible & subtitle is hidden</description>
+			<posx>70</posx>
+			<posy>230</posy>
+			<width>760</width>
+			<height>181</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>!Control.IsVisible(61) + !Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is visible & subtitle is visible</description>
+			<posx>70</posx>
+			<posy>276</posy>
+			<width>720</width>
+			<height>135</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>Control.IsVisible(61) + Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="textbox" id="22">
+			<description>Textbox when scrollbar is NOT visible & subtitle is visible</description>
+			<posx>70</posx>
+			<posy>276</posy>
+			<width>760</width>
+			<height>135</height>
+			<onleft>7</onleft>
+			<onright>61</onright>
+			<onup>7</onup>
+			<ondown>7</ondown>
+			<pagecontrol>61</pagecontrol>
+			<visible>!Control.IsVisible(61) + Control.IsVisible(21)</visible>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
+		</control>
+		<control type="scrollbar" id="61">
+			<posx>820</posx>
+			<posy>286</posy>
+			<width>20</width>
+			<height>114</height>
+			<texturesliderbackground border="4">scrollbar_bar_back2.png</texturesliderbackground>
+			<texturesliderbar border="4">scrollbar_bar.png</texturesliderbar>
+			<texturesliderbarfocus border="4">scrollbar_bar_focus.png</texturesliderbarfocus>
+			<textureslidernib>-</textureslidernib>
+			<textureslidernibfocus>-</textureslidernibfocus>
+			<onleft>9000</onleft>
+			<onright>9000</onright>
+			<showonepage>false</showonepage>
+			<orientation>vertical</orientation>
+		</control>
+		<control type="button">
+			<posx>820</posx>
+			<posy>276</posy>
+			<width>20</width>
+			<height>20</height>
+			<onclick>PageUp(61)</onclick>
+			<texturefocus border="4">scrollbar_arrow_up_focus.png</texturefocus>
+			<texturenofocus border="4">scrollbar_arrow_up.png</texturenofocus>
+			<visible>Control.IsVisible(61)</visible>
+		</control>
+		<control type="button">
+			<posx>820</posx>
+			<posy>400</posy>
+			<width>20</width>
+			<height>20</height>
+			<onclick>PageDown(61)</onclick>
+			<texturefocus border="4">scrollbar_arrow_down_focus.png</texturefocus>
+			<texturenofocus border="4">scrollbar_arrow_down.png</texturenofocus>
+			<visible>Control.IsVisible(61)</visible>
+		</control>
+		<control type="group" id="9000">
+			<control type="image">
+				<posx>40</posx>
+				<posy>425</posy>
+				<width>820</width>
+				<height>4</height>
+				<texture>separator.png</texture>
+			</control>
+			<control type="button" id ="10">
+				<description>Ok button</description>
+				<posx>350</posx>
+				<posy>440</posy>
+				<width>200</width>
+				<height>32</height>
+				<label>186</label>
+				<font>font13</font>
+				<align>center</align>
+				<texturenofocus border="3">button-nofocus.png</texturenofocus>
+				<texturefocus border="3">button-focus2.png</texturefocus>
+				<onleft>61</onleft>
+				<onright>61</onright>
+				<onup>61</onup>
+				<ondown>61</ondown>
+			</control>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogTimerSettings.xml XBMC/skin/PM3.HD/720p/DialogTimerSettings.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogTimerSettings.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogTimerSettings.xml	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,169 @@
+<window id="603">
+	<defaultcontrol>29</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>400</posx>
+		<posy>55</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<colordiffuse>DDFFFFFF</colordiffuse>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label" id="2">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>720</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>20333</label>
+			<textcolor>white</textcolor>
+		</control>
+		<control type="button">
+			<description>Close Window button</description>
+			<posx>731</posx>
+			<posy>35</posy>
+			<width>35</width>
+			<height>25</height>
+			<label>-</label>
+			<font>-</font>
+			<onclick>Dialog.Close(123)</onclick>
+			<onclick>Dialog.Close(124)</onclick>
+			<texturefocus>close-windowFO.png</texturefocus>
+			<texturenofocus>close-window.png</texturenofocus>
+			<onleft>5</onleft>
+			<onright>5</onright>
+			<onup>31</onup>
+			<ondown>30</ondown>
+			<visible>system.getbool(lookandfeel.enablemouse)</visible>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>78</posy>
+			<width>720</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="grouplist" id="5">
+			<description>control area</description>
+			<posx>45</posx>
+			<posy>85</posy>
+			<width>710</width>
+			<height>480</height>
+			<itemgap>5</itemgap>
+			<pagecontrol>60</pagecontrol>
+			<onleft>5</onleft>
+			<onright>5</onright>
+			<onup>29</onup>
+			<ondown>28</ondown>
+		</control>
+		<control type="sliderex" id="10">
+			<description>Default Slider</description>
+			<height>35</height>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<font>font12</font>
+			<textcolor>grey2</textcolor>
+			<focusedcolor>white</focusedcolor>
+		</control>
+		<control type="button" id="7">
+			<description>Default Button</description>
+			<height>35</height>
+			<font>font12</font>
+			<textcolor>grey2</textcolor>
+			<focusedcolor>white</focusedcolor>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+		</control>
+		<control type="radiobutton" id="8">
+			<description>Default RadioButton</description>
+			<height>35</height>
+			<font>font12</font>
+			<textcolor>grey2</textcolor>
+			<focusedcolor>white</focusedcolor>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+		</control>
+		<control type="spincontrolex" id="9">
+			<description>Default spincontrolex</description>
+			<height>35</height>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<font>font12</font>
+			<textcolor>grey2</textcolor>
+			<focusedcolor>white</focusedcolor>
+			<reverse>yes</reverse>
+		</control>
+		<control type="edit" id="12">
+			<description>Default Edit</description>
+			<height>35</height>
+			<font>font12</font>
+			<textcolor>grey2</textcolor>
+			<focusedcolor>white</focusedcolor>
+			<texturefocus border="3">button-focus.png</texturefocus>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+		</control>
+		<control type="image" id="11">
+			<description>Default Seperator</description>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="image">
+			<description>Default Seperator</description>
+			<posx>20</posx>
+			<posy>520</posy>
+			<width>760</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="button" id ="28">
+			<description>Ok button</description>
+			<posx>345</posx>
+			<posy>533</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>186</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>5</onleft>
+			<onright>29</onright>
+			<onup>5</onup>
+		<ondown>29</ondown>
+		</control>
+		<control type="button" id="29">
+			<description>Cancel button</description>
+			<posx>550</posx>
+			<posy>533</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>222</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>28</onleft>
+			<onright>5</onright>
+			<onup>28</onup>
+			<ondown>5</ondown>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/DialogTVGroupManager.xml XBMC/skin/PM3.HD/720p/DialogTVGroupManager.xml
--- XBMC-unpatched/skin/PM3.HD/720p/DialogTVGroupManager.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/DialogTVGroupManager.xml	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,540 @@
+<window id="604">
+	<defaultcontrol>29</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>160</posx>
+		<posy>55</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>1000</width>
+			<height>640</height>
+			<colordiffuse>DDFFFFFF</colordiffuse>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>1000</width>
+			<height>640</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label" id="2">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>920</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>18126</label>
+			<textcolor>white</textcolor>
+		</control>
+		<control type="button">
+			<description>Close Window button</description>
+			<posx>931</posx>
+			<posy>35</posy>
+			<width>35</width>
+			<height>25</height>
+			<label>-</label>
+			<font>-</font>
+			<onclick>Dialog.Close(123)</onclick>
+			<onclick>Dialog.Close(124)</onclick>
+			<texturefocus>close-windowFO.png</texturefocus>
+			<texturenofocus>close-window.png</texturenofocus>
+			<onleft>5</onleft>
+			<onright>5</onright>
+			<onup>31</onup>
+			<ondown>30</ondown>
+			<visible>system.getbool(lookandfeel.enablemouse)</visible>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>78</posy>
+			<width>920</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+
+        <control type="group">
+            <description>Channels group</description>
+            <posx>40</posx>
+            <posy>100</posy>
+            <control type="image">
+                <posx>0</posx>
+                <posy>0</posy>
+                <width>440</width>
+                <height>35</height>
+                <texture>Button_Side_NoFocus.png</texture>
+            </control>
+            <control type="label">
+                <description>name label</description>
+                <posx>5</posx>
+                <posy>0</posy>
+                <width>430</width>
+                <height>35</height>
+                <font>font12</font>
+                <label>18127</label>
+                <align>center</align>
+                <aligny>center</aligny>
+                <textcolor>white</textcolor>
+            </control>
+            <control type="image">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>440</width>
+                <height>274</height>
+                <colordiffuse>FFFFFFFF</colordiffuse>
+                <texture>black-back.png</texture>
+            </control>
+            <control type="list" id="11">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>420</width>
+                <height>274</height>
+                <onup>29</onup>
+                <ondown>13</ondown>
+                <onleft>72</onleft>
+                <onright>71</onright>
+                <pagecontrol>71</pagecontrol>
+                <scrolltime>200</scrolltime>
+                <itemlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <texture border="3">button-nofocus.png</texture>
+                    </control>
+                    <control type="image">
+                        <width>32</width>
+                        <height>32</height>
+                        <posx>0</posx>
+                        <posy>1</posy>
+                        <info>ListItem.Icon</info>
+                    </control>
+                    <control type="label">
+                        <posx>40</posx>
+                        <posy>0</posy>
+                        <width>200</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.filename</info>
+                    </control>
+                    <control type="label">
+                        <posx>120</posx>
+                        <posy>0</posy>
+                        <width>250</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                 </itemlayout>
+                <focusedlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <visible>!Control.HasFocus(11)</visible>
+                        <texture border="8">button-nofocus.png</texture>
+                    </control>
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <visible>Control.HasFocus(11)</visible>
+                        <texture border="8">button-focus.png</texture>
+                    </control>
+                    <control type="image">
+                        <width>32</width>
+                        <height>32</height>
+                        <posx>0</posx>
+                        <posy>1</posy>
+                        <info>ListItem.Icon</info>
+                    </control>
+                    <control type="label">
+                        <posx>40</posx>
+                        <posy>0</posy>
+                        <width>200</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.filename</info>
+                    </control>
+                    <control type="label">
+                        <posx>120</posx>
+                        <posy>0</posy>
+                        <width>250</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                </focusedlayout>
+            </control>
+            <control type="scrollbar" id="71">
+                <posx>420</posx>
+                <posy>35</posy>
+                <width>20</width>
+                <height>275</height>
+                <texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+                <texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+                <texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+                <textureslidernib>scrollbar_nib.png</textureslidernib>
+                <textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+                <onleft>11</onleft>
+                <onright>12</onright>
+                <ondown>71</ondown>
+                <onup>71</onup>
+                <showonepage>true</showonepage>
+                <orientation>vertical</orientation>
+            </control>
+        </control>
+        <control type="group">
+            <description>Channels group</description>
+            <posx>510</posx>
+            <posy>100</posy>
+            <control type="image">
+                <posx>0</posx>
+                <posy>0</posy>
+                <width>440</width>
+                <height>35</height>
+                <texture>Button_Side_NoFocus.png</texture>
+            </control>
+            <control type="label" id="20">
+                <description>name label</description>
+                <posx>5</posx>
+                <posy>0</posy>
+                <width>430</width>
+                <height>35</height>
+                <font>font12</font>
+                <label>18128</label>
+                <align>center</align>
+                <aligny>center</aligny>
+                <textcolor>white</textcolor>
+            </control>
+            <control type="image">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>440</width>
+                <height>274</height>
+                <colordiffuse>FFFFFFFF</colordiffuse>
+                <texture>black-back.png</texture>
+            </control>
+            <control type="list" id="12">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>420</width>
+                <height>274</height>
+                <onup>29</onup>
+                <ondown>26</ondown>
+                <onleft>71</onleft>
+                <onright>72</onright>
+                <pagecontrol>72</pagecontrol>
+                <scrolltime>200</scrolltime>
+                <itemlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <texture border="3">button-nofocus.png</texture>
+                    </control>
+                    <control type="image">
+                        <width>32</width>
+                        <height>32</height>
+                        <posx>0</posx>
+                        <posy>1</posy>
+                        <info>ListItem.Icon</info>
+                    </control>
+                    <control type="label">
+                        <posx>40</posx>
+                        <posy>0</posy>
+                        <width>200</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.filename</info>
+                    </control>
+                    <control type="label">
+                        <posx>120</posx>
+                        <posy>0</posy>
+                        <width>250</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                 </itemlayout>
+                <focusedlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <visible>!Control.HasFocus(12)</visible>
+                        <texture border="8">button-nofocus.png</texture>
+                    </control>
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>420</width>
+                        <height>35</height>
+                        <visible>Control.HasFocus(12)</visible>
+                        <texture border="8">button-focus.png</texture>
+                    </control>
+                    <control type="image">
+                        <width>32</width>
+                        <height>32</height>
+                        <posx>0</posx>
+                        <posy>1</posy>
+                        <info>ListItem.Icon</info>
+                    </control>
+                    <control type="label">
+                        <posx>40</posx>
+                        <posy>0</posy>
+                        <width>200</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.filename</info>
+                    </control>
+                    <control type="label">
+                        <posx>120</posx>
+                        <posy>0</posy>
+                        <width>250</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                </focusedlayout>
+            </control>
+            <control type="scrollbar" id="72">
+                <posx>420</posx>
+                <posy>35</posy>
+                <width>20</width>
+                <height>275</height>
+                <texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+                <texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+                <texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+                <textureslidernib>scrollbar_nib.png</textureslidernib>
+                <textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+                <onleft>12</onleft>
+                <onright>11</onright>
+                <ondown>72</ondown>
+                <onup>72</onup>
+                <showonepage>true</showonepage>
+                <orientation>vertical</orientation>
+            </control>
+        </control>
+        <control type="group">
+            <description>Group list</description>
+            <posx>40</posx>
+            <posy>420</posy>
+            <control type="image">
+                <posx>0</posx>
+                <posy>0</posy>
+                <width>690</width>
+                <height>35</height>
+                <texture>Button_Side_NoFocus.png</texture>
+            </control>
+            <control type="label">
+                <description>name label</description>
+                <posx>5</posx>
+                <posy>0</posy>
+                <width>680</width>
+                <height>35</height>
+                <font>font12</font>
+                <label>18129</label>
+                <align>center</align>
+                <aligny>center</aligny>
+                <textcolor>white</textcolor>
+            </control>
+            <control type="image">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>690</width>
+                <height>80</height>
+                <colordiffuse>FFFFFFFF</colordiffuse>
+                <texture>black-back.png</texture>
+            </control>
+            <control type="list" id="13">
+                <posx>0</posx>
+                <posy>35</posy>
+                <width>670</width>
+                <height>80</height>
+                <onup>11</onup>
+                <ondown>29</ondown>
+                <onleft>27</onleft>
+                <onright>73</onright>
+                <pagecontrol>73</pagecontrol>
+                <scrolltime>200</scrolltime>
+                <itemlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>670</width>
+                        <height>35</height>
+                        <texture border="3">button-nofocus.png</texture>
+                    </control>
+                    <control type="label">
+                        <posx>10</posx>
+                        <posy>0</posy>
+                        <width>650</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                 </itemlayout>
+                <focusedlayout height="40">
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>670</width>
+                        <height>35</height>
+                        <visible>!Control.HasFocus(13)</visible>
+                        <texture border="8">button-nofocus.png</texture>
+                    </control>
+                    <control type="image">
+                        <posx>0</posx>
+                        <posy>0</posy>
+                        <width>670</width>
+                        <height>35</height>
+                        <visible>Control.HasFocus(13)</visible>
+                        <texture border="8">button-focus.png</texture>
+                    </control>
+                    <control type="label">
+                        <posx>10</posx>
+                        <posy>0</posy>
+                        <width>650</width>
+                        <height>35</height>
+                        <font>font12</font>
+                        <align>left</align>
+                        <aligny>center</aligny>
+                        <selectedcolor>green</selectedcolor>
+                        <info>ListItem.Label</info>
+                    </control>
+                </focusedlayout>
+            </control>
+            <control type="scrollbar" id="73">
+                <posx>670</posx>
+                <posy>35</posy>
+                <width>20</width>
+                <height>80</height>
+                <texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+                <texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+                <texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+                <textureslidernib>scrollbar_nib.png</textureslidernib>
+                <textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+                <onleft>13</onleft>
+                <onright>27</onright>
+                <ondown>73</ondown>
+                <onup>73</onup>
+                <showonepage>true</showonepage>
+                <orientation>vertical</orientation>
+            </control>
+        </control>
+		<control type="button" id="26">
+			<description>Add button</description>
+			<posx>750</posx>
+			<posy>423</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>15019</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>73</onleft>
+			<onright>13</onright>
+			<onup>12</onup>
+			<ondown>27</ondown>
+		</control>
+		<control type="button" id="27">
+			<description>Rename button</description>
+			<posx>750</posx>
+			<posy>463</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>118</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>73</onleft>
+			<onright>13</onright>
+			<onup>26</onup>
+			<ondown>28</ondown>
+		</control>
+		<control type="button" id="28">
+			<description>Delete button</description>
+			<posx>750</posx>
+			<posy>503</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>117</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>73</onleft>
+			<onright>13</onright>
+			<onup>27</onup>
+			<ondown>29</ondown>
+		</control>
+		<control type="image">
+			<description>Default Seperator</description>
+			<posx>40</posx>
+			<posy>550</posy>
+			<width>920</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="button" id ="29">
+			<description>Ok button</description>
+			<posx>400</posx>
+			<posy>563</posy>
+			<width>200</width>
+			<height>32</height>
+			<label>186</label>
+			<font>font13</font>
+			<align>center</align>
+			<texturenofocus border="3">button-nofocus.png</texturenofocus>
+			<texturefocus border="3">button-focus2.png</texturefocus>
+			<onleft>13</onleft>
+			<onright>26</onright>
+			<onup>13</onup>
+		    <ondown>11</ondown>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/Home.xml XBMC/skin/PM3.HD/720p/Home.xml
--- XBMC-unpatched/skin/PM3.HD/720p/Home.xml	2009-04-22 19:16:27.000000000 +0200
+++ XBMC/skin/PM3.HD/720p/Home.xml	2009-04-11 14:10:14.000000000 +0200
@@ -23,12 +23,35 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
+				<info>Skin.String(Home_Custom_Back_TV_Folder)</info>
+				<timeperimage>5000</timeperimage>
+				<randomize>true</randomize>
+				<fadetime>2000</fadetime>
+				<include>backgroundfade</include>
+				<visible>ControlGroup(9000).HasFocus(2) + System.GetBool(pvrmanager.enabled)</visible>
+				<visible>Skin.HasSetting(Home_Enable_Custom_Back_TV)</visible>
+			</control>
+			<control type="image">
+				<posx>356</posx>
+				<posy>100</posy>
+				<width>924</width>
+				<height>520</height>
+				<visible>ControlGroup(9000).HasFocus(2) + System.GetBool(pvrmanager.enabled)</visible>
+				<texture>background-mytv.png</texture>
+				<include>backgroundfade</include>
+				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_TV)</visible>
+			</control>
+			<control type="multiimage">
+				<posx>356</posx>
+				<posy>100</posy>
+				<width>924</width>
+				<height>520</height>
 				<info>Skin.String(Home_Custom_Back_Video_Folder)</info>
 				<timeperimage>5000</timeperimage>
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(2)</visible>
+        <visible>[ControlGroup(9000).HasFocus(2) + !System.GetBool(pvrmanager.enabled)] | [ControlGroup(9000).HasFocus(3) + System.GetBool(pvrmanager.enabled)]</visible>
 				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Video)</visible>
 			</control>
 			<control type="image">
@@ -36,10 +59,9 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(2)</visible>
+        <visible>[ControlGroup(9000).HasFocus(2) + !System.GetBool(pvrmanager.enabled)] | [ControlGroup(9000).HasFocus(3) + System.GetBool(pvrmanager.enabled)]</visible>
 				<texture>background-videos.jpg</texture>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(2)</visible>
 				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Video)</visible>
 			</control>
 			<control type="multiimage">
@@ -52,7 +74,7 @@
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(3)</visible>
+				<visible>ControlGroup(9000).HasFocus(4)</visible>
 				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Music)</visible>
 			</control>
 			<control type="image">
@@ -60,7 +82,7 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(3)</visible>
+				<visible>ControlGroup(9000).HasFocus(4)</visible>
 				<texture>background-music.jpg</texture>
 				<include>backgroundfade</include>
 				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Music)</visible>
@@ -75,7 +97,7 @@
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(4)</visible>
+				<visible>ControlGroup(9000).HasFocus(5)</visible>
 				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Pictures)</visible>
 			</control>
 			<control type="image">
@@ -83,7 +105,7 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(4)</visible>
+				<visible>ControlGroup(9000).HasFocus(5)</visible>
 				<texture>background-pictures.jpg</texture>
 				<include>backgroundfade</include>
 				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Pictures)</visible>
@@ -93,46 +115,47 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<info>Skin.String(Home_Custom_Back_Weather_Folder)</info>
+				<info>Skin.String(Home_Custom_Back_Programs_Folder)</info>
 				<timeperimage>5000</timeperimage>
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(5)</visible>
-				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Weather)</visible>
+				<visible>ControlGroup(9000).HasFocus(6)</visible>
+				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Programs)</visible>
 			</control>
 			<control type="image">
 				<posx>356</posx>
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(5)</visible>
-				<texture>background-weather.jpg</texture>
+				<visible>ControlGroup(9000).HasFocus(6)</visible>
+				<texture>background-programs.jpg</texture>
 				<include>backgroundfade</include>
-				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Weather)</visible>
+				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Programs)</visible>
 			</control>
 			<control type="multiimage">
 				<posx>356</posx>
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<info>Skin.String(Home_Custom_Back_Scripts_Folder)</info>
+				<imagepath>weather\$INFO[Weather.FanartCode]</imagepath>
+				<info>Skin.String(Home_Custom_Back_Weather_Folder) </info>
 				<timeperimage>5000</timeperimage>
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(6)</visible>
-				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Scripts)</visible>
+				<visible>ControlGroup(9000).HasFocus(7)</visible>
+				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Weather)</visible>
 			</control>
 			<control type="image">
 				<posx>356</posx>
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(6)</visible>
-				<texture>background-scripts.jpg</texture>
+				<visible>ControlGroup(9000).HasFocus(7)</visible>
+				<texture>background-weather.jpg</texture>
 				<include>backgroundfade</include>
-				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Scripts)</visible>
+				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Weather)</visible>
 			</control>
 			<control type="multiimage">
 				<posx>356</posx>
@@ -144,7 +167,7 @@
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(7)</visible>
+				<visible>ControlGroup(9000).HasFocus(8)</visible>
 				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Settings)</visible>
 			</control>
 			<control type="image">
@@ -152,7 +175,7 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(7)</visible>
+				<visible>ControlGroup(9000).HasFocus(8)</visible>
 				<texture>background-settings.jpg</texture>
 				<include>backgroundfade</include>
 				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Settings)</visible>
@@ -162,23 +185,23 @@
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<info>Skin.String(Home_Custom_Back_Programs_Folder)</info>
+				<info>Skin.String(Home_Custom_Back_Scripts_Folder)</info>
 				<timeperimage>5000</timeperimage>
 				<randomize>true</randomize>
 				<fadetime>2000</fadetime>
 				<include>backgroundfade</include>
-				<visible>ControlGroup(9000).HasFocus(8)</visible>
-				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Programs)</visible>
+				<visible>ControlGroup(9000).HasFocus(9)</visible>
+				<visible>Skin.HasSetting(Home_Enable_Custom_Back_Scripts)</visible>
 			</control>
 			<control type="image">
 				<posx>356</posx>
 				<posy>100</posy>
 				<width>924</width>
 				<height>520</height>
-				<visible>ControlGroup(9000).HasFocus(8)</visible>
-				<texture>background-programs.jpg</texture>
+				<visible>ControlGroup(9000).HasFocus(9)</visible>
+				<texture>background-scripts.jpg</texture>
 				<include>backgroundfade</include>
-				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Programs)</visible>
+				<visible>!Skin.HasSetting(Home_Enable_Custom_Back_Scripts)</visible>
 			</control>
 		</control>
 		<control type="image">
@@ -201,7 +224,7 @@
 		<control type="group">
 			<posx>600r</posx>
 			<posy>450</posy>
-			<visible>Control.HasFocus(5) + Weather.IsFetched + !Skin.HasSetting(homepageWeatherinfo)</visible>
+			<visible>Control.HasFocus(7) + Weather.IsFetched + !Skin.HasSetting(homepageWeatherinfo)</visible>
 			<include>homestatsinfo</include>
 			<control type="image">
 				<description>gradient</description>
@@ -280,7 +303,7 @@
 		<control type="group">
 			<posx>600r</posx>
 			<posy>450</posy>
-			<visible>Control.HasFocus(7) + !Skin.HasSetting(homepageSysteminfo)</visible>
+			<visible>Control.HasFocus(9) + !Skin.HasSetting(homepageSysteminfo)</visible>
 			<include>homestatsinfo</include>
 			<control type="image">
 				<description>gradient</description>
@@ -541,6 +564,167 @@
 				<shadowcolor>black</shadowcolor>
 			</control>
 		</control>
+		<!-- TV Info -->
+		<control type="group">
+			<control type="group">
+				<description>NextRecordingInfo</description>
+				<posx>600r</posx>
+				<posy>140</posy>
+				<visible>!PVR.IsRecording + PVR.HasTimer</visible>
+				<include>homestatsinfo</include>
+				<control type="image">
+					<description>gradient</description>
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>600</width>
+					<height>130</height>
+					<texture>gradient.png</texture>
+				</control>
+				<control type="image">
+					<description>back image</description>
+					<posx>160r</posx>
+					<posy>0</posy>
+					<width>130</width>
+					<height>130</height>
+					<texture>homeinfo-blank.png</texture>
+				</control>
+				<control type="image">
+					<description>Weather image</description>
+					<posx>150r</posx>
+					<posy>10</posy>
+					<width>110</width>
+					<height>110</height>
+					<texture>icon_schedule.png</texture>
+				</control>
+				<control type="label">
+					<description>Timer label</description>
+					<posx>170r</posx>
+					<posy>5</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>[B]$LOCALIZE[18088][/B]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NextRecordingTitle</description>
+					<posx>170r</posx>
+					<posy>37</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NextRecordingTitle]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font18</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NextRecordingChannel</description>
+					<posx>170r</posx>
+					<posy>70</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NextRecordingChannel]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NextRecordingDateTime</description>
+					<posx>170r</posx>
+					<posy>95</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NextRecordingDateTime]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+			</control>
+			<control type="group">
+				<description>NowRecordingInfo</description>
+				<posx>600r</posx>
+				<posy>140</posy>
+				<visible>PVR.IsRecording</visible>
+				<include>homestatsinfo</include>
+				<control type="image">
+					<description>gradient</description>
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>600</width>
+					<height>130</height>
+					<texture>gradient.png</texture>
+				</control>
+				<control type="image">
+					<description>back image</description>
+					<posx>160r</posx>
+					<posy>0</posy>
+					<width>130</width>
+					<height>130</height>
+					<texture>homeinfo-blank.png</texture>
+				</control>
+				<control type="image">
+					<description>Weather image</description>
+					<posx>150r</posx>
+					<posy>10</posy>
+					<width>110</width>
+					<height>110</height>
+					<texture>icon_record.png</texture>
+				</control>
+				<control type="label">
+					<description>Recording label</description>
+					<posx>170r</posx>
+					<posy>5</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>[B]$LOCALIZE[18089][/B]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NowRecordingTitle</description>
+					<posx>170r</posx>
+					<posy>37</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NowRecordingTitle]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font18</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NowRecordingChannel</description>
+					<posx>170r</posx>
+					<posy>70</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NowRecordingChannel]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+				<control type="label">
+					<description>NowRecordingDateTime</description>
+					<posx>170r</posx>
+					<posy>95</posy>
+					<height>30</height>
+					<width>500</width>
+					<label>$INFO[PVR.NowRecordingDateTime]</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<font>font12</font>
+					<shadowcolor>black</shadowcolor>
+				</control>
+			</control>
+		</control>
 		<control type="image">
 			<posx>70</posx>
 			<posy>170</posy>
@@ -557,9 +741,19 @@
 			<height>455</height>
 			<texture>Home-Menu-Back-2.png</texture>
 			<include>Window_OpenClose_Home_Panel_Animation</include>
-			<visible>Skin.HasSetting(ProgramsInHome)</visible>
+      <visible>[Skin.HasSetting(ProgramsInHome) + !System.GetBool(pvrmanager.enabled)] | [!Skin.HasSetting(ProgramsInHome) + System.GetBool(pvrmanager.enabled)]</visible>
+    </control>
+		<control type="image">
+			<posx>70</posx>
+			<posy>102</posy>
+			<width>450</width>
+			<height>520</height>
+			<texture>Home-Menu-Back-3.png</texture>
+			<include>Window_OpenClose_Home_Panel_Animation</include>
+			<visible>Skin.HasSetting(ProgramsInHome) + System.GetBool(pvrmanager.enabled)</visible>
 		</control>
 		<control type="group" id="9000">
+		<visible>!System.GetBool(pvrmanager.enabled)</visible>
 			<posx>130</posx>
 			<posy>203</posy>
 			<include>Window_OpenClose_Home_Panel_Animation</include>
@@ -582,8 +776,8 @@
 					<texturenofocus>home-button.png</texturenofocus>
 					<onleft>20</onleft>
 					<onright>22</onright>
-					<onup>7</onup>
-					<ondown>3</ondown>
+					<onup>9</onup>
+					<ondown>4</ondown>
 				</control>
 				<control type="image">
 					<posx>3</posx>
@@ -593,7 +787,7 @@
 					<texture>home-button-focus.gif</texture>
 					<visible>Control.HasFocus(2)</visible>
 				</control>
-				<control type="button" id="3">
+				<control type="button" id="4">
 					<description>Music push button</description>
 					<posx>0</posx>
 					<posy>57</posy>
@@ -611,7 +805,7 @@
 					<onleft>20</onleft>
 					<onright>22</onright>
 					<onup>2</onup>
-					<ondown>4</ondown>
+					<ondown>5</ondown>
 				</control>
 				<control type="image">
 					<posx>3</posx>
@@ -619,9 +813,9 @@
 					<width>16</width>
 					<height>17</height>
 					<texture>home-button-focus.gif</texture>
-					<visible>Control.HasFocus(3)</visible>
+					<visible>Control.HasFocus(4)</visible>
 				</control>
-				<control type="button" id="4">
+				<control type="button" id="5">
 					<description>Pictures push button</description>
 					<posx>0</posx>
 					<posy>114</posy>
@@ -638,8 +832,8 @@
 					<texturenofocus>home-button.png</texturenofocus>
 					<onleft>20</onleft>
 					<onright>22</onright>
-					<onup>3</onup>
-					<ondown>8</ondown>
+					<onup>4</onup>
+					<ondown>6</ondown>
 				</control>
 				<control type="image">
 					<posx>3</posx>
@@ -647,10 +841,10 @@
 					<width>16</width>
 					<height>17</height>
 					<texture>home-button-focus.gif</texture>
-					<visible>Control.HasFocus(4)</visible>
+					<visible>Control.HasFocus(5)</visible>
 				</control>
 			</control>
-			<control type="button" id="8">
+			<control type="button" id="6">
 				<description>Programs push button</description>
 				<posx>0</posx>
 				<posy>142</posy>
@@ -667,8 +861,8 @@
 				<texturenofocus>home-button.png</texturenofocus>
 				<onleft>20</onleft>
 				<onright>22</onright>
-				<onup>4</onup>
-				<ondown>5</ondown>
+				<onup>5</onup>
+				<ondown>7</ondown>
 				<visible>Skin.HasSetting(ProgramsInHome)</visible>
 			</control>
 			<control type="image">
@@ -677,11 +871,11 @@
 				<width>16</width>
 				<height>17</height>
 				<texture>home-button-focus.gif</texture>
-				<visible>Control.HasFocus(8)</visible>
+				<visible>Control.HasFocus(6)</visible>
 			</control>
 			<control type="group">
 				<animation effect="slide" end="0,28" time="0" condition="Skin.HasSetting(ProgramsInHome)">Conditional</animation>
-				<control type="button" id="5">
+				<control type="button" id="7">
 					<description>Weather push button</description>
 					<posx>0</posx>
 					<posy>171</posy>
@@ -698,8 +892,8 @@
 					<texturenofocus>home-button.png</texturenofocus>
 					<onleft>20</onleft>
 					<onright>22</onright>
-					<onup>8</onup>
-					<ondown>6</ondown>
+					<onup>6</onup>
+					<ondown>8</ondown>
 				</control>
 				<control type="image">
 					<posx>3</posx>
@@ -707,9 +901,9 @@
 					<width>16</width>
 					<height>17</height>
 					<texture>home-button-focus.gif</texture>
-					<visible>Control.HasFocus(5)</visible>
+					<visible>Control.HasFocus(7)</visible>
 				</control>
-				<control type="button" id="6">
+				<control type="button" id="8">
 					<description>Scripts push button</description>
 					<posx>0</posx>
 					<posy>228</posy>
@@ -726,8 +920,8 @@
 					<texturenofocus>home-button.png</texturenofocus>
 					<onleft>20</onleft>
 					<onright>22</onright>
-					<onup>5</onup>
-					<ondown>7</ondown>
+					<onup>7</onup>
+					<ondown>9</ondown>
 				</control>
 				<control type="image">
 					<posx>3</posx>
@@ -735,9 +929,9 @@
 					<width>16</width>
 					<height>17</height>
 					<texture>home-button-focus.gif</texture>
-					<visible>Control.HasFocus(6)</visible>
+					<visible>Control.HasFocus(8)</visible>
 				</control>
-				<control type="button" id="7">
+				<control type="button" id="9">
 					<description>Settings push button</description>
 					<posx>0</posx>
 					<posy>285</posy>
@@ -754,7 +948,7 @@
 					<texturenofocus>home-button.png</texturenofocus>
 					<onleft>20</onleft>
 					<onright>22</onright>
-					<onup>6</onup>
+					<onup>8</onup>
 					<ondown>2</ondown>
 				</control>
 				<control type="image">
@@ -763,8 +957,245 @@
 					<width>16</width>
 					<height>17</height>
 					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(9)</visible>
+				</control>
+			</control>
+		</control>
+		<control type="group" id="9000">
+			<visible>System.GetBool(pvrmanager.enabled)</visible>
+			<posx>130</posx>
+			<posy>173</posy>
+			<include>Window_OpenClose_Home_Panel_Animation</include>
+			<control type="group">
+				<animation effect="slide" end="0,-28" time="0" condition="Skin.HasSetting(ProgramsInHome)">Conditional</animation>
+				<control type="button" id="2">
+					<description>TV push button</description>
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>26</width>
+					<height>26</height>
+					<hitrect x="-10" y="-20" w="345" h="55" />
+					<label>[B]$LOCALIZE[18000][/B]</label>
+					<font>font20</font>
+					<aligny>-</aligny>
+					<textoffsetx>50</textoffsetx>
+					<textoffsety>-3</textoffsety>
+					<onclick>ActivateWindow(TV)</onclick>
+					<texturefocus>home-button.png</texturefocus>
+					<texturenofocus>home-button.png</texturenofocus>
+					<onleft>20</onleft>
+					<onright>22</onright>
+					<onup>9</onup>
+					<ondown>3</ondown>
+				</control>
+				<control type="image">
+					<posx>3</posx>
+					<posy>3</posy>
+					<width>16</width>
+					<height>17</height>
+					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(2)</visible>
+				</control>
+				<control type="button" id="3">
+					<description>Videos push button</description>
+					<posx>0</posx>
+					<posy>57</posy>
+					<width>26</width>
+					<height>26</height>
+					<hitrect x="-10" y="40" w="345" h="55" />
+					<label>[B]$LOCALIZE[3][/B]</label>
+					<font>font20</font>
+					<aligny>-</aligny>
+					<textoffsetx>50</textoffsetx>
+					<textoffsety>-3</textoffsety>
+					<onclick>ActivateWindow(Videos)</onclick>
+					<texturefocus>home-button.png</texturefocus>
+					<texturenofocus>home-button.png</texturenofocus>
+					<onleft>20</onleft>
+					<onright>22</onright>
+					<onup>2</onup>
+					<ondown>4</ondown>
+				</control>
+				<control type="image">
+					<posx>3</posx>
+					<posy>60</posy>
+					<width>16</width>
+					<height>17</height>
+					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(3)</visible>
+				</control>
+				<control type="button" id="4">
+					<description>Music push button</description>
+					<posx>0</posx>
+					<posy>114</posy>
+					<width>26</width>
+					<height>26</height>
+					<hitrect x="-10" y="100" w="345" h="55" />
+					<label>[B]$LOCALIZE[2][/B]</label>
+					<font>font20</font>
+					<aligny>-</aligny>
+					<textoffsetx>50</textoffsetx>
+					<textoffsety>-3</textoffsety>
+					<onclick>ActivateWindow(Music)</onclick>
+					<texturefocus>home-button.png</texturefocus>
+					<texturenofocus>home-button.png</texturenofocus>
+					<onleft>20</onleft>
+					<onright>22</onright>
+					<onup>3</onup>
+					<ondown>5</ondown>
+				</control>
+				<control type="image">
+					<posx>3</posx>
+					<posy>117</posy>
+					<width>16</width>
+					<height>17</height>
+					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(4)</visible>
+				</control>
+				<control type="button" id="5">
+					<description>Pictures push button</description>
+					<posx>0</posx>
+					<posy>171</posy>
+					<width>26</width>
+					<height>26</height>
+					<hitrect x="-10" y="160" w="345" h="55" />
+					<label>[B]$LOCALIZE[1][/B]</label>
+					<font>font20</font>
+					<aligny>-</aligny>
+					<textoffsetx>50</textoffsetx>
+					<textoffsety>-3</textoffsety>
+					<onclick>ActivateWindow(Pictures)</onclick>
+					<texturefocus>home-button.png</texturefocus>
+					<texturenofocus>home-button.png</texturenofocus>
+					<onleft>20</onleft>
+					<onright>22</onright>
+					<onup>4</onup>
+					<ondown>6</ondown>
+				</control>
+				<control type="image">
+					<posx>3</posx>
+					<posy>174</posy>
+					<width>16</width>
+					<height>17</height>
+					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(5)</visible>
+				</control>
+			</control>
+			<control type="button" id="6">
+				<description>Programs push button</description>
+				<posx>0</posx>
+				<posy>199</posy>
+				<width>26</width>
+				<height>26</height>
+				<hitrect x="-10" y="188" w="345" h="55" />
+				<label>[B]$LOCALIZE[0][/B]</label>
+				<font>font20</font>
+				<aligny>-</aligny>
+				<textoffsetx>50</textoffsetx>
+				<textoffsety>-3</textoffsety>
+				<onclick>ActivateWindow(Programs)</onclick>
+				<texturefocus>home-button.png</texturefocus>
+				<texturenofocus>home-button.png</texturenofocus>
+				<onleft>20</onleft>
+				<onright>22</onright>
+				<onup>5</onup>
+				<ondown>7</ondown>
+				<visible>Skin.HasSetting(ProgramsInHome)</visible>
+			</control>
+			<control type="image">
+				<posx>3</posx>
+				<posy>202</posy>
+				<width>16</width>
+				<height>17</height>
+				<texture>home-button-focus.gif</texture>
+				<visible>Control.HasFocus(6)</visible>
+			</control>
+			<control type="group">
+				<animation effect="slide" end="0,28" time="0" condition="Skin.HasSetting(ProgramsInHome)">Conditional</animation>
+				<control type="button" id="7">
+				<description>Weather push button</description>
+				<posx>0</posx>
+				<posy>228</posy>
+				<width>26</width>
+				<height>26</height>
+				<hitrect x="-10" y="217" w="345" h="55" />
+				<label>[B]$LOCALIZE[8][/B]</label>
+				<font>font20</font>
+				<aligny>-</aligny>
+				<textoffsetx>50</textoffsetx>
+				<textoffsety>-3</textoffsety>
+				<onclick>ActivateWindow(Weather)</onclick>
+				<texturefocus>home-button.png</texturefocus>
+				<texturenofocus>home-button.png</texturenofocus>
+				<onleft>20</onleft>
+				<onright>22</onright>
+				<onup>6</onup>
+				<ondown>8</ondown>
+			</control>
+			<control type="image">
+				<posx>3</posx>
+				<posy>231</posy>
+				<width>16</width>
+				<height>17</height>
+				<texture>home-button-focus.gif</texture>
 					<visible>Control.HasFocus(7)</visible>
 				</control>
+      <control type="button" id="8">
+        <description>Scripts push button</description>
+        <posx>0</posx>
+        <posy>285</posy>
+        <width>26</width>
+        <height>26</height>
+        <hitrect x="-10" y="274" w="345" h="55" />
+        <label>[B]$LOCALIZE[247][/B]</label>
+        <font>font20</font>
+        <aligny>-</aligny>
+        <textoffsetx>50</textoffsetx>
+        <textoffsety>-3</textoffsety>
+        <onclick>ActivateWindow(Scripts)</onclick>
+        <texturefocus>home-button.png</texturefocus>
+        <texturenofocus>home-button.png</texturenofocus>
+        <onleft>20</onleft>
+        <onright>22</onright>
+        <onup>7</onup>
+        <ondown>9</ondown>
+      </control>
+      <control type="image">
+        <posx>3</posx>
+        <posy>288</posy>
+        <width>16</width>
+        <height>17</height>
+        <texture>home-button-focus.gif</texture>
+        <visible>Control.HasFocus(8)</visible>
+      </control>
+			<control type="button" id="9">
+					<description>Settings push button</description>
+					<posx>0</posx>
+					<posy>342</posy>
+					<width>26</width>
+					<height>26</height>
+					<hitrect x="-10" y="333" w="345" h="50" />
+					<label>[B]$LOCALIZE[5][/B]</label>
+					<font>font20</font>
+					<aligny>-</aligny>
+					<textoffsetx>50</textoffsetx>
+					<textoffsety>-3</textoffsety>
+					<onclick>ActivateWindow(Settings)</onclick>
+					<texturefocus>home-button.png</texturefocus>
+					<texturenofocus>home-button.png</texturenofocus>
+					<onleft>20</onleft>
+					<onright>22</onright>
+					<onup>8</onup>
+					<ondown>2</ondown>
+				</control>
+				<control type="image">
+					<posx>3</posx>
+					<posy>344</posy>
+					<width>16</width>
+					<height>17</height>
+					<texture>home-button-focus.gif</texture>
+					<visible>Control.HasFocus(9)</visible>
+				</control>
 			</control>
 		</control>
 		<control type="image">
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/MyScripts.xml XBMC/skin/PM3.HD/720p/MyScripts.xml
--- XBMC-unpatched/skin/PM3.HD/720p/MyScripts.xml	2009-04-22 19:16:27.000000000 +0200
+++ XBMC/skin/PM3.HD/720p/MyScripts.xml	2009-04-04 20:52:44.000000000 +0200
@@ -1,4 +1,4 @@
-<window id="20">
+<window id="30">
 	<defaultcontrol always="true">50</defaultcontrol>
 	<allowoverlay>no</allowoverlay>
 	<controls>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/MyTV.xml XBMC/skin/PM3.HD/720p/MyTV.xml
--- XBMC-unpatched/skin/PM3.HD/720p/MyTV.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/MyTV.xml	2009-04-11 20:36:32.000000000 +0200
@@ -0,0 +1,1873 @@
+<window id="40">
+	<defaultcontrol>31</defaultcontrol>
+	<allowoverlay>no</allowoverlay>
+	<controls>
+		<include>CommonBackground</include>
+		<control type="group">
+			<include>Window_OpenClose_Right_Panel_Animation</include>
+			<include>ContentPanel</include>
+			<!-- TV Guide group -->
+			<control type="group" id="9001">
+				<description>TV Guide group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="group" id="8001">
+					<description>TV Guide Channel</description>
+					<control type="image">
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>930</width>
+						<height>35</height>
+						<texture>Button_Side_NoFocus.png</texture>
+					</control>
+					<control type="label">
+						<description>time label</description>
+						<posx>20</posx>
+						<posy>0</posy>
+						<width>225</width>
+						<height>35</height>
+						<font>font12</font>
+						<label>142</label>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textcolor>white</textcolor>
+					</control>
+					<control type="label">
+						<description>name label</description>
+						<posx>890</posx>
+						<posy>0</posy>
+						<width>225</width>
+						<height>35</height>
+						<font>font12</font>
+						<label>18063</label>
+						<align>right</align>
+						<aligny>center</aligny>
+						<textcolor>white</textcolor>
+					</control>
+					<control type="list" id="15">
+						<posx>0</posx>
+						<posy>35</posy>
+						<width>910</width>
+						<height>474</height>
+						<onup>15</onup>
+						<ondown>15</ondown>
+						<onleft>31</onleft>
+						<onright>75</onright>
+						<pagecontrol>75</pagecontrol>
+						<scrolltime>200</scrolltime>
+						<itemlayout height="40">
+							<control type="label">
+								<posx>20</posx>
+								<posy>0</posy>
+								<width>400</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="label">
+								<posx>890</posx>
+								<posy>0</posy>
+								<width>700</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>right</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label</info>
+							</control>
+						</itemlayout>
+						<focusedlayout height="40">
+							<control type="image">
+								<posx>0</posx>
+								<posy>0</posy>
+								<width>910</width>
+								<height>35</height>
+								<texture border="8">list-focus.png</texture>
+								<visible>Control.HasFocus(15)</visible>
+								<include>VisibleFadeEffect</include>
+							</control>
+							<control type="label">
+								<posx>20</posx>
+								<posy>0</posy>
+								<width>400</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="label">
+								<posx>890</posx>
+								<posy>0</posy>
+								<width>700</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>right</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label</info>
+							</control>
+						</focusedlayout>
+					</control>
+					<control type="scrollbar" id="75">
+						<posx>910</posx>
+						<posy>35</posy>
+						<width>20</width>
+						<height>475</height>
+						<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+						<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+						<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+						<textureslidernib>scrollbar_nib.png</textureslidernib>
+						<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+						<onleft>15</onleft>
+						<onright>31</onright>
+						<ondown>75</ondown>
+						<onup>75</onup>
+						<showonepage>true</showonepage>
+						<orientation>vertical</orientation>
+					</control>
+					<control type="label">
+						<description>number of files/pages in list text label</description>
+						<posx>915</posx>
+						<posy>535</posy>
+						<width>300</width>
+						<height>35</height>
+						<font>font12b</font>
+						<align>right</align>
+						<aligny>center</aligny>
+						<scroll>true</scroll>
+						<textcolor>white</textcolor>
+						<label>$LOCALIZE[18060] ($INFO[Container(15).CurrentPage]/$INFO[Container(15).NumPages])</label>
+					</control>
+				</control>
+				<control type="group" id="8002">
+					<description>TV Guide Now/Next</description>
+					<control type="image">
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>930</width>
+						<height>35</height>
+						<texture>Button_Side_NoFocus.png</texture>
+					</control>
+					<control type="label">
+						<description>channel name label</description>
+						<posx>40</posx>
+						<posy>0</posy>
+						<width>150</width>
+						<height>35</height>
+						<font>font12</font>
+						<label>18402</label>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textcolor>white</textcolor>
+					</control>
+					<control type="label">
+						<description>time label</description>
+						<posx>240</posx>
+						<posy>0</posy>
+						<width>225</width>
+						<height>35</height>
+						<font>font12</font>
+						<label>142</label>
+						<align>left</align>
+						<aligny>center</aligny>
+						<textcolor>white</textcolor>
+					</control>
+					<control type="label">
+						<description>name label</description>
+						<posx>890</posx>
+						<posy>0</posy>
+						<width>225</width>
+						<height>35</height>
+						<font>font12</font>
+						<label>18063</label>
+						<align>right</align>
+						<aligny>center</aligny>
+						<textcolor>white</textcolor>
+					</control>
+					<control type="list" id="16">
+						<posx>0</posx>
+						<posy>35</posy>
+						<width>910</width>
+						<height>474</height>
+						<onup>16</onup>
+						<ondown>16</ondown>
+						<onleft>31</onleft>
+						<onright>76</onright>
+						<pagecontrol>76</pagecontrol>
+						<scrolltime>200</scrolltime>
+						<itemlayout height="40">
+							<control type="image">
+								<width>32</width>
+								<height>32</height>
+								<posx>0</posx>
+								<posy>1</posy>
+								<info>ListItem.Icon</info>
+							</control>
+							<control type="label">
+								<posx>40</posx>
+								<posy>0</posy>
+								<width>180</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.filename</info>
+							</control>
+							<control type="label">
+								<posx>240</posx>
+								<posy>0</posy>
+								<width>400</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="label">
+								<posx>890</posx>
+								<posy>0</posy>
+								<width>410</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>right</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label</info>
+							</control>
+						</itemlayout>
+						<focusedlayout height="40">
+							<control type="image">
+								<posx>0</posx>
+								<posy>0</posy>
+								<width>910</width>
+								<height>35</height>
+								<texture border="8">list-focus.png</texture>
+								<visible>Control.HasFocus(16)</visible>
+								<include>VisibleFadeEffect</include>
+							</control>
+							<control type="image">
+								<width>32</width>
+								<height>32</height>
+								<posx>0</posx>
+								<posy>1</posy>
+								<info>ListItem.Icon</info>
+							</control>
+							<control type="label">
+								<posx>40</posx>
+								<posy>0</posy>
+								<width>180</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.filename</info>
+							</control>
+							<control type="label">
+								<posx>240</posx>
+								<posy>0</posy>
+								<width>400</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>left</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="label">
+								<posx>890</posx>
+								<posy>0</posy>
+								<width>410</width>
+								<height>35</height>
+								<font>font12</font>
+								<align>right</align>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<info>ListItem.Label</info>
+							</control>
+						</focusedlayout>
+					</control>
+					<control type="scrollbar" id="76">
+						<posx>910</posx>
+						<posy>35</posy>
+						<width>20</width>
+						<height>475</height>
+						<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+						<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+						<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+						<textureslidernib>scrollbar_nib.png</textureslidernib>
+						<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+						<onleft>16</onleft>
+						<onright>31</onright>
+						<ondown>76</ondown>
+						<onup>76</onup>
+						<showonepage>true</showonepage>
+						<orientation>vertical</orientation>
+					</control>
+					<control type="label">
+						<description>number of files/pages in list text label</description>
+						<posx>915</posx>
+						<posy>535</posy>
+						<width>300</width>
+						<height>35</height>
+						<font>font12b</font>
+						<align>right</align>
+						<aligny>center</aligny>
+						<scroll>true</scroll>
+						<textcolor>white</textcolor>
+						<label>$LOCALIZE[18060] ($INFO[Container(16).CurrentPage]/$INFO[Container(16).NumPages])</label>
+					</control>
+				</control>
+				<control type="group" id="8003">
+					<description>TV Guide Timeline</description>
+					<control type="group">
+						<visible>!Player.Playing</visible>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>285</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-a-moviedrama.png</texture>
+						</control>
+						<control type="label">
+							<description>Movie Genre</description>
+							<posx>-275</posx>
+							<posy>275</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18110</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>310</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-b-news.png</texture>
+						</control>
+						<control type="label">
+							<description>News Genre</description>
+							<posx>-275</posx>
+							<posy>300</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18111</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>335</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-c-show.png</texture>
+						</control>
+						<control type="label">
+							<description>News Genre</description>
+							<posx>-275</posx>
+							<posy>325</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18112</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-180</posx>
+							<posy>335</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-d-sports.png</texture>
+						</control>
+						<control type="label">
+							<description>Sports Genre</description>
+							<posx>-155</posx>
+							<posy>325</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18113</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>360</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-e-child.png</texture>
+						</control>
+						<control type="label">
+							<description>Children Genre</description>
+							<posx>-275</posx>
+							<posy>350</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18114</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-180</posx>
+							<posy>360</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-i-science.png</texture>
+						</control>
+						<control type="label">
+							<description>Educational/Science Genre</description>
+							<posx>-155</posx>
+							<posy>350</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18120</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>385</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-f-music.png</texture>
+						</control>
+						<control type="label">
+							<description>Music Genre</description>
+							<posx>-275</posx>
+							<posy>375</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18115</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-180</posx>
+							<posy>385</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-g-arts.png</texture>
+						</control>
+						<control type="label">
+							<description>Arts Genre</description>
+							<posx>-155</posx>
+							<posy>375</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18116</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>410</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-j-hobby.png</texture>
+						</control>
+						<control type="label">
+							<description>Leisure/Hobbies Genre</description>
+							<posx>-275</posx>
+							<posy>400</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18118</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>435</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-h-social.png</texture>
+						</control>
+						<control type="label">
+							<description>Social Genre</description>
+							<posx>-275</posx>
+							<posy>425</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18121</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>460</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-k-special.png</texture>
+						</control>
+						<control type="label">
+							<description>Special Genre</description>
+							<posx>-275</posx>
+							<posy>450</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18122</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+						<control type="image">
+							<posx>-300</posx>
+							<posy>485</posy>
+							<width>15</width>
+							<height>15</height>
+							<texture>genre-l-unknown.png</texture>
+						</control>
+						<control type="label">
+							<description>Other/Unknown Genre</description>
+							<posx>-275</posx>
+							<posy>475</posy>
+							<width>280</width>
+							<height>35</height>
+							<font>font10</font>
+							<label>18119</label>
+							<align>left</align>
+							<aligny>center</aligny>
+							<textcolor>white</textcolor>
+						</control>
+					</control>
+					<control type="label" id="30">
+						<description>No Info Scanned Label</description>
+						<posx>0</posx>
+						<posy>0</posy>
+						<width>930</width>
+						<height>476</height>
+						<font>Special13</font>
+						<label>-</label>
+						<align>center</align>
+						<aligny>center</aligny>
+					</control>
+					<control type="epggrid" id="10">
+						<description>EPG Grid</description>
+						<posx>-15</posx>
+						<posy>0</posy>
+						<width>960</width>
+						<height>504</height>
+						<onleft>31</onleft>
+						<onright>31</onright>
+						<onup>10</onup>
+						<ondown>10</ondown>
+						<pagecontrol>10</pagecontrol>
+						<scrolltime>350</scrolltime>
+						<timeblocks>36</timeblocks>
+						<rulerunit>12</rulerunit>
+						<rulerlayout height="29" width="40">
+							<control type="image" id="1">
+								<width>40</width>
+								<height>29</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">guide.png</texture>
+							</control>
+							<control type="label" id="1">
+								<posx>4</posx>`
+								<posy>0</posy>
+								<width>34</width>
+								<height>29</height>
+								<font>font13</font>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<align>left</align>
+								<info>ListItem.Label</info>
+							</control>
+						</rulerlayout>
+						<channellayout height="60" width="150">
+							<animation effect="fade" start="110" time="200">UnFocus</animation>
+							<control type="image" id="1">
+								<width>150</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">guide.png</texture>
+							</control>
+							<control type="label" id="1">
+								<posx>54</posx>
+								<posy>1</posy>
+								<width>100</width>
+								<height>60</height>
+								<font>special12</font>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<align>left</align>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="image">
+								<width>50</width>
+								<height>50</height>
+								<posx>2</posx>
+								<posy>5</posy>
+								<info>ListItem.Icon</info>
+							</control>
+						</channellayout>
+						<focusedchannellayout height="60" width="150">
+							<animation effect="fade" start="110" time="200">OnFocus</animation>
+							<control type="image" id="1">
+								<width>150</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">guide.png</texture>
+							</control>
+							<control type="label" id="1">
+								<posx>54</posx>
+								<posy>1</posy>
+								<width>100</width>
+								<height>60</height>
+								<font>special12</font>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<align>left</align>
+								<info>ListItem.Label2</info>
+							</control>
+							<control type="image">
+								<width>50</width>
+								<height>50</height>
+								<posx>2</posx>
+								<posy>5</posy>
+								<info>ListItem.Icon</info>
+							</control>
+						</focusedchannellayout>
+						<itemlayout height="60" width="40">
+							<control type="image" id="1">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-a-moviedrama.png</texture>
+							</control>
+							<control type="image" id="2">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-b-news.png</texture>
+							</control>
+							<control type="image" id="3">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-c-show.png</texture>
+							</control>
+							<control type="image" id="4">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-d-sports.png</texture>
+							</control>
+							<control type="image" id="5">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-e-child.png</texture>
+							</control>
+							<control type="image" id="6">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-f-music.png</texture>
+							</control>
+							<control type="image" id="7">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-g-arts.png</texture>
+							</control>
+							<control type="image" id="8">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-h-social.png</texture>
+							</control>
+							<control type="image" id="9">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-i-science.png</texture>
+							</control>
+							<control type="image" id="10">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-j-hobby.png</texture>
+							</control>
+							<control type="image" id="11">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-k-special.png</texture>
+							</control>
+							<control type="image" id="12">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">genre-l-unknown.png</texture>
+							</control>
+							<control type="label" id="13">
+								<posx>6</posx>
+								<posy>3</posy>
+								<width>30</width>
+								<height>22</height>
+								<font>font13</font>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<align>left</align>
+								<info>ListItem.Label</info>
+							</control>
+							<control type="image">
+								<width>26</width>
+								<height>26</height>
+								<posx>5</posx>
+								<posy>28</posy>
+								<texture>OverlayRecording.png</texture>
+								<visible>ListItem.Property(Recording)</visible>
+							</control>
+						</itemlayout>
+						<focusedlayout height="60" width="40">
+							<control type="image" id="1">
+								<width>40</width>
+								<height>60</height>
+								<posx>0</posx>
+								<posy>0</posy>
+								<texture border="3">guide.png</texture>
+								<bordertexture>keyboard-btn-space-focus2.png</bordertexture>
+								<bordersize>2,2,2,2</bordersize>
+							</control>
+							<control type="label" id="2">
+								<posx>6</posx>
+								<posy>3</posy>
+								<width>30</width>
+								<height>22</height>
+								<font>font13</font>
+								<aligny>center</aligny>
+								<selectedcolor>green</selectedcolor>
+								<align>left</align>
+								<info>ListItem.Label</info>
+							</control>
+							<control type="image">
+								<width>26</width>
+								<height>26</height>
+								<posx>5</posx>
+								<posy>28</posy>
+								<texture>OverlayRecording.png</texture>
+								<visible>ListItem.Property(Recording)</visible>
+							</control>
+						</focusedlayout>
+					</control>
+				</control>
+			</control>
+			<!-- TV Channels group -->
+			<control type="group" id="9002">
+				<description>TV Channels group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>930</width>
+					<height>35</height>
+					<texture>Button_Side_NoFocus.png</texture>
+				</control>
+				<control type="label">
+					<description>channel number label</description>
+					<posx>40</posx>
+					<posy>0</posy>
+					<width>50</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18062</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>name label</description>
+					<posx>120</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18063</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>now playing label</description>
+					<posx>890</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18064</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="list" id="11">
+					<posx>0</posx>
+					<posy>35</posy>
+					<width>910</width>
+					<height>474</height>
+					<onup>11</onup>
+					<ondown>11</ondown>
+					<onleft>32</onleft>
+					<onright>71</onright>
+					<pagecontrol>71</pagecontrol>
+					<scrolltime>200</scrolltime>
+					<itemlayout height="40">
+						<control type="image">
+							<width>32</width>
+							<height>32</height>
+							<posx>0</posx>
+							<posy>1</posy>
+							<info>ListItem.Icon</info>
+						</control>
+						<control type="label">
+							<posx>40</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>120</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>410</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+					</itemlayout>
+					<focusedlayout height="40">
+						<control type="image">
+							<posx>0</posx>
+							<posy>0</posy>
+							<width>910</width>
+							<height>35</height>
+							<texture border="8">list-focus.png</texture>
+							<visible>Control.HasFocus(11)</visible>
+							<include>VisibleFadeEffect</include>
+						</control>
+						<control type="image">
+							<width>32</width>
+							<height>32</height>
+							<posx>0</posx>
+							<posy>1</posy>
+							<info>ListItem.Icon</info>
+						</control>
+						<control type="label">
+							<posx>40</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>120</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>410</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+					</focusedlayout>
+				</control>
+				<control type="scrollbar" id="71">
+					<posx>910</posx>
+					<posy>35</posy>
+					<width>20</width>
+					<height>475</height>
+					<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+					<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+					<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+					<textureslidernib>scrollbar_nib.png</textureslidernib>
+					<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+					<onleft>11</onleft>
+					<onright>32</onright>
+					<ondown>71</ondown>
+					<onup>71</onup>
+					<showonepage>true</showonepage>
+					<orientation>vertical</orientation>
+				</control>
+				<control type="label">
+					<description>number of files/pages in list text label</description>
+					<posx>915</posx>
+					<posy>535</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<label>$INFO[Container(11).NumItems] $LOCALIZE[18065] - $LOCALIZE[18060] ($INFO[Container(11).CurrentPage]/$INFO[Container(11).NumPages])</label>
+				</control>
+			</control>
+			<!-- Radio Channels group -->
+			<control type="group" id="9003">
+				<description>Radio Channels group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>930</width>
+					<height>35</height>
+					<texture>Button_Side_NoFocus.png</texture>
+				</control>
+				<control type="label">
+					<description>channel number label</description>
+					<posx>40</posx>
+					<posy>0</posy>
+					<width>50</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18062</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>name label</description>
+					<posx>120</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18063</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>now playing label</description>
+					<posx>890</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18064</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="list" id="12">
+					<posx>0</posx>
+					<posy>35</posy>
+					<width>910</width>
+					<height>474</height>
+					<onup>12</onup>
+					<ondown>12</ondown>
+					<onleft>33</onleft>
+					<onright>72</onright>
+					<pagecontrol>72</pagecontrol>
+					<scrolltime>200</scrolltime>
+					<itemlayout height="40">
+						<control type="image">
+							<width>32</width>
+							<height>32</height>
+							<posx>0</posx>
+							<posy>1</posy>
+							<info>ListItem.Icon</info>
+						</control>
+						<control type="label">
+							<posx>40</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>120</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>410</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+					</itemlayout>
+					<focusedlayout height="40">
+						<control type="image">
+							<posx>0</posx>
+							<posy>0</posy>
+							<width>910</width>
+							<height>35</height>
+							<texture border="8">list-focus.png</texture>
+							<visible>Control.HasFocus(12)</visible>
+							<include>VisibleFadeEffect</include>
+						</control>
+						<control type="image">
+							<width>32</width>
+							<height>32</height>
+							<posx>0</posx>
+							<posy>1</posy>
+							<info>ListItem.Icon</info>
+						</control>
+						<control type="label">
+							<posx>40</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>120</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>410</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+					</focusedlayout>
+				</control>
+				<control type="scrollbar" id="72">
+					<posx>910</posx>
+					<posy>35</posy>
+					<width>20</width>
+					<height>475</height>
+					<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+					<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+					<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+					<textureslidernib>scrollbar_nib.png</textureslidernib>
+					<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+					<onleft>12</onleft>
+					<onright>33</onright>
+					<ondown>72</ondown>
+					<onup>72</onup>
+					<showonepage>true</showonepage>
+					<orientation>vertical</orientation>
+				</control>
+				<control type="label">
+					<description>number of files/pages in list text label</description>
+					<posx>915</posx>
+					<posy>535</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<label>$INFO[Container(12).NumItems] $LOCALIZE[18065] - $LOCALIZE[18060] ($INFO[Container(12).CurrentPage]/$INFO[Container(12).NumPages])</label>
+				</control>
+			</control>
+			<!-- Recordings group -->
+			<control type="group" id="9004">
+				<description>Recordings group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>930</width>
+					<height>35</height>
+					<texture>Button_Side_NoFocus.png</texture>
+				</control>
+				<control type="label">
+					<description>recording number label</description>
+					<posx>20</posx>
+					<posy>0</posy>
+					<width>50</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18062</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>date label</description>
+					<posx>100</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18067</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>name label</description>
+					<posx>890</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18063</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="list" id="13">
+					<posx>0</posx>
+					<posy>35</posy>
+					<width>910</width>
+					<height>474</height>
+					<onup>13</onup>
+					<ondown>13</ondown>
+					<onleft>34</onleft>
+					<onright>73</onright>
+					<pagecontrol>73</pagecontrol>
+					<scrolltime>200</scrolltime>
+					<itemlayout height="40">
+						<control type="label">
+							<posx>20</posx>
+							<posy>0</posy>
+							<width>90</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>100</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>550</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+					</itemlayout>
+					<focusedlayout height="40">
+						<control type="image">
+							<posx>0</posx>
+							<posy>0</posy>
+							<width>910</width>
+							<height>35</height>
+							<texture border="8">list-focus.png</texture>
+							<visible>Control.HasFocus(13)</visible>
+							<include>VisibleFadeEffect</include>
+						</control>
+						<control type="label">
+							<posx>20</posx>
+							<posy>0</posy>
+							<width>90</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>100</posx>
+							<posy>0</posy>
+							<width>400</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>550</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+					</focusedlayout>
+				</control>
+				<control type="scrollbar" id="73">
+					<posx>910</posx>
+					<posy>35</posy>
+					<width>20</width>
+					<height>475</height>
+					<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+					<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+					<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+					<textureslidernib>scrollbar_nib.png</textureslidernib>
+					<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+					<onleft>13</onleft>
+					<onright>34</onright>
+					<ondown>73</ondown>
+					<onup>73</onup>
+					<showonepage>true</showonepage>
+					<orientation>vertical</orientation>
+				</control>
+				<control type="label">
+					<description>number of files/pages in list text label</description>
+					<posx>915</posx>
+					<posy>535</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<label>$INFO[Container(13).NumItems] $LOCALIZE[18066] - $LOCALIZE[18060] ($INFO[Container(13).CurrentPage]/$INFO[Container(13).NumPages])</label>
+				</control>
+				<control type="label" id="20">
+					<description>recording disk size / free space</description>
+					<posx>10</posx>
+					<posy>535</posy>
+					<width>600</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<label>-</label>
+					<visible>!Player.Playing</visible>
+				</control>
+			</control>
+			<!-- Timers group -->
+			<control type="group" id="9005">
+			    <description>Timers group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>930</width>
+					<height>35</height>
+					<texture>Button_Side_NoFocus.png</texture>
+				</control>
+				<control type="label">
+					<description>channel number label</description>
+					<posx>20</posx>
+					<posy>0</posy>
+					<width>50</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18062</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>date label</description>
+					<posx>100</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18077</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>name label</description>
+					<posx>890</posx>
+					<posy>0</posy>
+					<width>225</width>
+					<height>35</height>
+					<font>font12</font>
+					<label>18063</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="list" id="14">
+					<posx>0</posx>
+					<posy>35</posy>
+					<width>910</width>
+					<height>474</height>
+					<onup>14</onup>
+					<ondown>14</ondown>
+					<onleft>35</onleft>
+					<onright>74</onright>
+					<pagecontrol>74</pagecontrol>
+					<scrolltime>200</scrolltime>
+					<itemlayout height="40">
+						<control type="label">
+							<posx>20</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>100</posx>
+							<posy>0</posy>
+							<width>520</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>290</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+					</itemlayout>
+					<focusedlayout height="40">
+						<control type="image">
+							<posx>0</posx>
+							<posy>0</posy>
+							<width>910</width>
+							<height>35</height>
+							<texture border="8">list-focus.png</texture>
+							<visible>Control.HasFocus(14)</visible>
+							<include>VisibleFadeEffect</include>
+						 </control>
+						<control type="label">
+							<posx>20</posx>
+							<posy>0</posy>
+							<width>200</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.filename</info>
+						</control>
+						<control type="label">
+							<posx>100</posx>
+							<posy>0</posy>
+							<width>520</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>left</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label2</info>
+						</control>
+						<control type="label">
+							<posx>890</posx>
+							<posy>0</posy>
+							<width>290</width>
+							<height>35</height>
+							<font>font12</font>
+							<align>right</align>
+							<aligny>center</aligny>
+							<selectedcolor>green</selectedcolor>
+							<info>ListItem.Label</info>
+						</control>
+					</focusedlayout>
+				</control>
+				<control type="scrollbar" id="74">
+					<posx>910</posx>
+					<posy>35</posy>
+					<width>20</width>
+					<height>475</height>
+					<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+					<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+					<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+					<textureslidernib>scrollbar_nib.png</textureslidernib>
+					<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+					<onleft>14</onleft>
+					<onright>35</onright>
+					<ondown>74</ondown>
+					<onup>74</onup>
+					<showonepage>true</showonepage>
+					<orientation>vertical</orientation>
+				</control>
+				<control type="label">
+					<description>number of files/pages in list text label</description>
+					<posx>915</posx>
+					<posy>535</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<visible>PVR.HasTimer</visible>
+					<label>$INFO[Container(14).NumItems] $LOCALIZE[18076] - $LOCALIZE[18060] ($INFO[Container(14).CurrentPage]/$INFO[Container(14).NumPages])</label>
+				</control>
+				<control type="label" id="21">
+					<description>Next timer date</description>
+					<posx>10</posx>
+					<posy>535</posy>
+					<width>700</width>
+					<height>35</height>
+					<font>font12b</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<scroll>true</scroll>
+					<textcolor>white</textcolor>
+					<label>-</label>
+					<visible>!Player.Playing</visible>
+				</control>
+			</control>
+			<!-- Settings group -->
+			<control type="group" id="9006">
+				<description>Settings group</description>
+				<posx>317</posx>
+				<posy>135</posy>
+				<control type="label">
+					<description>Backend name</description>
+					<posx>10</posx>
+					<posy>0</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18200</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="40">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>0</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Backend version</description>
+					<posx>10</posx>
+					<posy>40</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18201</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="41">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>40</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Backend ip:port</description>
+					<posx>10</posx>
+					<posy>80</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18202</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="42">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>80</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Disksize</description>
+					<posx>10</posx>
+					<posy>120</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18203</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="43">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>120</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Disksize</description>
+					<posx>10</posx>
+					<posy>160</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18204</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="44">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>160</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Disksize</description>
+					<posx>10</posx>
+					<posy>200</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18205</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="45">
+					<description>Disksize</description>
+					<posx>930</posx>
+					<posy>200</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Timer counts</description>
+					<posx>10</posx>
+					<posy>240</posy>
+					<width>280</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18206</label>
+					<align>left</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label" id="46">
+					<description>Timer counts value</description>
+					<posx>930</posx>
+					<posy>240</posy>
+					<width>-930</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>-</label>
+					<align>right</align>
+					<aligny>center</aligny>
+					<textcolor>white</textcolor>
+				</control>
+				<control type="label">
+					<description>Info</description>
+					<posx>0</posx>
+					<posy>450</posy>
+					<width>962</width>
+					<height>35</height>
+					<font>font14</font>
+					<label>18199</label>
+					<align>center</align>
+					<aligny>center</aligny>
+					<textcolor>green</textcolor>
+				</control>
+			</control>
+		</control>
+		<control type="group">
+			<include>Window_OpenClose_Left_Panel_Animation</include>
+			<include>CommonNowPlaying</include>
+			<control type="group" id="9000">
+				<visible>!System.GetBool(pvrmenu.showradio)</visible>
+				<posx>0</posx>
+				<posy>130</posy>
+				<control type="button" id="31">
+					<description>TV Guide button</description>
+					<posx>0</posx>
+					<posy>0</posy>
+					<include>ButtonCommonValues</include>
+					<label>18050</label>
+					<onup>36</onup>
+					<ondown>32</ondown>
+					<onleft>10</onleft>
+					<onright>10</onright>
+				</control>
+				<control type="button" id="32">
+					<description>TV Channels button</description>
+					<posx>0</posx>
+					<posy>45</posy>
+					<include>ButtonCommonValues</include>
+					<label>18065</label>
+					<onleft>11</onleft>
+					<onright>11</onright>
+					<onup>31</onup>
+					<ondown>34</ondown>
+				</control>
+				<control type="button" id="34">
+					<description>Recordings button</description>
+					<posx>0</posx>
+					<posy>90</posy>
+					<include>ButtonCommonValues</include>
+					<label>18066</label>
+					<onleft>13</onleft>
+					<onright>13</onright>
+					<onup>32</onup>
+					<ondown>35</ondown>
+				</control>
+				<control type="button" id="35">
+					<description>Timers Button</description>
+					<posx>0</posx>
+					<posy>135</posy>
+					<include>ButtonCommonValues</include>
+					<label>18054</label>
+					<onleft>14</onleft>
+					<onright>14</onright>
+					<onup>34</onup>
+					<ondown>36</ondown>
+				</control>
+				<control type="button" id="36">
+					<description>Settings button</description>
+					<posx>0</posx>
+					<posy>180</posy>
+					<label>5</label>
+					<include>ButtonCommonValues</include>
+					<onleft>50</onleft>
+					<onright>50</onright>
+					<onup>35</onup>
+					<ondown>31</ondown>
+					<animation effect="slide" end="0,-45" time="0" condition="!Control.IsVisible(36)">Conditional</animation>
+				</control>
+			</control>
+			<control type="group" id="9000">
+				<visible>System.GetBool(pvrmenu.showradio)</visible>
+				<posx>0</posx>
+				<posy>130</posy>
+				<control type="button" id="31">
+					<description>TV Guide button</description>
+					<posx>0</posx>
+					<posy>0</posy>
+					<include>ButtonCommonValues</include>
+					<label>18050</label>
+					<onup>36</onup>
+					<ondown>32</ondown>
+					<onleft>10</onleft>
+					<onright>10</onright>
+				</control>
+				<control type="button" id="32">
+					<description>TV Channels button</description>
+					<posx>0</posx>
+					<posy>45</posy>
+					<include>ButtonCommonValues</include>
+					<label>18051</label>
+					<onleft>11</onleft>
+					<onright>11</onright>
+					<onup>31</onup>
+					<ondown>33</ondown>
+				</control>
+				<control type="button" id="33">
+					<description>Radio Channels button</description>
+					<posx>0</posx>
+					<posy>90</posy>
+					<include>ButtonCommonValues</include>
+					<label>18052</label>
+					<onleft>12</onleft>
+					<onright>12</onright>
+					<onup>32</onup>
+					<ondown>34</ondown>
+				</control>
+				<control type="button" id="34">
+					<description>Recordings button</description>
+					<posx>0</posx>
+					<posy>135</posy>
+					<include>ButtonCommonValues</include>
+					<label>18066</label>
+					<onleft>13</onleft>
+					<onright>13</onright>
+					<onup>33</onup>
+					<ondown>35</ondown>
+				</control>
+				<control type="button" id="35">
+					<description>Timers Button</description>
+					<posx>0</posx>
+					<posy>180</posy>
+					<include>ButtonCommonValues</include>
+					<label>18054</label>
+					<onleft>14</onleft>
+					<onright>14</onright>
+					<onup>34</onup>
+					<ondown>36</ondown>
+				</control>
+				<control type="button" id="36">
+					<description>Settings button</description>
+					<posx>0</posx>
+					<posy>225</posy>
+					<label>5</label>
+					<include>ButtonCommonValues</include>
+					<onleft>50</onleft>
+					<onright>50</onright>
+					<onup>35</onup>
+					<ondown>31</ondown>
+					<animation effect="slide" end="0,-45" time="0" condition="!Control.IsVisible(36)">Conditional</animation>
+				</control>
+			</control>
+		</control>
+		<control type="image">
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>1280</width>
+			<height>128</height>
+			<texture>Header.png</texture>
+		</control>
+		<control type="label" id="29">
+			<include>WindowTitleCommons</include>
+			<label>$LOCALIZE[9] - $LOCALIZE[18000]</label>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/VideoOSDTVChannels.xml XBMC/skin/PM3.HD/720p/VideoOSDTVChannels.xml
--- XBMC-unpatched/skin/PM3.HD/720p/VideoOSDTVChannels.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/VideoOSDTVChannels.xml	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,192 @@
+<window id="606">
+	<defaultcontrol always="true">11</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>400</posx>
+		<posy>55</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<colordiffuse>DDFFFFFF</colordiffuse>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>720</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>[UPPERCASE]$LOCALIZE[18065][/UPPERCASE] - ($INFO[Container(11).NumItems]) $LOCALIZE[31025] - $LOCALIZE[31024] ($INFO[Container(11).CurrentPage]/$INFO[Container(11).NumPages])</label>
+			<textcolor>white</textcolor>
+		</control>
+		<control type="button">
+			<description>Close Window button</description>
+			<posx>731</posx>
+			<posy>35</posy>
+			<width>35</width>
+			<height>25</height>
+			<label>-</label>
+			<font>-</font>
+			<onclick>Dialog.Close(606)</onclick>
+			<texturefocus>close-windowFO.png</texturefocus>
+			<texturenofocus>close-window.png</texturenofocus>
+			<onleft>5</onleft>
+			<onright>5</onright>
+			<onup>5</onup>
+			<ondown>5</ondown>
+			<visible>system.getbool(lookandfeel.enablemouse)</visible>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>78</posy>
+			<width>720</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="list" id="11">
+			<posx>40</posx>
+			<posy>90</posy>
+			<width>720</width>
+			<height>480</height>
+			<onleft>11</onleft>
+			<onright>71</onright>
+			<ondown>11</ondown>
+			<onup>11</onup>
+			<scrolltime>200</scrolltime>
+			<pagecontrol>71</pagecontrol>
+			<itemlayout height="40" width="720">
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>685</width>
+					<height>35</height>
+					<texture border="3">button-nofocus.png</texture>
+				</control>
+				<control type="image">
+					<posx>70</posx>
+					<posy>0</posy>
+					<width>35</width>
+					<height>35</height>
+					<info>ListItem.Icon</info>
+				</control>
+				<control type="label">
+					<posx>10</posx>
+					<posy>0</posy>
+					<width>55</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.filename</info>
+				</control>
+				<control type="label">
+					<posx>110</posx>
+					<posy>0</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label</info>
+				</control>
+				<control type="label">
+					<posx>675</posx>
+					<posy>0</posy>
+					<width>330</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label2</info>
+				</control>
+			</itemlayout>
+			<focusedlayout height="40" width="720">
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>685</width>
+					<height>35</height>
+					<visible>Control.HasFocus(11)</visible>
+					<texture border="8">button-focus.png</texture>
+				</control>
+				<control type="image">
+					<posx>70</posx>
+					<posy>0</posy>
+					<width>35</width>
+					<height>35</height>
+					<info>ListItem.Icon</info>
+				</control>
+				<control type="label">
+					<posx>10</posx>
+					<posy>0</posy>
+					<width>55</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.filename</info>
+				</control>
+				<control type="label">
+					<posx>110</posx>
+					<posy>0</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label</info>
+				</control>
+				<control type="label">
+					<posx>675</posx>
+					<posy>0</posy>
+					<width>330</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label2</info>
+				</control>
+			</focusedlayout>
+		</control>
+		<control type="scrollbar" id="71">
+			<posx>730</posx>
+			<posy>90</posy>
+			<width>20</width>
+			<height>475</height>
+			<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+			<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+			<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+			<textureslidernib>scrollbar_nib.png</textureslidernib>
+			<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+			<onleft>11</onleft>
+			<onright>11</onright>
+			<ondown>71</ondown>
+			<onup>71</onup>
+			<showonepage>true</showonepage>
+			<orientation>vertical</orientation>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/VideoOSDTVGuide.xml XBMC/skin/PM3.HD/720p/VideoOSDTVGuide.xml
--- XBMC-unpatched/skin/PM3.HD/720p/VideoOSDTVGuide.xml	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/720p/VideoOSDTVGuide.xml	2009-04-14 17:51:41.000000000 +0200
@@ -0,0 +1,155 @@
+<window id="607">
+	<defaultcontrol always="true">11</defaultcontrol>
+	<coordinates>
+		<system>1</system>
+		<posx>400</posx>
+		<posy>55</posy>
+	</coordinates>
+	<include>dialogeffect</include>
+	<controls>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<colordiffuse>DDFFFFFF</colordiffuse>
+			<texture border="40">DialogBack.png</texture>
+		</control>
+		<control type="image">
+			<description>background image</description>
+			<posx>0</posx>
+			<posy>0</posy>
+			<width>800</width>
+			<height>610</height>
+			<texture border="40">DialogFront.png</texture>
+		</control>
+		<control type="label">
+			<description>heading label</description>
+			<posx>40</posx>
+			<posy>40</posy>
+			<width>720</width>
+			<height>30</height>
+			<align>center</align>
+			<aligny>center</aligny>
+			<font>font18</font>
+			<label>$LOCALIZE[18050] - $INFO[VideoPlayer.Album]</label>
+			<textcolor>white</textcolor>
+		</control>
+		<control type="button">
+			<description>Close Window button</description>
+			<posx>731</posx>
+			<posy>35</posy>
+			<width>35</width>
+			<height>25</height>
+			<label>-</label>
+			<font>-</font>
+			<onclick>Dialog.Close(607)</onclick>
+			<texturefocus>close-windowFO.png</texturefocus>
+			<texturenofocus>close-window.png</texturenofocus>
+			<onleft>5</onleft>
+			<onright>5</onright>
+			<onup>5</onup>
+			<ondown>5</ondown>
+			<visible>system.getbool(lookandfeel.enablemouse)</visible>
+		</control>
+		<control type="image">
+			<posx>40</posx>
+			<posy>78</posy>
+			<width>720</width>
+			<height>2</height>
+			<texture>separator.png</texture>
+		</control>
+		<control type="list" id="11">
+			<posx>40</posx>
+			<posy>90</posy>
+			<width>720</width>
+			<height>480</height>
+			<onleft>11</onleft>
+			<onright>71</onright>
+			<ondown>11</ondown>
+			<onup>11</onup>
+			<scrolltime>200</scrolltime>
+			<pagecontrol>71</pagecontrol>
+			<itemlayout height="40" width="720">
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>685</width>
+					<height>35</height>
+					<texture border="3">button-nofocus.png</texture>
+				</control>
+				<control type="label">
+					<posx>10</posx>
+					<posy>0</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label2</info>
+				</control>
+				<control type="label">
+					<posx>675</posx>
+					<posy>0</posy>
+					<width>460</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label</info>
+				</control>
+			</itemlayout>
+			<focusedlayout height="40" width="720">
+				<control type="image">
+					<posx>0</posx>
+					<posy>0</posy>
+					<width>685</width>
+					<height>35</height>
+					<texture border="8">button-focus.png</texture>
+				</control>
+				<control type="label">
+					<posx>10</posx>
+					<posy>0</posy>
+					<width>300</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>left</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label2</info>
+				</control>
+				<control type="label">
+					<posx>675</posx>
+					<posy>0</posy>
+					<width>460</width>
+					<height>35</height>
+					<font>font12</font>
+					<align>right</align>
+					<aligny>center</aligny>
+					<selectedcolor>white</selectedcolor>
+					<info>ListItem.Label</info>
+				</control>
+			</focusedlayout>
+		</control>
+		<control type="scrollbar" id="71">
+			<posx>730</posx>
+			<posy>90</posy>
+			<width>20</width>
+			<height>475</height>
+			<texturesliderbackground border="2,2,2,2">scrollbar_bar_back2.png</texturesliderbackground>
+			<texturesliderbar border="2,16,2,16">scrollbar_bar.png</texturesliderbar>
+			<texturesliderbarfocus border="2,16,2,16">scrollbar_bar_focus.png</texturesliderbarfocus>
+			<textureslidernib>scrollbar_nib.png</textureslidernib>
+			<textureslidernibfocus>scrollbar_nib.png</textureslidernibfocus>
+			<onleft>11</onleft>
+			<onright>11</onright>
+			<ondown>71</ondown>
+			<onup>71</onup>
+			<showonepage>true</showonepage>
+			<orientation>vertical</orientation>
+		</control>
+	</controls>
+</window>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/720p/VideoOSD.xml XBMC/skin/PM3.HD/720p/VideoOSD.xml
--- XBMC-unpatched/skin/PM3.HD/720p/VideoOSD.xml	2009-04-22 19:16:27.000000000 +0200
+++ XBMC/skin/PM3.HD/720p/VideoOSD.xml	2009-04-04 14:19:52.000000000 +0200
@@ -107,15 +107,25 @@
 		</control>
 		<control type="image" id="1">
 			<description>Panel</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>0</posx>
 			<posy>0</posy>
 			<height>379</height>
 			<width>373</width>
 			<texture>osd_panel.png</texture>
-			<visible>yes</visible>
+		</control>
+		<control type="image" id="1">
+			<description>Panel</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>0</posx>
+			<posy>0</posy>
+			<height>379</height>
+			<width>373</width>
+			<texture>osd_panel_tv.png</texture>
 		</control>
 		<control type="button" id="210">
 			<description>Skip Bwd</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>32</posx>
 			<posy>158</posy>
 			<width>77</width>
@@ -130,8 +140,29 @@
 			<onup>208</onup>
 			<ondown>919</ondown>
 		</control>
+		<control type="button" id="210">
+			<description>TV Teletext Button</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>32</posx>
+			<posy>158</posy>
+			<width>77</width>
+			<height>79</height>
+			<texturefocus>osd_button_txt.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+            <alttexturefocus>osd_button_txt.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+            <usealttexture>Window.IsActive(608)</usealttexture>
+			<onclick>XBMC.ActivateWindow(608)</onclick>
+			<label>-</label>
+			<font>-</font>
+			<onleft>215</onleft>
+			<onright>211</onright>
+			<onup>208</onup>
+			<ondown>919</ondown>
+		</control>
 		<control type="togglebutton" id="211">
 			<description>Rewind</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>95</posx>
 			<posy>149</posy>
 			<width>71</width>
@@ -149,8 +180,29 @@
 			<ondown>920</ondown>
 			<onclick>XBMC.PlayerControl(Rewind)</onclick>
 		</control>
+		<control type="togglebutton" id="211">
+			<description>TV channel down</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>95</posx>
+			<posy>149</posy>
+			<width>71</width>
+			<height>79</height>
+			<texturefocus>osd_button_rewFO.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+			<usealttexture>-</usealttexture>
+            <alttexturefocus>osd_button_rewFO.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+			<label>-</label>
+			<font>-</font>
+			<onleft>210</onleft>
+			<onright>213</onright>
+			<onup>209</onup>
+			<ondown>920</ondown>
+			<onclick>XBMC.PlayerControl(Previous)</onclick>
+		</control>
 		<control type="togglebutton" id="213">
 			<description>Play</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>153</posx>
 			<posy>123</posy>
 			<width>100</width>
@@ -168,8 +220,29 @@
 			<ondown>920</ondown>
 			<onclick>XBMC.PlayerControl(Play)</onclick>
 		</control>
+		<control type="togglebutton" id="213">
+			<description>TV Channels</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>153</posx>
+			<posy>123</posy>
+			<width>100</width>
+			<height>98</height>
+			<texturefocus>osd_button_channels.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+            <alttexturefocus>osd_button_channels.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+            <usealttexture>Window.IsActive(606)</usealttexture>
+			<label>-</label>
+			<font>-</font>
+			<onleft>211</onleft>
+			<onright>214</onright>
+			<onup>921</onup>
+			<ondown>920</ondown>
+			<onclick>XBMC.ActivateWindow(606)</onclick>
+		</control>
 		<control type="togglebutton" id="214">
 			<description>Fast Forward</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>241</posx>
 			<posy>122</posy>
 			<width>64</width>
@@ -187,8 +260,29 @@
 			<ondown>920</ondown>
 			<onclick>XBMC.PlayerControl(Forward)</onclick>
 		</control>
+		<control type="togglebutton" id="214">
+			<description>tv channel up</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>241</posx>
+			<posy>122</posy>
+			<width>64</width>
+			<height>75</height>
+			<texturefocus>osd_button_ffFO.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+			<usealttexture>-</usealttexture>
+            <alttexturefocus>osd_button_ffFO.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+			<label>-</label>
+			<font>-</font>
+			<onleft>213</onleft>
+			<onright>215</onright>
+			<onup>921</onup>
+			<ondown>920</ondown>
+			<onclick>XBMC.PlayerControl(Next)</onclick>
+		</control>
 		<control type="button" id="215">
 			<description>Skip Fwd</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>287</posx>
 			<posy>112</posy>
 			<width>71</width>
@@ -203,6 +297,26 @@
 			<onup>918</onup>
 			<ondown>919</ondown>
 		</control>
+		<control type="button" id="215">
+			<description>EPG button</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>287</posx>
+			<posy>112</posy>
+			<width>71</width>
+			<height>72</height>
+			<texturefocus>osd_button_epg.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+            <alttexturefocus>osd_button_epg.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+            <usealttexture>Window.IsActive(607)</usealttexture>
+			<onclick>XBMC.ActivateWindow(607)</onclick>
+			<label>-</label>
+			<font>-</font>
+			<onleft>214</onleft>
+			<onright>210</onright>
+			<onup>918</onup>
+			<ondown>919</ondown>
+		</control>
 		<control type="togglebutton" id="918">
 			<description>Audio Menu</description>
 			<posx>138</posx>
@@ -259,6 +373,7 @@
 		</control>
 		<control type="togglebutton" id="919">
 			<description>Bookmarks Menu</description>
+			<visible>!VideoPlayer.Content(LiveTV)</visible>
 			<posx>195</posx>
 			<posy>268</posy>
 			<width>84</width>
@@ -276,5 +391,25 @@
 			<onup>920</onup>
 			<ondown>918</ondown>
 		</control>
+		<control type="togglebutton" id="919">
+			<description>Portal Menu</description>
+			<visible>VideoPlayer.Content(LiveTV)</visible>
+			<posx>195</posx>
+			<posy>268</posy>
+			<width>84</width>
+			<height>78</height>
+			<texturefocus>osd_button_portal.png</texturefocus>
+			<texturenofocus>-</texturenofocus>
+            <alttexturefocus>osd_button_portal.png</alttexturefocus>
+            <alttexturenofocus>-</alttexturenofocus>
+            <usealttexture>Window.IsActive(609)</usealttexture>
+			<onclick>XBMC.ActivateWindow(609)</onclick>
+			<label>-</label>
+			<font>-</font>
+			<onleft>210</onleft>
+			<onright>215</onright>
+			<onup>920</onup>
+			<ondown>918</ondown>
+		</control>
 	</controls>
 </window>
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/background-mytv.png XBMC/skin/PM3.HD/media/background-mytv.png
--- XBMC-unpatched/skin/PM3.HD/media/background-mytv.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/background-mytv.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,975 @@
+PNG
+
+   IHDR     j   l[   	pHYs       
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   gAMA  |Q    cHRM  z%        u0  `  :  o_F IDATxK$I&}"jGW<viii m L?p7UfYUM-"'"LUTAEyY?O?atnm+5|^oAEo.op~
+J/?h-}]	  R*
+  "vV"* @UA a]#"uAD1
+QEk.D MB&{R @~RPJAT "} ?pa@'BwOU(?g `xml VvBdmO`B@.I @PAR
+>~_Wm7oW;Bx.( V_q\c3l_Q]`@=n{k_{NpJw3!"3}"V^7gk@)Fo3|=1T0<>dBZ}]_VJ9~fQ`{ EgG{IwZ~_y}n!jkcM:?"[")J{?]oxg`7Ulx}}mxz|j@@q}YW7oG,Pv?~
+V|W O']K-_ K76?z(BM.,p{>>M!}]+ZC!lr`ml[z`59{?uMn]6C}
+/ QzI78
+kZM`YY!p_HAc@J9 P	YB|;46L&<|(/Gs_`kY\)xw(6bKt(i_g{P;H?28UHo~Vv57q]uk.g8un<?s|`>^H-E7vrhP=TXP	m[,(AxZWyF)moTv.KOejX@T)BkDO( 
+yHQ!co"XMi.ch<> ^01)EgoaO&FKG-e 
+VP5]!vE /6?ydQ <0
+^'#=PqZ*P<?v?*@~8#rx B"tz3Mqw
+D
+Db~a={<CsOg1P]A!o(mM4Z)cyqm|&w>3NYG{tF~q]gtu>|Z"op{v,oqWGyX7l^n/X, &v|#VBttp]wAj[qy1,v5p5ai|C~\E@#CvdVg2p@y?(F	% GscvW,
+.>%"csuAOTbx43w `'zx {}nlt:8!Mc>hX(tg"fk~6kKJ;{3Vko'B2wAnc>W,=*b5:~gAt;^puc&Q!}17how (R| PJ) fp{:JRYW\ ;o!Tl OX_VH?DRYz6q}-*y3@r(O@{rxKaZK@kWI6/uKilFI<L( jDF?T}Kl@ ,`t}{Llj,0H,9 b>v5m_0r2
+Yq>,KEGQ-9Ut4	BF q  !"?+)`\V =>DK`}>bmZw,F<S1:5  53ysY8#V}5pJ2G	UXT@.O(xuY,x6(pY*(.RtBAa#Z8Q%:A'Ee8onyZ*H:Uj:y.av%~Vz *3))0
+(6yBAt*_ED!(?WR&$9k(;OI##i2v[Q0>jEs>7@ V9@\M$[@m\ UM.z+F(@Za9t1Fpp|?k*ws4
+Yg]v~kkkK#G:Z+jhr{3*wOr{v~Bw
+15}T;cas,@=C4s{$r#XE',P(5qhg7_}mC+<+'}nE^U	5
+T|OO?|o+^OXnzY\%5[G31PLR4:iM90Gj4_UuKS&9+w|`rG 3?=#;~T ]wq4LW1S{
+	uWA@8NymBMW89"=Gz>;Oa;"TGxA#|t?pCE>~gj\Qc!}im?;w<xT,DJ3T/
+8_,_d\d(Nt1
+|:2~5;pww=9b	@	PT^/xi/Km	!JY}GO61C`_J(xP s_HQt"4(+
+L<cpAZMdO5U5`/CK0DwzAB8y j]FE~2i2T"M|d~G!34&~I{DTL#y 
+Ty~xH?,?;S:Bv#GN8g;#zGUf?:qg>cFz?gG_<XTA1s)V 8"}T<|n/~ Nv#*qV<"~Q$FO.$9d 0hrRTb6|
+zB`]tumh;Hw/g|;}WK5c#<wX
+},A!/WPot9yEY6Tw0IR	j@ tCPJzNkx-EaeD3Dr Zw,>SlP{?k|7;?lxuk]}W|l1J&W5d6DGu]E_*~9vG,_+<8+:q>wM}:cHW23lPy '#k'e5bS1v<
+`je1ca"n&p;HD *Pr&~wik@zqdi\Fl`h;[$J9zT}>,/$N?oQA 47{ '9@"sw^|B^j)ct0bubP&}7N$Eu_X(	Jx!y])PP#CXk9<w>_}8Xg9B7X;x?|ym"9)&~6}@?gyXcr:
+P@ipJA]?H-P$j*4|/|}w\aB)K**a\	M@|38P|zK) ZCcx}mk6CRVt yg{";'q51|pN!N2Xr^7IdPLF1d3H~FwV8[b4:~{D,GuCPxs3L;][qo s(z:I|G[%>hi(uFEFv:3#r<KRe_Za</PZ;?gpv"llz"As?$aFVJH(JEZbrY1'	vup@E7aB9v;YyM3?[Nzo=Oa4ZYk@FcFFit7gKrY[hms&4'c`2EN@/.2E7+T|) D;[Z-wR|[m\ev?w9_v-bQ3:Kw$G& @EY(:]{5H	V_P>/.t+0z]o,u9Y\.%f2^Ij"' mVyfG7L"r8 R;`wF??OB?/(asn?q.P?`j jls8<C:>7*HPHGvgyxfJ/Ks6^XStT#Bp+L
+ B^.o9<t; uT0l	{$l
+OH)";3M0yqed}$}M;H9$|62sS;lExd1	0 |x}wyv1fP"S=a?=ahI?}Ox89*0L bv*j-NnpD>pJ@8,RM4X||6.JB'O7?~2xGQp_ 9<$}E
+5%C,+Z RDL+*x hSY8-4/y$5=9%zG<D%PAA8IkS?^]g"cmUL	Mktr>fJy:n4J8vZ<8H{{}XTZQ<UD[G] B-O<eDP	O"_;Xc{G3ji~|ahk@Jhj5TSfJC'_3+tfHV ;@	K F;0j9$($Yal5|xCj!^PJ~ vd]/qks=s4D3qb\XQ"&GI3	arN
+Fq(r;{Q ;svnw	mFq}LgCI1(V2+}p(QSHVP1c7Yj*<?u}GCs.PZf4g?M %>z5O88AH>EMy>MyZf |IRchtF3`(tZAn/~xCCn?e3
+J(R3OKL@R2fFa1g&(z=NH270rPxg><X)d&_	)O"
+CbDlVQ}LeT(`0P.<g5dyy}^6`R9PNamhs{#`7)@fhGWb#.PN'v
+).zi}E< 'W(((T	C\"sD
+iE\*Q7[(sPD66@k
+bQAL*
+CZD.@nwnlYR&mn>b^ZYa%'+)Pg?F( bCQJ< v:c6AdxQd}@lE0FzFlOA*da ad[asP$;j	$*pi&fb_Z~ +%[rMf}ZO~tD0lw^108IEH4I#PK58p7TzT|=P1/Wv%m~		'M-"$ZkMQ oJ ]`ry/MU5sc4@y?&@4yNus4*}G3J1w:0E1(8<lvh2v3(%NE VB/x2AP3oV\]`YRG`#w|b8ptqw63n?Y6xS<^pZ!Q2gNJtEgUDqW~:,>bsHb%4tQ#Vl&dqW3@- %%V7A0yAQ^:6Mx4.(<F.\@qP`FB$=d2t/XDt*"1&	v4{L	uHtm*o~{(.
+\.Pi[G&<zp]7%}5tFS2"KzQ{;> (ea9|7N
+06/`:T&f9A?~IHKiG9kb)!EgGlLu*lBvk'mp`dry;_f/Zw)Dc!>L=a$|{Q;h8,F{hAkmk.
+u_=*=gSsi8a5,t*xc|V"PX%%F~K2.a	@VhVs$q#pD*1o|0G1m4?\zI(_DPK5wCw?\	5D0Dtl<r)9^m@831y4t:hY|}v}\KQSsYFCy^0<vB9R=THv7'G;"`OH(',~(]AK1p)b&@ N9L>*W
+&LingLp(nlB5 NI\6qq9vE%YS#|f?2pK;Wte<#3&{ lps #`@	`?lKxp"*p!&T3-q@rRhw^ 6:%tNQ mh!Ygket^~vvJ6Y80}v1rbrbaP:ZD:_9m|gt<a%M0'rVA)Sw1`WLYq/Auu.K3iS=MzB{N
+z2'Bpw?3qJw2d<%4_Cy<GHF*>~_s9;E86~$"
+ZoR c1Bb ;6U\Oh(1ef'k#3QydFN<apVg:C,'IO	rpR<!9F:'1YBUl+;*(x KK^?
+?2g9v;&/<16{fH<`g0'>W~pQ6?G?0-=^NU;Lt:g$/~$[ybGSJ.5E"k'8S9}ilL{;kL;i. #:?8$ LDko;*_J6hH9)ia2t#tO (|0MGlQ_H)wtga[C@eRmHn(mXEPN 
+\QQS&6k /Yu?,FPT??O"'aIp{~{W4;/}\wDgLc	{YbcP6BoI0Jb "Kml'M-M6'bD1$!(EyHi4?A(4i6nCr~<FYS~!.GFTH]q8-)dZN~WOF9PkT&vLYV^KgPS lF?3>|aiY]AX'?Ne{3!8s8=[%"(29Jj8'^]/vvp[W00HLR;Ju1@BPb5&&Ahl_sB)G3c)"$ p~Nty>$ &T%]892Cqw>o?3E]^At9n_9l/!
+q>*HcOH3/L%5F\m\Y7RxI0"ZghZk373xh_ug(
+-:L,b2so	mH=)\nNV~&Zvf;fc1?w;E#2G=!ub9B}uG"$;!RU YG,~KY*]|#:m
+\v,<1C3a_zS)j<({o&4q.kt=4P*a9;4]<W 1^_J-t'#H}B= 4\vSD'7=g73COI_|Gg<6&A>z6ATdzh|vI72DTLc6yWo#"qT\\y}3V+s<J{[h1&8D!{`>S>8Nw|:Va3#@E@PbiAPy?{)fUih* ;xf~}xP+G Gh(sDd45tHi3$rn8:] I,~rx%qvsEIFv'Bj3*	U(bPV"O&gYQds,%le=,r7f{|$G,}`&_M<?TUGadmMt>_9lJrz4S'QB)S)_~J6g#fLUu/Nq(2U;wu0}<
+M>PwObVME`CF+:>2QP3\;F^zlhH#,H=Vplmzd0G.FI	4Kal4IrgjAv^=w.u7CnI{It7;N)9j2F4CPjXc$]@=Nr<I!}QI?Bw;F{r^4:~cKgZCes*/
+j|m)T%GJ( Tfu4JtSpH|B,f bN8{*!s
+_?v:w);w3BMaf E$Kz~<to=e	L7:,2%/ _Rtc}Jv({/`~<dg/CVLxhAE(8RB;<|!,w"[%|zw$'!m4fu>wmcuNMb><W#cN 5;JB:xz3Qd60~Gza;d"CNm<T$A]-0 gx#7;?K|R"e.KLvsq|n3AhIP'T%/52>J3&!`g)8#\+jp6<wE3m s#Zp2=dR0LRUsS.%J3olgnhv&N_yI5ps.{B8cb:<z	;&8#}4:i#{X	Rlo]<LbS7P#4SQ1QX$Zs)&KlT!d:ce'Z[w66f{8ryVIc{	J..rN,Q@C0H8`Rg"zG#peY2f/2;O:;1.
+{nO	YqODqR{59=:S<sH	AEgD{:-TwD0$QVDc{RJu%f3
+?+};z/-YZPf.+ T;/i|v&s6q@,2EoI2h0B?9D:f3[}Eh&\Jn
+1dI0m0y1Gy^_zE]!0fa8vce=#X$4T&asN,rRqHlyFx?wSF1c|*L%[WEU[{(Sak2]Yc2} K}Iz8	p?GAZkDi9NQs)QV;x\E	(EwDB=*v{}b<[hx${4IH5G
+kmp$#N\]4qt`VOoq}~Rc%{6(F1>cVd "u(h6\nLjpnw];ez=< 
+^AJ;9y$sMODtz(mgGiD	O6<ZL_L{bXG^N|v>dS*u|` 8^ H{6}5luD|9G>EtYy7#xDdZ.6r7tpOX[GU$1Q7Hvp1.{Coq#!89zD69dz7b2CO9Dw~>3G# w-?!0T#1fst{'YMz	QWxz?{F#UQp:#~np |cA(PG].+h#	"B	 AT6K!%MN7~?-~M,!'uUN+LIJt+>*/?[4X"`o!2!%:jDr5p`D9DAN8M68:;9I$};%(x1nJ:sRQ~=nXirYeH,!;z&,q|PpKTwojY`,c	
+C(s]={_9iXFExz= yQdsy?I9b2P!He#Fva)x\-gLMF#D^1x`B:8f8O cC)\7,W\.uXhL)u-c&3ZS&q29;w0?<o)RH:4^`96#SwgAv1u0AwKpx;B%I
+9,v^M4ir	?fCVi[ewz@cOXNLn?^? onv.9jp'&9]>9,{IpNq3;.KcSE8#PNSH~@O72MQ4lF~6:vAs(t'9UtI	+JQiG]%oP6oW$y1%WK*x>c #JOohpR%9corXF_NJS$$'<b'9Gs'cnd<q~6>>[!4,SY!1FUN 7x>(RjzWA:FT\	-.j,  };'$!G8Gh>@n`^s)
+7e <:"mk(`Tm6,8aS
+90I]
+{O& m44F'H(5i1]d'AGCz:5Awvvw3;,DefFokPw"#A1  A]svGC<"=1^<W,)^l	0-\O	Cs}`O>OR,..6/Nv|xPuw4A) @[`QSm	T4
+=G*[~\f!/!02.G5{cQ	O9	"4fV#<\mA@uYNuAd8FkxBvb cqFfb]'i>k2EuTZqx M,n_% <'*d:fKCuhuP_Pr15	@
+$/P(Nm ]{@qATRl64ghE+2*bQH^Rp>];D6,:		_511v? tYPk6{CXP6d3L|	r
+0#F5u1x9E}wz$qNFYj$pp$t@V7p_nR0a4dGKD[fo{"0W4;
+/^Dml-\Q.! X8yU18`ojEO6hLu[e/@z*?Udv(z&1QEBuPQPL!f*O< jk}hmLY)1qKkV?p@BGgD8}9f'(3S3StB;)#G6IZ}1*]=UvRck4$rjPaw]=X'9O(<3J	Di:2C<Ha`3Ga=|	mOl([HsIQeYp\P1TiGUaG,<_DDlOOkmJ:$r7PSBk%qahmE6tU\/>FMw?/ap6Z	hLO7'mogO46tFlzm:~$Y8b\htSOe@A8ur7k_WCB;B'G.|![4iu>v>h]>Ib<&vn E1L-#{Mb&4/Zg6ik7&\9{!TpAVX{qM}xz%D`/bd]PQ.;4*ts,T	T~HDu/eA7FV1i]@kbXTy
+RI.,9|.J!IuPLEcY1Z<}SZp"T*_|Fv Sx4:5!^g.A-4qd`t|AE-=C|&Gs]3
+F+yM)KSzJ[Y0{eYfeb,Hi1fGJv6lmCouIp|S<9#qIkLw7y6P7nh!	O3?0cYu1$Y>=o?|7onAB(KmzCzn<(ft:;K5=O&#+
+"2CC1!c=#=$M8XMG3;va6shB"uz|1L7Cj >ai"Un1?~.ZL`k,`f,nz-8	6WWQNPaby2\ r}3HGP& j^@>`v7qJ,.y k\Tv Am].ZfV9+k"MQKS#AH0T&6VlA!l&aMA+'DLa6 \u&8LzM5PjA)zte,#0A'UK#`Q\@c|(\|SX_N`d$uUgg?jN2aj
+w"~Ck U!IO<Y|+( ta3R"9OVGIB
+8:/ba	Iv<Dfl>b_/j)x~Uu <;i,_XC1w	kr4YkKP`R>=1w>+{P8DC? @G*xN\I#.@>`[d/EOwj
+uRFI##MijA1T9g	jk6bURX.vn}p{pvzV`v!mCIk}aa5@,jcl.%/d8,]anw5J]G$ m'3IMU 4l7/u5,Za|PqMeYCd@T
++J,vl29>u@)k" u)R9:qia;\B7Q/apx9XAa,7~J:N*x=9C45qMpT*#CQnJn2rbD*J/4O
+	PTe0V[iZ|}Bk+*jR7XV v|&6&}gNrNP<Z"wo?zZt	@F#%vx~z\q{}Er)5e>\P fW_u}2C \ y0M,HiBHyj]T>nvz/P+0'bt qE]`UF>]hVeH~+:vI(gf;vjz6{>il1apYm7tlmN+hbDu0BYuF1WU$5"8d!We:@y;':!2\
+w.^<TX  J(j)P|zyrL^ ZiV8UCu;@{!.+wa	Md0XM/.e5]&c.]V$%<(`Ij&^Wgu,z(t1
+DTzK29#;/&*;C-sN _}zB9|`3V&.??odlSCo7X3v(<0>C>E~@d{TUA]{m1xa}}|%P@^_^,uj\[[=(~V|op^q[7<-5A=noPk5o,)H:RK=::=cz{#!|dyN0Kt@i[;g|j
+vWppu[B.7gwl]5%kbo5U`	v7rGl_T"_^oWM{#*FXU3D;v4]a@!6\TbsI_?74i b\m^^_!n"4R]PXp0zxe8:>NeR.P%lj"wjVN&[Czh}nUqnz>SKA6h1RoSo"c/YB:fi
+ET6 }LRYa6W5#1eYT[g[7fFb8/WV x
+# 6uw>]-.M"2^.GMJux,FI"{'=CBN)yOg&'#>'|wo~JVvXH}z*x5nWwL`".4XL?')}[A@RP*$XGzwm.i8'`n#g\.^Ad~l>_<_?5XvWbv{eA1NsvdC4C )Pz ~$tG<<g8pCSB	~_^_?3EQn]7OoFulbZ)b4i6[l\d~R~B&.:__ox<Dd5v3Ovb?~T\7|P2uj1.D	M[`L1q]O$.C94eyUq!Q;CNX7NxML7;dg(AB>K&)\9P$+ugH
+ksR
+rJSHxEd5qq'p1;3BlAq	[DTAnA/Hj;#s#3N<o;PdY`dHmc9}wFtrbycQ"Lp0cc~)R5\+aaJ/_!wR UHE9Jwu}XHe@k=p\nfz_\RVT?(E!E7wx?=5s-\/u)am+bA=?~:AJN$96^r&'&&3rTf> Gs7'WH.D:~I/|O?qFpk6"#He]M
+	dd5d)4IyAR*(Q{nw!
+,#Ve`-xb;J.l&
+59CvQPA
+0>f($m\pGA)y+F.H:pPah<Pd
+PKt"wn#Pu{pydsGS]P#olC,6jzxxiQsJsnIGty);kvO=J\-QF1KAzW|ZcEH!Q?wYCB:0>i5]@dTG<~l/ppeGYbv>x5)],kp\[;~G{|k4\>~?2t32^(p}8[:>~j<%Sj7s)X<yOEQ7Lv&rw'K|!wW_|?_topZNZ>;lt#<Fb=$Va}Ki|:&&98 B?g95KFm3L<#Xax"(1i#0Oimh%tiH\[(LWRf5P+	buk w1|u@<T|M7]f?*3^v)zrqj_8;vf}H\@]02M|3gSDnPXxi\<uyi8<]lm#[
+BK1`^RFp?d;
+Rc:M	7Z}@D>S> ] <cz7\@o05D@	tzokS0:;X)VsEj]HLB:#O})V)yA@x|r{u*2SbB9 pbnZp.V?	?G<_{'n&.+m\x<SjwCl{'uTmUbFBD6,:d/h}5&nFG2]Z7KtFo__?Ack7Vzl;P*P+ Xb8,ZG paMq@7S|a$OTJ@p4H@.P'h_w#Ec<pT5qvXihmR+hDb+<6w2)FIFES[ma,Tu5&z@g%NM9f\F,7}"dtg	0av0C8uqP0qeAS$;U:HDa#rUL$Gb8,}#gfwHZtCf.")w`1h`6z")l-:2IAl;R\z6Zt2ALnE$_y9*YP4/5Bh	=vu2rGDIFRi@e (RTeiV{?tU2$Dd+IqT}?}^O	^^}|mw=1=zR8W!Zq/\6(:6#*]lOBx-+HRqkJa\t1
+~~O/x~f\/lb9^>G|zm~#xwFZ-Ki/Mq8H32dm.)=B#D_wx_4xy}q7vD:#pM4dzYY|tQ:bmBY>}z7t^;)NDXb"(E;%TQp#X)sZw+4,\UEwsPp!c4&[@_?>YQX9ri;'D!AE@.i^jZ	v:/q Rt&r2&YL{$pJa%yi>fCGtOg0sE|NT)iWnnb2Yv Kt?HN 534&FlBrv1N3qTB|*
+qNl77Oj#Kb3.B@	|5_\.Ons$d{"mf:9]03[lW]2OT7-3?zO?+.OVtryO?~J_}R/G.(oMg0U|owOx~\ZpYW?hr}=mw]q<J5n6<iB*^PNC-: :@0R^| :
+
+)RlAB6CQA^\	OWD5BUw9
+YX5
+&{t< V&}a2C1~,+_~S,m$&Vofw8$nc*;*6fiBG"C8_y@L18k9f5%];1fIgIVZV ybJ7; mQvOj`87RCD@Hba	wt=CrOj!3jGS'rx}2HYJ!
+ve,DOE?-&sh)2IDO(ddN8 P2bgK2H3{2Cwh61wfHo<_[P)}.+
+);V<]fp* L>E4$'_7mw
+P-?cY~{Oz?#wo/x.6K0oYQoW_^<r}(*o<\PJ5RY?s|b\qAK"^T<=],]m[!\.tX%<Oz3VvY)&H&6G{_bf?BX3g1pLhoNq}Ba11/G7D*w4&Q[1,BmJS9sVf2J}BI|O'KKp1<F 6BS)k6Fe[%u6H uVvvY	=was{j\ih6[b@N=KGf#NxsND4*[w{>]1J7gy+ql}W^ C";C	g	a&vJVGvtJbbL&WR*A]FFks	Ya3Fqh2h5K{dtb0PBa7Zdn3)6{p^eV1;4*k2"SP`(Q{;8*W5RH||Q6!r(V*7&z\~Wz+?2nr_Ai}"%n+?|(\	?~?#^o^QMR+|UwW	*x;xo~o _O;pz}.oQp>6oLPOx-~7xW3&csJ9%mD3:@*vcT A[&VGdOz#_h:nFOTT*D3;:F0cQ@&pIUSQD NDf;J@,v2.dzd Tx@<psAHqA$|}[|'$vn&FNzk&+>3eLs,Bq1M` J;Lzr=;B/d}Nu[RP$
+#u993n()G*6,'4|2Ns<3mr Ey|
+pD/#~B`5v^9R'gP";d?
+"CYPLC\xZk&#AV7<	\!oh1C9iT^Dak %+AF\mx-o	@\t=	;Ku_~& :c3_p]Zw/~2C`dR.xoo~kZO^2f|y@oiK#uq;FCp PUh4R 6yj`4{\+5AX|tQ<6~p6WVrl6j>7c1G*+ 7d;\ZlqX*{wm,k*X*<5;>J9->v.[
+0U"1lm	J=
+qPF	y_J X]d	g\7|J4!>R5g3^)# fWL;/iD.1tikCkWLD,J[WlA`}57{F4a`(yGsIC~n%>"2Bwp<gxJ{*Suzy{rGS~(}z yqWR#T#!\tWb%77lm:Sr`ruF0F<xe-WoqY.O+X,2_<Hs+(.NADe(E	*rEkK1|*P
+c"2;;7%r+Xo/,Zr9_.Vsz}/egD%113t<tGI@3s
+@rS9yaj[aeOm
+d+%Stp0SF_,l"X Zxs5(mtA'k}`h[=dla3T*X`GXwHp}Ty $l:R~?b,f2d\7sI
+lPG 6HcBJ
+n.VTQ%x{s	E?EFDB#	pCwrq=12%4F+>e l>3x	J#xnOd'E	P>Rp7B}B`<)xUx0S
+#U	QKqzJ02TC[C/U4/"@N	L3*u}YW(u-`+HVVK0PPVw7p2`zFLDegta_X; \UAp`lw&2)nh\[7oyFI1rB,d{~"cWuDQ^?7n-:xCq^0`dI	'7@<4cIDG8u#}/BSm>~x* |'Rl&..jQ]"W{C50Vv2En(b3KauAM`)(t`m<3Z3G
+B9+MtllzojeY86 &jY. -sk8mcCdTX:exWg*wP]mky.sK3"`PDy1:OH`LPZ=<ylTfvokXZZ
+ QXbtu~rRviv0fY1E,{Ln$Rfxr
+1
+6jq=fKFs^Y_wUKt&#J 8fYX^2e+=,?"4Dad`0Rwq	vP0yaZ)A<(6le(nQCZ@JcGtx5|.R[
+CBgEFCWJZE 6l0nNZ+T/Z.~&#nC'=-
+FZu_efumMdf(a0]M^feqxm*`kwgQXh[W7yA)>#)dt$}k&CQ-1!*p-VAU2Vb	6}H:*H/V2#3~q33skpA)]mB@|&daFR }wq7e1lX{-<iI7*n7yh~rf1l|mhkZu0)FoL"p3=\lvG>89L
+IubD68@1Ex8n9:BH1Gj,a&4	P72te/c5(%B2)1cF5Jt!SJmDGH5oWeSv! #@6OQ	e"|{<FNarR|mI< JxaGVMv}w[7PGrwI\A9 @6"{x6<yr91PHo]d8Vs!d|VX\T%56$]wo,I0xCt,pqN(Ym<v3]1o18^@TSpuRMg.yJFBt`=HpS x[Q@Q%I=
+K^dFQ{r,h#At9iV]. `#c*7QEhWF6Cj`lPj92Re[\SL3UZ=UZk_A9TN>uVxNup@]x]S
+T#K.X7%Aza*0Z3/3,S3/OR[TIK	a*E6YGp\PSM(5"q]QnJ2i\|w<e,gs}rs-g"bEj<^5xKi"fx2l9), %
+koDjN#GNgRYt7&FQb@^crbE!iQ~NR|BW_%-O=4z$xHF'$!PY
+R6n	}p5Zh<h n(0:L,n1Qr:b]o1>v7K`
+,Pq?$oJ9GMlhoaYgs|2hTM!
+%pB}:My~&Cg6<O}#REMugf}yn}MXCh^lUAAu "s0j&
+r;l.I=vxKaj1Kr@4ib!;RFSaV7k@WlGQ$A1H ]GI^|-b^PI]D-9KKCDB$XK`gts{nu	8<
+3%aXEnh0U9R!P5f=F	5G*%s}J$CIgi
+XmXxVG9~2xs	tt.Ys:l;e:4&z`81B4Q:`7TvX3T	Z Vv ]ZAB+j	BVB Yif0I\=k1'{iN:jnV2J0>B#'Br`wQe}5Mx}=d^'Z:6n	,9R#oax}5=BlWBkShW;:*txqVfUwM 80e-r]<4 .x>a5unb1
+74s xp!i]srSvY:j`.tR/Gu:L+pG$Mxfh|,f}vF[Lm	ydnR5;m^VGd*dd%#9oK];<Ra!vNyQHlnm3jJ'|R2ptA($IJ.rS|"HhMk#P3 <KT@Vf&@R 2+>I>,0q [C|$3M~<)1N	[5,m e;[xhKP,|
+sdt8 FW^fY"0^EMntlzGTh@BraHa.B]I]LnhI>6A*L9"hGL;Z8`*`zJwy'zDH|s~W/D3Zl
+cR5{B;S7,"J`pfD4S=K)::a1&?u xY00JX1i~ ={QKAku{$%z38UL}4Ye*&&]:i&6,(4
+N[)iPcteS?f,.	YHyY@$n
+o c{'%.X<DmA[#OhScKcTQuU&1+7hHet)8suy:2Sc{cJ	E^WJ{"weNi0[0GO82@Ih$.L:( N.8kfyL<pp,Ha(oMsK 2`!cHyy@|j
+qy13Q3J^
+#K0e\TlkJsToJN2vp!){mcC 5%Y5T*3w>TaB8$?R*1nll{~pn](fD7ID2O!'lm70')u eD{!$1!1c)mAal}5|TS}t0:ZelmhC9Z"wON?*r}aIcUH3s]PK A0nz uXB@LrHQtYO[M0gH`}9dJ8[vI4R48Ju"h%!z1B%`>RLN3=!y||cthubzimGlrT	3AG>Pj'>
+|-%@jzLLGa	`/4)S+
+O*5($fhPIGy!=Q.=v14~;2=fT. aMHyvDX>"}/nH(<e1OH4aeu?]w"07Iu<#vCvk~>]N9^O:+t+\/oiGuigWb:rEat1.pdQ+]+.OoJ@7N480}*ZFI2XGYGuO 9ok}R<
+mxy99T#GzM7o
+nxGV:`Mw&y-4$j*5y[[TghA<':l&t({mesGqXb "pIt D3ras8!g*8ByH22Q1'"5j[0SS)SMY%?f;2GZdAliJesfG_,!Ns"6.r> nAJ>{6}DvP*|LT,7g
+MLsI4I
+i6gEXBCH3ea	}`\rqU}TrA sNxt$>]2T.Gb	C;(CW$SGUN |
+uEUJxHT &N8u XdzX&5jN~L>=|w}~B}B/|_3xzm"5!23?_QBkp?{= zpKODi7@_XT\m6ptnG/i(Cy7KA]cyD|7CR"iK!bFl[;:*.0Y7;+RH;qOiwi3:LgnDo.	ysPMv;HUB|z-Km1,s4m!#GDMCYblf6UFBDm'U
+!g*7kd~HqS~Z2p7;+ Q^:bxv<`aoW(6yD*\48xG- 5b,h*T@C	P/"u[#.~xV,RLK00
+   Ft<4P;
+
+n)|^&pw.NNv)j"M( 30"?503.ipfZxE)I9S<7}u@1{
+SQnjbM< Obt0.OoPDu0^'m;_>O;w/wO`,<e@f2*2_R>^>|rL%Cf+:2;k@jZ[Tw;{R4Q\QBF!tE'	-6KX?b$z:pPm@GXo7om ml0B{w
+?vRl,7%4^Tx\u{1R.2jr0TqP`_{)T;eyc]J5Su.nd%R)@4/0	QLl(5'HT9!ZXAGPD1FWQChk;FuM85Cdg<uQZ./8lD{Vp'u!M6IIY)cd5[%*23U/6hgK2I1Y`PtZzv}?
+te'/uOte<d"xH`Y{ +Z$=qLLR=zPg/l1~I|Gp<R|U:t1M'c%#+%C!sF4umpMMUo+Gm}?R+15*Zd.tK7W|	E+kxk<
+_oRX4XF.=(YdZ$fJ>9IAX!^<4;Fs>pjoo^vsD WE(V3>t6''p1Sl]<b}^ht'BjNUYqko!PizTi
+^ i.	I
+'N&V9\,	LBfP'x&6a@jH47/:q{p~vMaf\<<JeLK9BI'2)swS
+SDRnhF$J"J)'d$G\P(#tf0GRSbL'fWAB(AK=AX
+DIc!3g.%53EQaMAL`sww1'QB)3sd,m*W14#v}%uV8CIgfc/q*,'\J >Nm^
+?g MW/AYW7;m.~+
+.xn/xo}mcgX6"YZcfKlamnkxG !pS"!i*		:~KwaI1|<
+:</ZP^P' T Mr3979Vw3HB1 k"h}= 4PuO5R1C%6/
+nq?c<	F
+OQXStZ*W0xXcu&:5U:=v7KmQp+2]QEJM&Jc&eZF.r*WTu#*K{]lC0FP#vAZBEw,Bw),zr vy<-![4.E!bJgT"+2n4,g*5&z#2b)a1F.b.O0hM3_K~VfaQCg(#T|,Qr6GtOm5Eq[oX_W,g,Xjr m~.xud_yo}}.xzbYt\	Owo QO^JJ\ygqgX&w|.q,ohhcI;YILi29rU &;IH?#2gA9"-;U&W(?xTG*lJT/)Cf6Qh l3Ra}?`k?GDIV5#*bw"L*h4E>,J	x9/ xe8$..72V#Ge	),L7'?/ wgK$J#P\Bvl#w__|m?1zoK_+46n7	`*
+4{,+vDCFG#0TwW>=Ot j#GNlRevU.S<^h*)3;=2 tqpxtCj';,QRrEH-us,$|*z	nmms4,}Li,:y-,xw-xu>v,DX*+D;J\p $!@Sq;j>T3dp__khv$%2T1NMD(2=4(9Iv}JTgU6*Grxm-F8-==-P^,xMtPAO914S 5Yk29TES~i&xk*TL4Oe`<)DbELg~/6O2LR=.6WW  %zUiHR![dCdo.u<_>B{$c9~RNDay,d>wA|xS)tjoHb BI<g&c='>'	:iC^IvrtX^n2>3y>vJ|isT caM}y7m[js.
+-X.##~[7]VGN-eB
+Y:
+Rbh4W0}+S(@upo`'.OX_?\9#I:w.SDOP ho![#%9PtuPb(<QmVSEl/4mx*)I ?2;XaOR|`4Ja'N;	#Ny:Nc1a%espa]v$c9Q8>#gyJ/xt:.<n)QQ&T1'I1K(?%F@f{IDbn\"dPBRYwteqIHbWY0;OHy^pf3<GoGrv=R7( ^woMzRE,prNZC/;mpJTMRQ6Y0RVl}Aad65'"YN76ck'VX4wGko: M"9CQ'AH}y1D.``RF3[Ztxvk7;ESa
+KvK,41JScN{=G	g#npaq)VIft:7wq	]NE20]<Y~H7Fij<!#{(:lx[
+=1O?	L9L'jv],rl^:6}9DAafIQX"qN|=zX(slaF, T@Z,BmK(>$)80io64"MWldIcaJt9.MK"-Ro}JRhs)>7G#Jv(-9
+$p|2:~ND#0qbh>)m1 OMSt63&=we=h>2 NHcN/ cA%P]P~(1h]wrFbd0x2MkG[MjY],G}Y1*1/oh}"n @YQOFX'\/)&Rj!gF3Z$T7=zcqpSP	bc~RDLcT,8dN?Cw3QwkD;`63v%7#
+9Si7[eD]1~Dd VPw:n &Hq"%6Dr,mh=b6+vD^D_&>ua4QU+rR/V urgMRV%q\/m4 M;]C![[2.z8`BkEeV}P@QG\|^0 0p0hg3DW#^_>cMSg2"e<dBb(vinu(NHt44 ^s$r!(z5&KFe6%tp&45az)Ys#5jGH<8CWcYLEJz&qx$LF(\fp?tz70TI(LmU,@Q<t29m6f]7
+Bi7V|x_+j-xiV. *+*x1.mCo};Q>OEacr0%bCFcJ|cGRzzjh0uu^~5d{nA yjt@Rk%]nzW72rDbrb<.70s/}V1mQUD p#=KaI%3\.\/a}9J_k([kkPgIk9xnVxQs$rgI/Pk1$\2xqYHR1$P}EkOo
+YW}M)iYEN)_a7weCNPlcj]Z54R\GsHyz]6&'*~y;qQw>coI	9)p1UmtDh\g-P)Xq<zs_DmB9Y<V7Pl ZM:&(ry)rWc@/(P*pXCqrh[L;\sx&'mYAqJ
+Rc5LG$13#z>d#pOseE3jN\h^'=xC91x<*TC5![!3chL$HQtwE+2YR2h"h}XTwEHMx#PDb??G.hrfxx[)uG#CD;~naf=XxGeJ9[zC +#)j+R$v&p*c6=L6xIfb_aCnGyqz\hv)tdaIgDq(V;Jt}Y:5; mtkvBrdcow39hfw^TDV$f*;8d00<tSl[G[6 }f#N[#p4~TK+V{$(PROBj^_M;%<T*Nw/%s<A,??s!tE*&+8i0s22y19#OWf&aJ0@=9L;sbw[UggUm>jHp>C	bpCGl"kyB)[O&$4dN{W19g1!4m#9- =J@x8eW7wkg@
+)`H)&;)Q,nvI7Sq0aX #_lvs KH]$oasdQgM>Nf|$j~LU(#;
+?m&E<id%gg6v[ER}F	:ST%)Pk1hNd8$m"LoD bkOgr^!eyZ &M6T6^/`<a*<Is7V>#~l!F3$b>D
+{q aJ^NzD}Kc6CbfCo
+-1LT#@YkcJ|ydng)p*t6w1G=:kB0~N5dcCx"dX]t& bv!My
+/rsK~{<y~k#4-M,Zmjv<:uOr DG@VQ&(lv3bv>Krx'`B{{{9He<3P];&iS1Y	HH	1&RVY?nVw}'sxt$Htl&5]3@b |x7_9(;9c:qG5mJ2l92'ArQG@05M7 >paJvW+1	mx>>|`edxa^7Ox|']qN|Lg=2:7o_0Q25~o~RRR0|ZQ9rNr
+2;._hADy7q)Q8{~5NX5
+B(B=a,ElE ngR$C8](>'
+~_Ka_m;(c/c*f8,\:(ERxl"k7.6!b> PD:!{nV]eqt3G]|-]kfgHH<"w5fG2yn
+Y+ L YQE?@QhS|Td
+AJDVSpZSrEH.\&>J0(*>{$%K^j)Nn~ Tz[imr]lDtEC=.,K2,.OxmK1b>.mV :!_tIw+MQ#=0r1)%2u
+?miC<Big+M=B(^C,o>IG:HA"W>NJ]D'cX5wu-38Y)6{:=Tr_"/| |PfKD:rzo>-`T0H
+K)mgjg#g.wYzhWRnxXm[[-<4A]dl?mmr-	OOnz0<0
+A(\
+
+p	]1YM*<LE*'_9;|HO v'+!:V_9xdr|zk!3$CA\"F`PF|:"NutPV<"aA=b-eM2lY']p5|\<=1mlF\P?+A- /"YMQO\zMW/%egaRXv`P/;G!s/gFE+)0ksU0UC&%	ct%
+sW}&]ETaxEc'x3j :6o($|xih$i.%,u q$Ze]MmC-.&FXN&KHG!1)
+KV1&{%?R9.oe)"ITtKqY@
+6H LzD!O$9j@P7RQkUE]eL"h`F\\}Tn/r=ic!#vCaLHav"#e}s	kGc=nX5z}fuKv##2TJd)u
+vc*,);GA3
+KT=he6+.vJ7+Gh$'tO/^p^PjA]13yZRhXW|
+nRpD7XjI\	o x{ m.4gf wBLh3LwMuU=c))R>&?P%o0_TNK\*3C!bO{7 fTPmh*Ryt%C\btZop)^s)CUJa?q4<F<L4sFC-1g`5{te1vk26D;^__PnK	ZtD(y
+kJ.1AHnr0av&qMPi'|{,2?el@)W,gR6;IAAr{5W2hphNmV\/WDU&Ib;QfNG$kUm/uo $pv=]fWUEAD_yV6.@egfx]SsOGG`(!MX <RZu\ur^"xrw.DjXD+/:yyz'=|@;*iCw1f,:5q@<	0>(H[H~~!'~	@'	p+X2j|M#^ys6Ca/HaV;`'9328]KJjcE1s6
+U{|= x8	vu+IIs)t%2b]L7
+x 9xo%,	VJy_K"SHt8{<"cgE-Wk5Mc5ig8>c\>'wiER|(j:S$tN<l^;J,Cu-knydK%.Tn$P cN![9Pu-CBS#H)[vatG:-3aXFNLO]rY?vZ2|q~j?&-]ST-'inihA5tXh=N;Z{]aFpd,OR;k$FVJQ+.jj(}l-KQQc
+{:-E"6qmK	mO8<A/Q-RC}	n'lk->U?Z%=@nei/\'$2%=kd`Yv=L*	<4=q[As/@h`Dekh:qsE:Sv`)Nx,!L@4}~W[q$c;rQr5r.In\:.a
+4sYJ)t \G)	#kmj="M	 d3b*30|Wd,@"xL9wi]NZ}Iib7$W?FZFAM Uqq^8S0}'{GvOp}t26[^YqsG1J5T+	xguZa\Dj~d8v?+#&{@=	|!siSKxM 4W\IQ}-~\pPCl$rW?wQ@^J}~tH`:~m<XtNNgi0>p.i=`^vvl4{a~I<=bHgrfc|@t(VE7N~tC`MFGhXl$6[!Q@13&/is^DQ7s^D!F`ETgK.tCJ)0#\PS|,,	yQYS{sfd~D@gfD+k-a'4q06@NPaUL83FWr2-[Zx =XG9:4slh ua>S_Nq=OH
++!zOq"g#Qk _mn}j:X_yya:Gq~4z-	04Um@Sv
+;.p29	(X\mk6jG
+y0#W~k^;v\R{DLl5i|RCPVgr '1ALIG}~{>4jn`|<`^>2gHV zefbU>qmUgp 9~YBsllt.x=%ZZYQDm5+j_zn:i U~zh.v7miGRv7*>axE~W6gGeMCM1HGcyQ-Z,%`ADuA:^9NP%A(%F+&m^a0e>6^MEQ[UOWc$h*o<H!ZDx2O%_ <Y _JZ9Iz'O[XKGPuZ(h:9$^,c/^vWlqGVP#9YhSO{se+O?\~O~-cQx$N_e_]Q|iL{M>$39O#x$X-0bT9Xw0;OmB,C#D  Ty	qLM5\;<Tcv>Z\P24W:'T#)@?]9I##gfXraJ>zup-BaZVj6Jk~;`yC7lZjaZg!rw=i}xNt`d
+?o `'F*hV%Yf>5HRPM?@tVq:*H/#h-`X}Ll0_:FTUiwdGntC`E]<.gZ 'EN%p8A	$SL"V:f5r&h&EJ/2]isOF %(h )a%ER3YG %XQkEk"#-C"DIAwlG /o9CVS6s3xVS\OR{2||kxcu%8 u;E+}[q$PT.(x"!c-KTFWiv- C*x$FXyuCOH^`z)%,2iNNj	di0kNA7Sq?pd)#>;<%vw+p,#N0eu`%As2(08bnh(Fl$d~6CB<8}}Xml8y6)qp	f =XuJ,uW.UmhOFgv9
+f~b^T<C@:xH.r7];EiT5@O9h463MxSKV|XGE-Pe$H`|ufx"9Uv@5lHYh$Uqoopl6AC?OO?XX~*dv,?F38:.s8t9
+PG1F	[Db*[!T<E !|
+6 i/>YL"V4w" #=G`Aawuh|@''-`Q=W<VV|i5L1y	?KmQl~I(FaZuY13gYU95zq!Ra1,);H
+SMX"@w0@<fRA NO!u	,GQ-sNm7YED)OMQ1s
+z5:GO:!k(K+GFuftPvggS<c)g"/iI2'Lg3mJU"2\zZXTc=`}1D&<JkhB/A \7B@4OP
+pZ0hK~.w\w\7B_Btc{:Bv>0Z:Ft%PY
+{ Fs]1Dz>N.c<dW{]V}M@///\//+zDffU;dY1 HK1pf\8!4_sSOSdJ1-v)|$kRZCxy8 	0Er*d~c->j93h5!9u"	TK:|+jdGM3YMt'Xr{LO]2NPlG6$$eC5-8*bEB\l(fRVz*W69@f 
+s<e's.kz_G'pDbh#SQW~DdGdYm"ptSRjXTBXH#OyE!cU=T:kg$N7 &D 3n==Xt]*y!My_*bUARB3=!kVw%^h07O==k#KD!@LLl
+w72!%fn8ow?9dB`0t3b`isYtq!0 E_gmGO(I/+|+|AJ?A6o
+j+zxHnSnW3d&[0FHFR~21\-^}v(x^=;*oxeVE)g:}UD`*(5tOSqJ#ctsNIro_@I`)#h<5XQYO\"6%h$9R7\mKHY2VJ0`PK{4wHkpMqo`nF0vW\cQCah:1l 0? lpZi5)4ih#Q&Lg[Hq H8?KDytBp|F\w\k1{ma`r%0N/{28F/|M$I~HAaD(Q10fd| Ojy4pQnU~oJu^[S.}*y"dC P (% q(P`/+~|/F)wTDAu y\}8'<[07<?m0y8mJ$S Kxy/_?|?/_SFNUUgSP(r/(@mu^_t:~*`9ie@gXWO1?SPi`=!o	7@v h@I_lXq('uBg7Jp'~DG8@uM< FVx$o7\_^p'Y1bQ1vxZEIC@(LAc*PY{S2ZK*!x~**IY0v}ZPx'	y?)hT2Ek'wdP+:zf5p)Yp0klY}xMPu81DL]<jOw=)LlJ1JCaZ"ZaL8@/0U4qY\WV$e%aB
+HU(~K^K1VQZ
+J)k<42oOK`M ;
+!A#qp
+e|k
+m_wkxPO CEctUK>vu;pRIXjE'z>aN#yDh(qM*9x+/_^x_|/?`fiMt}J~?PJQjnMA,E@']4Aem{Z`C-,52m/KmQPN'hoZpx]$}7H^=uYv5^f$/ww_=rpM ||?Z@&GW)/XdkI	H6s\)n4s`,`S!e4{!ypy~hWTwk,?U
+w%:57@+4jCisN
+jQ]Gj_H:w^p|h=45c]=IE-xgx'+|\,HY	wh%G8.yR4@#h	qy:z\Y'd#_^n;RqW|6.UZB_ca?RUyh"eY@yk~?~	 5EC[spKVS|^}@l{s=)nEA1kq1-nS|NO|E/+^_^1DL+VkZ|l8rTCq?
+nGg~1.$?w4vQp1X @K7|<x%?&x9
+jx}SL-4V B_axGiq L5+r0D@U8<s*L?YA
+F!bDn,b	-*;VP7JxXwKv6%</i~_o?TCdVO>x"^yRBhN#LcAy{jTe2IkO|En`hvzJVoE^p'sW0_-	pXd,}Gs$kzf+F1_WSSDUCk6
+x.qU{L	Mp+oq?~Q2RJ+oVb}(hS q3 hNK
+	h^./pK	wGkG)<"UqGc]0
+:(1Q%}/;^3^_2^.	[<v*
+o^08n{~qPt1=]mZQv~Zdl9=8a+w="ifNsRRC'CO+% B~.+r`>|&O{Dk/_WXS!org#CX[,v^kof:Nj;$fn [NAao	U;k?a@[p:tK--#?=)V48yWjq9'
+r;:/t0}N2cx:{>AuYO|[S[}:?/C>BP."Q`ZK0
+O4=u	"b87/xX/
+
+\qmq#!4U`lI%/W	 }qL)ixTW3tG})S ?q:bl@.9sJ
+I-]p;^wz' htbp3wn7P9P1D|ZC'zc;m*Tj!N+_&H$"u~3Lq_J'V^;WNp%QkBR=/,pe0)5XJ>0
+mmH*xIZH/t]M
+!$N[lB8gRId\iyIB _f<|qp i* hQ|zwy$+cumUQ^njE 6_4EJ^ZLxr!QByBNAzbG`Q:5!PJ9}]w=:I{:Qv?c	<+>vYg_=c6[g
+'-JS4{T ^KtE5Ow:XDm}?3^7T-Z\lk(j6x;("Ah6
+]E BEg Rvq+M.DJ;MyxukcYi#2u*6h^D!h>d3qKmU6\6x}pa\6oZ)CQPkq#!$gG.N[ud'>4amt&7N*ldhJTT>)
+Ta, $Pq3kZaAr=Vt!4UH~mN`0?6GZU^M
+Wk _8R!AvhZ]QGD0-au]h,9l;,}CyD|	R<fRbM.rk)N<>r/~"^uzhuXiB]Zx;6.>+n~Q2/ebSju~q,}CJ[mQi
+u3;hYuhY8UA#m>cBZg7=`HIgBZtc
+g&/B>j	m	q'#w4,1bO=Q/.)fD]-L*(v-S|$X Q'Kh!JZJ`
+w_S%D=g"Y74!m%;wcnO
+D :	~Kl"Vv9H?Q{]@x{6`5"!N	9.z\7}bm\GSa?q\6\gmO7lavl7vxjhbj)QuVbNEyixOzw @O(3iEI3ZCj}XEc3 NZ-k-GZTV[(;` c1tFVBiC: ?! q|O W-V(5\?~Nw002;&$bF0$PlZqO<!F'@u:/sT*CXKUw3q+j1=6x}odfNIfD2r".R^rL(8Dx	9q[+noSyP\D-1o!\5{ T=RzIWG*eDSyb8$Hxwpni<H{lViN%O ?`3l{+@u
+ZZ,e/vpk.R_m"x	d?3R{^z`NG}	IUt`;[oQ>"'';6"6-H#
+!Iel{3n(TCR{!	#DIN~	7Z <X8x#1.1(o5Xg:FQm6kx'}wNyZ;cn9hu0'AM|LRD[%j_<(Sc}"3n8xa-hubl=>ciB$:UP'bgF
+mO6xI9e<(@[rp*|`q&ay$8)#F#g	%*q <QZs*@Qh!?HPJs80Ht_yP9"/tEdGFC3Ca
+?,[<kare=%N_/l:m5Tn[r^zxsT}]m#FUAQOrA/,E&.rUq(
+J-v o^d}c kB6e_~fEc\3sMdP	HCY]3~Ie "oMIx?D't$_$%D^Qujc(^po	/vK-tvB^F<%&'4%M@@	FQ?Jb`UvJjKA[)$k#	KJm=YGs8uJ nh{)gE{izBY44kve`KX[0Pm`;DREf^A{L> e/#A?)	JDz3\<mOnAVXjxHv{.laHwK-!f1\{LNx{iY%*k3w7vEY
+]i+>;HmeZDxcF!A=
+5ZlHF dh91n6\7^V[N&n6 gCW'^jV>QQW$Q_o'oA3t9X~;DL(t2Tj@e	o<K#x4Q:$^J:D[B}C@f	".P3T!hfj)p)	{ekx=a"	$'H&mLV
+BD|FC,d.ZJ	)Yt)e0V>JSvg<CPozmfn$&Q~Ayc3pU4sh~v|*qE?!Bz3JS$$H&`e9udOJRH<AY&QsFph0"
+nq_5KAwFiTWlqM<7 |r "zK12! qzq ||:t46otc 4aL^j_:a15'0RABIwNfv,n65BBx\de)H$)UZ+m4E=zh@JkaV$H|EJ|Y]s6\b5/[T]s (<::-I*rSFFnQGhR[Z9%v|ImkA;jM%T
+so
+(-);#B d@CSA"w2 -t-V<Ok Og2/6'k^bo5]THG|FL&1PsO5hkJO I{CXF6FZ{1,)%c9' fDt@e	x`#_4<a| 3u0-vTq)zU3o@}gU')c/j?"oV@`rNxG(E@Dwg3rk
+zG"Z+"nl,1Pu$Rq "`SJtpvn	lI\LoH	zY4q]~\ c0Xj}[YH`pu,Cl1kbZ+F"Z	I\bwN	\I*RJ|V:mwxlIe$a3B{ (8S|\NAre,[@$<)@YssJ:J5~VC5VP]G'[\E<5=HQTVZpTGR*nGQ[24<d@b2!
+IRdO@`0@pi*!f 2D<m}lmga8Vb_WFST%/kkH$3nXOzgcq'z'gz<^T X6a4w#PdO!Ql?7p8} xi"r%1D9:~C"<B>Rgb22
+1NMhqtA"g]qwAnw77&zjvyY\kmc?Q!MXLbCZ]Zx`;_'3#SG]e<CfpR|UE( 3;<jTSCd*0[a5}W1\"(kjvQ,L@[B,xLE,T:Xc,K1j|S!? )Ma7etE9"C:jT[b?-:,@jo~7^v]\mxH7~8]6e :[wN>10f- #"+p3t&EIDoU9BKC=_n/}tU|0I@%!$@.@JN,
+J[9EU/pYx;Zg
+42N{ ~VlF7w'BP"Pou,iYY-&yq#sWuCj|bv]~aKV=Wl?
+pz>E`Z)f>w?<N|b8O226*kA<zHpv;/_/\m4uPJw$fs}T.;wfqR\{S#Y8RE<2^k;q(PW :!t2s@?luHiB:r y(1_x`+Y|DO#McXb@4}9.t1r NPSfT"$08:pvH0J0Z9cUcLM`%M;8)uzw+4g[b/N		0:#CkZxWvI-ih48mS L$0>_fjUE)w]q{3_*/p6N
+O8EUFD
+\k0dh_e[>ND|=7W#b]geN y%\-Bo_e(.{bWN#'Aa '[g9X>T9k7Gz@[`ZVJ3L-zej	\Ap/TAMfPvhGl5,sc<f X},CkJgGW &e0{:oY?oP?_w;_^^_"<ZHppp^0@2./W|{ECBUVoZDp+Uh+`v~@&D0S5kY{vq<*V@tR,\sYJ8llQ,E?E`P;&MphnRBf_	X)V,P{41
+A$-".@ymW@.|EpN gd j|FDkxkR8VG,Dp{U\h(%TW*2IL*0D$ahfOK{ZIt],H )a{DAC 8h=&@E"n|D[jBoQshO{R_/Y8j~'3-cOFe-e
+N<2spIM#j~@41IE!V\Mms:o7##[T'",|;OOr_$iv"c3?<HC$(1as^vHY.KPmcnop8t5A2	1+9'qFSKTd]y?s"	j1lfH*kHhhI{g?(@AP@-z11NJf2Lu"`/ww,Hx}qCz$;;r%8J(	
+qOrKD=R;Lu9g4*yD=*%\_^oDk	5is&k\1<!,.Bs
+Cj,!3E6s-0 A<vyyL/z)
+/KG3$ Ld5=;bH*<#E3d.+]Id9IZ]2|xVA!9,$((F(--"M]L`YAFT**no!y*k0m!%-a\3"(\2":?#`Uzv[A-(pmt{nAFiSAG3Gx{n=/9%  E0yG$w_x]Gv( P?eEG/j dN%ZjsZJ>OH Joc~~se>	
+.0{:JhDx,tJO]Z (xD>&W>7[MG1B4'HN>.(pqZ)>`UCq:R n`Tl0k4ihL=Xq2AYfEU ;WvO?7HjoC,~#@^^OZ3j+3._P%TRZ-Rfcp9PjAx~*Yp	~Fw]-djZpUS%Z:|'#^41nFCGXTj,x 3
+Gb
+$t,r`)$WGC( a vp8_@y/HwAd/] +)<&~:+wpJSS:K--!^%qKYFN7Q{ r?\ _ NaO	9'4x?gP+%4^vmL<#;VZ|,& Uhm8:hiUpkYa
+JYq~8Vk	jR||$ |
+8 $u2kwo.l:C{|O&: 4ovh;m*z0HfM@l\HD$s
+=f%eJ3up;y$HH)/~$&\T4Yi#mN0X&5>js6_l"+
+j$`Iq,([0##I. CW^H-"d4W$P~ww7\lV+
+rPj~6 ~ops5Cm6agTl$myLl+@\q8jQE	?+?
+3cw-)f ueY.NZHa"&tOH5w{BkNKcQsrdA_5~vd@I"M2:2{qp)NXf>O&?|aCl
+#OkvW,o8ws`$&I` 8;#H&-q ~B8G"Y Vc=Bu6:2OJ-hUrrGhAEU3Fe"FF-m8^q=$^'/`0/-:nfP WHbvx;^qWGP/A+	b5C |vunhC&]A}an<
+mNmgpuggoB1k}-2HSRotq`lh8H.K>#(03z	Lj'!0$NU>x+;
+h kR@##ImT-'\Ep_}\\X3Go 	gd\__ R//.Y m8mR~#wPs#h'qBmm/+.8PK_}O1M^o{Cvusg/`59|\#%,By1xz75bw\gw1S,I5V^/ 86!I/f)7Z"rpdAJ@NhC~dtAV5Fb6E04l;J#zm0~s$m[NH[%6P;}xi5 `Qf* hphB)BMR@Yq*G`5")\		Uh{Uy'd3d.Rgn5<U]p|o_^'fLw11NH<T`"OK}:X4|vz"![ P
+P#Mu6#/fka-6IfNf_'WU :ilpU,p>zEAr_]Lbc':<j|aU3 ;CB 	j(ZR|)mlws|&	*n:*~'\qM9_pu6?;O_
+RD	)}~y_G_6@$y  F8L,k@vj0m
+L5<GUbqrea]H9OqNuu	'
+nbOp(5Ev|_"nJr8{;X3G`XhY&;cG02ei_:`u4@RIj"P$=c/9*b/%#-ov__$.S%b&F4G AzD*@6^p3#Yk"Y.`twOpRq)BL i^]BSREm|xmn#h7_{r't=cETd	lcLPX'gv|$]
+>CE0(a1c8)f`PG@ux:!Uh$n9\8w +wMrxz5clO#]wXb-; )^B#wMRPNQw"[ #V}ohG-Goh( /_mn>}h~ +~e H(gP6[q^1lurU-|RGc\+r1Qz"Cb@c2) 6?PA__^ 8(m>]cPtU0Oi}Q46d	L-]N-r%1Jid\/!h@cW$\.HRo.aKe7<(gF"AIu@MUu?eZNbdm.Mq;7TPFQ|;i}r)rs ) FO)G~0y'7NL@ie-\xo/+o)?tc= /#Ccgx'uewu^(>$.i/]!WSL\K}RI1_v7l]H.6`AnK#k&#/ >( 00==Dvf]EtnsEm0~6R\EZEm&;
+%B=
+J6B1mhv%3vly< /0`p_:$3o{#{W"'f^Qi	9>X\3xd{,Dp|Pc<%LI{^J`x'R
+(/$|`XQ30>+!tK044X5yS
+nV
+"gJl")nnE*.Wfd8Wk6mreu\/} o[DpC>X\k& 
+5@VipQ"'{yZF=>]sJ::;VT`"$9|@l@SB		z_.-cbXidwTk2 od#C[lLmj4E^Cy NM!IPUp=">;XvZ[fOhx {t8,I)|@KCG)1<L-hHG;v==B{h('*}b{[eV+J40n;Rwh(`fKraCs)dSkh<(' $pVe\_D|C"5ufdSvy85]R(2fOO/5:d &'k<bX$`>~9{._@yKOw4,>%{wX	"$.BkQeuOxb9n5m=K\|yt+6 Z_S,^6|ym8R)c^.x}g\/%e2cfFrGPsft;\Wmw[^1LJT_u;f<$>(I82;t]|_UUg	yB?lq4^6]"^,)m ~w>\1{'Xitvf[lxS]pt[)~:#Y(3
+f=2ObZ&6Xq=0M10Fpmt\RTS292 l^ynm
+}o#~lG2XWm~= =nGhP
+Qa1iu@\  /W%yG|7WQdM	ow$;[P"v)aYZt-08Bto`}Z_+~mc,5XPGB'/8M'zV#J^P_f'g>gNZz
+xHhSaoif_=~#jH9 Xx;nB+ EF4bKUx$%.{&qOy@fAE/H*T?8_	kp&lakrG.	{0=]"^Tg8b>/a7A*uamSAvZ8L3=0Y(
++IhirLf7C778/fY+9.`i3pj{B=^^.nvm4#u;:5RN{*4Fh8YhT^A7e4Q E?&[b@FLz -_,G+z7OB@eCE cA
+m%ryGw]'?3CydRR$iy`Kgv, (R8j@CJ@kN5C-VVpQ( B&8&98DJpIC,q'1"8w /5cAJc1UsV	D+	3q=%hm(jO9 }wc.@m|yv=<Z RgePz!8GQP)H_^hwyO	nb,X=_*!btATX];GR{V~Bb4m,6dI$#BZD+@+`G.[%zMxf\_2;aK=@?2w.F+B/Zt-lE,JM91VZq>6 TGrhp AH=B:4cB&QIg[1:z4&DlK[NHtF~#tVo
+"#:!@%lz(*\Cpwv 	_XnS
+n0$<&7UX[l=f?@na5*yMxUP ;5!pdo)E)0B/"~)3r<()1:qW@N~QI)AYDbWK^})JzgZYd'bOmKN-+c@!v YvoG\W~|\wL8G~\!c	ZQp*D!SY`lm\/f<ux>0*ccS>g</9KkAc52()asU:6*b"9"4^/h:NK!Yw5*;hZs( +NdB{v1^[sO{R5vATP0Gy%r\.;ccFH2=C`O~hK;JCK6%hGG&p!dr
+rA#CW{qj~95sn^mv	KbE$wGDji5U8'>"w|r.6Z"\6])nqlc6C52]"Fa!I
+u*=.//h/2q\,s>6 OC5>W'ou}Pm<:K ^Q:rmXtvQab?r`9<PE4=i4g`wEuVlK72KEZ! V!Vh4	w:NNStv[FDJP
+FO|gwfw(2P6W-KEa==i+C8[UNRVv3'#}P9Ck4mtV;nkF>MWICN5:0i]uXWA/@7SL@&O8Jtw\w z]{Im MGS25.UH!N*^Wza\/	_/	/ A6RHyL}rMB-u$GPaq8	6eF!;Ef	Z6^.Bay
+^cr\2;CUxa7yA
+Ew~d"lk [A%}*+[=;n3.~h-R\|V%#GM@/b6&":hDCDC@O3Yi;<tWtEgs[BLDUO\QvdxL@N%7X|.6We)V#6K#( (OSt
+Ayt6r'A.,tlh$:x
+j$Ayf#x'V"j)s1^A&D>mOBsb[tL1E(]/I9r.J@'V`c;5+> D.iU`IvB RuV[** RvE[0Xs#;=2	=u&2&LBDvE\D6Ay	pF/%+|'Q&S,)3$i`qGU
+cZ1pGO$S%g\/^n})?K<b3dvI]T13[#Nm!# OOG{NPq@JmoGdQ8
+JK|h[NQ)XO+)KAB=~*`q2yA`<{)FXSwotQd
+$g:ujurUBU89+)e[=po??|r/V"	5S($S)sR>|6VL5l9 vg=j&3k"m zBlwu4 xS_c`aasRr;!o-gl9y @q,i@zt-_*iz\*kEE41ZX<C6"fw2Mk!v gsg,7CF!BamiU+b]"ui:
+{&[VuM|HGoZ i~8q3Z0Gg1P{FQ )@mnCbjvA1ZAi$s`6 z ( b<7XtM[uZ%\=4^-%^3^.	nF)EA"fm=t=MG\P'B{kzDc1F,l" L@7;8c-	2%,yb$-
+H:%<aHD~9q.@F'@ltjOaIN)	t-Vc	0.$d$za	eo(Yl)v:YR	e|}C&,azK@XAsR<h X4;Eq^|`nILH"X'Qt%a+h]CImRwqihhp,WZ>:Cj d)"| c|0LLCcN< apx\aEQ
+UdZF'fLoXy1S*=@tP&g-;~D~IWhI=J61pe 02)R5]#SBBv2r0.N#fl0kI('-o>%	[@y2N]66Z"sxW^}/nx7X:sM$OLV'?&a#,w<@waHkbI,jfxND EDJ="*<ogNxZjXj.lk4~O|#937_H:~SL!N$C[V @6gZL]W
+[[x }`	1n+NXe~^-h?;$pq9seA-c 12H']"g=p^=:Ywt)~|$v?7pqs|omT22qab1UKy(g
+|rJ1U$j0>v;1![@':Vf@N;R&+ sTFmc9f'}M3jPiK(g$B^Uv%	xAF~%c!@Ea"~&b:BSXxx0F}l"n|qjuwj|9())1.[g\b! *i9wqk0qrx4#DPfBiBUX)$;n		9g,)`qH?7cG5n;N8De>@`xJqnl1*Z{(?:OyOeY19Kbh&&bBKCJewp6&=,kNov=y,iT0:|CG pw	C){ 2p.}h@LuaNDI'9B34#pH~Q5(JQ
+9%uoG{qX\=3khsDGp9w
+'_j[EL]\k$9c_PB:_<yX;>18($_:+M]`(,U?'@lhPQvtS<y/	N\/*;dL0bRzi[jW,	I;IJMbZ").
+#m!+o	|9S^$vwPIgT
+>&i,Y{BrD0IG]_Ge-B63c0c$SEfn{N>IP;=&cSyhM yfAj=	{P.p-m;^^ rtR*? ZfNYh'/~9Lp4:^wWm ](V:H2Ky[=,:F.M`(`y9o6~48:l
+Z"m4}yBF%	[$;] twTUQdvqF1A6z^nvq@!`}~((,VuWu@Ea<.-Qh
+nqj&sukHGbiTW5iE=3v4wdP|H-}AX$84"F3#;|	OX)lY>EhZ1q f0PCO/yvc#YC]@<>MebK24/PrLiNzYt|qn]N@zj4g<re{6 pVo@)	|s*Q`_/r&dZ,k!!:4<{tGkM(<)	rnr`c`yB=U`OO rdl-Hrg[s95;O8OZvwl[BR$HGB;VqQA8w5h3]`A GsN3g0;C"?8B	)9+I~)E/S@
+zS{: Yta68h		[x},:+s]~&(N<uL73.%dH~E/($hUq;*L[GGI4+HqW; !	mPI%b9>	^l7VeSAj\qb2H0;Y; "8'*$3z3&::.dxEh?K1}"Lb$J(sAn|Bp
+<o c?@'	!F)jbs04pk#EwEP*qP6!\`B~!I o]*b\t'FQ<c|m3[B-i?r}Q:Ei[|\]vhWu35<4l1"Sg:<'~6O\@"b`9\deg%#s,mH[cl}(4 ;00fxuJLhci0hz]lMZvk
+RPKAZcHGrH9|-*m(t<;3,"JY8I36d>i_<?4~!V]Dt*#h0.y0!BNizh?F0XrD3A>\R1uXt<SoT@H84sRrW "Mz=A8>7@(${pFvP`Fek461y=:,UJ`Nb3Ptq&0 y.8W?RT1>R|u >jPlaa]*@E.`eY=	W_. 1>r;"O
+U@`!@`2xe\DK*NO~kP7FA64}!)%BiKQiSE)HS'z/B$'nA$/u`.Zs
+)=C$r2&v?'LxO02h|_`1~N-";I 3' g[=PXcunNuc?D_TL!HP3ZH6\QZmV+@98'pqG7N=AU#tv$kY}'8>P+:[D\%~v>	#mKv6:s^}z(<dcVX!6|c^X;D;gz+zWuo4I0x|	YdRX3([C[#8gv%F-n=ED%oyy`%9^yq(92tb[F>S'XD-/J~fHfEjr:+%y
+%h(On#c rI	JE\A>&#mqxud$TL	a*$c=lAj
+@3q$4aj{k1iMY!|fX|8|^bX.'6Mb a)Y\[Y<:{l qQ DBrR*z4t
+] S6$Mq4E-%Q7OQ-q)g[F%;ItD@gYN7=wFd\kcXlL??h)4VzXM5eK3[kRJ7w\ .]n6qydYZUw#GFwv3J"G-OSv	rW2IZO=6t6+{b-%{)
+4]T"r%1qB(n0?Q-KJ":#*O&	e?kbTfluS`x}5,4>;yb6DM=GR`URhI3^;r.xpxSe
+_S+jj_-W9 N#4JphCU[q;p/jRU6uFYI=^X6x[Owh?CC"9.rWE=JmG#}z3cO+g?'Y"MUl0Sh9u&g#zV0b_mw
+ZcH3H3TihT -oPw|9|tMGMNC1Am"\+>3SFwAxDd{((?D=x\<BmU}5vH8QjwYI$4]ewkg`PkC3C=
+7+h@yV!Uk:H7U#E~]
+H9={ke|L^\7j.a*N^mMI2i@}Eag%5RI'}Xo|zjJbGZ!'YP1>$)"`&?PiORt]GX8j!&/p
+/~oTu#~MG_/C@kkz[z%)vA1_;F6jE{3~pzemFDg{_E~CpD-u$ ^tm@KaE!5>i$X[aVF+n!%iCjT-RQR>PvrX#&ikYbj;zN9cW&01PVS|7Q
+
+WV/ZXDR
+Gdyz%BOVvi(A\mvSx~K"?XkE&U %^
+AC2-oh"x'ywE{0Mb	g|zrVE zR{Pm%#d wP:zgF;_+ 1O	kg9bYVonPQt|ge1Y.K9L8zl"^4tTIKf=C)gp'WE=?wCD#.zV&a/-40uaZF9vY/KxNs}`~C_
+|"|
+23{C)5XH\rrbidP!xhS"f,r4`Sh8V`Ax6lB()W-$pJfb-zGKHG xo}&i s*K>K=pc~R&'8e?dw>O*m->dXZ19u7y`qBYZBv Z!!R%n
+]\4b}tl
+U0
+i6: 9VmK gO:8+B	;*f@ccD-{'ia#^G9r0VHz<b@=+?h1@wLf'N}GVwj(qpqBcbY%`\Zk(p=YS	T\1`7g/[@k6'F#s C=8W@c	uBHL5+hsp(VE)U)J3IYmzaA8sDn#-EaKp^ Vk1&'qvD:'Lf*.Djj,,
+JaO	$mMI 1Cr_,`^~ G'Qj}_GS'	<9)\6]P4~lFabJc
+["{Jo^Ml!N5W5)}HO}4w!96q~#.5To:.zq%qC#nt7\Q`"Skr?[p6Xp_z}EbE'b*nC)8pw Lv%|r`1f%ZVN^Zf|}>q=uAOR=|DG=e*S?<xAW6QcRDmjz'>awJ)T R\av# <	.^RMD;lYx%+*.Xc2Ct\&a3vKx^PZuMPSkumiL}Y3>?gvB  |Mld6_g)2rNJqo-f %`s6L4b~_\F)L8s1`14Sd `5WERE#1/WFli3~Lfg`@zu~Cd|?1m;eBtR?laB&rEDE4~>a5^A$BJ1s`/o(N`:3\+9BFR1U&sHNJhx-J^-h":s`%'mrzN:t$Et0xh-& 1gW| KS~ c}EOc/?s,.;XQy~OKZ&uw.oB={m|y<^tV9~on>XF_@u/x1<
+7Vrx`)N,&}6.Mx:|;!j?Ly.{s[|	LxxSIp2ZC)B! K])bgr	Z'xyZo9g7G'3vfPmh_cVT6@M|JPb/v 4sEr[S_bpc:F#*hB7#B<aqUSD/)rcq_63#g[EbPS7KUd&|;c~.t{u.[Q8F[Z/y7(ooSiMZ7,PW L#)o`8fcc
+B}O[[.q>?Q0,E]d{z=(vvD6'W/tK SFe8yTLT>aNz) U>PC>g{0<A}___\\/Z9F}S4T?D{z(Z5=[HUzAg$IOaSzpP-:_,^QAPy3D>"
+IOnS;/b.sai O7C|5!)PT(Abl8VU*p3.ys
+es nz^p>-i6]	unG<dnyvS`<?;OFvzIs->VjXKG)~'CQIOK%mOSo,!d3
+uo^p}jA?"8fa;95uXV's&Weo;wKJG\[r6:y3v+Vdh.Ev-:^zI:!bF~SthL=FC}8Y !uax(!'v@r&!P^u 0">PQ5,)hkV[
+M`).G}BiaFTaZf5o$0Wlk=8$XBa(:/#V9ci@"*| lY<X+ ~{2)""0j}>e54iQHZH. Om'_tM~^Y)@i	4nLs
+&Vv)URUE B7Zlt2^(Td6f?Z>Wrt>M s;s|b:H"1nr1=LRiutxJ$/V1n'F<+eH{sg0|B[9	8=_yhI+@n']*/juqvostd6
+nK?{-"%&`kE9fW%CJy/{`	Fucs]@wrAjedhU}l[V{a>0y9lZJ8PY?"VppDf'8ptFw3289J;*.DgG z0|x%&v:~QjqLD})K`K57.H4 uX_(H`nLvOf#n5sUR3C@-A
+'Tw mw?x%5gH2Ecpyz9>p|jC)ewXt4rjO^jc<S s!	>HhF5?	'\&ojStj=/Zq ~SicZT_gaSjc"YpBetVfS{t.GIy~:{M1/]-Paqz'h7@ZR$JV"0\%}5R}G|#hp-qY|.%(!-gD}_i!Q'rxY~@(zokzF:{ )$^x#pG4*<S"Id1Q_wtzW/ToEgkZ>\NgY'<Cxzd qB }?+P?F9hy4*F6ZJNx0#5AeNfZklH.ud^B5=Qj)5pbqg( |oGOE5tRx7[ctkn[+Bn|Pp9=sZ`
+Xur.wQ(A@>piGUkE[Xm{]Dvx
+USi4";{x]4<F@P#K x!IK\DBoZf8$P,jg&Dnmc'M*P5te'	N4\>lelJ{>8N4%hdg`j;w%^`w\~WQaVn/Y<VmGw(nGy
+t`r<.w:5cW@^ `a<HGN=s[k#EYdm|1HnK#Fpabe=vK.]l{xz)<k3^:gL{3Db4jmF[g.	=X~Z>I5db];M*)=,NC	d;9ua$1V^z_%8'q#swY#iruphJRi:iF4/^//tu"Ih64{8d1E 1E kzw!$vmC_j4Fgzqic
+h[W
+DnHOI1{aM4#G'0u>FL"JO^wV0	Vyr7[;	Hs{;J(#m1 ].7jM"hC>XxFDZp#HfpbmaQoQ[PY*V@W ?. BbS]d qsy4
+0zf	3}\
+i8nW:?}%KSU=	 IIIDj
+
+;L[
+;Bprp($4! 	@wWt33sVf}&:Nu{b=nVO)K`,E#%0MYM;uq[*eH$% Wn&&NFTHd< ,P:<XDHE2K0C5H!L92%$:2/fR%1GGqdMM>1J?_)C/QQL Xn9JV$~AU[E'uHaUD}9#K ye\A%I<xHK2+`h]&M,? #fhqf2rL	2RN?[TW)ZYl=X|?X2a|m^WtJU83 ARj`^pKQ'S/zb}K4g<Bh.*qG0{Iwtc\ :{87j&4P/ysPHD f4"C}&ZtK*e\<Y)dG9xj^CCh%@tSesWPn)%LW[\Ws=:SE-r]2e;.3S8
+C#&)Yp.>b.3sK\Es4!m]D!}0/=1yT
+[,Z?kQPXVZ@w/X5,HvhAF/4Y1n;Y8qL((w0v7,~hqw1w4zw*$_!EPvhZ*N|x88,JyE@AI^bku)A<4pZOODL.Ts]q$Ec9nIxDoBrV9$,<|99J,vnRoAM[m>%%3y>.F"Wnz&jr{gI{-iRkfiR<S">xUU]?P\`%28/z"-]nANYdyZ_rxCkKh=8LkcXa'I?#R,9ZfCyr)!r6T&u9`-#mVj;Ou,tUx2\mcbeg:L4q4at) K	%uqqJ6	:*9%#k/Cc"pd?Q0-Ny~Z4[ TB5
+ Zq5[DEip"uaD2LbS]:%Si-:gL&'T5#OKcj<'3i
+
+8Q	zg@=ub8whU_f	49/83EG@5t_;~>SFl\J<M9#y>*:y~v9VKmFRQ>2>6vr8-%~ZKYk1)BxQQ,DWU[*b>RI;~<>f/p>}JC:i`1\Z&nM?nrU/J[8PNlUq3$W='-$<#q`m{DLy6&n[fj8UI!0j!qYx:dqhHVec0VI$/gZPf){?2f?E'|]I)8wQgx>,DJ[G5o9B*2=f _zU )t)#Y
+]!,<+_;]LcEHq/w~/juka]f=F-B	1bWr|Kmz)}4P>`4EPfj{UIz l62%UORuS58h$u@8T97D2&(QDgEL{}Pc1)lY-3)vq8Cb1K?wz=8[y	PS"b83*{eX&{s	a)8>PVUsuzLXi9X"ET9|q`jxusyyu5rs<<h#*H&5$1[B^GM]Mq>#zpNVMjanY.k6S	C!%G};s1FbmXM'P::CR_~|(Q#w=*uFJ$2XU~"f}s4JwGoBh@JfUH8l&k2/$OvA9/A|bW<5b2uf*Zas zE	)!8'+\Qn*p$'k!!A)>8Qqq/ u8xa+-4u8s5b[nEm=0j0lbJv-[.vIw'Ka!b*\`y.wUY|)"iZ9UXTmlrfX`Y1rV2w|7;d{|X3d:-tZ&8<^@9b^f>g7|z uV6ypjS2ma!4*1m.lcyuyL8miBk<5g+`D9h#82JL	6Oey]I|L }YW%0oEx@@~S|sG},iEG%h%kb6\(Br^,;?_R9If 0%~^v7wYs! ~BShRNd _STVqyc977u%gA5S;POV<Ln#PO,K/.y?R2M(im<x	LA*e4/wN*t	)`4y
+p%8Oo]X{ oK}D<ewY0Y+ciB~^8(=O}bU&NB^I	&I9MQOiH=;q=rw>O>~Hhy<<[:s-NrVq)nHcF4j=yp1w0Ge\^nshZMqitk6]Ke\zg!&b"zd_KwGR1 2Hz.$hm(f!bu-_iQ ['Zh\whk)XweGq>x'vBQj9*Wa.]NIJ,hZGbY>+/e5ZgfGRi%h9cUqN:GA"5~C[%=Ca4!x|!HQ	(VWtjyA98 twfRLhrR$DJR
+''XrSLwSpJg5G@q.,@g^Y,]n:ht|p`^b1zk7_)es5{vT\j,?UR\w~8\sLM)2rU30!/5UG?z9[59?i8[+#7=_DZW/!i69*.Gt(h2H<iZe#]?r|u;^pqUd	r>n#~dzxVuj]#JeeoB
+ij8MSTeLJ.[( XjiOZm=LTG.E(BI-CjDg;.1;sNppggXYuww&xIli(z6?dP`7HzH9!TuUfz}N"Wonem fZV6'uE!9q,8XGYaNjJsUP{(/<$b20#n#h0s8xg94/@`:!sP5b\)9{=no)57:rO5OazPy^rY'JEs"{#[VB*xAN5 )diEM+%8/AS9OC$pYC@3+~_|x~[?c~g?kouF{fiQ&v'gXym8nN]j3~t1/c-6Ev	lo/xOoz^.t\	'<:&optMRXiP^sE'`
+lQ/gJL_<i7o.8sx4!
+)b+vS3iA 485-/EAz^>go	`%mY$WM4(IRs !k::	x|y.?K'Q)!:=~7Z<@sBX4 _|B?Dhr1e
+5<2-\j4!x494IcO{P!@{vlw<9Ww+0bAyTGSe=@QvZ"E|ug6wQB33ZtAw"b)<k%%0Sq+ vV1.L*8m:<]JR"e#Lt:Hs!@wGd.k'g6G/~o36=m{J6lNgu6uEy8Qb]	-HQ3#J#W7^>1:zf|dvgv<|w[oNO=77;6mZBpH[ceXc]F|WCPRTnF+kdRY1I@]|PE,M
+y:`u9+XZa& 	]l8XDG{g ,B#*0vEe~,G+`{|gSJS,<..OI{J= [:kYoqG\ok.bxo=cT4\_+/| \r2]U]N/a$T%3/)ZmVN#KBR-I`aE\f6X])DGiRzZt0_t"T{
+FS<eU%hOux]_*59l6Ii#"d!mu0]C;9-I"spj39qGH}odIQ	!n;GW?f
+6pqq*pLk1k&>]
+cUzXI(J?cY9YiqlNV>{y'xpGX@7u)K_: ~kP'P<S+EqK2z]C"LJ0p%j.[b{$)\3NK^;_Ib}iraeUWw}<5=H
+Y6UUEO+1(L@JV?wM^q]}bv\2g{}vnsuu'2wHLc@:g8]tzU54p^dJ)e4&UqomX2^^6''4M50]$PI)D&WwRy-P.TB^fx|'z@+``8T&5,"rw@Q
+dGw-U:_k'KaE0g/^?WJ|&ipLc	
+w^'
+>
+w?~3yx7<p<{q>$JKh:?_1'4Gr|f,&SV^A!^]CMi>5g!j[O9+~>?|'mx#x3VA&0fvDR`Z}8p%c*E |1gYDZS E)ngi]$&oLRu)ES, 6~W+t;R@D'j	snM=:ON&}_YU8Sit
+GCFU65o+NiM8r+IF^{|2?OJv|{CBCLS>|7h8H:j7sF8HE#%K^0`#LREs"6%Hqn 	tVU-(fG}s./x9%b4T&Z	Zt3&D(6BQkUKq<>G?SfTk*.JsdP!k]Lc)!2a){Kp(,E=a	0rlS>_7_c>~v4	o>}i	4)z!x(Q] 5nIq6A17
+;d4L8F;RvGtE'_^=77bzQ	|3^& ?5b\&R+I[+*hTr/4\r>,~>gB@lqqZtQ\!dWx,N"w^kq3SkwPRe6CMe82d(d@NeS>{|sr([6'BhhV-}|_}>w|JCKLCDIJ[$-*Sa`(XqY64t!fbRaOJ!M	U{9==O=C	R$S'Bp8RVs$F
+lvX!4SY%G_}Z]/y1n=3 x;.fR$7,gleSJ#~^ArM\*sAVdr,i L8zdF2F.yC$}$,wDpK"%dIOee/G&|6 rOdFqOe`}..H=\ns{g/x|!mvD@L/f%{I!eBQ
+fN[%`$;cOZLheS
+;hf$p lO6i*{3o"dE!=uzsOTnxaWaeT!QP5URm'?GK`''0pNWEO8^5M;NO8{GWdFl	8c)>e HHY.4-!^w|5A!y)iC>%0\\3js\Jb4yvZo;|z"MUC-PIUQ lT ywE/0T7_!BLcsw+URV"Q}HZEixd5kNS{#?'7>?o|mVM$[n#2+V$"66MRaOQ2b g4BT5>J-5KqY#m-,K-Kovc]T99{WW|O~>o|~wN9@4OaJz	VtycY{g!6}q(251h"R .2fAp&+4ONv^"|&wBdIS0SHY`JQi]2k7@ =T$QQ9*&W.l$\
+$Ym 
+G1R&GUo9|k7cm.+nxoHt%pt|_\=>yh<h8,_zI:2#v}J?}bts7og
+Hle@mcuLXl=tx-Q[7+^M>	}IV7*zSOVBe|=p3fO{K.S BL3YIe=ASIUzR[
+"hk,Otz'd')a~J'#x?_%.xc;jXR.i"c;9b2phYuoM$[tAWBQI\*t1KBMqun<~g~w!O_7xK=./?3QY
+&IJqY9<;b4=)Ms<Y'Q_rp	 w3Kum2e
+[Of1j}$$;\_,<f\@K+|2B(SY|x(\eDFFe`?DG'yx):m  u,=_v7VC' "bYJOWAe.	`H.5.w#xxB]s|B;{hvQ	t50myp~AZ2$dL31]'HK4%crK@^dw$Y429(jAqBc w+u\~c6j=&E;:)mQ%MU*]We@	f;J2$xL7 m|v5osrGl%oo~pC'1VJbUPb-"VBRiTw/1*}4K[#1g:64%^8e_jNJ
+qm]#1EKPN:[7y.o=~'GC>+K_oqz\YW	bvlwDlgW^Ji.k#=3DN\XV>OgI.s TvkHqVdsYy/&q)9Wcss9U.sZR#W:!thz#Zox,,0,=7NR#J%$W#cV	.iWg\>wlN9;{9r9'o!+;=&:~DdodT*-;BNKHq21haCKV#rf3f#F|~O ul6\< on?pys'o>b#9e,9C;4DhCyQdK0ryO>zm1kT`{`H-,Al1UTX}:["nY)jRPW9-ZS.*jBj2WPQRRE?{Rxw{Ks"d9E$:okdjd)NXEZy znw\on#n_4haiXbk4<NujMbFUD;Sw-B`8	L`=c}b$Dq`ix<~wzo|O?C;2ox)6:6P3yzQHUJll%KS@KVDi|gQcD"=MkqAmho]+Y0^JsF%D(S?g(_wB*kS]qtP8L"eSlJyiT_q,6fmTmE3?(LOqA2u]n@29:vW<wd1$ Og_d{x/.qdf>OMcP
+.=A]C%`(<A"!2^`R<mqs=xWr}'rvrvGt6d1nZk@|}W<yo<amdk'<bd?rx@+yZ}@.NCfi4LZZTl&]tkLJT4+Nne+G<)xL4'H$szH%LM#k``B.37|3n_W42c]7##wt;K#GCyhdeR)5$RQ,k&G*.aZb">k[G<qR^eG2W
+A{Gk>zGOy?[>}WK?4pJ"EiL~q$x;2)B>k8KT5`g^#2qBO{		iyX=<c0ez9;O4f%2~x|z;)5OSib&z%5b0G<F%^{/|Fi8/xy7y"Q-OD|`a ;d}zvNxm	LYNqh8r-6b4h>$RO710_l	nuJG
+ B1H>>l6^]^27|Gg$sDMXG|cD1F+k dFQo_3}ce03
+)0]`r?peb[k*==( rFG/794
+*/Zj	/!h=~)3OxS@X:fCf7drb@!Mcv	[W,X-=T9Qh2ti?3[ DHc6fT}b[il2Vd;aD(K?5NV|G|#~[__w_&~O'#F,OL=)F^mrT4L\6@FsY'*8PM&]J'l{mg'Jp>X\@xTc}Y]WD	r2xq0:$e%QWPcauJy.
+X#`1v!<:'?O!Ks=b&iHlHtcB7@G6PfvJE
+2gaH:iUFN<QHHtv;&4~dmZO8gryuMh`D3q)'g7>8N'O;3~$%a"MHp CJQFB}?y	e972mcJ x ;.:[t*!?%	*6@szKQYWo 10xUW)D<5k\sBy]<bN+O FaO>f>8k+fFOS4n.^RXPwq]`41%hcumBR2S(2\aHV]E,BZ#S)o\\~+|G?z><Yq.)2E`m%h2/t`T)IbbCOC9%nno!-qtaEB1!$-Sxkj:UkN#~ZSFxI'2;Osp$ x1_{;t'-:pMyHVi6!)GdkTAcmR0`0LO3hIQc&zAixKW[Ly7llmV Cnn{N|<#.1~9]hd;v~`9#gs'4MSv6'q4MAYN- `r9u)FSDcc{9gVL,dPm,xd;@Ws0;gakE8Ehpr44IsI~  v)vR G{j#iqrw)nJ.?q~B6jv.8NBCBB1cbB#+O;$a`'!ye1cf?"n?2G>xo=~	?'/~7t/OB}Ej\9gbI|zpW!ibM\An$=ugT?=@sKdI(d
+7	q`.?>OLg2yDJy%ip0l'4N!frf2<
+CBi`"5 cD;ZfQ#T aM'1/c,Z	T7(`gonzqp$i%3~@<n{/so~#.3N\0<{NDmP,[;4.Hpv;59ga(Xa6Mh\.q4
+x_:.v5~'ehV ^UF*Yet@j "502W!;e4>s[
+5Jm'eN']qsf0Ib6+\vh&[r8/Q)?9\xrO=>u!#ABWFN'0Jf3@G[il6-*vQM&,gTC	jGb?s{7/?=^\]vcE0AE`NJ\a?+NNq5Nx~>$SvLB-a%67G}u~Sq8 VITZ%#u	GAPP3k#|9n:1#89rlFHb"2WRMet[g^QWER -:M p<c$kmJl ^I )4iCBERqQqi4"4f/_A5'4n&0]c*|~3>{|p@5lNGg^s0#1%amqD=c)~Fld,^#5T dqP/sYi>g+zx~3.:;1(+IV`Dm.$H!Q/+ddypxtN#{^\r7hAhf h3{cFK"#.J1[/&XJ8021xJDbd	-n[<A~?Z6Ga`QP9P!3Ap[9Uos=d_g`9)J
+NZ9fk(J!hh`w~6X[E{?QVM2=3&tME5[1GEqL*V[$v
+/FU jsXNV 5A- oX6O3t_8s441M)bXytY4/_|!CNAS|xd8^vs~[2|%B(B`
+1{IBdIk0V7n92&]&.%)+h:vd0xi[oAuhs6o[	ls-aOX=7W~i:PVlI)zfI)[Fx+	:;e8!5\B]GoSX\T}B=.jWMx,DQx!4DR!&%G1N#ypg7=c.w^^sue&mZ3W Jg g\=6VKXRJ&XPjZZ\fHJHm=9C}}O	>bg{n3"bT^O{s(q "E3N:oQ#?"0*|ioso`_on.FV9{m-s
+hj9Tes"9B BSxe5u
+XRV^JhBHNr
+O5eN35K6uDi0]Au >=&/Ek.x{[;4%x_QN6JET?OA-$4)/K`Gm7X,y4DePtoUqibB$IhM D6cH1fH#8M;=-'4NO%fwO`M-]kVh]C2a)r)su}.9 ^BM#UB)
+xSx:)uVfY(u|!ex_w:H6yeq0c5w;8
+"LX}[r 4E[">$KGJD.dz{$7#>ZYlC6 lpV9'S.8L)!	|D{oG%khG.N7q&&%s g\vwEd\X	{FQ<=i[{@'ooo#OW8sPPfqW{ &iT/"M,Y+.ifl	!L.U#2 }[3]-A++-}ZGkMq2k2veDrl*w|N/rWY'S,2t!U%Z&/] j3{T(=dS8d$A%TX:L{_^&bHSK)I)e<ma?T?\y("j`R+VS8IxWU :e,5$bYsnoE:4M
+8;vz./x\^Vc4wC?)"6[Fbg{Q2=Tpte]HSuv^-|7XG`RD5[\wQ"P<h,]btsBkAD.NW=8pVvQY(7"MHNqicIk{-+@l{>z~NAueW4lF<1=1MJBViIr8qDed9]osUN6/~-o|w/?~S0RXN'VxQ|(h/-)4WUC
+4UQn`*P^s{17>Xr`4<RT>kt/
+gZNR0e.-"'Be1_k*nhi^R%bh,cdR 2v0_4Fi(WnrWL5,F9RIGB8"C`#8)lvWcEu"6f>rlj57+r6*4c:1Uv94M;\L>QcDs4lX4%RJ|Y;W wop|8OYW
+iLs.^(z?B	#H x_E6Jw /4c.6O<)g)2DGT(1GRp94F\I-	64~7Z48l9)wmIqG/Q{{Vo==`?Wc")[BvE{Qno"k1R(B;o+G<<lIM\;} l\	1R(d"Z'sEIXjmumS DBml*y~nUut`M^K!E#y"-tPCe<&NC.!zX;1tlpTX]aB!!6@uoyKxEc
+uDR*xW`uNm4%@
+Er*s)\+4&rShP=)4lCainOt 
+=F"B:gC\0>$pir1fJ;a8JZ.z{u9L:26a3P/Ci~wMcFB(EWh82,m1&M|@(k.By`L#*Bei3i3\a.gEpvwOyim?B`3:yt-lV`D_43C7+JyR60G}a~`^O537_9v~}7N+/q
+BQes$(WX.mgS"HUvM{yor',_1e-Bj(Wm'g[X n|&&)!3L*]uNJVs"8-NR/4cMYYE?.+&mf6/DF""Sp9B]:.
+jRWBKbZPWv^Jn'
+T)hB!(q"*rqXxPa+,)V+6Tial4&M@j7f~#N:+>4f~
+LwGR,.j/9qLD}	!x(+rGm~S%7!1hn4"d8&^\|vFgB|ViY_7n5H#'9`yja}*m=dU.h6vnf#gH?
+1EFPd|0Q*.bM~8!^Q~Dnn2Cw>r<4ooIkoz'/`%uvH	r(m08VQV5wRneNqL)}b$LBY4n.Mr>K f),S|(pGB@|8`>pS"':|}NG%),l}9<1E#Ea'pFs	sJ\pOR-\"".X5zDXzwMdB!$:,fiJU06ZVbo
+!aD._/IM-4>a})lhW7\bADp'/:/bC-L-w.w@Q$wWytw5|Lww?YJ;Kt
+h[v'7\8hJtN=D^*<rGRL#6kz!2 G>=nbY2I	R/E7hKTC"FPqDN(/w\m#mr-E[#EW6E{#iNiCbH#/D!~?lbk-dq;r,aAYu-&\H6!>\yxo;~w+~-.9HY
+9{*)P/ZZzuu/uj!/4R7+qm6'+6u9+6~#SPY9-&4+\|;z_-Gi#d9r3@!zj)3*c}1(i'`$@	b@=d?@lP	+b?:+$[h98#ikHbuq`i$_x0;1t%cI'$Et5!Rf]K%a}[VfSzs$]O?D,J34DJY.59*Yq- r:X`C4;}IP+-;GR9Z/rW:utLh@ZC^m/GkMpD>fi|{8YyN6Ld8MK0cy8Zj)O!AiIw{bsf#<>;a5|zu	~nD%Oq{k3up#&x
+R2V%%6*+Xn<M|hHGRRvM39//r$<p(ONV/m5l|u_q1Na\F~/5@LNal-_<t^N8Z#[J9!0aoS_2C!w6XVnNL@:J:]Zr~w-gSWk'<jiV5S)uMH\e/.S@nS{*NWLn_X~I*0glFd,t"a6p(LK*?RENB}`Vf'$H^y G 8o#](;]D}9Hf	MC=IC`(IVMzfKS!Q*;R37E&*&d)CE_7nh" Y A,R.]A)y\WyU$.{`)"\(&?M:>fJ	ZT<]xY	*rjT.LY8VEB#N7MgA$IdUnj;Itu	h6ccbBXHZ::tM#dxvkeF,3Eeg*I#gq`['FaO\]m	|hWk5OoE$<^:?2="swj,BTt\TV7-@G>;NxN6SzQu%C	lpgV>tV`rg`TQ4i!YrHC$BhS9 Jm=Uk3U6 /nqTh+kh41"\QkdeLxeM+*d."bQN;l?F(qr38iQ{"dM T]U%xi4~mVPju0	4fbX4Bq90/^w*/AO^}Q+
+x*(`?g:YZw3xoBA2q_Gx%"h!eZg~T->"-"#'#]Zq$ry;>h}i,pW^cfWYvG#ggg!FD?63|H1G`[NWkq'uLh{l~G74mC_h.fi_9y/~///;|M~p/_L' n2,	" A/H"hx2,'ByGZ7
+	SViM< !f9C.;gW2@#zWM>+cWDUJqE4Ae=j	JsY8% y_)Buw<WXTY?OqNa`8Ewyg,t1quTmgp>+~`\ng/uj65c8K.xnC
+HN4K ~e{}<wt@
+:M4cZP#$`UnhKz:O3*6"%oT:}Si`a0Ilc.cd\p{.^N@>
+)l7Qs=%f[zhh&v]~kaOm||CFH{`Izb9ul:N7+#~@\CVlz8lIJ2IMz-"l193Nz:@ogv9f7OO	]y53!GoGt$&4=SNgad2dY\y!esXbMo;cC8/:jAKSY;>mm0Y[L\)	>yYO\Zar"|J$LB$
+59bmZ??^i,Q8uY$ZG8L[eT3O.o1%rZv:r.wr\0G9f.*t 
+eJ
+\hd-:1^]	g;;5+J(-BI*$bjyBRuFuB`KZysL@w0^	yB`TaFKY	8Dhm>+-.&nw{%f>Y.Z:2D+i;TOCh4sHyRInv;py'97#Gcsl\C;aMzM<m:mwfa6OVk|M=MO2CO8\a_NJfsrJ"9&{+7$S2]sN+7g)+gF/gjV"=s&03f5R87^ec@,`sNJr	^W9<+\	 Fn8!(&:wB"	O+}OCj;&&>LiqUWg{L'L/(9 (kY<Fv}rHZuC)pf(hEh|R2H\\9hiLeM-+z/t7sdiB6gk<v\\14\,^:=*k~p\U&Od'$@84M3]FExT}JD>E	/VP]hHm[=i*.sj.ED~U^t6<:oypY#Yxqmd[a(	9;=9uC7#FR{uf%Yq|.D" e
+PQy
+gibWI"!6Wd6%wox6h,>_X!*VmRic`{]*H|"pUsXZ{&{72\0|> IP+xX%Ui]d{>6\K3W-yJg`J4	el	@mVw/&K&F'0WQ.]l9DP X]*Pl3)9G@<xZ<g'*Gi@9x0IRD	EzPce` WNkyP#*zgd6(va>,<:sU8R(D`(imGVO8*q\ Pd:tO!=lyF<q=|~3AUYwv4z^\=%n`W:ma`oy9ZzYqy	''5i%crt!;tl!!%!vXeBcImM`{pG`/^Vty|_og2dlfp-AN;W>Zx>&
+`a2J{N	@$LCR"4A~&IyJ,~PbjjhzgTm6s87:u"ros^xd&2Q3Jkx`ij/rtRf>^v zi\KGYDJ:\uE]|tx}!4	H&Nkw*E c8g68Gb,UfI;*zF#T8sS"h?]x*2w/FUh[D*1)2$EMxrXzdm5NRNO89%}|I?zCk<yr~&g")6'w	W/~kXw||
+\'sv	n]W;>y?{'-~@Sh`+^|gyp~[5YCJxna`i:)n\0&)>xBnHcdZ0O{W[bW 39tpHU T-LK13K7 }rd\V)'8NWDZLE)Bt@H}1i]^<Ze	<
+4kOBa&$~^<O2e'LGi
+Dk!v;w$q 6:<~+Kc}G&K[i)tFAt8	./WL9YH,~15}+2z):a1,vHE?(r^N\V9/NVT		Rm$VQxv#0Mz[D%Hx-d;8{2DPRH YbZ$JL9:3q2qtc%'&0%2FGy)>
+D^'>lm,'4{N@"5<-os>}~|={@/WF}[.n^	)RZLWxD8Q$@Lcsh!EPVH#78[Wk<~AL4ZqlR*,_ULqzE xi|P
+qZr\ )6-S[;SdS
+(`;8uo~ff4=yG*v$CHJ@VB%r/tcNy6}K`Ogbmb
+P*#_#2,#C/K{}%z7V32Az^&N3[7fOqav\klZqzLf_m/V-8)Rd=-@lv<vsGxw-c.ViFq RHWsB6qd/	bv@>0">5IK{>~=m<yzO6<}Y:r5	^yINHZ~t3	1e>Wz 8xb=}{O6\D	o<:7G'|>{~}BVDG!qNzbN(~OmCO{&Fv$Z\{W:iibjB9]rrq9|t^3~{)t/(r
+PbuZ&ON4L3Ng}U*Yfh}-Jplov'4YV sdW
+FpYs4>SL+:V@.~J;B<#I'OM64N]&iQ:)	G~jcX9\3w#l4cV7?"p:#U# fXOgI3-h|yEe`]G*2M	|M(xPdipC@B`o0B0
+.%*FeN=AAv@#.j5s}o5u1;Ep&$7<8X
+H	!x?!YW'H"2q({)s_crF$dlskiEB-w/6x^E~t'G!F#kosqXD	go%DD;cJn._gZ`!:236%Es&tiB_n~m=]0[>~{p	/s~Gg':O1\~E;XsH{38AErs4Dh]}Vm1<s}I9kKj+9*U(6]5p_bCk/6IQW86{4QA&h\tL9:]ZJ6*S*q@Xw)	"sJX.DJJ_:K-x2iJ1	[MV5r>W@|1P'5}W4	R`)MYc	/72[mbd?eKa9G&#8O_WjSQS9r,2Y9#-^WA!l:pr~}f%%kVUxqvidvC&[[i nnw##t-m)(;F8:.Vg.{gJ=
+'Py#KD<qMO1%9!B"[Ev#b;esrB>GCd,c]rp~q|[~|BGhF~Pl|:7jP$Z-Q+s wJ
+#Q5MAj#:\<	T!k
+XI.};;8&gTG.TSWHbi-"y.g%h_nBW*N( Y*eU+i.o*8<1|]lfyKH
+br}RMjTdZt%\FF~vf\cdb"%i~$g^,S>uBR_RTO7|V?))Js.u"wFbdy'6H.q#b
+ZM<r&>iVQI9_df_|/$D^\ow#~jyI^UzxsKhB!i$~w+.voVM+oI9i/GO\m{-)%b1
+Im6-]Y1}0Nir@tg24Cwm>Fv77l/7kb:>ezE8h-_~Y:`;CB\A&zhy&67W[]Y5f+S)y#2Ip\_p>[q,oRlvb{`R:3)[eZk Gq:ihf#<N!nUb3`z*a1rfp`vo_tr.TZfMP?O;cU#OkO,":gc4Ko	X4/.BS+"K%E@W7nx)!A[SrVQw:RM|CxEG0t 1}+_(tW&>L*s7bW;.sz{>ig-mxA[vk<98_~7
+qPoG{-<{ANVgw<q#MhM(oN:G(f?WX5&];	I7/Oy}=#:(Y#UTs,caG%8A{'Ijh:=!]`Tyeolxz{B>vFuSX_~,:	e.WsWRb\.rxJ^Vh=Ksc-+[<B'6g'[#72J&wm;$=D/sMO='3'L^NX3n~U\J;y0() </	Lg_
+.sgP22L&4Mur)ury6PE-.BJZgK	oTq@9^Q'SU1Oe
+tb)OWZ%aCq8ScI 2I)\J[o2QqdI$LTYWCVx]78/g{G#Y:cT!3mB#]%"W[~r@&u.BUvzir5]g7JC8o {^hOF4Ck*1zrSXx`WQH 5@eob	q=~%?h9EhW'H\liBH;\gF/y8TB Y1{W-o{>| d}3qk-cfk|<jVdaupb/wt4Ce'CkVyrKUs5Xs%m"oEIx"6BUS	/:wuK} p<	o]R60&bS)UYB@S)Jw;i.{jc},6j e*pa*b3OYy:*;0/JXvRJ?G`3g/^cXW:)RfY-RmhK>}>|'.w P1y}zv`LGN[NW-5jY9;9BNmyUE2!e~oN_
+A:|~KGq 4m'4D:OOqvom6A9\d;|mr9ZH
+Yhep%S
+eeRtuckd6b&\(+BT(!gJyOe7Agli)}5"t@gFg,rdDt:\RLB #\qe<J4cV;`Qzp!`?7
+P(U<z6_J\T-X1	-n:H% jg6fXoK[uT{!=tz8:|g:s3l2Rr/&3 rT9[N>4$e=evPw.<Ys
+7{aL}bLEN>GxISCrf+Ik;o#)tB 4g`c<N!Yy@=n4vqq$yr;U`ut8PJyhg@ap8&9e}o"ah2Gou~ORvw>fGV
+	g9C~y8V\'N1jx1rS0X6;	\C|G~kJu9SQ+Ay8dy<fFT$:0Vds5eI|K;kB'&{y	js6qQ~&-x9sJeu8=]
+:uEo2= Z\r&C/FEd?a*DY,b%g:0I fc
+AUJfN[ }o)?K|VvQ xO}L|$'}DbzIdS^NV	cX`q&NW4Z]u06P,r$qh;nX!'$tVi48Bs-+QwgW#)Ohq7O~]|ty}|9_ ~ohbO+'t]jh50L8i[{0q.]ZRpi\W=7)P"9FVqs5ak^V8q_XiujAP'I3y<M!Bhmj.-o=JzXF36*,8!-"^*ipL,z_se9z,~]qUE&fv6eulL/!] f)LVvG-Em/2"9t 
+pP;*]Gx u^b.
+>NA*v':yLaN1~,EeLk!lm	%Focu9f>|oe[~=+k}lK`C!N@z&})xEKp$e\dl&XZ*E2'*yg{!UNTM&U
+ZI1<L08?uZl-K~cfzEOx'hfhBby'cOO(a0ND9K&]g{4Tk>kWhI{$+CF5|	W;_:W7s\7?e}@P&>~[~_/Cni4@+-><I!hB0a76O#8xo u_qKfg5rvKS<4NrWS&:	rclIqt <!=G~6SGPa_G) nQd3<of'G_d6dK"y0PYQf,<#HD !hsV`)b1n0MK.@+q%0OiieAE^*	7$S~,R+8[C&GvxAbsu)g/4j@RW ),4\_:;)B1JLkUw?q_\IcL>cZp4U:!ILSm``9q'5X"42u"3=f$:fg#}?p~
+^Wv=m$lxpbVEnogq*ia+awSY5&1}Qc+77;.H"4&xr6'Gl#GaY[M-(
+60V>7}G>a"i[7o	il3~+gC~5M/	$gG<4Uv<zL<hYnf^#RsJTjNBIPpKa K9k	R'z))GRyr*8W{Jf7C"_K3$Za EdM][sm[k;b"GLatngWM	RMak2J]4}V7k8V|<Hc{}5=^!'ECsU)++R#mPQRVWv:G,Y@"ex&;.3b8hbbCq,;=w.%N-Nu=H\-r:1xHY6{Qb&o>9If%_NACc]~#fa?'<S~MUcv@/M*9b7t4N"Qn?dUN7	nF;tfj^=OvxnJ9kCj	m6-_^*";7~~J7uGWVoq<}~Es$&;GWRI@Zv[0pv~N>g^3=ggnc@
+g;*YW2C$wqX<-\iT=p3YdES(|~[>H%R%U 8Tubv 2 "m3kUk'^L,=ozJdN[2*QZRw:t}X	`AN8B*/ZoNn\I:rHPE?X^pZW40\8Y_/v^kxW!O2KH3UW
+%^eGA BPYY3F\=]<w,+prVaWUbV\UerE-'6jb]?-n^\wESqWEV9Z7;*@#5k/T3abqid0*Mwm>)iiB~zt^|#%&e.N/4'%)A=JW^_Tm.XJC;	8]&FZ'\%e0E&m[G=ko[~o3/=xp8/nGNL)z%8L4:2E1LJR<4MSwQOc<l@=ux&m4h#b]\])m)=485wYuFCksTgk/dk,zXU*[/l.t;,.U%\."K["k|_r|Z ?(ufMCF*y6vVb$*H*)$XJbrdvTeF]}?H9_twfbmft^=kT(ty]!-eiJx<K^(F)L
+V0o_~J<<<.@<YSvDwhrm9V\.ALYhRH
+3OePm0kx>@bf8BJR #)Cz4{7/
+,~~!Fin=_rs#||#o@-y<z94LSi4mZVx:h~y
+F6(dGOcd#	;5MsbrH>ObJ*2xV:
+Cpi^, "q(E-.*YlN<Vi9>zZkQYY 
+%eXzXZ"MmH<|'y.xMW2}8y $-"sTyMt[UJh3q-P\t"ks~AWxDuQV+UtjJ?|/#F\7h^/50uPn73\+'YCo&^>5HW,N35hzt 9J3jH{8&-FljSu`'))c.@Yl;.}Y`a7U	:li!%M+tMN0L~-[S6]s|:Mw|O<^F==!o:]Kt&;g$p<<y<i-SFmRfqm f|7;b3bLp*Z}h{L!&n"M/U~:N~JEVRGDEG
+dp!$/Q^j!^w/TVgY{ ]y)CO7gZ_0tuCp!3UpB[Z2}ULo\=-KYU^I9*1GR, amsyeNl)y8yX]y;<S9B@Jqj- KW_f|z|SUn[nq`q	cZ_AkX_;Z_z/ZYc]BOyfV[+Njt3K,BzpcL aJb&)Q	sqh8vzLO-uN8fh[O8%*m]!/,KJu	L4}A9v4+nZS-0
+{H2^	tCZ/44Pn[-=x6vep4}0MB9.hVo6]Wrk-=n^8e:9{T:|+>Ux&Ehmsw3*d1_MRe%-S`Z[9Nw6@XbS^}!j(k"T]wj.5m:<>!lK b^>.s/F('jR,[x<+g$!)-4d1YK!ILE-sxTS`Ejq R2pEF<RZ"h ~	jVz~P7#[hW2y~kAVe-3b=^<	G">Jo*0,l&.L^o:4CBm`GovP5V/eSQh5=!<31wW3eeY	L6VtLYD_Z-oO4xn'qm`3pU=0	liZG4!px<9Sbn'a>tp#7{W:vS";N#9GA`ni"NN)8<w]%~T<-5mv!W_W,3 gA3 \[_?U  i{QX<0DA|iJ%%L8)J5A,"?}>R#%"xKKjk*z2gE/)HE"00c99~#9g~od}	RAj&Bx3$=f|Z>b4H0ZT%5ns\]bor6VN~R>'lqZjs\AXBEWkRm5zc&9H 6At9Nb%gaR7@4qd=_8$4og7\Da	0%P%g+xC4)9(&+ =[]a:-M)Iz8fZN9~_-[noD	rp<v;G]xagnn&~;g/<#Ys-Mp1%f3QGVsj#n m<F]#RZgs_goi/ ,[GC^!*}xd3< )z1vCQ&>w2<G{Y+mU9{M8ev|V)(WVz8Xg'V>./9-I=Y;~mxK	FT3)sYE_XCs>)-(\WyQW0W'_)MAi~*uZa.~ql53l"Y[^p_JCW%ugf\[~~|
+JT=s[GDFy(]]2-$;>>moNvN"|G|h-D'8r*C"=lqx[t7E<#t%1j|Xf-RH%ow<T7-xeNA@n' }kO '||4M@	8l7-!8Z2`9RhyJh!9)=VqrR$G:2$p"8bz:{6s|^QJ8S/!({a.I5\u.v6s(s,@PUe O#X	P.v2
+JM#BM6M3AuU_,W_,mgJ 4=	#8Ois>*=2ha=vjtdMLSBB<GnYh&pN)+.%S5[El}~9{!f* rL)Mb!tpe\0}'ghW;-^)u:]OjCwL!NVH-<8n<*18q~q9	)F0N4av6
+@We(i'x9F!fY"ErS
+gu=M^%+1Yhn*9r?O#?o7vM;\3G1))7=m]#lC@..'itb|r:'$B/lRdp#q8JWt6L	.hKsA+FhDpr	
+WC_.?{lWYDg-'+WUAf	5k'(h	VO,NK;a^[.u].V,9h\Gq fR8s$+^Y,H9G7<C6]N*Ue+\Fk4x29	~1Grw)kS4O	Y2%QsUvsdU&C@*Wg?MR+eAkku 3(' Y"@x+b.Ktw'VZ2$J{Owj0ZYH\
+&}#L%3!f44gw?"!4)o2p<Gwlv4Fs *\#%eI1-#..ko
+Y<VDt7VLEG|}C{ft}O3bJ 1Oc9wx6n77&#9gl~g?{zx>!8E.k<7Jt>1U.:a v	u\u700l,zigf3XaupJC6*I?`RKRP"/Pt~~yk^WDJhz!{R]k8yC/o5<]2r M^$
+r+<+yH)
+Tj{
+ki`5_4E!9|C"ci
+9iF 6b2zJ|ZV$UNn)mjqKZU:c++jy>x~=Yg*9
+Xt\=jKOn PRY_ $]R*8k{1e;/{L=%$g)5T:SPbM0I>6usVS*DRf{d:GJ\n6j?1/	DmcVcq"m`	MGmz;i`qB\&&U	mE7)'oZT<4q3>[M;Aw!kl8E81]h!w]xUii2EbAI:M&Un<}n ^)'OmZIV	~ZZ%2. {U7\&Kb3~%zHW
+TYJ/sl
+zDa'8<9'JR!OUX(v Mf[5C]BE*Lgyv9-7P\ $N6>/b
+tj)6IdD$/7u`p>pV+p
+7?
+fT/I/5jk'_ke|:WAV7\0D2[z-P2UVBYPbYr-=\"|&xSq`m&df|pgECaADY3"yNVfBi,[/K~FDOGxDS1AF8d78#)a(Ou[H
+7'<&)1FO6t4&9l)MQ{kG/Bh=Yi31}QkH?IUrCz m)GN/p02:wu_dR+`w[l]7	Q+U^'F}.%AHZ5Wm7HChj]J 0#t`Mhiq:PV%.|-{/'+dQqi'{!YKO3#pb6%qFbJw	R}c@)sBI.1	IR>`d1"J |bUv:M\pU|tE0o{Y!)q/k,427Tj([T8^P@D':#!q&&&`S6.'RiI@{jZ^t!VKs,yyJW/:]49S2Y{o=M0~M'HROs$e+rtH$keMp G~53.'\u{l<X`?i+J tiI}"
+EONci$
+c) 8^9T=f>"2Vq{*(pp'Zi fFr17n'1<U^"'~JaUP`@Dbt2]U':ohBgg'bX6;OyF\D%?tO4'_|D^hA@dXb#'e,QJM+uJqSLz-l	\: J*bf@yhw/ZWx9v}t'LQCuCm/DSNXs<;.Rbi=Zp1F)Y*366)R&>8%; d7FbZhsel7 (L@rIid(h~p(~ygplGN}>i#	4&.dMdw]k'(Mzh4	Sv3SuVdN">4s6Ye	'L81&gt$M!L	R	h		wx?)]%o+\:4Z9Ygy8k$zDrE5Z%t[h6a, g+>_,.3AJ+fo9O`XWwNWp%I"+ }wR,_Q4N8u%"!B[?/4Mc&YHty,($hRr()
+);D=3bZjjT8M)3k<[<\2p.:+s~ *~J?8BP'5E,s]s+lN<F+03a 4%!B)jy dMNY	6ef*E'6dDlt/4MFI$x7qIv/d038Cp	2N&aU#013\F|l[:C
+ |}C2nyKs4)}+63O#bvLbrD6 6NLB'Zx'UBmKhJD{,FHb"unn Hqkzx'7rFkiKpJK6v%8jdW'zY}y8[lZ$>NxARJbP<KLT/ls%!+EnWdlHHP9)-p>3`mx	5%Ru8?H+ps{nt:0E<rDX+A	@4Hs cedlRiBE[mnNJ8w]o+dYxOrvK%])Xzj$51y.by~f_~(6K%&z",LHh)oVc	]JsyERRc{'T_&{h	mtg/<ncSU%1L^	9bSs6F5a,@KwnN^d?7KPJin(Cv=)U). edUoi|(%+pS]o:N~GMo-qL4LLh;M3O29yqB:D7L*z	8iZN>|9Gfkm|Ai/EE?`8h4Ng;2>\nJIQA{On	a*hH98\A\+sI}-V;\C.&t0	My&:J
+7QtLG !:mmD4W)Ew["%HXS/z
+AN[RxT.Qwm+[2R%.'QM
+l:7MBkQZ:8-"<F|(9#Z`3NXjjVx.)K.l\s".wAU<MG66\M<G:	.0qc$4-nGN#I8GBOqa/p:=~i418a#-0}#4smh Wg.^UjUJyzDP)YyvZ_q*[cFk8WUPLJ.h]oa n.RJXOE!AT)+N	"3f4pG|mQj?oN=8Uia#uMYefB6uq1L3pt|;~G?3o6-Nwo;qd6o6tm12&8}mqzGtqjM1xH7-yobo~~|p\&%&eTmMv`Z9apzh8DGiG[H=oJcIxa]l) b'(6j7-L.ikb9,/gHX{e}BFmW++Qv#:wl8Nf.5
+xy4wS"HEk$5e6*	AGLz \]%2]
+A''ta"R]4W8\wBl@)^EZJ%0rJ%.\'~%THL4rgD?!e&zGoy="9 .p>s8l33&ey:<D51lp4M;q21bY8hc*fTk?kek6_m3^*s7kl+x9?5o69U=K`pJ%ij!wr(.-Q-2U3q-"yKuQZ2P4M0MqH. Ni>X,Z\@M47ox@m:	OO/ku@!FGv1#r|v>rlK%{{J'oh
+-<F/46v+zk\"4r>H:BCLqb!37L$f"cZt m"UTb*
+&\=@^"IVLJ|wUY	b_'+K]eT_D~ O\yPdKj<cgDxKP
+a-4-O7Og!m%]	b9+_>d	uo/;%ewo+taD(Hvhc51N5F\Q+*<-daE=9{q""i:14eRjMwynro]CX
+qI l;~Mv;\pO*<4@Bj*15Uo,EuE6a*D*zgaiQ HE$+\{#XPe/kh"\mrw*E@L\^J
+m`Da#%\1\gU=vbHE9N9n[&8B+ng~8q9o4LSdw[2	MCdtMcRu2"}.!\lfpsdtq`nNW:/eBX9NdDa8 2wx2S/;)3jfeRcNH2@%yrlkMJTjo0\7NUhh0&vNh)nM1kwWWdW9[h(tG4r}&W0H	q6)o@OO>Lr<x<v,e0+OxQ]-fMA5\=#)-#^<~CBM7vzb!Zv$3mv>FmHn2cJ"}Odt>Ng?YDv.8ymC".57bQsi<4&|T70(y'\++A<V/,(W6y_NV%g{(DaM,\	OSd)d#l#B+^nF <dBB?'*]uH>QNe1%KkbbC
+,Lt{_}=_{96-vh<;,,F|	Mq*' eqov-haam!YI",4AnT#J|~xs{m\@Pr&s	ui8<M44.Sf.)N$8	C{a_.`#6",R\n_c (s]%sZbEQC-]y%WXe^^n:VH$h}
+^2TL 8	;&,TA3XYQwuZ["gs7CKz7/$px4ol[C=9/7a&C?'	G6|	Flrtt:x isx =)ZpnwMj6;\h{no{R>=<02N~{Cv-~c-d"Y]
+nSFYbb)YU*U+a2XfHbyM: X2H eXLP!h]+2Ii'[\{Pq5l\:iXi5~K$ByT[D+f*h#s@})pd2KXIY{s/Q?o1Y`$	@nv4MCH|zh[SDH4Fh7D^qhM$czO5l@|-Sb5b$&#9'BaqLKZ<CF)))1N5BljxS5jIy.GpXf,k7'sM.z]jM.B-kMrkTu3Ke&k*cEPPMV}!9ZC<r>ox42o=-{'lR"B}HWOq>H@'Gx--BG>|-1eoLYJt=t)|O+y|<w1'#!) v9OOgrbS$'	hkF#XhqZI][ly/}a>s,h^s
+VL	kQ_e\X"swR.n4Y@y2eB	Qq UUWA8)b$7fcT :+}TA0|YLaWBV,}\pg{24m-xsTrATi B9NBHVR<EqP0 x5P'KwKLq@;wHpf!K2o_Ia'4OL)qr'LQ&e?embl4h#m`u/9[t4MO.h:p%gWhZ) ++bq!bc/k[N	ck*][rGSH/S5IXcPsG(&4fe<2]Oi0hb>\qqz)pAT7?Of^
+:_y^+XVJv*;~Why,Q:cs~n#qKx\`|k@S@8:NCt8&rjjm	]os`Sw>R8me$f{q777y||,m}-JYa{a@}g=V{f.by!875Toe\Es`i^_e2t5+rzI1>,3*
+rB St<sL[I[B}0e9Sh	6Cc1*U@++ZlN+)y&Ih1)}SNtasz
+GMUgG}zC2t&H0!GDF lR0-]pm)?@'ME)F!4sEm[;mv4\Ql5kG7_#WGn~~W<~.7!e#q4`8pea2q3s37SMlF%zr'lh<x`P:*@_<sYTV	H3:L-'V(\ro@D2^*Ph>ap- hi!qm45r2;~9W.zJab\7[TP^/t_ <!_-\+E-_}rVi^"9& PqF7J+sT1`x`nO8<=1/h1&4mK?{>r88h|#%	=!4i;Xv0T
+&fd}n
+!n,,d7yn{
+j|p)f`i|$+"`zN{iryt\ YR~TRrxhe<=hwm_gm&tms@PSz:Z]-P{V!E;,.)2{pw [
+xJ{]C78^DasO%(m[6]t8+q%f;IT0gHK	Imgt8&/#.}3rm7mMkY74['Woz~o?_KeGR0{i0#i8n8l-0<e4D<);CTiL3>l=qB%U^Vp)<@Es|]T~X5uw	Wq8ryh<q)Qs:;e-\->QNBCGi`?-LV9.gDT9iJt1[,g``,j
+Mp6JacdPUyq8C\Cwu=Sd<@Ji"mord\NgkQp%f{.0;|h)s<lhSi][yOSZ;4D`r,3ai/ge{es.Lk~$NV"zpJ2|U/f>khu/s`3-M5s!erK-j0{-QD8A9*)'e6szRgIV	40g>>P4&y4(i9_3Eh]vrj}9FjM[d0hNMe4]`[auP|6'9:s7{woKw<>0<'L?w\||rfCf2rGl=mvt!;?:^F 4E/Pq]2USBW5{Wy2-qbb[Rc#jT:,+bagauxBJJU~vuQW*g%=v,+M-%|wO/l!Y8*d&@`V+m{9<?"DGh<IB-#[e_\|VFmgeM-}wh81%!7-	-}I imi~%m7Dto8lw7)(Ukaiq9/Pz!](*m x	n]z98IWgACYe+RaA"P*f&VrPdNcCfaAVE@[NI
+;vw\!%hRU 
+S(1
+SZN^,dH;:)P'9kx=aLul7iVsOc28*q	i6kIPb7Dg0Uoi"aN:Nt;m74
+gN*8%#mtvo?}K?o'G4G48rveH\&e[o<lmPtlf(]9
+r?%r5;j/Ns@\EA^X$_ ><gn+Ubbb)<g$r2"3v.-[W{@%H'yd~[	LlDxi
+NIy=%;#af18nv;=7Dt6BhZlZN:s]5oL:?Mprl-1988Pt=^788N#m;B~8nsshe3hOOO=!4uy9L^T^@q%x)HMWc\L\+@yqA+_*CsTjI~Ind^nr@Nyfpj1>u'	c	\q6Z<O-Y2Z)Myqx:~ym.fa)h\m={5NIq$fUEop84s9	[h[iKLt13L	ahknfymx{-??g~'@Ji4LGNyif{S2L6-S/-1@Y8B)MM)1AgC^nu/1HiTb.y,}-e\S
+ZqDAf6AO3[d5_|MZtMRKTf49&?'V
+|Uld?bS|3!/y,B
+5IK=YJM!ImeqnK7FWTRyj	E?M7Bv.HR[d
+?<C02eB&7~7d?dyW+OfKv781"j<udN{%45|QdiLJK.::rv)A[~*+u.^G	_?<~f,"
+yVOpD6%]uXyr\y{7EQ'T^^>j:'Z@\3B x!4Z1b;D%iE#
+2cq:4,C!-;:x{!91Mb*]]%sw6psu%!<^jK(gq80Nmw*Rylx#io:GAq}Wn_%wq8<q:=2M6qe88oysqvNa9Mg2::66z;eW,cg[hJZr0t!|AV[5dlSWHKk:[6J&xs{=pB!dZKPOz[yIc]Y XHVU"\mA.p-_j^2Jl/@9M51*"6Xw+T}3+:li'(+V Hr|b)tiR9D	&dHHLUPOcf194]\.#p8"fkZ4'GptmGog\-;t#41M(!8L*	L\8q/7L*M|juZcz(c U>\/t*l'k++<5<LX*TP Ka_2oTS%?gia
+Y&,BI_6lw9`q	eHePMHx*7knMx{w-@or"hhtvW'"x{pwQ\tsx.nL7:olo-_7_~5?0Nlcp9\wnnpi-av;M\@6^,m g^)F,9:g8m.0QB	)y;1qrBz]1+u#]BM-_WpqST`+ xkYH,sa@QI3YKjX[WCrr\}Y(*'T Slqv*7hFHFdJ8bIjH2\kVkL ]#d8DzM~7LRdpwwG#}7|#4m6S{V|x<rONq3W0']:*d7kg=i^r%pd).p	\WZ\fm5^4Z`3v/vphr0'Ekt'(q_K}?m7T/z
+U3K[L=Uhsa#HteAhy0;Vw(2*U8G jmRBQ9m67:EVS:Gb8w?4[;dtvwpw_O~o~p$qi.gsx<r99Ov]<Lfn3
+(#,!kot&qUlMrWN]u% 'e.M">._dgKfNKgPQdZZ- 4O
+dj>%c*7mohU5Yu=|VOk1GyAm03)|5Ndvg^&gIw4-i\ kH6x_j)2%i"Gi26SO>h4-lnnBKWEJ|-bR7=}3\e@'\0Jz}S*m5+_!C_Tzve-|n}Q"T@JTN)Aui*R&a7Z'*@i\J!(A(j3l-6X,.bFDy_A5ZnR"V(J+dKd0'FY<}XAD/=8\"O#xh|hb.COcrP!R?KNmsivmgzK.2*\~G<yqv;G>6#7_Wo/oxx`:K$#-;now\1a%p;4	L}`l%R)N\X!RF2~S2M2rIgDxW`ya.`,}WqtO!Bb\5}D?X7AzWk%+<S9B.&g8O`u/SArz`3N'i
+D:iYu 9l%O8UVsuH"\|!#:&4_)l=:RiW&R<EI	0A[Gy<&@o=my<[y8k@=N"&\p.3qh7-^7459|(Bhr -4h6|^Jk{@@-(J	bT3`]zgcj8kUWG=7%MjU
+0/,Styf6bU)=YIV-@9mwKajb#rA"dVTAC;!Uh,Hn#tN\BDI9Xoh]&Km	3q2
+cyv1F9e9Fu C	#t"vMo6Bc:SX],#Oox:||u?a	lZGk6sI7-z/~t|bR4//OOOw\nm9K8mL9e@@yyen7;D9:x82;S%nkQ1%WZZ+|%#yN]wg)5=<?\w6M*TO,KT8XrRIikS.`AhbHY"$;A
+-O]R"/),ck3901mMM`Y*/fI#- EG~KD54&H38G2MH6:")E1(&yvLO3O>[}@Jq8cL)w<<~ZRUM%-)V4(rd^f5C]=H(%KWj3KsBsT+`X	_nXgU.,PW&L`	:?fo1XLRuBQ..4-Vx'8*g$N) SBeJd|q J{kSj2n/?5PmQU\x`G@|`2D.L )s7~OlYIpLe"I-5lt+*nc7MmD*3	M*aU9eN|_OO|'qz;r|f7}O8o92onWo/O?|~Nqpr9r<rp'v7ebmqJdXX0y8LXRe|S`U2$$"9Mhm[1a#8lWVjR-1ktJPXfe]7pVso
+B:xXZqs)bystK7:*g3'6\34jZ~JUW-.Hi3%
+,)yfaFTJ&at$<*UZPV'+ig<4e9}!XM]/W4,e.HIeI|.Cm0P8<~~Coil{p.Wobmu9)?/3aH"F%~%g|fdL8M[/#+MYLUUXF_X,;\H,^BJe3E 7jKmH.a8:Opb;@ Q|!XDr<dsMP&@zdNTS5N#fM%9"LS	)CG0E'W&3}HY#;_`Lm)Z`UNlnV4~cJ$f#lm93%N>XE6lZ@5L>tO=n77t#xJcny:w<}{>~z_yzxx9OLtd{gq,_"~8n:Bc	/3
+8Fq* ^(Z3T'5g,qblk4Du%2(ZY^t>iX:_>X\w0n@:	0r[URk$J)P!Y.BM9"4MsqKRvCBa*-q<'9q'l
+8yo+b3Zf HXXtRH|]RyMS[)S\o`.'Txbp-JUs&;oqMk:%h<=tl[5J2#	{>~2)XJH
+?e^&k@VXAxfTzn\V(SfF~Z7J'eZYjq(jM)qYG4
+8e\[BC20S6<@J/#YNowa*`B]X(B}!^ApbQ|2-E5D7o9	>zv@ADH=[BRm_S/nsO9~9x||zOOxo;noDbmN{7|~z_x:9xxzr:q8ap6/=vdk{}a	}M#k/V'h8O>j 4p g9vfASkXQE@]S1kk%F8{(9k`ff,j*Ik`z)zX4I5i`+Z!-ommt-.2#4!9]+Uy@I-0K4:k].WftED9%gxo]*YlTSN3HpB,U|R#y$!YtmkaNrssepF|wH78''r6	m`H5j4s^y_*dd \S	x* n6~ZE*,KS^NzTL}/-k+{4@p*_X(bQrvmf= do5v6+~zRPe9g+\%g<i4xO' wlQBSg2aobUHA{~/77@
+9"P}D2X)-[gnn:O;?r8?p|?WW_nyv>ql<}ye#.|us$#w|>gG>=>tfOtiiv5t8oa^v(X),,#eGn9Z
+j,cy=-siW}t	!5tUVL
+KQRe~m#,ySW_&ySdYt9UXA=fYMY
+Jpq,^~S2]9fac&f -SV.0M(MwYL
+-UzZs.t^s6a@%,y RRplbZe4\\A.|Ba%xkjQuPpxHx-mhZi@2~L7E)aRH]mEW\/V	DJ+71~>V`-?_YQ;$.2w,mSAfSLHk} r8w5Y7&ut@WQ&JNeu_5h8G0Diof`  	YY#L29G>;td/$w;0E~_y{22sE]YToMnff	$smt;nc?#r:p?-7]Mm`Y\&p+\yaHN8<<=tp:8y<qNat=f6Mf!XR_!'c3FJ2<LsJGR7cwWXp+DR~gT$pWTK7}aWt.bQ+\:/o2',If8"0,~\&<CO#NK-rFNi',Z<$i#w%<WwJdga|B$MUR
+i,H/x`_W&t]aEMhMJ#P:[ TJkV#ON0p<<8qxz@v-m~cjSEZ_YGR*h1sfEB/zyP/l3_j9r/# <
+Zf8C9 Je3/!j2B(#*L1q@p9/,	s)Z3g^TIDl3gB&YTu4Z+3L+UiFHdKp7Snji<L3A}+}q2zv}@|,{f)le*5*<!.o-aoxzt|G>_{>rf7w7=]M4^[!'9.i4l8]2ax:|x>16i$xh77mbm7]:>'&tRThJlZ`4fYQ2> g25GIWQ+&u@q:ruy85kX%vsJA#>lf5WE@eu|*)	aAY{p5c(m#Rp)#MD-^SO!?Zm;
+9dT `(`"L |xp4
+v	52EXUDeDKVyb(vkBvfH)Dm/\cQ58vo	z%ZV)zu6W}YL'tT_oW+\#&}w_-'g%NfYg1885+&adn26:kB33mU&Nc"/W2_t0&c/PY%P_\$2wN IHNir)NZ!2&i;	l;_DX-y
++NagU[clq1>4]n<=|77;n;nk]&gWb3(q08aM4p8NN)T/"8p2-}q5lvu!RrZR$|0{NV~g1FY.}eyjd(z0^dF,	C5eUlQX	UDgL$|USB:Z\g7@x^!p@&G=Upd$Z2>D!P	DlfxA;OH9qfE98[(rkNBpr,|pf\`\)!|tpPxSm,%p*4^:9+z&;s\A_8H4-FPHLi>2u6T4~i 2kt	v]'hd0Ou#O	MU5zkE@A B8N6p<zB(Q .n>Z|*%%\g"zIg'fU<(X% ]ke.XR9boSgaV}nCD5w\bmZkyv	+8bwlzb3H.WQjOXELy+N+qIw<a>2O?{7_x{n6B(Y&xMqslLe4L\<r\iJvY-DET9c'htZZfFK$J<gCj.`01RQV{^!6\uv8!V_IVbLW:,x
+ZZ w_wuLb++L:9Y\X"LU]QmWZc,U )6H	tul3<h]SS<l2q"ab,\!4H&zBUV&nVAX/!`{rOh rt-i?u{[R[QW56{-*[p^:U|me5?&gn]^rb\,@a-khmE`s}2qbQy5_m_" @PWCsNw$(DJGx&piJLcm<^3Y_To+
+u}T'b+2'Tg1{A=5Q(hBXc/n<4*xQneHE]YbCe'jExeUnnjT+	Ib*n'J<tvqq{x'.'>|=wwowy7{:ncqou2B6bma)	S;.1s`Jqb2cnir=c4^tMk'<)6U3Qo9_ryg|=3XF5\6!W6J,Kzl _'^rJZWYgC.}2S{eF:f`WJ^KQ|m6\-CeRiri+~_*' t k#p"&ZYkRh+}D<fjbEvdP	Xr2??_[oXZJQVfvck;1j;j\n`o*tIXc3<+_.{jsE(BPaV 7ts8_kNmps-k(D{-6l:..VG,w=\#K3l.ZzHhpk2BuMv
+ybVrWfr
+BZZY.N2SjL1HKQ.E"x.@TfE9]fGSps>.o9?~vx}7{nzno=M~6oAB<Bi,S0L-13X,1&&D,(0%iJ7Zf[FU^V))S7*N;uoq[G;zyuR>W%Dyk~]p uw6"rB@`K.S8]_U >U=5h{s!xC-^)r Jwa"GOn<>,J)ea%=d:_"J?[i1-k0\[J&:hFIkEPdZUQD:/3C8NKFXR^$bD{h$+X]}LSV=./IQ~IquQAJiuse3`[Y+VKR)Bs}+0u(feG	vV\XrW.z[T-%)eqK&jRpj/&8-cYB+XCHQ);kY':zl"R,59OEJ`+BTb~51c"2-8>3|.?wr{6n6mO[@,7b,D'uLOc2MW0'C-|zmk')	;@s15hL YHM~8WJ2Qsm8RD3\>aZ#dni\WJ})_y&8kK<X/FBWYzXirJp*j9{_
+4f~q<>~8q?|$/~oiZ.BBse],\JHN1ka*V"(u3B]f.[];.+^XfJU| 6v^Rk,9CJ+	ui"W6lYY'iyO
+yR\yNWIdSmoG*aj/8,dP ]U<.mrZmAiD851d4A+Q6"
+*'V|pW:6MYVjFNyUgK,	{M/UZrozfsERNyQg3*g}p;O<==Ovnwwoo{o{n[6gO<^-k0lvJjqq|qr-Q+mR	eM<#$q4Z=+FgX!bh p3`j/v
+_V]z?|_.fjF /us^Wc+nr$/{
+#9sgvHp7d5(*nJ-;di;Oy<'<DVjx:|9yNxo8rssv5Kq\$~ff$cu18_dW6I4(,[yBt!bK4qJZ*W!fEI,6$YYh'6G|yEV+d-2*lBffn\07/~{DsHm3VQLV]*l4=HyQi}I U8&l7@iur$Hmq-:fY^O7v:Gi+,-bUoN[)mJz%or5r)J6PW):-/2D-)syeeM\K|<=>'?~nm{=g:uBYg:J@N(B!UCk|u+@N3PFeyJ<UKmE*EJ]>'*tm5\ALW^bDW]UZ{v\k`qq9HrEC5-UdBZ'r.nse~?@JH)f3nt</'7y#tb6"Ips8p>+nC7{Q8viBoh3LS.Dm>2iN;ad\s^M4#	mxH8/8,Xf}Ksc
+ufG]PFj,PH)/xy'Pg,qBtN_/QZFzr7(/uA2.	x_u3o94_-*S[HnW%,,HQq6jCikcZS^11ZOPJ
+JJ2g!SiTAB80mEG	$ 91yt(;VoV?kj<t
+jHe#/jaO@+~yyu> 5&Sb|x~t?p>x[>}w={nM~k6-4Mn|60NpQ2LUAIS/=W> Wq\N6gWf1-:j#&
+#YH].3wq'UwZKCxh$/ [XXc$C]XR}eJ`pmBqYX)p%BCsW[e`f> Z>yUt[NSvqSE*	J:ogz, 31b\lsWk-\ezrXmKg_
+j@Wm*]J]
+,q	9jF,Ze<
+*]id5PX*N+KO^zau.
+y>jZ;<CW@o|bXBmD7[p(0*4YJf/pU4 c!8hUcEi|6zN#5E9CRZ}iKIsNu	hU-f j6D/0h
+8$ty7u*cK$1'%F>Y7;~9"0=}0n9|z8~x[6lwosww}=76y@h:KPB,ET=kU]bC1)VXEw_]kVN2(cUcs8h*z}6CB<R<DHzxY2rJ_GnLUfsAIMW!-z;4=6|]g7Dy&Bh2iA{f/UrV/f}y%O'.BoY)0jQg8K*4hH2'Aplu%('2\8Ju-yN?DpTTKX-`6l<VDJ"j)pUj)<yYv/CB>4>WP4*X
+++*2)%H;M-mr9	w\o-.m !g0HdDA 9)86MsPg9>MJ@ZpMG@E=@m3 12K%S[prz"egBgBEi^{	.^Pu;D*Np6.TKKLkK&w=DR|zTUd(g+\
+_&~7pz9?sN|Oh~=777fcovoM	m=Mx+*X}=
+Klr&uf "!Xa!:jZ|kH r%AW|}mhQr\mc%%R*u$lRR>2Z~W,4Y9+W]te<BXkhJ,"-i"F|2d\3RtD6e\6RZ,VC4)m,b1#9d>N<ayaY+EJ6wXMSAqceLZUCfT1TE~r{Xd2*lg^Y*jk^j+L [6g|*>M
+',Ll9^3=h2"{d *B,#=oPJU5XD! 6>=f	%G0f{5s~STgiSi9f3rBt/!_E_/.UQkK'QJAjI[=,V	Y1/BUPkvEJ3/Va:b+~UZ*U\LZ0@Bk}~ud2W@)$We&Ljw]MJge@ER`3U+(f:=[mW!0Npq~/x^|88?`5'qz'[\;Nv"mpm"c	ndK@;N
+nB gu1O
+m$U|,$r}JT7,07A]iQOW:
+ %Yu]+	^7`&/q~~%.-q_eI5jHj3ij)%x!,Pay-0Mq
+2E9j^y1TKj!DB0Zq;KJSC*RQ])CjPMdp.#Y^eZ+'}[-qrK+< PS*>~G.R.P:\ZkA#	ce<4qZ;1Z%b32eq0HSg{ 0yZ E_dKdG(8F[3}e[C%i4b))_,`]2`+4:c= 
+fk>	(9QT+0mmY>{@v/MPIN-&?Kp8;8?g/p9.^a.^>xv{)N'8995pzf.b8C0a0Xr`dA]|jg|t t#v	QM|\''[dA"	Ux%0ZC*:tex:D!F(Jsg,BttJ$V@ttiV*Rm;[ p>V\QX}SJwj,JGv8[\pY}@2PwgJ,N R?;Er2/;lF_h;(T1iF*!]e<CPK.NU[.u].u\c0R]f_`+WMhCG>Wl*+W"BN ^ O?{0vkyANaSk&2[8MTa iR,im  J=% a`Klg|$X)KF!,O	--mji|%_"y=eZ%~m4)bd,bN?\;B[]#In#.mWD6c` V	n-tp3{_3\p<qgO	Ox@lwVb`wnvqal0F	V@q z`hit6!Ue^t%~^o {isYREEySWs-{H+W#qu}GY\UbYS`)WTH5);3n\;wpr?QmbJfB/}=&Wt./ .%HL9 Kjr$goG.z]{jCCWi%h]]7!dX'9xMo:+UU.pT\(^NOWL=(#4-{)p8"GblqhqYHB DGm	S`O]K9,p,F@`&-bJ	q]U@]+^v+f I^?+Bs\jeqh<J#[9]6\mYm6R\)".s?5H*y7LK	<_?;34{=g8{Nx6aq8nf;`dw	qf3`Rc hM5#^.~V:;HjuS `*Nnqx5W[h2sxA(%po#{_Jt751,P8^N56]H	(. uo/#bMMh<Zh@p]SBlJ<',4a;b?|y.PsGQbc<tr>)-e=n6(U "+(vcF \x+kEZ0<_j#irp!+J{u%P |(Z9v}2SSpl3pMv)t0P_.UC\AJSq`}i^ nL
+^L)&*Xb;DCX#
+_n P\7^z*	IKIQNYo/Kn`bidUX~O=_YVZ(4z-47MW=}V\*.Yk]$ @-E,e	g_x9^xa9..O1a0l[l-1b-<0aDDD5_NdZ3]dHS.-`Q4zq0iOg@X`"P\DM3LU FXSQ	KQhd:.639'l+ Ru!cY",l?2Dg4tn|n~y.btV-wt'n+)"@#&vK=,Ch	l,=w+t.cKkV;eMQu*"Pl_bz<Vx.|C*Di*GIh6;YV2K(w\r 4e
+ev% v'[h`.ik[K=}ITP(z{%o90x}/:]/P.&CG~5F+@O%Pu!ZK5+SXD`S~=vE8.v}v+Gk-Snhq7k8Lgxq/pqq~0{L,vyz*98b1#b0<hB 3/X6?*M^V%#{r]Oq&u=`&TqZ%*n?YLO'V{\
+1RT]=pg@Y-tb(uNXvX2@C
+MT H8wI;\?7l?!2aHT`Z@Tn-" s0AQ[R #LG@$)X{q7#r0*AI*	kuMjArQua-EFAHUW'AKV&>/m#H
+Y>7XXmG?kZ'1f6/Gxqg|#YM;##e6:"eBwDq9f8 K\f-EE[g['1%qQR+8t2(nG";tyuLFR_NM=B@16[js\wez)<Jw|wmPj3szAXcK9GzS3/.&<%L0c84c:%Oxr~cp+p0t,aq>pk&Cx)83l8mkGi0i7XM,L#,~uR5w@=Qxr|yDRUS$"IA 's2r<z+$FtcIL<ek7[\\d.&0JK;%URUIS4YHJU/]! !zN; &Lb}Yv]aznryBD*UFU4:w@X'w H-b%:zuXV1ZC=C	BK5<1mVj aCh)FdXrf\ccS\cv qm$sbC&jQ2O;>| >>
+lg?G.],s1]
+ULBf_z.WJ*YP}={6Fc"`Y$I|}< (y1)0;a[Oiy%AVK{[ x1t^7\!\Q` Q8CGjf,S,QUn Oz
+mib>3/z5Qj{^Z.U3ji-%[ 8 emD.\}6#U=$n x. d}}u[EQ\PvG
+ggG!h*GWHeZ01 (cF2kF `F%cYlnCt>hG]d.r/Br*)z<X	G:|>H+7}7K)aW	eVLx2GrvDq-B_,";_	._9W<ey,6MQ(_ v{A;*+tZhsqi946cde6;.;M=-kk
+
+|/wq.J-#+SZ %v(5+]7 Oj HM+c"-Iw!(1crPR;dM~A^S@WwT8h f]!fi9O!e`Y99cDU_9a90s&xbCx6nlJhU[BsM t5vc/B#ExB;8`S"6mkq6QLkOE/De:%)trP"Obo<KA/\P4X[|md@+l2d!FidlD^caSmC@Y26)	I3t}DfAjBJd$QD^1GfE]6}rRL:B6t=.a%mc^~jx.*Am-d,RS'(iJ12Cm[o";+) D_S5Qu+^
+(/DZ:v nB{!!TE59eo{
+1cQDP]($
+d0	{%B^lgIk0xM6:VfQ`Q`Yl6/c$l"c3:ehMGQSNy7tA}c{|NQ'
+8w$TU7+f"Xf`J	)g,+3:qQVq&55XS\m_>kq?R,J	n j%)RgVN40%L /) c{<eL8OYc'J:3lI5'fwb.m`?#6W&R`;|9bp0w8VV"vyMQU(j@iBhq,M@/9~M,(B+o)h{ rYwGOC	JjTuj2o60	,tv3Z_R]SY[M1&CbcV6>_+"Kh*V'(p2L]>VUueoO%S1Dv/&5-A"%LI0(1b5hE0W<VAnd=|Hi?HgihX"_cPK?JkbNK7a]Z5OK]
+wu_e1w*daS9#EdzQ g73`$lCR>T58}+|NT@E1u\>%LHJtMC, ceuSF^2,qV%Ai0+S/Y_9*hk'+7>P+mU	e09vVpP
+25=mf3 ;D4_E#(GU&n/ \#=M5Dhii6k,G=U6,:OA,>JC2@-OC5'TsvPfj|2V2XvL
+",?^,SG8Ht+j.%J\r*TbRKfKj9r1+cAu 7npMCj["iNyN\v	qyt m=#A*]PhEg$k$.0Cg[t-p*w0W
+9c_?f ue2b] -vkGTQ,)Y	]'.Te&Nb-.fZUK1@MWR.Q;8SRiWt1&;y 8+2,R#	^#QNI
+:`F.Rd:ZdhE6K"CSj+^q
+e~ftN +Z7/eP?>	P.UK6L/.Yrr:BFA<6,arp'jpcn#yI-v''
+^^ PP
+X dUD0
+e8-%iy%[pqqAPTbb%}Ti8:_R}u^hX
+h--qWzW8`)\{5v?iv;t-%lVn r&	qc83nB!^h*:TTHHsZtr"$$vH#cnc>CyH$='!fB1.>rV-_f!(!CR[%<y<`qxF/i<cnWkR3R;Z{,]+Am&G/(LZBr,[H "aPPaw9`=o1L6'4ycKG,+9
+W*-PBCg/h'@ 3S.Iqu	_eS>>ovv$=8^@(jmMjGCly?pZ0[.*=8EMq7lwRnWzTqe&wn#M=yi> /m@a!@&HP574cPh&3EEp+{ zU!|:UzU=(Nl\u9s+/H+`8BX.fl(E7Lso3jZU4ISK^$W+!vn g_\ zb	"^2Br%p2u~"S e@9g,.z!@e#0e[q h0A-"&cRC,FE!0/iH)d,6}/ =`W`
+hZ}MQwNBh6%j	eF7{ e2n
+X!k$3u5 ]_:5a{V ~?m.isq1"86d/&Gj]!;\|.O!VEwchF6|FtR9v$D8!LW^M,~E.JVN-W#H&6P_KatB*G\q'8y0#iFi#rU*Qp"gt~v#f{t"y.rop]O	f(UiWpu`
+4#aW/j(c$,ue/A:OD^#Z}F
+sdQvo9/_7~wpo079fZJcC.mE)
+$%l!b!(bdlAjuQr..aKuJd~5TqTmY0t:p9= %g$a=xeUiudH.]F\	IUK,Q ZSI/D.*]G/>W7UPM]=N=l""q6@q%Gl.R	rQp?yT5iHK<#31MjktrqZmVfZ;sImHV+X:
+^\)zX ZPdbppxS{E,6nPWS#cGl2u
++ku]P*j5'{lvx9.i~1-)c'e02]z\I#Q7w;k,@++l BUEglivuKx+MMTc mmP2S
+("pB'%n}_,oSwv^5uH>(aP6A0e?Gn)vg|q 6;l6wl6"A,HY0raf0$]k#j<l A`KMVI] b)Z1WbD~4
+|P	' )lqq0Xle%,nl<HM:"'*N:aJ,T8KJ.JdRVIwH[PN1t@K3>%AXq@Tt#[&	JP"/1DYQ5c
+.hM\kX	?tPEc*Nf-1uxvtMEi5ts+fh92EjQUPU;z>bSU`
+C3!4!`F(d"Sl&xq)e	)-W`r! 1uC8E+ak?t^DVgVV8j42x#K%m{	G~Be|/(E,]ay2=<(	m}bf6X[25w	#.O1-W^I18,K@K<p0lq
+Cwv=)a M4'\|	uFC@ds&l\w1K 1b C+uQ\[vdIu!]%@Cm !by8L\]Lxqq,`&Kf;G0GIht=9,1:l|O->|]|[/JcznB2D8h<	9bzOkAMdV5!EIbkdoas +XR`Nn,ypB`-/3$X.uO[Ho7m\'"w8ib`6RjKjAq/9!:2/%[G:DKtBO*6Uq]^I!F x>bC$bUe^l,s_J[o>w,|L/C
+d\D!dBYV#d.bI42D8ZT):+x:[1 	i 0NNOp58{m7UDF#9
+, +cZ +24/Uu;DG=O>OWK/UQu
+WR.X&%uMkeM!j}nx/,,~1"Fafb>-u8l-C_5?o;_ANA40,P,h"V,1'b0	Dsd*hIm6 qc"=wP4I'g+j-U,z+O/Jw~X';2.g38X%c3F10[l&RVxB^<VTJAP!nWGg4~ZFBt* -fB3w]k I>>/Wy`9lCh7<9'+zI8O\M:nA|Gx~>@&(%~Z?u\8no6-]f<P gY	dat2WC:,1`,*'Wy1v3d"<|[n`H|m:n}'I`@8 0G4:Q1p"qM*R@k^U~e t\|RZ+w_^zlYh (ra^Vm0jjt&?H~-Bpb`,
+27a}g/wqm_7^CW[X\|B>1+36AC]&y@PrhlvuidNWK6KGc61_vZW
+	@r,qX1E,blqf<?`I;YCi"HjvjNq(D3QY \>U# GZ:"[	"D;wIG,4E]t4n"RJ_$dS`D?=U.[nbja-vR]']go *Je]R~s-gg]75Jw9]h+W.{oI8lBX'ntJ Y1C}`U0T9g :|Bq3" b"	 #' b|2Ou66MM-K_C|gsLK026$|0[@*	3Ek,Z\uWlL=+kU/F+E|Bm[X-z`cV@$wfjn#?cECn	Yh<F@YKUY.b,8v7?xo}hulhh 8`40!aUPE8nB"wlf[ &5r#%`iQLH4	d"diMGT2acn1h,	)/&0}}0{nB#=*.9Z4_Z^@eG^qMurM(\-H8()^,(U$k?w2 \K]G|["KCoKYKM!YmzXjm8^tZW"&p@;qDNNIu<9q/UCU1(Yue>wHdP8*{:Do-,
+0y^40F\;=d>~k5l9`Yf 0n{.NNv8/3<?GD&\8oIDv Qlj"jJd9S~h	*a<>Vb,OG>ja?K~5_^=/+& Bryicq*Y|fG2}{k,N9`JS];zqYgNNA8?{3|o |7)77!".Hi>+3	j I"xq3`U.UnJWDg@Kb,!F6*&I0TVOBXfCis~,K2bkY{
+9	%A0kEedV{/Q[;LLW6r.OPs#NN ,	c`pQ7Y	ySkwYP3'r)
+>\eU44W{5
+\FE?*EEU]Fd=)DND*xDZ3_Sh)k$8tLc.y}Gg7vt<Hl y,Tqv0IZ`]
+P!`!vVS	/?0;EJLPn;..'8;{%%xnad"svU@g]J},*,j{Yh?xU/.fBGC+ff?JZ9hU<1T$fgu@HCb+!M0if`e)?/~|7q@_+Fs0YP-0".
+b0.1"_bz*`1zd`Iya,ya 0 (>p>881O(2[fDf1K;>B@t{8Kvms)MjnH9@iqthK_heJb)[AO|-@-"?HE\rqg
+mSN4$ ,k`
+*Ewy k\w<\ c7@&f*1\W*ZGO7
+[8WaXQ1&N7b7cu-].Bbb),s(Na@  F1t"1ZpSB	XK^0_$L0/0;8A^ Hxy.8rHMHhcJOMI'P93rGZ]La#oocJ)wp5uslpd9\ 6%.Yn=nYY|1|l Y_EBr3;nN({d(.Xww]|71cbc8WsRlpY*pHPd4ZLl:}9#	b%0 2c&(cvP	9a/FG\\	iaBkW=Dlp5%z\9-Y vc/u  *B!nG;5W@nW37t	W1=j1]CSj ca	/&gpDTVLKJ!:j/qe5Rq*^
+P`=z<	(&JR0@2T/6+U/DZegnuD5>99X;!^~jPG~BX3#2 )%O>iwKU&#<C`]Ha Jj05;fy0`s"6VI	
+iNb0^slz7L+#fl&V|L!DW'*2<Ta{1NG_+?,cRXWziqUFE6*)l)v -jB1(>DHSE!z)VA,3DvDBCs2V`Hk:&Rqs%yL0[8Ta:_s</ "?|7`g!LneX`
+A E$4EAYA,\aX yP0S\,	SYJ& !Z.F
+	_!FDSASV "kt_e}%O9Nu}*Vr6&`:BMF#oK@Hd c:4( n/!VyX\Kc
+01f;[VWrh$*&	\l^7EU/6hwGgVkjUUjFUo6BbB"v3b\XH%j5WR2(;"5%iMx+	5o{;lk
+E0x@x70 'q%%Vx=7?CGq0Y,2eJzj.KQ5ZZy
+1WYb*;d)+t(\eumO_B{&UXT3D2K<b%XmSA>aEPs3*Ak\O>GI[_?zxwcgqz~~fR,C d GkPc"0U-2q X$ 001c$CZ0)Y3D0`-zy,SRwb6H:Cd*$j+Cku6jN.,DufSuw6-n"1:Bv2+dw* NFX	|sO(+=y*%5@= ..A<q:a`%~6TG>QwFqi%L=8k4wQtu.mEV50pU;!;( "bk:p	u_Y/ 8
+{ 
+yA^fi&+FYq;nq/1'%spF}]+K^6*v#Be&=yqXbm>xhw$vPBZo.[}Ysn|90@KZ,g` k%^r@!w$D
+( vIdh4wSQ!-?q|Wxokkp8?G/O BfW0[=F>EFV=H4+CB"Iq6-DXHYljiQ&(V3e:}?^V:Z{ tJ.3m%L|L]v"I	vU^JM5LU?bz-gUq	+koQo;3 DUknim*k
+{be)VyjWLi8DIPE(;K0u W9c.;}}VG*6X\=dA/VSQO6$*&z)f y7)p[RzucZcIV)h;QZ( (^0Xs5%^BkZ\	2)-=^_0b70a q!ciu]T80*WOzV>R%cW^\5"f5"}ttnL51vYEo{pi4'jx8Xf#}Vl;+Hk((p{~}j4a^<y/?&=&~n11r: $A
+
+(.0T5<<FF$6i>vRJ%I[x7'Y;yad_W.XT2fFxQq{{u7dB,d'HkROX;\h!\xIEpM]-jJ40i:`:X
+0-g/ {f
+|=(BK=b2e'QOG|&&\5#R
+X8yP@}N!D894#S f88J.lHS.EcRi6;eU\B'J]$>?lgC$"#i`1"qqBX	qpk@lTl:E0J8p@@f$t>B,.5dcX"zg_/%[tV5s)_,4h_%Mu'~>{!'+3_^fcxKFMV2fb=8Z*$L|~3<Sc~}wq70|:6{!8V|0-/XR qXeUdJC>,x"g[`1jh0s!$xvv\jw`XwJ{Sh6Pm,YHTq>$2RuT]ti}=TKQeBQ=_I	@#kg*$do.3*<3WgL(VWe_+jvIU-oyR|\_VbEJp3?	! iB1Sz9U
+&B0`J" :71[
+Q,5u=?l#znCfc `XrEXSlv'P%)%V?1gd%vp6 xin	d!f3&.X#)s;/84+zy_5/}A\lV29%mETFN@{OW/ S7SH^l_Gx9ambBp/@C,6MLcsnOL$bT.xukP8g/G;[_m{~Ml8=n@#_{PF6@)n<!Dfg!6;=T3$&f`2!cp`;PJY<N.JgS
+u1&
+C+s3)DnE}:f!Ce=e"> sBNV3v-T|*	}ub&~BqqG,?5CE(b*~._u
+>AEu
+^'L<r(QIF,:Pqq*V&sxm6cyYKvv bkmB V4xy7U?"d*Zt\Q1	(y*MceBA6z	zz^KeHsFNdd''S,H`,bo!q )Vf1fy
+UL:~{%lj \UWVSP>RNQ!^Xbb fcVe|/>GG3< \,("U28 v_[(=Z6
+LeJ x$SO<o{}o}kvv'A4)6>FHbp"
+	DxW:u5u&g0(XqrXk9+F7uqdFEX5>Wvr*U"l&y.U >i;HtZ\q/<:~|8w}UY*+O3jA`uO:C\tz%qX#u@D_{?N}?wl@&(CWt iF/q>#q
+A;% NT
+1h-8eHP8$mmwNd\lg0JdJ 9gLLr){a1U:,>mrV.BsUsB1?$F9R>~U/w_/\Q))TU4F+DT&*8 2aO{@ 6n^?gc~'xu:q__0aB$Cl@#)kdb8"A`n@`$Mw x}~|xwpzavhNsVtDF"v)cB. gt4;2p1R|%S1 *m!}^Z@:fC-eOXU{0,^QG~pp:%SJ7{W`>	I0gPUTXt:~d<i=Vdo#&*^Wup_?+>roAa\\u }&LzsRw6"yY'x7;o!-JuuCIO7+R@w8beO"Z1st
+9{wbc`&w,kLo	Ay2cY&;-I>6-!H3T*T8@1`qbvVr^`mj?qRfAtV-mt6_+F%uq^VKP`>hb1)aDfU_(1NDq&Npdko?w3|xe#9h	$DTJfe4WmB1Y
+e49b?M@ }_ v{"iB?~w67o& 5^ HfdK+J>=E^=P!VRVaZ W:L3ov!/"aLt@
+yt/QA;Z
+O+/.Ni,E(*.VI;;")X+q`45H	9hMt.TJ"}BQv]@s2^.WdZ_h:^\
+=@YqR
+yZcjYim@Te8SRcNsa0-xy~7q)MDZ9OFr;GBddWZQ*XWHuw {>=:@<mh822*	.b4K1Q,GbngE:+>  v.Y9!-..f
+`Oq)/!d(DtEKS`  pP4qqT`-a[/#W %0IQ=YY_T-`pVMW`E@av MaP"l"DM~. &l~}>Oqvqe+O*ZKfwNDUPp(U
+<;e0A`&)tAX>{'=w|w|>$C87gq?h)B$1?lJq<s4 Y^2=k @I0D1`1@5UBEr6!e~iQ{a+s^ vJGtms0` t&F#m.:!)]Vu.~ZjH",bKt0+p:QhP!6F!: z= H(k W3.&rbC`{s_qdva$QzN	$'<|w{q: MVYP.Ox2\$NM5;J]xF! @.l_@"`*Nv)U<I1Yz4udtDO
+`Q$88bjZFl0qQ<-'j-)*PV^].'fG+UrWL-t;LGe<5.9U+cY@KiIR@n#$
+^#Tsawn{x>S|!?zGaD#A 02B% XlN	9-	}	xKXE]cN-v7/x3<!n9-<w<`Q@q3i5]daH4$Bs[;Ll@2vl)1DXXE"V;"L)wkDrC]Likf{H`*O.:]Y?\6OAXnj$=C/#ut9\)CdWbeN:(bhntP96JUCkh	{}7?-Y3O&*e5PhTL"QQ53=|OS|wqmS+sS[sVaxE-"s6)lE7}YD
+X>mTQTU~z1Fn  `f\\\3,;v$:dro5Uj/+=\nn=W)%YkaW\^<8_!{]P\0`%c^ip&` !(`npIBUAw(43jz )cc^fCn{<oO>O~3>`D9F3}EEl}HjdQC0xVvnOOw_?;o|_{k7_u3UU0m*FG !!kVGsC,VxHbde6b1$zkrp@,[I%t"jH>?V8T$-@DN=k,W4CKtshLJnjP'Gh*,.1Qby1;fgx<h
+Gk8ZA"Ml^NlL{\'
+WksJy%B]>R5%%v+YF+B_VAR "&l_2LX@''6V&8yI%A4a .N\W M^"|BuAK[ipK:NC&^A(Z}Z/vLe1N' nt2Dl;Nqzzs=ybN	32BH`'`fD z`gb/UL*k0=khuKw3{s1Ms21l@07oG~Hm^/ !["`p}?%-{Y2u M8K]6e\KJEUgnSnv>v?~ndcX,6
+$y2cRd1'F"-pv8\o(_hBQ@:8rZhOhm9eXadFa<'6P /Zm.la5<~:wNqh*,luH0}hRjV[Jqr+U[g6;fvKE6E@=_F:uJW169^JrfN	ZYm]7OW	,fbEd0nc/~aq}=y!F=%CaU wHWYrawW>xgLI_2@j*&fI:j9516fw"3HD8Z.ATErovVSA)P1^z~i,%{b?cAK,itXp~~@w;.t NOc&5Tb;e<k{=|_O?Op~YO0Bv]DEfyB	9aPV=+#tyZ q`Y"	8bI? |7?s3N heqfX@.U9s-c{aD&oV{Z?_P;.k!&8VVpL!tScp|=
+2:BAR"2s4rJi`c*uUW!`KP 9# LYkxpMJ9omp.n&`6n|\R>h,k2U)fIT]N\7Uu&zUT)CL/v}1<h4#FIHKVg?,7v3{uw65l1NV*:XQV3W%V}zXqm)^l!ODL%h'p7l8qll:.jG+U_E}Gz	p)mliZ0O	6SqI./Tk,uJ	/,F+"%
+*99rr!9gcg03v~MO?~s?'Oy	he]w#h])%v&R>$[G~__-N 'x'9xycS/JPvC\bD(:AR@U0Z*c&!$C(6dq.Z0M]rk.6h,#(y5S;vcLv:Q+rt0aXK-/XMJ_W\+*;A=1vf^A:*Y\}]>_]YraEPJG]5rgEGwqN`8 hlSKlwp8==~<[7q8cuEn#AM:#fKdVE(W{TU<o:]8j1c?<eWv!n.8p<@d0
+.S C b:T1%AX~zpRa KE[uPj..m5e]BfbXg_<Rsv8$Pl!n<pu40f3N#o_*~G';a8uRSRm0qw'T&cgmpIKE	Uf5$ Y"0H1	Y?+y?7sH~f1b3q:OsLdANmBBqNbTlb&*K|}Gm>^fuQ@+|9(&E;G~rP;%F.W5Ko% xO.v,Z$a  ^'E<R@juH>~H]etP//E_v\P\N`KlVU4va2yS3!;iB{k iV;0v@Pa)a?M'w5;~&`UHtg)h^3]
+p6bW51?fmPtP%7j{]7Oz\n%\^'';lL\\\`&,bi%E`Bz#_W=zS%:bKto/2..8?bi;UDq G<Li\pk9bpj,n6PkdnN~8I0?!!-:q"_?yMkSh^BuM'%;RXJb?q46BJrnE)e`$&RJ0xn_?#7o!'*aaN5LFx!LfdlG)Bi4EQkK+|Z}B} Y{NHq{e+IVk@M-HV@[[#	[
+	cNl#f%Eb njH- Jj)("_CG|??.yxi
+gHZ<8}tNcK0=+&f/8k[9%Y\2fMyx`8n9A^@K&$%A^ .^ahVvNQtqU=@, ErLad nDC-WRs=`'kna)NNN,T`XG"2K.I>W4E$H]BeV`<
+7=g8qD|OCgq$l;Hy4Kp+gLJF=E](`Dn{0`?2Y[5>b35V Bk'xw|3|><}1 T-	ZtifIe:&-)nlZb
+d@-(g[)|7^0#f|=ogug-n{gVpP_9af0![*#hBcsbd11jB*<F!FY7Tl=d[gMDL=K/#a d[@RMQ	Fnw mB+|}mx;C15?F33(
+V*&m;
+b+U3L)qm;yebLCrOUBtbL'xWXS\*\'h@Zf1)Jty>]!-yOs<v{oD^\\2#c7SU*8%(	P_}VZmTv;~?%xVd>z[;:!Gi,p&rLY/_Wf1F6(P_a3&k^q!b{sRIV#lw;ykA7|IkkRQS`NNO[gx)>G-=~`q39be{d4aRB@ u6E+LTaprrlYap3<S<~{W]/+o"1(^0$[u06)qZ!sE[):+>wpm^I&ov
+,)R^v;xa
+}cN\`U_MCu5imHdf0Z+Pn+?R;>]1{)OTlLZOY*V	Ayz}=+V>]:JjP<iB&:WIB] %8jC|)Q~B1v''8 P;&)cp)t"	s0FHrZKcuM1#vF^i*-d6W^M[(c?H]?+kp,$&qp{v`&i4]xbih[
+JqO*[`k?&_/KhN~lC!D`4fcc)k*/\20E)s&hGBk.G
+5{`!06{x}}?/#x9+bm0I:! 09ts
+ZSX`cU|b`f1bAP,O>! _5o=xouo/0OK]Xv^1eh?O\LH;m2;#:5IMJ6_]4FjVq*:&}(5W@JCl$poy.9QZw3c^{P?Q~yU#A8_Ie*Ub?A#w
+'rb'-P2Yw^Y<FPQzS(+9)6%1Q?8Tq~9|uy:F1fJ8"YV#)eE+|E.1y$U^:
+yZrV'lB0,<cN%DNl
+yM-
+\83+)W	,hveX*k%sD``sU1OqyJP	u?fS]U5+.zUHzVA"G.)Pw5}N1wnW?z?~=z/_p~"9G[O=L1o(!~V$Y+bg "G[Q :VVJ'x[w}W{__-<xpz-LK/p
+IK# 4
+~'<	r)\9oGt0DuQ,>uP+J|ifF jCUL3 ueJGCX:]6Y`fLe!ly8
+C+}i;vfmp{lgvz.J*US&
+~'hJ;0VN,iJB~O^E,<!S]0_1M	KpMa=q|W<F#Rx%g/qs^;ggg8\qaHX]#8__=W?V7Z>: PWZl4WCtacN(\Thg{8L./fcF(B}UEIG(4+,D=GWP=GhJ2W8`zdHox1aT+e-	c+7.:Q2jn9UnQXQ+8O<\]wo7[ox+sZ][Rzz;j6t8rIFnJ0"C5?=O8w_W oMkN9_I`)e@eZ$F$%PEHjPvOf{$ ~b +rmMPXq-w^qPzY&9cYtYZ]2qk9fa]wWJ4W&Wcc;&}*&L^,Q
+wk-U^<sYT&MNd\:QEN3`V1"4<FcF~&Rp~q~1>y7opg/1Rzq} rR#F]h0*%\}5p==Y
+	5P=090n6T "vxHyWMGo.j|u^cAU[kvRSeH6.|}S0tCyu[^V4o!0q696AuD^X(RVHN Nw[6[~o~~_|s|'x~>&C]H+3';T/<4j;*03dfl_
+lE!B?>NNNo6~-lnkob[R%'<a9
+(	Tr>&|GJ{uVpfD1{PU(qw#/OTt7~cnb
+U/HKS<//wG+Vn3_Y0z+*ipU_^;/[?Vg!JG9$Z	e-Kn615!['/Vr]q b'4O'})eld28Dvc>iwpkX	z8hm]+e;w/1^&B6V+J-xn+fE	hGjTUCb7ftCOrFLceJ/krrI	RD.u"DQX``& !)	%f8WZ`BF!k} qv(,tC`&bow~}|{xbjBxi+:v
+i2u[*F !8KJ8f\<So;-;s+x{~3^}vnQQ([`%Z28X@5XAq{o=|HXb"Uo_SO#$ue]]d2wyYiP*+:	mLP.6)\G|tYn"W}^5JEg%J0jnXB,Ub@/5f"QXQ0,m0~@R0bV!*MvC)/x%/^[7o`	iYBR^1S|=K|&bY.38%-W0lWa.(13kTd7},W/(15r.l
+
+'at0&LiF:,`lQGM~n?w?<\i
+v?bE^%hj 8`
+iN`(.]lN1`y3G`6!IhnNp-+[e"Tc@RZ, nw{}9>S<~,;?
+#B_O;J+~+2y"BX1a r%kY`Ns@L|6Fe^>>Co}?u=~v7oC)%b0D&bU049MKoyA(}f~PdBc61By(dF;APX=WTDk+2/0BU{wV%,j1X3-	eu
+?
++"~[7,w#L;wnLuXs[vFg"iq7m]\*U4%$p*t}uG]_V4] 'YXFT*"j_(kU`C:EL7FG+q! g//o8lW9#`cyY6/W1:Y1r_=%%"@Cq6Y)
+
+PV`0TO]qWe+&b9n@Z*S.4
+K U* MI
+vhO;Jjb'@XO*{_v!zRc%5RY1Oa	C#E;(L^a^Us=Y\";YVmbd(cQ$ qzo<~O=G\	id?K+lV{J0VN 9av[AtHcc	am#,3<</?/~#G_m=clr$; <X`@sKg$Qa]TxUg;Zj3lJEhFS\L p"h]Y%yT"S
+r"kS:Zw_5'WHY|o=WtB{ZJj"B5m]T&#%,LKZvl],;0!B#=NUX0%/$F/wB>8V=yg_G1`7n[{^Cj7Kj3WJP2KbIC&|RDZ69"Ra] (5~@T_q76^^u E	]AA2#Nc:$	i}o0\o::@eUEY.d'6c1Ub& /hXy{fG" #i1n'mu<C2.*
+w>xx
+XLP]QBP!*B\v][aY&L<~=|zsw1,~{(YV%vCZC>!XrYX YI\`z
+xi'}}b<;xowq';Xy"33>ReN`	'3L)#Qv)VJo0u2<WP:9pr-gv8S'/,^jhZ:\@A^%>aO;DA-o(2aOqf""uW(U2hVGO%f
+E1Ww0XiN~Y;1]`]'sGLGMsFiR;u$gB%|g<|O>[w[w8X=bX(Jh+.Wtn_k*Ra Q7&XT[hz/,;r5{$4K3'g9m0 DvveI1Jh-	9+j_+ uew^ rtl!6"FNSZCB.avn1\f
+fC/j|TThlJ.Z;2R3tnl1av>'}O?=~jT
+)3sMJ>g?<H@r6GGO\o{~o.^{mq!lCK.+]g_>o;oi]s'Vfg?P5]B{	j@3uD|m]UvM2H~"D,X+41S6(SO')zYQvA "Eu	05&\ [V;
+N;>R]i@r1 XOP?vg;*G{zo8s*ENY;c.YbbAC=G b^0`&$f*j*CZB!Lx)?}4OosF'9S`l!Eac-)gfETk;	>,WIzO8o{Ew4q~~ylY,B0@1DE!uO+k7!QXlMw)\%y3u!^'6 +C+fG)"GR}k6hLq5cJbUP-0wn[w<}~>v/?IP:@M5l	oO>gOqvv%/`%l6'
+9KJ.QY&AtRe>>/?3x_W&|c<!5\2x':|EQ<=O6
+}Y@:4pRm}&s[VLBK4z'P&1="t1.|bw^V&`:C+>prKM*GQWN;t`YMrM3`-;K:gq.~^-_7gTS$1_lgYG+]@ORe8&9#e-6,qb;fcYv46]RB^r1lDzG1YU@Z~~t$=lV/c/{VJeU*PjG#qf3TD2xf_xe2,<g;S"%l&!(A
+X{~#t"+e,rQU/.Hcu8/fq]:^>nq_,36q xf{GpML34	 o6n7n`w7S<M-oEyIn,7c,~xIg??G?!>?CNNNcwr*h~I&>eM*okN%G:[`]] vYS0*X
+NnR@[WBP>${})~huO9S-6!;x=4H*i{ 7WT `QWSUT+n9[^']l'wyM*H-'Sh{O+S}7C|I8M]nZ	%mBkxPVx<EN!2UgAiY"H*Xxf`]N7*R4a\?zq;LX3q-C%GS`6A+ZD_h/*[6@)1BUQ(p8nnp{K"3C:\kEFW8U\Xvet)/88)g$B2,[!*">TJt,'BC\P
+2aO $5ViuG
+)d	^uwo;?/pvgg,/XJa]8c	>{rK<x woo_!l#|oicwl`'_.PUHl:nE6
+|mkz3r0hAT]@D`v*JC([@.1MIaKD i[I}CScn8n(L)6!XzeIL@qm5Phpdm>,N#D6S z_*+WMbez @:8VeaZ9JR	*]2aM =c|m]n} /iBZ2)n1n{8DP0</n1O?}g'XpvcH{l	Yk:j}acpj,t{\s]Cc*zwG]*	bp~~%1`  B532n9@+8#umd;k.Qhg6U96Mc4>ST0XGw<*fE,K&Qu!k3*V_D`vL	s6{]|gxc<z/4[Z'|61BUqq~?O~#^7opr!7ovt^()&j$t\bdyR8=Hib;_6NNO4/.
+01Q0*U~?{&
+&ZW,T~Rt@NQJ5Yj^	EvjZzC@`$,K=+. \BAn+@Ky}921MUWYl:l1dhHEs2HGNs2Cj`Jt"O{Vz!c^`"US9dK&	q +$~q
+!`;)xlq8 0^b>RB*HVi*SH^.ZR_vWo(q|r).K.<WD!tadLC@PX1DJ],U/J#3+TGLSqCXe1MFx9C[;)CTG\a,Lk+t ;l`ziLf"/$Ia x3>>s|Gx1^/	2%0ATjcO#>`LkT^Ey _-ZR"tMT??o7?{||[w^;Ay?+F!N	 }|7~lGVeQH\{QDE`]`vLyhU_vzn9#km8
+]1wC7WrbU7k)m(O+:mWsF@GFQasjy40:>LTIU;wydPv3H`8L3Tfe> v#~8GX,rc`I	<g[7wy[G/^ 9Lc,TPJ&QC&uhp)}o"W\Wj8h9=rY:*?#-_3[aS(c#xtroFw]A;9VWuM4=HU9}Z\/Xj#Wt#Y;wEW 'KS/%_gz[tw6>x1~/'gdbW) 2qr|?{v%-899w(0 Os,n{=H $3LCv-rIx)?ooW;?xol_C]T~t0^^}trw^RWuXETxO+u_:uS..q8xs:n%oy ly=TWh
+eq:!|.U0RB!]@P(21 Hwzv`bbT(WAp)%dd!?5)"Csi@"ydkZW0 =$j~YY]}!_(;<2| E
+( d@g ++GYLf'nfcX")ystwq	A_~o^x<'x=y
+yHyVE_NE'%]EAf,&!T5wf)TjtTAX3GU~HHuNx:n~[78NV4MX/Dok/N/>z!@'LfCBk9a!|yNvXp)luAUS;8AuuEJrX.bE,:hytEDb!\
+@RP_|q}kO7ojr.i!Sfn@x_z
+8ufG}"t038 . 3\K?'GCq*OHklF)rse[
+`-*@9E^z}m2CXn(k^TC"bp1`~yo"In4 8CRgftMh>YgMZ]9z{1MRi4t*--rgea,	=LGYv]g0t+jb6ZrHu(yHC*D<ID4#3gLSClw;h!v	y rWWx
+"4 f0f,5^N6R.Jr;ZZwj9UhB>6s~[\>t8_:0,.w9j&U]H6vRwMt"zahRRY&Qduw_:,X*i]xvT&g+E@!<O?|o_?8&_TT2EC)( &,%alzRJLd'YU)A@Ez\6
+DT?o?'`iIn+HY
+}*6V
+ Q\?Rt%&~\Le	,_w^UW,y\11[\qnOf{uv2hw6*R%3w,3 ZXZ8a<3"T	B-,p9L!t3"vLmIH/Lz@s}sD(l"YDlsBN1*;4n,b_>>=@"}AiV~:sn4]vS|?HD%-Hk1D*%[%/bLSv %l6q0uRJl
+m0Of^'	Z(J
+uRG ]"5`;Kvc}IDZD?H-^%Ja	BSq3'+T++k=LPWa|)^z/_^asN8v<Dc\a`)9JcobUiaK"a8pu8s)87~~S?g+?#()_sjqNgNZqBu?e(X"^T&Bek/d\7P;+ebDma0WA_aRU ;; *Ya`"j ^ugJN&Fx6GH^8unxt`	zTod/xf<*5+08 8
+WZ,Yt79%[~g|~	/^"M	G^?]zqXSZ,HG[Awsk,*nvmw81pk !b"bT"[NB:"wb9+Q6.rFwn kE~@b mbVb2=~4 %RZ]1bY%Sdu2P=C->z?f|5K1&s	bdpdE4sA0lT9Ftc[G.}lFiG JUl|~-Kg_S1~GO1BKffy$UrFsNWj.\9bI0	RdO-}MN+EnO\S81;G|f+''_Pa^LcA1~62S	
+P_?@.,
+xj- z+D!%'uj/+J}E39!MGL{L<}P=Up^yk|5aa:q&U C-{]J]2iA;;j~w@F/Bb`;D^ax&5sxttD#CuZ\6UY"g%../{-
+-E9>CN:5u+PsJ2cU;v:oV@6V@h<(dx2O/	1n7( 4#Kp?{7[|
+_8M'898 )u~S1c;4 ]=cfB=fdd)~~?'??{|9	)]^quwBd>]gpF=RhVPjX3Qj3	P&)0`^^lU]O02}R8JbzV2SmUs5XcV+=KTwSED:yi #9^aa&V+%s|r>+wvy3ns?8P,a{Jf`FF}*1A/04p} brK P=^6 PC=5<HdUv6>mU=y\[jPGBNxGCn=@~MR]`N3=^~58 Wp}u>P8M;F.66#(umf`+j\3*s6Nx8EbYN5kON#MN3;p(S-TH+ "B`*<CiKq.Dl7<T+1jv_oC*rA,dC9IrJ\\fd2M3Xb`D'OnKz%"R 8H@3 2^rg?>~O>G9c]]L{CU?E=NM	IsNV:hZ2_mm]8"$/Z] SVw;^Sg:kvU.
+A)Sjt+OR\T, P{b1IbSRYK[YX\ 9#8n0(`!c0`Lio!ps+vW8yb,9^vAmXR 'p';vu wI8t.w.*' ]NcC`l6oQ&51deM(Yt(c, 'EN/5 `<%VRj0TfQh.zSo!sJuZ2hn1Y%9$r-[JceBM@ZTY9 9<WO>_?_^i9! fqqYyn6t9LC8"P1DO
+u:Tv5"9	nOK-z)G?~a$|G?'x?CO`	i:tY,SA!"6iiL[:yz|H+2/
+JK-\L^TpSs/P;e$!y0&!Xf3
+%,"ses{ICOMY[.E;:jaiMhXhhbuRqAmo4FY@k$eZ
+uS=XR aK YY8D mg'Eq AIpbx7|/={t|8 Kc\+T#MR|enk5uQRm9ForCd.@RJXh]jfi_ns#=Sawyq3`:M=qpO8NYP,hHza%A(NH;,(zs Y_dPX$QX]LbS<dexAjp2T]#;1 P$^#Hb^{%`kZ{0#plzh]>>gO/~ooN[6\?.G]!bvs`)@Ql'% 3dPDy-Ja|?}|;{	qke5-N>tUj1k9X\BiYZXZ$:$RmaUm'3e( yg#h"D!muUBASE)9wEwOoj<Nu@a&+4C_CZZgwRe.dBdqCCL'J]] Hfr V(UFXvMfa@Ib:8B`3rI$d$J&F=LPTog{xs>O=F[S@ (*4gp1/2pw+4!eDm4@U~nF7kb7N=IIO|+B]@l8xx=zavQ4' q`V_m*3R8w!hWnzsnC?^{YA&U fh!A`l~PqT2$CHTPDx?~s)%38$	D@2-/-Fh0T6)E1gHiiPB oKg_?9>=p	<Adfx*rl&)	SDnX"]I]}u}G!aSz<;S
+!P "W
+JaYZB+uLGBl|q]eY2Bl" B}wI\YsiPj}V$T&XXc<	+&"$_D(h~0AnL`8BT9A'm-~`#ivdl7[pPL97?.}#r&~/x)LXe6hn+hj`Rt*K/MeuBx\.^aWz,B3Gb`b3L0MGx-d<R?A[hLvAQ'DlF'i  +o!%T05\}RZ:F)]8B+:8"h*KhY
+"p
+<*w	/'quG>/^5l2Qi:	Q!<J-@5~y8tF;Xgi"yMQ{|Lm)9O/~?OK|?{}"	y>3:k,WwlY+(>E@.2}sn0Mu:U?(MLX_Z4'Dm	ioNvb@}g!DN:q-*8wN9)KsApdE:7])`iMbOFH7<DVU;FzYE.lPZ `J	C&p\\YF	[L#=G[i)$!VkP!Wktte[QD13~NiS)>(]!l6
+V/y
+@_legg73@(v`Y	rZ?k4
+R(]}Sr5(6)NM\-R&[~bV.{Hg[#f]kU!2B%~x^~x-TfQX]]&4M;zHV!*i2R7y+x-,_
+hOE,'|k</?v8^Y+E=UH -2mE%RNG$Lt6>w7@BK;m>W1 j $ix"*9K:A("rri&PPi'bH8kw4P< h-5LI-RI"Q)x5]j]8DgH9cI4B2Rv0C[{{Q,Y)z+KZ/-t-}ne@=Lqqwdfp{Xd5777:ETfT%{PU4	]/[>h2"Wsu0# 4/r./6J/3
+Y;5FGjx;0!27`1.CxY\3:|/<zt|!n/kyBI!1U9AW{9Wi_T:OXNdITsYhZ]0Zt
+x1~G?_
+??\;L,.(|Vnz/T'	H& Kt"*gz*/#swi8-z"`Nj?A57">cPz"Bebn9[]9[jA41((grl?U1ET`t ]od]zb&Oway9s81hAp2s0a@`t_4Ox	vH)!w$/&7	7tqQ|}}++:\RoS.qaj(wqqqi
+t	>,? Df:r4XlB#gXe&&,.*HRa@#_S-Niq}wBDuAjJhJf*fdPfr6O'Orc|'xkxo-NGC3eVFZMM,x!>ps{&,{xW{(r`hC#7/~1~|;A8mc#f[!*>D,I&^1M@A*'[&F*t
+y$MZ+~ I`#qd7uy;s\>~.VQfz6RNqne9 H
+ W	kiajQl!^p4LRuKzr$DiyC+?1M'1b6n8D}Z5>M'}{i8ZeX
+PC]^g~#9iW0B[z,gtY"3\riaai~QReYAV2EI>gA.	h/c)IK7_Ow*O:O.; 5%1bJu}n%kE:zn_q4&+rw/`^P=Im!<K|'8xsW7/x<p:qn0\imnY$B-%[wkEXqU?{A9Qfw`2fVj["z ni7-g?w~ gplxQi *gGn? RT6EuRpYE#1mlV22bkn!^D/\w`2OKS@*OPpi`flQLG!mr#@=W}ytZo_?@_8hRB4(RYJ-5X25s,56cRc/(j!Q$c>!`anL%.//0-849P%;u8]!3MqG' z!xE$E p[MCT\V<f!,YcB(mD2ndVOUMbAD&:iLaFH6^lLT	`)N
+| G8ulBQ
+t%]y93X4N|{bW5^}
+BtYc'r5g*CZ6ci*z"5Aa  "dkTPx_|'xO!?vbw.FLd+ <2P($7%P
+++K2 OelzH`OG%NYuhZ@{;{J&\D^07^WkFvKNh9w(PDshFE	TGcuVlB9i='i8CKb UE!\\\`:-#v.//qqqalll(hI{O'#$e}"{R,YAS&'>zEslvjn%W$$0$DDWsB/\.)L
+.F bc]&'<kdboyA!Mx9YY>2eiUZy3oP1-FgZvs><;VKpB*9,[aNAN"B.&@z~}>?op8`<Vt
+YN"rzbdAlLUac
+c7#)}_/"_~)?SJ8j.RYL,QZ>*J4 YI1=)Qj"}3';g,R"\,oQW8nrEwNz_6c;"D1U0FQ]tZHRqOXSJZ[S:t\,Fd R]'t	|bR)(-0aHvG{Eo`
+:xpf7hh/bT@(I/iq8pqqqT#[+naLe>ao/.:`YX F%?u3Rfwk &c09$2Wjq0ujPp<#?NYA~K-\*iE^^$vZ/Y\*bFB:[:p"f";GTvTs!$A_$cC.~?x^W+}{[n7lJpVhcEd!F}?3?CY^\'8[xbPsMH=^Kw?s'G-%Yd10Vpfm}EwdqF@gsn1jC3&z`z:tjs>e}@ud.:-i*z:%| 7bZGI}; ::6fPupvy%T{lGjCQXA? hJ@Kb=$H p(FE)%9{LYCZTOfoN"SN>8e/~y@A#Op/f&}j]Ul
+sB/jaXV=[j]'$NGGF3#kH2>BDYf2Y"`A9iBqO!z87CF/:qvxhst+juz":=Hga=Q*>h}9ai+LC[ aP,xy(9RE7ifw>?{ooqs5=i 1b$y);L"X; J?*^RAl~0NT=3P&X"y :"S(+|-=~~~?1~Op1'<8xSeg>zv&CRT.fJ`'J]jNgc	X=uF=:pn}4>c,t 8HffcA
+.c'/: ANiYzC\8+1fu@.Q/)UV)&\	`	~DdJ}Q=6blMEZ}%\~gLl[[{eUO)bfF,y=~&	g5l%-N)M 2p{A~PUhgRIHp?'~?/<%H`"fi!(~H|,{Z$-m\e_w=j9MX_!x)8Z*F;.FKK+VxYHI{DSv2	T2(lp`IQ1	_/+xop8j8^9  '$,="N1s3rJjEu:p]yE]dJWf7/?}	Opq:Pf]#Uo97:!aPR%K9"a$[)Hh^8BMT{zb:w!ONh[rWaS&K@9kPNrSz2".n_F@FRV)Yk2Q*:PQu%*2HDt @C1JNz8qflw[X!_V;=Mif8ncH'V?wHh+j6YV
+j."hs+9'~$2FY(,b>S)Hi1d+/P(SP(NE,qLIPEz$vp_cYO'N2 ru 8M\(h]0bv&B?E<>\)j>z1n>7y{7od)"RN3H{gZf8gxX]jPJoi jS,ir! H(4t?o{?OOz<^4aPe4i\B)2#QA'ukQZwfoFkS]m-tvNl|5<s0W,PW*Y{NyP)YQu.H[h:,h?_Lr`jgU^%E/&BOl*bg\IH'l`v} a=(q	fk\\..LyQA9&)&#Q9]um"EK*2Vgw{?jRfIiH+JhHq]T-Ea$s}~ps*, `NH@xs}
+Rn)%\-?~XGm0 hN7]Y750fXI:Qn_cF-'3v>rQgWS+fV![:d,")"gR$(inc\uOE
+R>`x'x	>Co/^ZG!;=O 0o/3I9sm<t+9GyM[ TN&J AsaD LNo
+/../??p$[ M
+:g?fmwj#i	1pZD<I?;tB0]YmqGUZhi:[Q#!{&sI(9n9uoQGV:D6"
+NYv8}G7k?(;@B()o@(^9c3tBqy8FBwBy<@x<S4V,Frrcs#nw^N}d{~{(&B5nY]n?\6LSppmA <~|	oo"[0.d]1Vw%rtWGqh
+'Y-BYe}N[_WH_J#Hb^A2y$\;BNvi9jWAL.T1Lm|yy{|nz"g3 <2bX{ln4dTI	k nN`R	-uXd,pI8_O=_:I\DD61/L&I-\:'~h1<n
+ok<|_u; i`q+w=tQK;'5ojD;~Xdb4*"@l!\l]D:U_{DsQa!c~zKkm-RKAa}8X4G#^xflq!s7:vxL^lyf-7+-/h%`/_"r_,*OZTV+-=	qH
+Bi]"K>c?~gO/AhE,C*/&9"
+6 F/3O4^W^g=	aee)g:a~Nge`=	SJcck!:28.^gOSx%p:Q$40)3_V|J94	4[B}3Z$mlm1oFE55dgGM9-_
+<1~O X"
+BduJhm@yH;!K3ZAsjBC_E85CQvKchBs;	K+ZbgluQ>Ro	1nwsdd`XT+SWwlp,Mn(xLj.=h%$iut:dD&+'A91p|:!o32!,!IW?Q"RRvE'd{wVU{+VGeI'{L_"k& --%,7:8czh[}Hn 3N#r!`l1=bx)2|-8'! -rPPuEEk"3:<e =bI1'B?$hsDx]:%--}++6NVN*1=n*1F|*9eGlE	OLljL VwBAc".1_%+-o5\ Ur.]NLTG&r{K>Xd;J}%kXZP 
+9T4P2TDt[zM!#)5(%!	!POX-JDK[;v^,DMstBEY
+V*vnN[:zo'j3j8nt'Z}f!Su./f[#%XHB*lAmo!$ns2Baa_jlf{1)F$W=2n7	1DF;=~gnKl3N5J+P^[j{FZQf_KB?r4	.!ap$tzg0v@Gsqbq		d(x#
+	9%jtHCd8D-j( XfU ,>ub(}yg!:{~.2,@>yRd1MB~E"8v\I;W_,Ta6jcn]'fS9.i1b;bb/W/cu;:\r]8P 1c)FSr:.mE B]
+KPQ:-~ I^J2Q/]B`4STGYQ2~@\U*<j!F3u(\D)	`k(UAh`?z-D!.&~(( BhfS
+&VH;seodQ=S'FdnwiE7gHp JGz"URgS1zce[3b,Y
+hn;@e$Y.L,Rf 	r2K8glR `Q_:u<06GBkT7Pi;;d5u~e=}Y-(CC#`%#aNg\@{Oq 	b114O'
+j#SNlK#3O{E,^Lq9@	[4tEo]m9hzKzg6TJPF$PwV	H K'"hrvz4iw~.@l:Z&<7W/5JI55r	g FBu_u.r0Y#n)ZhSu^=0\t@E/lY-\r@*+y`r0`MzdJ_iiK(c9#3HUl[eg3Jq-tB)3
+"5MH#%Fb	9WAC:KDuEB)2-X!	`90kMx(bD_)m7==y\
+/O`
+S1"rQj&1F!@FR  qu#>0ev)u:2.J~Gr`C6Q\-NQnuhiY2i/^>gi:t:t8Vv{O<ai:E;y9j&\W";kb\@+{O=
+i.4gBq.LS"Q16#.{aR;VVnOY]}'n{[d'@ F`xO~%WO	J`7=Z
+e3sOSW]}>3|[|o_-I_r7P A`F,C4KcRqf-yel6	Rd +f1fpBC&,qkk(GEgz<+Y <vBV#pj!!{! +^twM*	 F|<st1@V=
+u1q`t |BI/*G;xv;T$=JdZwqL9`K fhpD9#HFW*6Vq1SDB*+  f{\]mT}H
+pluHu
+gxxzFbP`Js{0I?xqbCz=NNRJ8LWxw9tlDiq-H~e]zr7]juABFQsU5/=^]HY?"*>2dv:M!RIm
+>}'O^o7|oq0O?aYFEbS.HE&}N1Hp>5se6oiV])g;/Yuv z-r1D%xfP8c!fvjGv	7]Q?xXW'Zix~vv{TN+*[q\dVx8Nxpu0M "210	a(8V>	 b-O(*p.5LFq|E%AAtfz.O
+Yr@H*LsO(i\R!B Tf`]%mC-;t`R8i wAc<4M8M'x{}tRG"$+42&iqdQ~[4l7h3<aN3<#/ #U	nG6WM[._-hu;;5u{KO\Jpw&V1VI2<o1qJ.l
+uD^/2(WY]ugPJ	)'S$? 7zoUxN&2T/E ujUvUj1KK!u[XtYAfRszzRlNPw/m-8Ys[>=IkU}O]Ez%0O|5 nfQ`g	(1K3mVz"K8dOHJqA%H>#wO(z;DB$0{b 
+a0'l=zMGvh]Dj{KrC+JF[0#c]&#eul3
+nnokN
+R5O:%.L-nc7 <}X-Px0F!-N#nGROss"u#9Q&;MqwRmxAtSVepuSf[*QgZzqs@6 1"Bfv
+>Bex sv:eY-|Ue
+	nbG7x~	)g9CPJ%!h4C3V	4)88H	(P-%RL^Ialh^$Rjbk'N{ kUh^[k*i+<O1$fc4I:BT={O.9#^
+mH'2Ask_>l
+xs{z	\5vuuBJ&`Qvc"M`K)KCLeBE"-v~Qk;y	5h?kfy_}d0wJZVf1[{OGNrJNRC#v{.,DupUyN	)%L[a0DA\Y@E;.nN<cwk>XVP^_.rK}72VuVQF@IBA0;txe@6F`fKu8F GF`\"88:!a'O7/_-\hk)%9w>HSd<nBfEvZwRvpN.vfPgp~5tQHK)U@M$:"+=/h?;BZ#N
+{YkQP&j@\U;:1$x%8zvp4#R1MGyTj;JUCHz` )H5+Q@t30XhEsT5NLB@'dq/s<%2f]0
+'$0e0rq0 1c)J0<TCbT3Ji cw,V|L;twY~~A$M;`N[{L2O^dP&8.&YW0z(#$>x	<yajU$K0c~`iot1. Di&NF}mOVZ#-;8S8bVT_z?6kHE$tQH5Te2TZ%Hfc*85r
+MYfv3^L@FJ.Ys-2!'S8ps}o^>_}~^}aPVh yC62Bh_# 3!Y#lnu.DT]J;#B! %#3!z2{uP7i{b%ci4	_S s^N$:.hR L=2&L[[,)U;9,	d6`RUh+0s~LvP t:"	Y8P Uab%"RtG"1g<M*aBo,g	rGx8]tEzs4k\knk52a;K^:\1c?{pSJvYZ+HNqcG	v\]]l62;\\\t:A@8Mn7X#RJ)e
+)MEX-bH*T>=,2\t%u:AFqo`Z[9y)l!j)2N5gp[i\1?:s8]1yKq*aXZ(
+W3Nf|~/~[a1 %fir<ORH(5+ \2RV-?Bl5[J,7OTj }]#Q- 2`UfQ:C[7qnFbd;2%hV~H	Otr,Jno6+~e+N:Ob1gOc;dlAUdzZ*RJ9h_{M@'uFz-m[V)Wkrdz -S"SnhT	W:ju,4SCZaheUV'({[Z<
+>`GJw@$/*Ke	b\R,-<x+5xGvtV7! yW9'R03R16"^>:>krOQ[_qf IkT&qaKb|4`b3
+|Vj&v|h]N]EzvP'P-?;OXc8%~?{OW/K|xU5w`lw;0kf0^lq88jf+Z~I:Y6JP&].a]ut$Hi__L^	zP?StvE6ZN,\qV+c`.v)&IzO_%iNNIGR	vCDl0MA0l;BS7TS.:-#F#I%& ,IUCc=DA&l,nA'-QVt04DHVvH6S#DfvjM%,P:+,i 
+<@=`:b]sivu-6
+Vo'6dhf)%
+pc10rP*cv..vcMVEQ RB4<
+aILEb#@1dk4"dMv]	^bp	pNj7,XED/CU*Mlg QHi1		zzjMw6qsF].mBNEWa>9F9+U4psqZ VzKR!5:+?ZN'f 8N|M.@,c!V:(qiwzsNXURVY}LsZJKVe5B KmU[HYY41e&NfN <N	%vfl3P$b8@d6zgKzv?DA]RI(EEjBDp~xR!O91	+7?DD(62tzTig:"@_wk@t
+"X;fL/x!`G/lF7e3#rUY!Du;B
+]l,N	|x<n{lz?K+za{j<
+;BOkg|o1(-[5]_TWP=";:f4}xgZ<s'XA^M| _},i#<~>s}|5~o[<c>i,2 l4<sI)N\cd@(TP,LCDNn m#<yH7o0[Z-4?6	A?!2	-C=':q,uBxv*tPr%7Wi[Bu=;=3aai=lslhgUy5"3g 0'?t,=2nN,wYt':DP` (+WUjwOZ$?;1&x 1q/^0<`a<IywM	C0^kC%;Bgs{Z
+]BwNQvs|wrY`w4)X%*8`3(hvOBClT?9-6>vQ%0Pq0{N'"D+h"s;opnh(L:V,}>j;Zt{*|^@G-]+ p]f"+&qqHUsE{ilzBcMxqO_/q:*D
+DxI
+1JYYh9L1J<x DEtW7+dg$I@	
+YiZv
+^&y\ B@0BnS2kNz^F{wv#AV>bx{#LrVf RQfPgaS6Oa3.0nl69&}P#[<;wVJr~2Pr\~_	}>
+NB7Hd2)akEJ[H$CVh@S)b/LdT,vR RUa::(s	5;c40"o3vI,US0*	WkS]>BC	;i"Gi0C}7a[{iVvsA#ke/1nE`q? ,3_oQQKAM|k5u(:B%B[+WQoEyi5NP2l v8Fau/`l.//Gos|K~F ):P>%gJNKU){?>^z_9QK"6rr{XN$cdRn?@;Kj'3TTUw}:JWvQTm,?4!-Fs	$@hcGFsSpLRZ8j/*rs?tC+t)uNg3{_O $`'`;m@a:0n{K.kuN&_JJW{ZwCaJs9>RD0X35YBPUAh__.q{XndRgHl5mv`=3im3K$A=
+;xh9wDgEi}{qtjM]}|KaX(;) H;Pqy79y6.k 6vO>7o_k8200RP,[=h/1!>yqsy8y\
+waD}ZWjnzG;YYhKQ<6e']+NjbhjRZY,*;#YuC.h[[H2AJ6qq\F)0%..1=5]PA/S1```K4.|eKbUN]y*,@r~d&eadiA`$l$.hn9p RY&=x
+o Hfm9!CPo4Jw".5LHURwt#]}k ?,`)vkwRee,7JNkb!*>`i~H:U*)
+Sv@,+B@JZGj9EIA`1_%Fpbv;|=%U"xS>YVOrpy
+$6Nh
+mc.)Z"s*ue[_ OW\Z==}x^x_|5^]4PWQ:uHWfS nnn7_gfp5 5BT)jV# zY5%pmj /-UPjf>B3(V+'
+Z+n&^" jgR\-	,^v{"@h9!c\b:NX22O 16qp5`:NN6lD l_@V{<]bg;<ST@=4M"28_~NEa WyD#OUb|l/uf	)r]VC0UoBNS
+D=zL'^m/?5(V,/b||:JdfQRb(=+1SOaeSTQCi:!Kt)Xl\,[FV=vEktT	jlHBwJP.MH_;@A kA,. )sEGD,knj	.65x=Nreu_n\)0,g-7C<g|o>~aB	8]%
+@_/A2K6<j+/u)\ H:
+X ME+5?3(EE-G%*YBE7ONztkV_w0,GY+P HRaX&MQ%;	\tgQ-8X"RN73ph7o
+N \}:.-v Z)%ahf6;	%t&j9RLW^/#&JQ(#KXLV]BF&# U"0UHD:)k!P(#	o^iqaqr.H2#nRD>$,(b#i!XmnZOytb\LXU+:Mt%;xWi&l~>Z]wt%F{nEjjnnbzjE_|'#lFqfA7JR4"vb(%s7R8k;*>6oH2EA6:Ar*C6QK-o++g$X)Ad;@?CjFK\K (I} 1`EWH S#iJcvq|=z/_W7x{G:A@Zcd}s d<8~E;?BPCB 0BT-NGXFI	af]0:Q15 Z0Qm63ip} 
+KHA)`MXX,+$}=#(w	X&a2{!rI#OY][H.x
+8J"FTIVOQd[4cwxTA=]U(uUZ A
+	9x!MZfbv!-P0	INF%8v1@V,%,YS|{#1$&nDAj[_aKgD/w?:BruaDgr"F>v/"Hm.%kDjw
+l-qE"*m}S,,>a11'e,n-^8[/C=;,@$^L)79K$rJZPOPbE X[}e'y`D$d,d_-Z@i1=fK, }IjWTV
+F+&P@t.9$?n7}<{</^i>%C'9SFI
+
+C4`ETa?#!*f[kPPmzH- b r"m4P[sI}[3:%mQ]n&m:*;Y4Wcnsa"tG#R+v%=>kQZ>
+s	`f)!h@a82yvfm
+4O)#b'e0-	1v%7y!BR	:UH#I9#p6Y}I'uhfu1b @R"6v[p&fp62T>m2hq.PII4r,JalY(;
+d
+6 &Uu4}A|XWEG^][Q5:}.1hq<ztDfH%mv %YL<&(v%"S\34r]`k0l#K4	ql^xXwkJ$tXRejPzg9%_;WTS[K*UA6MV9d-@["`]}baN&
+t\6~4b1wTW2q<y)>S	[\7y{EAE0aFuPn{Y'3F#7Lr6b-.!,L8jgSZ0LPaB?!,b)8{ER'Fq8e6UCP9&
+;MiadQ8Ut<p:bw1!p< ])4#3*,!"%]Y@1@cATKdf
+Q{TxByN}_^w'MuWn"9G
+e8 yNx{}/wgEL^!jY
+#AaC,O-jo]i8^@h='u<ES>d^|nd]\V%HrXqF,q5pU|qn3"HdY\.]4wNDP;h2|\$T8=v|@)6^;vfpNTSD ,q\#w(FBE"%X+,qbQdFU,bkE@yl*`Y3*x(X\-x_Wx%^}=NY%D5c! =VX(`Zm
+3lJYI(nqO
+{k|[hi4,(ObaR~w3,zuem]Kq@=\
+!ISr!3bq@agiH)xvEvKjSda P9p,(*d-_{snIY\8TES7tW1}``]8iR,lA"F+z5)QZBO
+$8h8E@]gmo5 wX}0	-bK>	P$jru81W}-5oP[E
+R!TCqPq0NLQ0XFc_n4.fTCd)a./Dq?4MUobbxtu*EX\WEYr5J;;HOwe"dgwFRrU;}QL>yrrZ<&'p'Ld(n5@1l	AwUa~>oox_~5znnnu5FJ6a]2Obt|AP-qT
+{g[JiU<{V+5,v}s_]eYy_pwA{gst4!qtCPM<xqCP|7)CQ_ 
+Hy(2NxE^	h h )bUW?
+(gY28T{O`]o R`$BvUEUpLs0KIv!40TA1B"v6i.CUAu7_"t,K`zgr-s@>WaAkZh\bca#k(r)!Tk78N3J:1M{Tu#O Hdjt\pu,WN@@0!b{y>iQTL)DHiF'fx!68bbE{Zw{E[&^(j	!
+*l		0H	.%1}\{P)~6u =G]jT2jACL) eD!C|8|^y?~+W,qL`7)yY7AL=m^]BR%J:+
+/M}f4REh_;b:i \SQ]N,()
+{6V],TH> %z2S]IAIqDC~}}qqqaQkDkfHHU(p0!,vyV#I'1i&Ah=hV9z1/s_x
+#g KaT9YX;J/x(k8:&-6<ARE)Nj/PuH@)T!Q-9<<};@z+yJL{3
+)(|.<_+V SzbmAxqU4#M*] ]$\-o9:e@F-N#4$U%$0BiiFI/q1nvnuO=q]\KL ;Ys_J92]d)^w=30rR[y!Sy"v.Ti@:Wg,~uJ (0J6eA\' ?^x wRDWw%*d.q$LFh{x$NU^zQK?a1W@cR u2TW;_gn%^`#Sn>I#r6ER'3%#'M[r0OZ\\\\ g+8"W[7uqwJMPJET*T+<z`g;*~]!\y!?HrnF5	v<\0H"QG0Zz-;k3wX4{`gsT-W_U`3@) 6	0xD8Dc"i<Ms!08j\*1Sp*UX"Z!\ax<M8M'3eM7*KSB"	7}%^\hbc).btl]cdkpheQw+e	 A:jIhz:u)ErQ9ry2#>|^o
+_|[|~dXm\<
+RNjwdmQYql+wg0sDQw]X' RTwkHY=|le	#u6S 
+P}2, QE$%#tC@N	o^pClW`I
+`"dvM|{\Qp{pd95\+:clsv"#e-b/1g0I}bWe4eVRPdFLNn:iPi^0T!0
+|A?kKS]
+)r+/W=4%&a-.Me!%[\mIF;iM%k7T/nP$cp<0r(=X	&e=5V)g+b']*iFg|q 4O8}3&;*/#*0#(rAYU[#vwx]aJ%Hg;<6A[I@?qJ)}Dmb+FT&~:o
+3sY$S>1ih"7KlX!*f#x?}+|/oqo$`(@@)x8pimg\xOOlX['T
+wuU$f"$~nhfddidPbMb za)FsD2/QB/hj>jX=1&IPRP	 ,m@<!g+xUYYsG9*vv4+J LS~!EYI AhXj/BQ4Zv3.C (f 102<RC/loL9,8gtvYW[pl{@S
+8=:@'T-VegaQz!K8pPaf \DE@iEcEZz6P>LfVPq,rJ}N#vXQ<l0HxB.il1#>|K]StRKa#-"@>h$@O~=?!WBk	c36@_dAE"$KtUAI#n
+!<}W ~!\l{!cfV:Jej%*vZZsSwAhkdIBi=k-03*Y[jvUYBn.fFIY'+*{pXV9cf01JF3QL&La;f,VF 46~_UP_5R0]LQEmhu^
+vAmKY'bCd,OKHy2=q  s8	%'S7TBeRd:A9L _c^ j',]DMH&3~8#D<gk?j_bX IWJE8`=[$.\l1W!;\u|fG]ait8)jjCb0"1@RFJ3rJp{1}\8]'<z= @'?rvNL=Ej]AGSBoS zC}EdkHLc58,yGDb}g^r]m7#x{K<}|)(>{OjnNk6~_.3XxGwlK=*J7/9{`hkcYHVj!RtKZYXw`E1:A)b*EGn\
+	q\iH a` Byj e^K*ivCm*F%ES)Zwh b{~?ypI[8s6>h hncB	
+43(lsB'nBAqQ,Ra:K`\1M%]w?|aH?u37M><>~.Mt{`N4UvqXO#(oM8cpdp<O8MNc@0
+PDC'HWL18!WHJ	*	qDJ=O4[Bld)4M8x	.//t$rU],]c\aD<Y+^y.YRDo2_FX@ X^"U:jAgi9\MC9hnV:#>Cd=L:F;-Fj
+ZI5e\uaQ>LPaB],gSwR)q:oM-[SbIBh,*;P]tr\}sJ84a  <D9O|B^!#	4;gX>]5MR2<bVJ\i{Du%QvHdiDbJYnQ"gu#,5M`[actxiJF(uBnTa "	%``.IPaf;wlA}bJ/NSvcl#P1 ,n@']v~t`1!hVFN	@(0&E\.43'P7!!S09U-ay{{aOj+4.&2D>+DW9`mp*~`FGf@$T:b+8,YMJ&hxyJ@:`	P[xneMX)XQrn8 ,j)O031hV)K3EpMyLNHu;[Q/4V[D"j$R'I	S! )
+ 
+$8B+[`
+i5W6^HV
+VS*SDsRUYj]}`QKu*40t>n'Z<
+BJI(7XzS*Z QzY8-fg[^| @>q	xin]c<@=7^SGt!0SX+p:q<aALvt	pmdiB.@[h2qD%jv0MG2FjLk,=v"+Uf]64/=p_Z<.@d!OLu"PC%'_E}~x+FL'Vc1R?'ePd+%3.^1#9$ggw @bI[nkI%Kv>:vmJ,]';=[1p,jSiv[Vv!A0%! y>!g lG% 23bO]i'r/B,Ld
+`g"vtERW/*]	bEd$`R$ A2kxZ#UkQtNx[M%O9IY*^P^Zf~J YE.\U;z]Jwe`cm]z_DEv9b~b\=%S{"t%k!wMN,8]lp`EO8NC"la.NUj	4c"IaFfX4Ny:!DVN;hKg]##RNx
+^=@(} (B]n_-l=0;;]`v7Neb}$-;YU[SZz>0*$Dp4B@v=3g/.Cv%A-3B^:7eu,&;&-(9/0 rwu
+.hadX
+J1Nr'#M)?:*72Q\&"J!>(T.g9Ha)4_fqf{MAT f9C	G]\^nL!.6*.s.IG	HJ2!)iyU`)`Nu<S1P)\5/@<,I9l("`)&m&qC,"0%DPLH9Yp:fo^b//qy9I gl4@0#"3$L)A$iRlrm5AjsT522JZYL u\FPn
+qfo}Kpe:|dJ;I]^r HMT HwV}u$~5V,6i<r$878_#-..//-rR_.
+4PKwlQ59hOP0lt0n D\^.~ev<g\~G!:)V3J=tu+'5zdICkV3;QVXs6R}EXVz
+/\=NN^tQs#WGGa({b'"0aP@Q<UluRjXd~-GdIi &{HyF.I#}="1j)UdKM}m8uK Q`b1h^gH	5v(Y[IQE}\]=@F=8i1#N{q
+77{Lbv7fF)YLJ7k&	K:G=h8da'E*NMz~esHpH[rJ.LEQkuE}0%jROJARp8d<>mqb1^6#1Q?@10$ Pr$
+JB$EWU8JA*{=<t8XYbA;.=R}jh1GP*a-CXME|]<.pP32%z/ 80J&{Oc10e0etq<OH	)A\c,lBX!HAZ,`NTN&yA8@6
+f1[z!c<rst>.]zSnetK	,hQ* AW}*]NC_I Vz5MU
+jjG4;6,@`&+2`V8h!Y8 !yeA-cSB<wDa1A:lF3/PDu.fFml"nA*"U|sRT$"j1nBb6,bjz$	<pq4[!`:0O3?~W@ zaL%/vNjv@9E&LvqZV9r\(CTG;h=&6J-#0(e.3nnO\6xru#b`LiBE}R FBPwkT]nFSlyn_ojYJXj+ciM"pEQ]VxV4>|g%SbuwY=~xiS{Q]NZ SGp(CFq?(GJ\Q4O1d	Yqqj |sS2i0h3Tio[PcfJh.YQKi*i:JL1DXlZ#8}+mNB@ ;?jMV=SirJ;u-;.P!g:k}hnu^Ir}d;'*Hy'lDY4j(5P/QVw'@":aH=*-elj|Q@A7v:pGa]rK0 FlD"l<lta&<cdNy(h`/Q`X1IedN>pX!.{SS8 jQgw}wle 0p)NBdQq(Vaq<4x?<z@% n \-N9zQMceP6Hl;xZ1:@ hvks'z\[@fcDkG0Y..=wKV,r	f&&ru@"#1W*!gs! 
+&Kg-b|OL|r1!teA'-0t{{XuZYZ:V|{ >5:XWegpabDnmwqSWWD.'Lf+_{3Dbq@T|*hQ"KHtY<ZIr-T?uh_u>\W}P />8QDm{ 4&;;?*=NqV.H5jx:Mx%
+>xn8D)+q@)0v)%9cN3<l;YPU(0Z S=Drh[@*6Q	/PF<=nkP:>}w3"ZqfA#p{=>\=g Qf%YJEr+ZSvOUfo*k;`NMRcw>{:LE\q)<t3aApW9["vG*&.[EKT BI(`J:n6t/ME:W:GJ}5
+%ybt#.g]) YVr%LUS-G^!&u=ZuATf~k_;r8C-Xj	&8w;kFu]-.Hw/ dg~\Bl	9!0X)A!p})x8gD<Fb0#r]`sB>U1zd#`pqJ67Q8A?-G&rirt~NVU&lQu/&{X!P$X*;UJ!A9!NSt\xvA')P?Tx=TCaI^!*K7n$7~?&=^(un>8OXmkhSX5?saw/s!Y \PYug&YqS2R0`&1"#r9geepoG4IH"`%q.Yg,>l*ng,\({;"Ndrw/I9w6sat.KWkI0tccwl].&lzGRmmX"|!E9kq6tVrD#ZF3S]9W;LMsZ'fz@hWzR)i1c<A2UX#9mZq8dop:M8xx1]8OS]&4cm6Iu3G\8,}# wf_eG62n+ uU %1Q]s34>uf/!sD)Q/UIE{aj30 :{&WFg+FXD<@=>=='[|wq5*m:JC
+bbqo$C&ICc>q1N5q&TIZ[^)R4!od#+<dA=KhE6ung--z\`Ksie*V<>Q{Ct8Y%qa'k G:jHZ\pJ7
+K(yNB mJl?Oy9qR4Mo3psk/T"es%;
+KQMt~ZRyN>'6g'zy=OMS=TnfBR__f@ D3n".6u,[QM<'2AHhhu&@NN1.f#7_~vn3ZxW<xx
+w8}q|%:jbmGC=.8jV$`?'& f*qGq cB-]Ql%O|/K!tHXqV)c3Ng|||xpg=!PR!CH9.aGC@>(r;r3'R3hsK|}?zD.!E`ek0!N?sReS	68g|){/&Ao&3k1("nIrpkM*Gesw
+Ysb
+no;^+A3:<mg;K5`A@s)N $XAx*^TA88L/mzs{[	nw!6gM1]%4 :GV9t$
+9<.`qO"/n:;:z{FVc6JqQ!`<hx,@$.x\V&Z~|wt}Du=AC@hO?+<8N0kLJ}\"cuKNKG.|ytlI X7N:Q6mqnw<7bc(NP&YKGs	Mamu}GRQw0wq^}5x}.p njA{vZtqOGBcd:N~`lPiJ{ipA!cL;kqI ^u\_5^,Q1}swc2\83\c!Vai,1rXB{@wptjPDgQA
+]vljfi:wqyM#lvM/L8.c~ekC\OJPj.c2`O+CN-xl<-x[Hf!j|g
+mbw$:y+ l,C4-e:g<03E-}xC{<<"vE6"?o>CFOha]W{K6J	hq<>2xb].Xu AAfvGhun#R.WS('GXw9NFg9>~D`7vY#x<b--@/+Be7oDd-S%//IB6d{IHxpllxzP92Kn1(WmNl:S's+xX~J,hs,93.^/4W 8KhY.izq3.|a]Se.K;Hz&_~cSEfp0Tv<2w"=;h8
+ 1Ev_:GtdN-x8E[+Zs$|#=AsEz)7RH4-!JK#u WAIlup}Z)`t+xCMG!>S(*7~hRm
+*d+E	& F''<==7W| MX"z@'v?`3`b@+uz\D(#iekgt4l?d^m.D"}v]G)<sGX &;|	%~7x/WknlDoG%JohM-AndL/8&M9'jhxxg8<p!7Ddo/)q{FEn/m3.#Q9w_RVuy`E}gQd@)X+<qa
+{,	,.1st.Hkn(U"*b d3=6Y!.7,okK]yMWg}R$YT*XU60 "Z]d2c2ww::qjK+g,eIZw4(sxHV]&i-c,-6SUT>
+Cy5:&-6Tiq"@jsQs{KX ZbG)[W!qGts9Yso-g|tr{@g\A[FOn	bcvxIkgRT.a{()!@]F{wWoPi001#*9l5Y[4ed m?Pcap&4/ Vh.^"?4[!Z|BukMbj*S)k.dm%fPN</t.g!VLF hm/#+^&}[[!T@^lNLgHtg ni02CBqle&qO\^JofAFc QOW1}NspxmMe<|au	
+
+yOg;j~):.ywz:-VE(1fZp}=``BZdw# .K@LxFo}O*bWp*?8PK3p[[=]uGE!TZ@qH[D5~V`!"Gi[Q[5LETjnn:b'^$Fr3m)zRJ+'w|oz($7<MB;M\eP.qx4wNB>Yc4*HH
+'#cG!!&JM8Xi
+xSK)cTwR3;\\7f4MkqXW_|
+9h[m	/U7;d	_tqPxWN/s5!#~S+T4
+XvC>Ggsay%:D@1)1`5^|fjKY5M^!49U&N	 g:)!w-Y*<Ji7;A]p+jp)&"Sg/uq\_#yUR_'-0|..(*WLzw_5UH1Kr)Zi4drV\ ?."Ab~ 00]XF,%picdRQ3;{ym=t_
+aj)W/yqw>A`X <'" 2Qd\W/\9Jgo,nz ? 9Z~L7DjLGf\p#aD2LUmBVRVUMU2 b{q8<Ccwow$Nf}*6i./)'=&rEvx% E%EL25s]$1q6IT:.VE3V.2K,BS&:V]{	T_^^72#/Ds??>CZ.$l9$CP].Q[)1]:Z[QZ	!MR(
+uSP)Xv;p<p^m-@#3?~o[K.#v?
+x8`}|=g,uRWHo&fy&%$|IH!Iu<V~{?#DY) >@! B9"KrO|&!21RLF RMw!iG	-eEPf:z0I.6=V	XQ.'9goy2UEH%D2vd)&0-|&\n\hF3.cN vQm
+ Ka}MIMhfX=mT]}<;(uHz-7P%;y52.|VGxQ{Js	95 &kR7ZF_bE
+/S"wj,Cc(fLXiSMVUp^8%.HL#2
+Xp?Ty0Hq@75\_sg 5q~q\WA|0$Au[u@bQK^R|7# f`TGokNp?b[@:sks)u:(Hgkrja$IA,c {;Yt;l}j~?x7K2q.aaM]p$(TOG<~zwpQrxkOl
+V* !(2H$1yP	A))n)&_^rl{H8QlWBAjThbY&"XEc1F]+"H-dKaHXsfK#O[,FMI	4\Y b&:"4b$15Sm([bRd7L^jz7dQ}Z4u*//"NUSUu|h^82M$Ki'm_5 6q+T?c4l[`m^3S-(t5Re*j	JW#t1x-S1`T.K4|vWuEAe/+/~#-7Q0vu{~u-AT>!*(Az>QdubpwA}Y n8tB9HCN3nSlC Q
+g%MaCzsqAWWERh
+F>QX,,C<D@"-oAhk`=JC7OopF~k{W"`76,w0l1P`hVF=Ra\!If`DHD{Z/;
+N#Z;|s4s_i}$]F.@=taw#-iNE2@7h;AdMuA9RJ} 2-VOGWv?6 ~0m]k+j]b r]T7Cz>KA'8Sbk'_M])=H1o)tLr<	"Os'\GP<~n<g?[7(!`=hqP{{G_Wtmh(-vpns;cm|{7}}`]W{0@]x/^^xnxz~PRZNsUxt8R+j^,oE=uQw7Q.${keT!c[@iwTk
+9
+!X	|I1@gElB!&_ @H)[^Hhjchzm5%Pb-a)vb_4tGwTOjLKDdhyykplWG
+*e<Af}{lC*Z153P|j!Ct	1`e"{G rX=k^+A0xLAhk]&uPAu3W94.-z	w=2w=1wGOGseBb29MZ&%Eg=PhCuq5{~9LcaHA<X!x*/:`J6@o8b2`'EZ\M^q!o
+!p^ gK+dNAJf-(jkY5FF!B)pld&EF%:*&D:2E>-kNEGGtD{pW86t!xl:b	"/Jx5gV&w(=5 HK*%Y-._"s|DXfWpQLsnUHc&mjx^BT" wy 
+
+><k
+A:z?u2s)KjE/drRb|g&';)k^zDM>tG`0n=&s-42.o5(l|)l3'-x<x^rw@#.0Xje;Ls[6(:#AlPS7En)GF/DU`X-[B~V^9k8i2N;q'o&
+ J?&$.6e3f!wD88 *q_JSDgZ;[t	
+9q<3e[xd_,Np?;Ix?iVS71&+ >wh}lnB?*I2*|&QUmCE4<{C_c&?W0b
+L|h+www-wx	a)G oHxF&T !s }]>qCp<kBq!> Obn z|5&iio9}u4~xU@sT6%HdD8WTFgdqKx^n7kb\-p#:J*q[Ff(.X|P$SvLLQ(ZnK|je/DiCU2
+*8hh|:b].(E?&:&V#FI)\(l3Q9d#rwwajFze[b&:lpFu++Yd=dn5(6k+2t]H[V1S1R]{x.FJbXv<2'uQ SS	 &a;u2*G8Ql%%R& 
+WN&@qB9yslVum#'N~=B,B.X'twzuv+V{w.3aXFIdPQjfuK3t)ny7bkw]>#Fwb~ (|nig M)U \kBW fcpn
+F]pC{U
+5#hfy8v?$ l|u^>T.
+BkvK	Hc?IcmEY.3P:
+\"p8|xi+OOXO'7B(,zXQGO8qi*a0x%Ol4
+~GR_#,xMNBj$R;$|YAS*:P e jS:lk4!#1=^~l2Uv: *E_!RLetj
+y|=CcB[bgPl9![$4{mb[n,>c.V X{!H<KS *L0C[Ge\3[/
+n/"n+. K+4d;8<>~og](&:W_`Y;%@ (	@GcFUA|HW/m$KPjB0'$R1/XE?,HC[Wn/-tOkDrbir(9S/)^SPidK4'cQ?#]*{jHY1!S	@4tVMWAO~u`.c[v;GqRv||tx>`^~eLvA_}'Og|`8Dz`g5],n:lj\x>1[c|G9#f M,o=&:w7F>(m8B.>q?aA}3>#su^zVymIL:{n38JxfeD)]$nTls]X#|SOW*y2g$-' k]    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-a-moviedrama.png XBMC/skin/PM3.HD/media/genre-a-moviedrama.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-a-moviedrama.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-a-moviedrama.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME%;q   CIDATX @z^Wk7j.'>O,             nS    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-b-news.png XBMC/skin/PM3.HD/media/genre-b-news.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-b-news.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-b-news.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&0v   BIDATX  0@xV	gV+[k(i%9}             [`,;    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-c-show.png XBMC/skin/PM3.HD/media/genre-c-show.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-c-show.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-c-show.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&Ty   HIDATXc~a@ 8E?=-%Q:`uF0Q:`u z_m  *    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-d-sports.png XBMC/skin/PM3.HD/media/genre-d-sports.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-d-sports.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-d-sports.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME'/   DIDATXc|0a?f!0Q:`uF0Q:``A  h    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-e-child.png XBMC/skin/PM3.HD/media/genre-e-child.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-e-child.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-e-child.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&%aSL   DIDATXc}a  $:8(B`uF0Q:`uFWq!      IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-f-music.png XBMC/skin/PM3.HD/media/genre-f-music.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-f-music.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-f-music.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME& 9%   DIDATXct|0a?f!0Q:`uF0Q:``A  B}D    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-g-arts.png XBMC/skin/PM3.HD/media/genre-g-arts.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-g-arts.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-g-arts.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&-oY~   DIDATXcdp~0a#!0Q:`uF0Q:``A  b_b     IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-h-social.png XBMC/skin/PM3.HD/media/genre-h-social.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-h-social.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-h-social.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,14 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME'E   CIDATX	  @?8
+W.n             } ArA    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-i-science.png XBMC/skin/PM3.HD/media/genre-i-science.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-i-science.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-i-science.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&3d   BIDATX  08* 	gV+[#{r             m[`1O?    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-j-hobby.png XBMC/skin/PM3.HD/media/genre-j-hobby.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-j-hobby.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-j-hobby.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME' 3L4J   BIDATX  0@0Nq E1JfZIN|>             @?X0:%    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-k-special.png XBMC/skin/PM3.HD/media/genre-k-special.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-k-special.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-k-special.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,13 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME&N<   CIDATX @PTWk7z.'>O,             c    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/genre-l-unknown.png XBMC/skin/PM3.HD/media/genre-l-unknown.png
--- XBMC-unpatched/skin/PM3.HD/media/genre-l-unknown.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/genre-l-unknown.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,14 @@
+PNG
+
+   IHDR           szz  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   bKGD   \   	pHYs  N   N }   tIME'   BIDATX1 @-
+@b&])rb             j-0lC(%    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/guide.png XBMC/skin/PM3.HD/media/guide.png
--- XBMC-unpatched/skin/PM3.HD/media/guide.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/guide.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,15 @@
+PNG
+
+   IHDR            	pHYs       
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-    cHRM  z%        u0  `  :  o_F   /IDATxb?>M7    `
+-_    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/Home-Menu-Back-3.png XBMC/skin/PM3.HD/media/Home-Menu-Back-3.png
--- XBMC-unpatched/skin/PM3.HD/media/Home-Menu-Back-3.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/Home-Menu-Back-3.png	2009-03-29 19:58:28.000000000 +0200
@@ -0,0 +1,255 @@
+PNG
+
+   IHDR         x  
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIME:    IDATxMmK%Xks2!DMbB,Jh(XI`Z]]
+7D9c>g=e^g|	                         *X7 >~ENyluG+>'t^SA~x;9={&HNlAHpcN}gICp&L
+ s;m;|DyD$}&Y83",  D _z<q3d?Qat5I^[DD gbszfO$c?Z7+" 1 }H9:f?|x%`'SI 3d?H |/:(!0ccSkbKC@/ ~o}xJA^olf<"}!C{GYP`^]?"!$	k~__c\q`/73	$z&qDQX&"=IGG.K7 :?/c} /f15y=#_h? 8Cz_C} $x']#{A5un'NIZ`cg08G^/E{~k??|>=K{c=0 ?,&iDMj1Y /?w ;NmegLw 	dG pIo+V\Ww: A -}|#\dX@,I0L$5c8oc8KqlVKf~_/n p!VdY} APF-6]f,k*G ,aly.#ct<Xyzm 33@x_B?\vH&RFM/]@7t AxKX65X$1*az! ':<JB0h<C1:F7!kfw4J^K0[/ Xea[1r,FM7}OXL?}=S< q`y]< Ik3	_WXD/7[k&?OTL^tJ1s! pBk-IQ$+,BB( t%_5dlq{tVXrkl#KL gG]BbflKo`a"d-c?EmH?BX` AakL>3X9/Z+cqLI`{=$ .r%5Dh7%73+5d47|ut!dy.P]Ldr.oo4	 WI`B	dGBc@ qg"@XLdFJ\USy =8Uozan[Y3}m (?ri~OOObdSlM k1|V m{,%oUe!'PjK)wgt8{^' Nne~>q0SiKo25L>pU	 wNW{@
+B)s]5apS&I|J7{}#{L!!`f! ;DS]*; .34^b;JB`Yd#"z~8<)
+ |fp{dks5K61}`!j"09aa2n%y #zUXf>uOeI!~|ue~)F. ,D=K2 S9@3%	5$:^zqEJ  @2l~6WvkY`X?.|aI'(R B/CStZM!9lq= |;&3dP[@C?k	V;@.p]x$r	WJN`O0NLg8$v"y@iC
+=!2G~.of1&Z W9s:u0?|T~Q @5'*=3FC0\blO#-?`dLMuQ~0BECZUPsA;U`EI 3	!fW^)fayX{<#=u\'PP A k~ -paT=E1&s#l9yG m^n- 73!#77 /t9s-DV??W4x|htjy@ 7{%xIGo@k[8uu@7 cau'BK=cH9f
+'.m F!|.#,|LlIz!'&iNL#*$z $ A$M}_<We1iC R	__[@@+ YfLM#zy>Y!7t14Ep^	siG^?9~HNv`WA[QoeX9-_5<}?' f(= \:<6z-}OQ3=9-5OOG.#a~rx_cQeLZ@Ax%<&D];=)]%-x;7=pD1m0cg-' 3_bv}zz%\YaZO3~1@%\J%gOd  wQu?YUGS'cZ ^kQ<6 U]V'_=C{ X?g6	rSQ.O_rIJz4.Y#i@C@TG`%CjrUYan sSVg)3L D$,pcX,H`1,b+i6`cM` 8GdOo/Qg  lQfBH[1^Ov\Y/Yg,$YpAHPy RZFfI6NvZA8k0~lfeZU@KS`LMc2*K=SPokCm,%8{(+:cLe~|w!rpR_N+-gC4xHDl; e,)/gZ2_A?G  umvB!,-79]a_ <C]B #Frq#gXo'HJezAO&?XHy9x*p|_ u\/[M:~@-z~	 uQH^b-X'l?7xQ#0{
+jozg~y~'G<1lB. H9p	!B<o4]EGp e.a3GUw>D on#C-Uu9
+*`,Mi+6e
+`WTe6y z^;v h[@3,ec+ebRw%ZW*_&cm	<$~ wrZP@o=gqp~>-cw`uO8h; 2afO\3o[KxYz4+&7<
+P?J_I~0OZA
+xKO6V3,\,9,|rHK$?c0@[;Y~O>	!X4kp{alQ|9f 	)%yN@	AU 4Q{KS {5+/~]8{
+]mx46{"(ZJ[wo:p`&_!o$`O ,>xVY1$7OBr@jCq8%	h~Px@vU`Lag5zA\}w?-_
+I++7~~P+N _O_![  B08][??, C#!Q
+ \Z*'X@c$cL\k0vC9l=g^:iOL~@8DolaCf;,uB k}|2yp7PtAW?\,{ :gr<:jvz {wF;c+
+*[4zZJ&! ogYk _vemu&Ti>t=SGog vpS`wpoYV}r;VMkCO? S ekB"FIyyoDkZq.WFop:aPa&m.b,N#F`$uSpO	y4Gm5^_1Vf1JX#KnpO0T[dD< 3e~{	jTYY\'4zkm&,pKg?R_ 
+ &0e>@*Hj2W(Q^(Ax}l0}Ew=&4k4/&cXa`gsp:t7r_>B 1(V1vk\:z a'*J5|Ut	-7hig@;Ah6q|=U`B*Oz@D M `wF<l{>bYv
+{1{N9k%*>}T`;[K?~v@Qcv"W #d2ni2F	zfzG8i-~/}kWh1| :1f?A~_sV0ac{ &|tW6Oan;-e. AN=q'^1;~yw)^U;nyIltX	P~Zg_YCO6#UVM}C|B; KttAq O v&$ h{m mG e   FoW>n%e5xz3|8+ ]St OX+iqA3<;:0*w88#gmOd+A=!4Q?.iks8A]d~~D~}.!.Cay	49 %?3v6 qT6=<',HI dL>BzM,aY,tF25L}`pd/^625]= w L+q;llg~, f||?j,iD 3? A3xX{ye>6H;69v~oHvd* |7px`@NvIH\?M_?N'X`o'
+mw]5 f|agH y+# 7 S .sDR dIB =0R *Xy:) @*^t5@I@xyOv}c
+X;>Xh hW y;V1E-;U >>TP2\; L - ?1N L? CAyfU4GA BL ZdGn#c4cM< hQ HFc$[.-=^i
+Ax??7)+oE dOL1_YffH
+\}'6If_"Bpa0 $?ayOq%PB B  ?J/morB\H_
+c# |<qnSO`OOO$cg_ A>Y"M?3K"%Rk\	C fkb_h>? /K'#wlh@XHG<  ?G8l^O@XKrbOOO?),3ULx mgw=C!.v	 !X(A,`E $  ~1s8bwD^_^pKj10,izb<?e ?E`0^~/_.dB   YH  ]/Ng?PIbYN*OpC@{yBcKJ,z6#bdX|4bX\ 0Bm% AO}.;:F}az[PJK=Y7(	dA^1|!|4$ A/)a7^G* lY=f<0
+ F,gZm=]:5;A ')r    IDAT8U~ U \yTK}F}/w-6n$z`^R`]y|< oF`Ik J|fFea!=|i?z-0,B!0=< ) S
+c:M/I#+q2wy>Mnw8v363>MTG	 8o|N_9Z3g)|kI  a`gg0n1{?y*@ XQD+	<) x\j^Nh g O<Z5 A>dh`ab~pF4 1VS0myh=O>IAxWpKs1n mJca fa4&*7P 	slGZ	_$yA=Cd/U}$Cyx4}% 6m!K  |}uN\XZY/p)Pf,xXAO) n zwS?#d2KR Mw*'~Ow  Tao/p4y65>W@S+'C8]y>p>D Ag~@%#j[Z`];;|3FA@ K:7*s6
+@AW
+0Wy%7 *Ad@i{Np3iEQtUi{$Wu@l?	A7&,1ikhGm#y Kt8(< 2A/ 7h> xP&3f`^z~jlzr; 6$_ AA\[<K(.gI-`Xp6/{_3Agq}q~M h",r[p]xDny#C46S A{[87hL,Ct+{Q]9#7 ?J	 A]vw	&Arzty A>}^@m+5/O'Pvqcp;
+ uANo:cj}8u;w^T?I.#tTB-N,a( 6mI'9OF]7D~#<Vm>^Mj?Ax 8='lL}Htaw	k#|(%~ B'%s,yQ/m pub5O' h<p)Am{A&`zM} A}h971/>h Pa{-92 :zQA +qD9  B4Iy{4{?\wv)q[4h~; h9AD'n -Pog>/Nx,|aZIT1b:AkO"ZX` mc} }yP =W.#,/pppo =GG W N H  |'K3]?^	g/nV DDYF3,M/ /P;;Wqr vw= .}6<ew3
+{f]Q[tGO{   fCi!;8~=}` sojcL}:s,|l*0iGNyaGD 0&yKEPoX@4kP|(s!=R[8EZACky$]`'y; ;_Uz=)H av_M/ag [r u C9 ?tBhpS]7Pi0y%A:O;jSwzmGco_6qPm% A>=F;r\yt; n~dgS9pNd  |jp^ MV-x;>2k&w}A|COx03WW#?L/  c*p=ONuA i_v ;_*$D.V-6p{TJ;/'XzK U cD|ya^U0 , @: H 8xw5>(N\8ZO/.!Qc]^1Z` B " YHe  0&?z`m:Y 4.WR_1%;\~L;~w HV6Ou,nm`Ro	?_,~J $6 tBrB.s8]ffcH`A> M\ 9Ovlcs{	dk=pk~$/zU0-`#- 0\]B_/2S O+ 8X2/ |_Wt	X\ay.  &@00	 A3oxsYXvPZ=WR^Ib x
+f>?~~qBXX<6.hfc^w5^!Fkb59iDd1B|y!0  @p8y)? 1o6t2];~V@*sH,__k1tqA~qq-D )B,w"ARpxc,98)^ sy1V) F?owJ;tG Ub >`  t} =p,R:A3xf"Y&AI3Fct1n<Q`kr<y}rD6zA[ uF2/kG3L<L~?B%/TF	?~`$&(hZ?g73!V {}sHUFb6~ / J)  X,m s  ( }x:>N3Lb ,NY1[hOTJ[eu0 u+ &x	s ;G:^NA)kijSwB4: |0=s ~ ~M A3%g Gwy5# ,Al~q~2xX&',^/
+A  Nf?hEP~l w#h5D'I|c Ad?n8ZfZ0GbJ7} apqC:}M~f'od'527EC9" W>\8+AK]~s%	 |hpXR)=:|Z,%)A;L X}K=n@C9\S[|,VAKQF@ ?{1w>17ifg 7]@9y
+OVf~;gu2i0KD\nz w na\A$L#>8e0:o:gJ1@i{vG7-4$[Wu|r	A7{cVv]S@8
+5 qxc>$8` y
+$ b;t	qS]/v`MoUn a`it`g0W7Y~MX |als/% A~P6?x;'vH$,^d.62vMYA> 8}nX0tH~X1AOA1Lk5lc$:/ `{#  ~]t"n	
+I}/ |89Gm+5/O'Pv`wAxpyG=y= b$?G8ZY$0/
+/o z&A ='oO@&{Gb>{\-5;niDGQ8Ps Y O1X@y[?P>  0N;i^Nx r\SW4PB!+epyvo~g IU3{'RZ#O|<Uv71x9 5	k&UM@6<drQU9x,O kOAQ <gd4EleB.Yr o>  o{>_?&GU?xKsI_W4H@Ad,I T?T9	<hAsoii)Mio`Z  @9G|.gz1I}Yc(pO/A; ',0"s1pWzv-P_HP@~p_jw\ymK?{%*Ax;kt>xN8{~"99aAOT!]	Ax$L3n	 07z8A]?w^aP+5- N\:UA`/1O6~%0wMk ,|l*+pzgUUZ^OySAO%S_Pn*wtlpK%J L>h8I({  ok^u-w?n;cShBr lczw*cG=,A'aefM`|'Q2gf&|'mO?.8_c  T_{W5zS]g2@AZsshTm{|CGp vu:b-\v&/ LM90D ?8/ fsQ|*;E<\3s$N ]e#?6Ax.=n nKG_:)<yxH 1qff! 3! B0  Ze{":aWBYsF-iUrBO F2_C	ZH hf5KCz&12D>%`R	PH<% $$iJ  B./|$U%t 4qHZ$zBx	srJC@&@ rp CX-{,X< h<  y AvEivz	n  /Z@ 1Y 9x{IKDo.`B =  7&#4zl7[k}*  r/.Z #f	oT`H9S6/O`.VXcIoY x?px|G0']v7n%n(8jfkz]]B?\^z
+`Oy1   z!`! \, r By A||:g=Sw&;~X1p\rwH6#S@4/1so~pQh*B+0?h[?%_/@{f9%b\ ,brYDKL?H Y;q[e2]n2	]Z5J,utO\bfl/f$c$A@#ZX*t(w^eb#i///Kk / x@%A!;r,Rlcc&E[k!\F~+ FB`4/{}_E@, [-k$fG# L@cy =b5a({D!ETP^xVA?/$q@Mu^vcV+ImS+'BU {s[{Hyhxb0 pGZ< u;
+0+-&Mw~4L p.hAi\\P_N;o" X,]` ?&bKQy_ ?k r 499 n >)57(AR 0 <s%N3|0 %?897$ Ly]%pC!,'/"ZAOjn/0|[TCE|pOE|A" Nf?hEh xw w#$5tiOVV?A\?n8ZfZ0Gb&P=c <4P&B;hA	RLu lmepw:_6ps5z
+fHCLn_~~2`]4`O} AC$=|*3joG!KcHdXFH#$W@AWPMyeAn|x O=}{3JR Mw*'P>RrtszAG`s-m8=4`rqY7nh	 xSf@wxts`k A lra +33{NV^fVY=mXr n|_A?"nBs<0Z
+#  307I~
+y G n_J[]' R5    IDATM&>.8h2
+5}`J~Z:=2BeeKM0Dvf< +W,(up~AxOX';3f_z}\20 `CK	 A(}-H$,f.62vMYdeAG o]nX0tH>r6(pd$QFs?AF?'a>k>	?	X^&`uH [o``L} Am/rwn8dY1,V3/Q];#v}3i>  Db9gf1LN6Ap{.CNGL1s A$/w}LnzODlfXh:,d |4IgSJ?O:*FI 0(sG:wA_ =cs]1goO|? !Z<7CE = G@  l;udNtAwYkAN%X[9Y 4,. 
+wL9^bv,d]A p5k OAK
+*Ku{zA\H9n8_T]R;_cdi 7 z#o7
+ c{oK00^D%}^8`	 A3&c_ 5L
+ 5r{4{?\wv)q`J   e;yVcq19P!.^vU8s'p42xx<\&8pK*U t+T|zpEy)/FQa4c~9PA
+ ?uHV\A^3?:kYxsnMZ|$ .V!0L AxK3mc#ky'*Uq'6<T*\bU?>N;5KY f|d}LB8(q*	GN\:U1$SJAx nKLhx)z0l3X1Y2XN9huA|nj xZc.Z^OySAjc_Pn*wtlKv+/\
+/Q`AIEN Ax[}*o?C%+`3`@xo Q  '6FUz [qsz3r* E<=otgYp4	l,ZI0 J#iFcn`J 8}?S={d{?v_uot:Mo*> A" -:8ZXw=H<\/.@2[5|\+@A}#-KjO/m)z pC`u~NInZqhfB0`@0,  "``X']y%ApZ8gf!Y,ahf!8' #\{5 qKHp
+PE `f1B v)CKF u}\'L@aW Le>H>es`t7^d?;7g'
+  H!  Bm HFE( o8gm J\}jI: YZb3xyl"` J8! 	 A{f 9w@4/y @5i	t|N?.8]g '?lK,	6n |=L{V,~ao/6O7 @!B0ilF0\: Y3>lMte<X_].v:\334t KO?e\G[tc- Lc]/^r	!, 0 %X@	$EB@O, ,@
+4[cuBe[vfykci)gqs_C
+t!D1F<wKXOd K  h^u(.'"]\X< .{?}I~21bZ PaEN65np{0 `$e{w	%+ 'H[znO3`M"PM2)y14h6 .1kS`Or y ACk~M=sD60sGIe?,e>O ly$Y s9AY7sf-PJmw-ov.20][uq\!8C rl[;t ';aY'k27ap5
+@nkUoEpr{xV	}gy=e_oYcoL+Y;i8
+ kzxZlJ<7M8ZK`C [I  !9n o:9kun/d_HmbtGI.L%#;vM"_ , %~'b=7YNN5-'stf.Me;H]#	An"OY/y[cy35VlY>kILj7L~A|1+ F>8q? uk&8]./F}# {4&i2>b-= fVbG]`h/Ax sjO0!\<y7}_hR0_>.z	 A>`jK\Aw;V[G=wPmSAk`3sAk6#2 )e;gJ#-  ?W<]lU* Ae=- 0,_d`kM.Cb(P{F@K  w!til`C@kjtIgt|VfXuO`tA\K8!D o" K <UB3h=;3	Qa*
+VW q"c=5xLdoNwXyUr&WwB[[s#9!z 4I#6[_t/v~i)K(c (
+`J \vvXB	C%u}=SFHsu{86?s#apHF WuUpG_W? Ag2 .CmwT9
+X-xuB (hmN8d3L D50S G^ ]@W oLg5N_ka0X_Vm	rG%G"-r Aqw73? %U }t\zZA4B [6X-@wP6 ;qgy
+z@H:H\({
+N'fOZ
+ 8,A%\-}Xu'F-\K@{q9~ HInG3> vAn?c}Im>\789[}sdnC<"=?Zv5IaM^#$1rz}l~l}hC	'`
+zkhu{>`O*!C	5gv,8L/suBh s$A| U>5As/`  Ov V|`s|SH Cwm%aeT@.z\(!e=	 _m	_7o3Pe |"Ya@vO_['c.{&+QLN	pS   |fiB6	wS6jk]k~O,xd:diuFUM`_5PA8ECdmk]%n~~2`j^6?x. p?2%b/K[yoh=_M'AZ{~4  R )aA31\?7^`OnjC3!p{|38qAV=o}5;7-Xiji5 l
+'n?Uph{* W3\_~\4%?v*x cu`g_SF=M{x.z{o`_4Zjv?&1:tw@-mIgh5'6PNsjvYHoHa!eBU~L/{jXt>zDn -43;ZS\veBXx&mD	VrB7Iz0HX k#M-mYmE<4;I6 |0uCq&sZ?v bo_ev~ZR@}l?;k
+o3P@Gk`7'e[=kliut@Mdi[/Gc	w: ]@f0Uz8:Nb;9$l=`k\MNd^!x<\A] 8xNIu
+mB^kBEX G|hT o\8<=Zc>yv&U`kVz7cs;5_lNhM3AJ<  7Y,<`{AXRo'5I.{L.
+#|= l?% >r>l;hyHe5JZcjRK=am0VE!6(iX
+u@0X#,S![) [pjp.p=o& *&%P!.~ A 8oh O *d}n{oPG43gN p+ f[?		 |'L,|D:=8'+$wQ(Wp lVA]Rzc=O#?fY0`4V9
+ o[>A?7D/ThS2z LJp%q#Xed(smKStoAy |L 0c<@i?izVI4dk>\\-"' *ou>!Y{=a4iH?UZP#ciP~cU #h ,Fa\7e
+`*De |T1vq8S^}BXapesKAk"'-#r@}1s(P0JSx*7 + c<h`B	lF,h T $;+'k 7jalJQ.O_Q#%>.6EfNr^~8w$ lwAF!`!~ 9=_ `A@F}7i%oEv),PHC%<L@n-d'' |!7	V4@`Zayni .  R	 A><0V<[;77v JdmW7/H$7q	:oN!f= P HnVxyyF\x.` 9/S@
+@\V"a&`;W-`~<L_>hc].lK$F2G`P`K!\H,%@I |4?q7v9k!li_T?mMDCo_B~DZL|$,cf8?kJe})\OOO\b_`pIVh= )P A> (Me:*ktsp~U]3kA? =K@$7e3#"eDp	 .p~)%k`d0U$PkF4h1F<=rEFp ,0\/ j 	 A>?kFG~@wxcN+sK^C/8! b|u	h`f/3!C?Pm; #lH].fJb . Ax<0%2Ewd^n gOI+ @Z+a(idR(7	5s"3 &~6E/k#C# P P  |dl:4:8Sw@+f
+
+ '`<"2Tev`};%q~<0XI	~3K Ax0m:|cYF`j OW
+ q@\Xmi 2s > xa@wY B0O3qwOLg3Ul=` Fr tvu>CuKUAr<{3	V=qvWy}nmdZS^ZD!VCQUj%zr 9 |a,kNNk(U=SlN4PcU4{YkYY&ci}@V9Dv,w!"s|+c6S:	/XIH,uqyx(f_J[X) 215?Y,n A~l?(=Z`wbE07cO!UNF Z	# B$ AS0XAg sX}^96, -ilp^#c$w?/S: ,AjJG
+ AA?m7}/q{@w3l9*$rnFuEvF    IDATnND}	   v_sW 4g' us-=g +f7A('|B!{S@O3Cfwq;mwnJc!?iZ<	)^D|PL^Y#O]k|aTo={~3g`a@+Qb^|tS~*1*Z~]S@ gWejV6L;0J]rebq;lL^M.QI;]~[l%"u3Rr6B kUed@7@)s(Q MAx[=x9~]m*	hm" }6*_"?Bb
+[sy<Z TG5X&
+HB`m#=-\9_3A0J U A0]OuGuN^$\uz}593s 	%/0=+A#01?;_^(^? }69($V{f<|GL4U^bQ"pC^ g|!'/F,Inb{$e~GLKU2/sZ)WWaR3ye"IrN	Qk<N(gJ71mKA&D@<w}/r/pf	")Wf- dk+z1fl~U&gkU;e 6r/r/4&;GG]q$h 6i!t0,Q*7Xd8`:of` 3F
+#?{{ ^ZpkWr)CcTv*0,f,M|G;s"9=ppx1 ]3	Y R9*}pwNg
+cj x&C`Lk7O6n&T PhEYxPvQD 	~o}{{I@3T-l6A@<au P{<DEQ+(,C%P3$N.v Oqs-^^:.wgUYFg
+hdttv]k	4pUTh' bq-v ^{{994n5Y,97uGbt1EQAG0"-QsEaf=2_#_v/r/g'2x |F3rD@ VRw6A&PqI>H #xNo	Ot vq;r/; eme1dO}.lD`h9IwKW~WT [n`p;&(}C	 '?;{?6]!ill0?}u@7f@mk`gz.aD-aNP?^KG	EcU8 dz>VaB^^dgMUaOY (P)`W5Z>_Lfa	z}8]tK@m~s- mQi	Z:O(d3Wp >s@?) ^.8w3%sb?sd7c.5/.a ]@-]p`a%:	Eo o3>p rs%m"I1L
+t}-y\"ri8%wr 5%_hcyUC4M# qC\E&&:xg"R:A6{{A\E.gC7FK@i~n{L?waJv?qXB[VC11)nHh)a +
+PoG. S8tMe?OJJ7vOfn-}X[#mVAESGjZ}pK"qB?Wen_17R^^~h(]Wr4|kR5'N&tddtaf g$t17zZb%i~' u(3p/r//#Za8 qxemD g#?g9>oTe9 X'R	9 ##1VN8y{{3pzd0*EJ-EOCW:`:qCA  T Ado?W
+ 2z? @%Nw, bT?qirO< ^;fs30X-W1;o" sr0QPBIGNl,*B
+U@w*q8Kgb_$~  I:9 r; r/ 5O""0Oqk=)L[a	8e=Wve3H@$H$#CdWe:gh
+\ %^ /mKHG/~Ot{{yqWuH!x{%x}*shuAhxoQKmd@:+#\u,E6?m_97sgJ\	os|/r/}0;%~5~X` 6V+`=0	 a>5AAHZ7G$7t5?Fgi$@VTSN+K |n	{4_O`30voi1/#bD6w	_ &7Cde "Qa=7|xZ<#3&ZY,G#v C
+?}&	{TfdM^Z:TGo!1y9C&[1n3YmTc_|D8`ok7z?Y mr/	?qkTKvO-{ eQ.F@ yR>u^36t .% WC#3a7y qpNr;1}HF7Avk8
+u{4+Xd@48;s'Yn|"{"^^~r;{hm9Y0=1aSX8/E22Fq j!@n^^"I{xrBoM'q~
+51#>@b.!,} +L[(,30Ehg=Dl+!'t/r/q @^DWcIwDt?S@:Yo jH2)DV79V-3 =c9VZ~oU\r/r/1GN>Ely&ucARes!g<:A+cOW5'R@tA07 g`8Y4IxQ8u6{vq@ .w]|^[C|	^,xlolw,F"Df:*LJ$zp/yW@au9$4@`VI% (B 7f ,vJHt2(q?! +<#i-,!g[(R$BT<Y;<V@?+	ky<P[Lh!IPR A*?!4)c,WZb|$oADW6,T/v :s/}s!GYy|KEhHG/ Y	Mf?SJLH$)%AJ|KI @T$Rgw^^~z37F>e {'$
+{H'yt5~c
+@Do	o~DYnq O: <\|C[/ `$% )	R/ %T'v ^?"io)b sFpFi^j~auAP&0U]l4'om,o6= [&JY#%?>>>P8vE |G  Looo?~RB~T )5+P3!Hop/r/1964}n57
+"
+"}~ws 	>[wP}`t>\ gC<",E|dgMw,n
+%2%gJf
+I|~~l$)z-]G~o?~0:C |g9>j)!cLo^^^;=FO>D?- p>>gT5L1@o&A6	5{Q??d +P&et; s12'$I||,x+X LLQ?ou {?laVvnRi-"bGtkE\dZ`c "	8~OF]$=|1#cyt=[F6B%:t; 2e~>%F	p(@Rp n~uw4`-"~%4qMbq6@ 0ge`H8 @9*ZCCp`-` 9D$g~1 +C3_3U?c=dOG "8W)^j}DpT$?,B-[
+ S>4X$8W+5z`%iImZ6taDc%^4i}iz8Mkn{iR[6N=i#@W2`atlC Ihv@;(IL*0m,|$ : _CII"3~,E^m v eOiwWoX<_R^"]~*zb'gYqQ1)C5aaR- *zsjh ]
+Rh|L	%"!:%%UnMS6OkErV-nU>'R~qo_BP1zo$SHh#sbeG lQLn8HyaQB\x>/%<U[\s+.q/r/oE]vM8\`cP2?rG5Z:joifX{_NW7hf&.Fck6]<9-K9RAVQUp@Nv
+PLGLRxHFV7R[q6~~x:YxQ9E/X R
+bzx:7vfi-myZtJxeoT~4a`gr<x:9	nhuF)I	v9l[I/ ^y.^C`_!yp#.8Bfdj"j|##qv"=fLwGke[OI|/l<r <OO9 NR#L{(6-^
+IR-5
+lypp6G*X-sK7p]N*_wi4<O	42`AVU. y J, WWM^i7WNmnW+W<<yu;>qkK% y7-aDYz&M'Ah q6CqU}t>	Mws?AN"tF:rcaPK_%]Xau	~};Q+eUrTOnnh	R(t y9H.; bjNEH] SWC&B~GPl"8>1]gM6\]r&c;0^e]K>hOs d!99 :	c&bm|B!"}3DX.%yX,k~WB#9v	e1$WRe)I
+UOOdsFjL6'~k]F^96=sgxCwc}:-I U_r6D!K<m o}NdjDj~Z[5i `uY:jgY 1TDF3ey}u/sjqF47Gi #+ fy1H!^>_o2j?c$H+QvU91{( e5ySJQkU_esR68pH2;5/%ReMskT$-g~)Em0MJn}Uj#bz,@59{rj	#s9,2a]
+:,. 2N^^oy#peza~.J	j6KNefRp1NN8oQ_)A97&@
+rho?,	nh$D2	\mn[Z XQ4 V-1%dxvbT4W<;WJWxrn?[+8\!>6p<&h6$*U> !9 JG9pxoYwtD>p9yUGk+s8$B.#B5u.Cq; _OIDTy/ce`H/&R7mlpk2@Ht Arg30ADS:btL1R
+i,EV/5:	]`;g ~[%xRJ<&\OvFao}YEczaelMrDBptqh|x"hpr8:o%uq{: wk@[1    IDATOqO;?7yZ 4h	\IxU<f,{gq 5P/d"s<@5 n0uiI=$dztO 4dt1a^x8 =&Jz3u<sL\s=3y_#M;uydx!U)Q,M|Xq=g0pQ>n@(}rQ^:"X~BP$&]>Oi?v:EOvTN4{f.8Kh9 0]]H(|OI-I&FjiKJu0~"\'s{jrbr/8!@k+q$>Rawom	i0^]SsCJ;fUetV^8sWU((,=WZ*D9#&e	!a?\_u3}>s	7I0c%HzhXe>#@.K /-2"K Q\f	h8L6e	3 WlQ%('^W	~ZLE&i CK
+G(\A
+(B=5e4\\B:W8Xiq.bZHk4:i
+~ _yw	89XrrX/f8Q5|v	ri@?h Wz@N0u1juGjJW1:u>|^kwr Vc~5	bIR(oK^^gaj3b^ ;8e[F  &@tu+QVDw=ap 	[3aY]/@>2JPC`F_ xsv!;<:Yr^ql
+iV~w 4 F/K4&cT_5o:u)3N605-o @5Q6AED$KK#) `ImA,) x W<ltBNWq R/ r ; K^&*V=NFvb h6' /SC'7,7&8iHM(IR%.p5);A'=- 	&H7Q<_}0i!)M=,"YZ@rt\4hSy@8i/~1yvk:fx3O!!=g*,~O8'z7xx"y*&ht9_[$Wri;rW.f`U80%5PZ6fDTRn}tP{1?ez #gj G/3( A!'/R4LkaAxI`$=6*
+/ue^n;{.r Z0Dsa6#jD6#T:n`1"~Iwz.9Qt>tWwB>-0{'P}UQ}I#@CzO>l<	94J}]+/|^t;2%v{ZN10Q`b2eV6=AXkg	#~fPkyUi:4bH:R$
+H zR8l2g)	qKQ[RiZ9P=GPixjFVbQ o`Zm'vww	.9%Zk'/:> p	g'x6?*x*HLi9G7/<^GUOCh47N{5d@FnT@E0*>cequG7 !/r	^)D?>kiv{H0`jHzjzUipm]2]uDc\g:u;"Ru3xn=o~;3(lh0tA$?B)sD	^[L{14Q!al$=s)L#5)R=-c?bV:D=D8P\_`{+rq+S1VGcD
+9}#dk)4Pv!cYiRmpFOWpS[8.X	!hJ:]'K?do(ThJGs~F[0 T0/.1XGa?k}w^~v:q72<h':@ @uV(
+u
+~AvM@a*}tV5R
+X'{[AJ`PLu0vBvB(BxN.poq &EMf,Y)=[SeG)Cfb(Xi3++m[Ecg7&lITJ]*.&GJl2
+V'x%qP@t)0&x;xd2}"<BlxX>{
+pRVH"1T-9DM
+H&	TNS;mPzCHR \vJnobI#en{=;pX;owt-+	(3Iz:-RRDgMa$[484#xhU/40U{Y4<C&c2V%,ud8f0hc"/^$bPVyhSo]>^gqPG%g[_U_^Werp<sr>^{\X8XsoawjTAy+G;O9*[<Qz|3B}{ 5as&K*Ue	&
+ocT)[/(LOHsRpaF6"tP9\KDz+@q%vX\^xm_QY<m<u2he	DcuH De+ ijZ}d+T=bF<nBIS<U]`{ls6z[S0ZCtDjxc ; `Ph..HRIzFT?JIv"*ATx&3/<#sB.Z:Gufg(xYJpW[)bMJvj:"?TQ%Qn L@Tj].>7iX	`bgxM	WUD ;*9[dk`VR844v T;tOe`}.)
+`M&3|-|iyX\_xmg<_:g?{~kFFI^gMh$,&iICLdD90W<~-=8~;|NaRd
+\R=&9!etym9KqKxk)yix NuB_r}""qE-K,-=,7
+0wldb82n?[UFrY^q.A`H<hf3(`*7{H,Rj"Z5W-Z pZjEg$fXv5Jx\_/U7Cw(%_L`,[,N\VC!1rzNn`'|4i}_N8O{	ne@&bw%K	W3`gr"e#0?snxe5sU8(91ZF`(5g-x+ :[z}">#W KOelK %w\7}2 @= 
+q- k';oK8F`7h>krs ix EkHV KU9{mCZaIA=+c(dl.B:?OR)gSg?[xQ;;qWf/ddxwZiO;i:9wIB;BnPbS/<'
+`K@2h%\43:PQQ"#5O5)l E)3KcE#33mAi_L\%8(GM6*fSzfa)"!y%Wwwjgc	]u`1.sz;<rX\pH_~puNyNj' JxdIu^"5\C1IMd_jga4B+62_:)@`D XOQuwQUi+u&{p DU9T
+seN3Ti:u`2>[L l6l+p_M-Yh'FtwNX*|n%8\B;LN:coW9d^~579_^r2za3sZwpIf2:``;kE\;0v*K,w;{KPwnpjy<geXRm+ 8|5 \`N&K#+7^YWwJ><vz|v	~ru;x:8:{=y
+B Ip}-pWIQZm}0P22gCg.q1[WkjP
+`s 2%@': s=~; {HP5 Z`zk7mU(j_	bYy-#\02%\f^
+54^rdvrwr G0iD-h 0;#YhV
+&*:thh
+h^o1@[NkP+}HT@JX4)l!V!9:'yJkL $?wMJi4	 !w-;hv%mq
+2UDg1QsxJ+WGk2cI!D(9Q5:\Zt^KRb!Il:dqyN<6$(O9_7NcZt=w2oljt
+ LF9^	aR2r[D
+-h72i6n.QPJ8gs`4~ YE:R<Z 1C|x[!bu&a'x7WdD2#&}?Z_WnWf^-u9:ub>YBn89=
+ WG+TF1T=:
+6M\XDj5}'
+I7QfI<Nj4Q*|:R=M_MS&1PyZa~]j9@l*kr V4~JY02Tu.Io3ePM(47	10&5<07c*3vm717''v<9*$'qqs	th"+i{NT,7t(0-; &%{S`CofGFM8HtMz;F=0.\@=GG)uJCFg@8D	G0`lF6f6jO	: , `@M0P)	X>&G-8a}J&Z&D1M!~&g	#bj`a<
+9F)Ng2rXyQnA;,
+L!X1bvy 0p-M/2,@UCtu<VrX|{hv8>}zE5jYu,f#s4%1P>ptCei,Erop
+&8jrF! : < UvJcFI5pJQ{3WZ^xv\3l9?d#C'PBP*F kH|)y V [<\KG1"zwP}qUkT8%j8
+8VU:/VGmGuU8^UICG!SlGmhiZ(%(7
+KR2`/qImca~d[195%K^!.\s N3sUv&IK2<gQ_!wj6.B^O}HlGAgwf8Sg0p^.	.HgTQX.>%Y*G>9d<70N7cNNbg8>{-w2k*E3F_.1Jyy4.d8F$BBh<?8$Eq@q 2x<QY7n%E_ jyKe;%Pt Z"2u h+7 ]xmxx&)h)SSV^>X]Jp1f8l;,=Lb<ubqJ+x&)Ut\bwi}kw$aYNzd,p:Rtv=v18}-'&A0 !JTn}g\ro#o<HhFmEy+KR5}(uS_2j4K>p N/AvK| < & $)Ij~Jr6PX_d"Q:GPg[|
+yV    IDATX{NJCl30re+<uo.=j88jfEIe=sqw@gt]45|
+<~?d}N1T(~ER
+ } Uq[J6D\;-`_<y~R?$I7HR{XP1H;iNY"+N|}+,.<'nv7^+bda%S6t0 "U<8|99+|Q_0lg1LE+]K		805x|*Os >\R1IrM j
+$MD0-m<@k1&3 w|e9)Ft!V`R=y<2I: '~]sX\[B8s ?YFz9Zybow1}>P+fBm0J8=@\4> 5 
+NtG &7a~#{Z~+wH5Mk9 ^v1 "$H&H $%ooxC.@*T[ $ !&V O
+}s@x;: ;hl#?$8<Z|(0MTzV2>	xOFQ58z	yh@gfp<,edDLy fU|S@:1G9nW x}m@0g|)?X	91P  y%'W[]wyT$EUR)_ghZ15]t)rkOt|
+Pms3Dy	@'9{fa]dFV@)m`X<Zz*4$5!7d(/ u"~A>JoI
+@ 7"Ho>vLCOa{hSIj{Hm<B]] Ny4rk`K'kF{7 nNUXq%|@Ft@)DP9G 1xAFB$	 Ui`I{=0+TB9% 
+TMP7;M G*~gw ~&I )9Nf48)TaXkb*6orF 5_/Y=d&kFgcF;/pFvw^RA5C\R!1~)6|iK=GtB D@6
+bI:_%jl*9<r; Dmsccp1}9qS\u*fgv2u;g?JpGNpboy!jDN4+gK~qgmqrEF81*!([$Z}GfwUNuld8|)t:}no]Ij"Hq%x*A#F]<i5=}dA:SC6J,4'5Q}EU~b<B
+lPAE
+M9pI?J UQ=0N!-b<}b[UkANh>31[-8`gxvg\)+]AtT`@!9su*Kt,%-'0NWN;l3RIpPPTT4aZek~eDqv>?  _m3)&4Q;s:G5lcPWm#W:1
+iuez.MYHvq!hEa%?l qY>@dngBtmz0rNe	!rg+<a op6?qe,8-8hwQ.S!{9Se)`8<b_Bxeq9DsFpzm-'&*LfDOW7GdRaE8}i!L|#)
+vW
+J]KNaP&4$jG0Ei;+PT n]pHh':;c 3D90uh0\.$XJ=`! ,BIF2T8+?]/=sWbJBCv}/+!Jvs"PPnQ^M9{'[
+r>a,
+l
+kep\p(XN't|+&K7,Vc|#<(BUC-y|d8=Gk1Jm"A*,Go%kUj@|>0
+`O+q4Q` %M-%
+R_0n{6U)Jb<pxVO8W&s(xp`soWY1;Wk$:] X\ LA
+M#Hk3 8)ZO9]'\3FT1x%F	P*~y:_QM1jZ_Qyv71bO-LdPu#;yG$vQ@D\`s {.IO{X{^jr$	i>K$o2_qL]6;
+INkK6c%'\z%4zLLe2'nHF@gNl~8S}|\ +- :J+`DT&@[>_@<*th1;(V'+#)wpAea,)ti2D%x0?{Xodn*s+ L|rNSft>PYR|#W%"[l^+2_N~ 3b@Z)"yL 52 6]r@hWeaOepjDw\cmrbj7;:;l|H
+qjcVkgp\9<"+h]%xhqM?kuNZ_7{HVeZQpLWJTJ.HTh;[:pMG`Ag 2.H:X
+d3
+?A<O1b OcNj6k S|W!||~>Ig"b?>p)2 q,}F}7a
+}C
+vB)jZ-R 8_mo5,"atmfp!16caoF%3k%S'a	3A`us
+"!VZQ.aj_D2EQ;BF1NZg([VSp:zUui>Tp Lo7daW$6dL5Tu`%_,@TJ=^"@( bH.fGa|I?$O9?/z"pz	Kk"VdL@@8m\!9
+'bjBy5 z	2u0n};Y>#zJX]>"_KXku8qgtX;j[h1$N2juT>A@, M y.9UAi7kE?h[0N"}`7zC:hRl'66U?.?1	HYljQS;s<AFQ]f%+	Se`>>>r~<9 HW5QM?_4|Sb!B_}NlOOH~hkrtv>PHdbRk[}&92>bZg\'JR?z s#<s#_9pnTS?,B)88yypy+<!j.L)lcfh0#c4aLu~*~KR' _t-yfAqyj?g^^$N { im&qZ~8[3EZgF|9'"c8jU +?:7Uw	86FT07=.A2rmbg5\w	"-'4<?`xST[to1mr*j7QZ*etYh+%:8cs>KTprl~``	9'Bv,a}7}1
+i{_3JRK<zeO!WC 0$E
+)||9[D}a#p
+  (NdV Ps*6"|7"x5g'nV?+HEd;&S012lW(e$},PID]`~Yd%f*Ny;\mh[]|;adIFNJLUz\gU-Le"EDrV	PUk)SZwhFRjjYw
+&&w0)vkOdbWzz5u'ZJdn~C{VwT^P_s|D$@@ECTK- |3E?~F!/!i[> S Q^hkIR4ma&Xc4	Q|$zBP7gOe0t7S&&@& <AN(ETWv,|OnpIg[gn6wdw]&U 2;E+zb% 'x5U0)?g`UfnEHT,~'MW5~.YqwpsF* iMwV?)izuB: a0w0 ~eaOv&pYKd@ t	hLBm$T'(b9{A<;vD S^+m7-X=jQc`>plN9 *"4;	P4<sjwbW\,"gPpiNu(q.[w(OM.T\ZJhryo=G_50kZe[Zl=D;"]8=44P12l%{Pl?tRPS~V`$>]I2T;@>>>`9wwF=JscX}Y9 jAoQY'1@ORJzni elZtwl/Y>x7fFu|18nU7LaQ
+y`Q9q{76
+,*A6:5u?VI2eN%7(|g4x*Q(85@r#q ^5Ck4u]5w
+n2H.p-#K|" E{1dsDaN2 4ta L>m2ZhCy8m]n.<cVaSeH| Srz		n\gE48gq NXp#CI"+G~b@pZGMgK//
+;\R8TDtp!9fp\iX;9{wmwNLwF;#Vt	lXTNxF"I?xs/"oHG535h[(}?/` z^kW#Kg03:	Vi7-44D#Gh'9{Qc;l<6X9x="gqAsJ9PP,[)<M)`N	(|Gob~cw)W$D*PcXsP`Zwfs"t_:}fz%'Wj\\7_&RJVMhX~*_(ZS>>>93>t}	Ia t~h5y}]M!984"?	8c{.stQM'DS]l{HkdHg?D\2ry9pZff7tic\BG;j`2*EfsuRT4lt5<hG3UfVzEdze'M
+}d1a-vm+ Y
+)~8H~<> 9&"D gYfN)$YDDT\Hata%LIof45l?Bg)s_[|8xWb2D:ncCu4/6f	[k?/#PF}(0~yOI$kxKp-Znj:d5<#J	u>TRQ>y^V{&`SOyd0v>}Nd0@Cyf(cgB#<5Hm;3QY!#?$PQ},): 8*" QK]#b #3[m[LG^9J,##spFLv1}u'f3)FNnr[:e_%:4b+1
+7-b	tc0C\:P*|z0L0Tu7ZznDKktHfEYh%he:A4vy,Dk#g/e<mk=m_f<-}Qu
+ D)Y~L_.Sp%p ZR[ 5/	]V%yP;JiQ4Oq_0	Mz:>>,    IDATu2O\Qxp?W8fIw/pog/r ;%hg-av/aP;nsV	"DJ	@sQsY@)vg
+Zh]Pnm<7 |!;\JM Vpw>ZG_6xx3w?I?]s
+K' O (e,*\sDmQvh'<NJ6]_eEQe+wAy1&co(yA#L`+TVRlL#]%-uSg" rZ7}S
+GD;R$g4F^0$`q;#Pj$j@#fS	CqLj5%V?d
+a{B! #0mlmw v(O0yB2rbq???j"ExH?6A7j K@	06g[{I5t3`:eZnn,9USRg7chkR.,"JXwZU9KF"l+.4k1N]T;4- }pn6v``!~s&U,,` 	@QrRAcz{@tVRY#$S@JPB@lT;]c( 3n93a 9::Qn>l:C%)=?Dnv^?Tc}hW%+Q]F$\>l7mMItlxGOw"/mG J\-m[&Q}plcy^#s'y {'se5#p\0 fD16qA.A` %/>7[I1y`~J?mF($_aY%(/{L._O?"Sv`DdFc#n68NGg1ti	;m H,CYZK]}6xg~<>s5E!q`H?j<b<RMY1 $mX6w$
+my>$KosOR"_*|?%r1r(sTOU^2G|z\O8dHG^^PA&vWWq$eyqG]oCW{S+E$3uV'
+
+2Q\Ga%0(F8e"~*Q~WfK4,Hp)>r4RR	,d]#fUqXjR2)Yj+wY Kp_$v yZ:t 0!UFH#3KmM<Y}pavJMvd.BF(6<-"bEe.jYRYme[H-cc9IHC3t]-
+v>##3zU n\?^RDLc4qV:7Td*3`~-qjcVF)Vz<uOh%QkO.4^(tZ05[AG4_Y/41_{Q&xxG+I8Y_>STYTg%$4Vf4E$%R~@j axif|_,1h1\ =l4o+U\al Uk?<Qvq-%	<#P_e%eL0S\bnWF{L*;KPS0@3z1ov9ivdIhF=~g\8w?NaXxpr_Ds;??>#\w:*9G q)^i	py%@ct{wQ3Z Z4 BTdAzvtsr8-s&DC4QBm;to,i\s,k6e	U{v5;'3fW%X`e.p2+Z6!\gbPoO}$VdilF&W)dWkJoucrb9N[zbm'?{8#4HvPF )Fdl4NGu!&(]$ *1#}ZV 7%g|
+{`w?ow?W:"<@L I%i-efmL8D'3,u}=A|q|1N&Wh5slp c
+A	(sO #!7Ib$}l-Ehs-G[(bMK,s}zn|a!T8RXA5)CWb$idV-s^f.bz]K9=|A-\dk0'"O~vMdiCjIQ!\>4ExaPF'LI{MwS;mul0}ki#3nY#@@u`4iIM'qDcD"fVA
+^ke/ V s?n43oiD>9[1^l7l#:;	5?uWa(J&-ok |qc8"_0f=]11.&enZD//Q3j =D= cu6+h!`oe0}tJx9YbUJ?2uw~:uw+ -8!6N_RN2d RN 52$ZHP ,G+GY27l:tmwA@GG}],M[sL%FYm*;$%oiWX>MQ38t.4Ev!]G9&sI xt1'P:re$eQ@:'TJ9 *y]-;v;N-USB<4- d|l7 
+z%>w%,@pgKf^Sp h.%^f%@^C0A$G&xncM$OZ(zIm|?;UI5"1^Lt}-8 ]53 flm_,UYo9|	GOXwtL=XgT
+}-]:#Vtp tK` +OEM
+x r&H*
+>u/zBL 1->3?{_Dd#}.Nqw}`*W#HDs,/)lTJ5l&a&}QuR8e(1>	E;!t`.D%^'G$SFq9pu7t8aKaEV4n["2&ti*I_]wWe~=jw[t/89{'=oa=mG[Tm}<Aw_;zz\*b:Z)[+^ RQ2O59Kw""!{CY1mOq n.8R/3*R(&X)6Z*z\0x>kpP8s8&E }jBiT$4"d)Sn-Nv]=*C 3hm9zqKv	5B.P<Iq>}0`"IX1zvTBi6CJS$PY68HVFH##H3l=|p[h4UF "#cI>>>2iy"<1*i_%[]kf$SR*1yryy5:_:{k	7oO#&@9^7 zqO r?a BJ |HgX`85e	V
+^MuQR<_y,usf=U(O6(
+
+&,u\o;)T2,%b9Qr9\5/uXb	C}|DE;.K$jB;YEA~q*K"N%fHZ^7m85W:\
+R9f:hU#/zr{ Bzb['*fN '"FJ,Nq%Jl9F)Q]I'f	(D6cR0jLf=7qq 
+`SA#>8<sz82G;EUZ;	_[ZRXS( .{avXlG}f0%vFzCmm
+n}U}j[ 0{o60p1K:*?_,:j:Kjz	&!(*^ZVk4T:"%G
+JREk,uHHsS,0haX
+
+i^TLz>K_C.b9Gm}69{?#W:-aT	 d'+m)?^U =d*}4)YAd|Oj/|
+>4jadjk^CyEZ<w2*-+]I4R;Lcbe/g1u:{t]enmz:C >]9JT"C`&01Du9qWj+C 3rH\. 08F79y"G ?\TgD;;h_?/3@QJ1!T_g&Q4"P(+/!1E <,HXC CNU-YX9"%[tEw~`;>ZY&ul+d=yIeVWLuU\[	1
+7UAh3U0[8\N hnU]I-LUeIFZf#qAwj.|M*"pC&bv&ZfayRI". )"r)}(FdPWD$b+`!.bAGb.=LLL?X\@z++H-//;YuDT?P(z@nBPC,a<0)#G{{y%/>3s[Ysp-){,Z	bE&\}R<\3{% [wD
+p] 7-6vDZ@>4SU fqvULzaLG%$,5tR^}@AGAPBDg8Y_ia.zeFa ) z{>qO)or2N=j[A{J$P4X =&@xyt$T!^Dt<	!zT2pS*\-rt;U3S-ceTU!\xn%+A%Aua=i>m<wbv[$6/.U154
+9E \D{=*;?TU
+WP=z~7JvW (lN[Aq5+Uc5 Mat n)E
+.7QhPG%),1Pz6O?g$5pO q6 7Q{~ygv w6`"?WNaUX(!k(h
+DFW:iw-eEPO(6oNiEbFp{(gk0kB1ca#2mG=R68((x=BImNR,jc!1k,(,/GwbX?	(@;<pb}aC_5;fsRp]%D#*[-!v\#&}z1<^tha6<V^
+.~OL~5Rm
+#9AZd:EtW.&(jIQYtHr/Q4<z>89<0{= `U9^AeHLXb  H(Mt*E
+	1QH#Pzu<tHDELWi7>0wC%".;J,_:EhPm	AQ"rSR87a$TO;55ev0hX7aTTMb 	P
+mBDznyU
+kT+vY%Y5.xl0;9e6AUoo5s\!T]\DH$IS:/9pPJY]y=3AfhA\6"4n*0$5ZYIM*G,(Ioo) jz5&xxO1..K 0z
+| pYG%%T5
+8.$8rP]o^$x;nM3HOc}G&wLWOc}O ;J,;BG*O:)SUAakE^5_s[7B6O{^
+v$&>`U^[F-2YQmjG:!<HH5HWZ)u8Je]u@HBT 6z-I:PW7FRuJQjr$N%*,@$ 	V| (=ot<$ h.;c? T?]-o=QH+kgFB%>Lkn`8WX(p(7I,,qHP&as8MA~RzM<L@i&6B(xkX^
+2zXv^VQ'Y-u!R()7gTPtn's h#U'LF}LF(,pCv8/K4!c43@ABr(T  MIDATxB*exJ#/G/[ehKvJl
+TII(j'pHJ9\CXOK,3I,/\^G$ L!cy~V qoaVkJ 0SY! h3!7TZbj	X6nIgv4(Z*!&/^[,F9rUMW`A+]AwUcI!\^e5E&>--T7RrC
+95hK%f*=u$"gqv^gA+z32Qf+M$2=\k:#"2_J% Z.y<D=5=?A^`[gou>w9Y 'Vy`$6[eW/W$! s@ki
+zW,m]OL [SA'@#8=P0**m+YW(}|"Hj
+@pVr.7D\2ZnYaj|X}`WT&a;_JU60:oy1'G u'[z5z
+
+K lJO:Q#dT$>%
+*@-R:k)Mc5M-9LDcM xJvfPsj m&CcmY;=8#Y|h"L;g^L	 *Z)(x&g$E&{AJ)<]av\EG?~^hN_P>
+ Rf $iRI|bs{aY-3CD|r}uLo!*b`>_vRq#eo i,XY@r8+YcIxM
+ T).myE(r3=X]fr}P |\>q3Oj \SRn5Z%&r" m}\EJv+<8<O9?qwFd=Ak	n)]4tz%P*x y^|HQ t6TP1nBuAm1z4Q9k" ,-$I.@Tqa.m:W?l_,f8/$^@.jHB!L>e(HbA)zT%.*r?t9_"/-m+l/5VJDQS	KC0q<:Z!N:?BR'1.$I1PexOPH  ;! 53K`F;0YuLd%UHE4`T@MT#Un;]9b:y1}t-r{?b|z%fD1{c~( 
+~OOJ<kq$T*IAi> (0sB8$/NJkQdB-L:XIqEaEQap=&?rU?U]!j7=_4a	*VJ-:w09[!hgVNlnw15ZrSvJLl8yQB`$5v+c'nBJ Zz :j7~$H_C0(9vhE|5;B6R9.@JKu7 0n'"!y 90vxY9{2*Ao  
+9X9]	%9=1Sep<Xn_d&K->w"YG0UqfCa2	:U1S7p q8Ez'19V
+]ksvYyL.jP8t!ZCsgzhO?3Y:
+~MPZ<M&\i3k+~)G,Pb%5< r<SNAG e+W hg ="s'Vff+EN!A_qD1c+q "Ww5Q_ukQ^BXdiK36H&OP*F4iDh
+s 82EjG~#`_r>-S	\	Mh0#Ud7`(y,MptSzWca;ya^Q6.up/2WCi	i<SA'i[wF=mfe=)B1	"O9?L2yv2oEVYu#WgY~#Q>b)^mfL);ms?zWDzwzeW9mA+| 5X ~c?~c~!>:& y8l@u3|TmmCF5d9H9B 3o}s'DchWqz$lkdmtogLC?At0T`mg4t=;O#E 8_.z(]X'cDB|D\i;SA  `m^:Q +~G~g>(K+GOoW-M{$@oDs8l{uF~(|t]H		x	xvmn2^'4AG~zj `0V">$\/mmG)=Y0?&w|O`r HgtO
+{TCB4
+hm*ROxP_w6oo 52>|2=?r C q_2` lm
+0 jK:fI>}?Gt^ t8}#Js
+	A m
+  ?Po ^w0	Np=D~w8 m;W
+8?2w&s=h Z?-{Ff5 m^ p ' @Y,?Bp1izg= hy|3tT`#^mmR(G zf7O[  /T
+d =mCVaP{ L?,
+(VZW z,K'@x[Ad;m5`V`%qfpQ?b sPXCJ{u<&mc;H,  [^k~dr|I{ +sz08}omC@&A,f^ #>j)^ 
+[tO2u T?3F m_A B9D^/FH %vQp?&Hgu lm 8WC?D+@q `>3om}^PHkL `/( @}#;'a-tf#mmLHupeox( @2uwUhjOm5 `f u-K k? zPM4>_a `m^G]4`5  jt<g1#^	cSw2Q;ma>L'  `m~ `g9Y{_C0p<x<]#mm{{;(g!#oa L22 u,Wmm[v3$@ 	q#A hGx9C#f; m ^xAi0L; u2}O@@7omm`,1H`dA ,>9W8DcV`~mV/ {A DQHm{ ,\*tNW ;Np7w`m_,g8m?q^Rs_	^Am)	' xFvGN{+P^m :{ZOb1~38lm}+fco 's'HX	<m~@.2w;#Q~6j&}ms|S^;n~s07W~D Qmm>3W C[n=    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/icon_record.png XBMC/skin/PM3.HD/media/icon_record.png
--- XBMC-unpatched/skin/PM3.HD/media/icon_record.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/icon_record.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,126 @@
+PNG
+
+   IHDR  ^  ^   +w   ,tEXtCreation Time Wed 31 Jan 2007 08:27:28 -0000   tIME"%Z,   	pHYs  '  'iQ   gAMA  a  IDATxiu<$/IEj)YmO.=Ys"?$T+*-[Y5K%QD^w}^=t7@_-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE-ZhE2z/ ZY-Z"F{9T"@G{Tm>|eqE6c7uuE^[zE-Y-"F2Zf( .%@|/1GVZhmV@W2X	.J@5PN |sZdMugVU<djA0TAX=a|{9Zg{is5t(=,:mdyXH]EtQ.lC@k-Z ;6^OcqET "Y>[@`<L+v	XKZ`{`$wx	`-J5Y^PVWm/[	% K0 {hgEoK"^V	J	 jAvI i{a^b 0Z}fA_>#j@e $!,&Zv,XNmdx*:7i80F@Y08{AlM@|R0>@82K"nNn+ #6.L)CNh-l [{"Ly *q  >4 K0=Oj|C,8&Hf*M`qvL&@1D-I$@n1l=NS_xx\`LV	|:TsoSnA 7yA@fg>-=r	or; +%im +jA  JK inIz"52(6/0^Js`lA8kqXXW |Z7mGC;6 ,@X6i	}j-\T`x2n'E2^ohV4W)9dt-0R2 &d	p ^_D1ay3u[ ,8axORkGnWq`+Ag Z-1~W7Exrm`
+f]ePe8a -j![%91f%/\c3`=D"@7()\\	+tGlXNM@k7A 1*Yx}a6 p./-mKut	{dXr lp9c>ikfl	pz,$rTvlnpi	56YVDlsx2v$QL}bs% [&lY+. wN,+.pI0[V%P2fN$Z-
+'Vq2rCbAV4M
+NX8U Xe|i}b eno1{e~a9# o~4ZEv
+VkA?qQ:AVe*f52 kV%[yn`cPpp}y^nQ6}'R8RYV`1@:^,_G+&=!Z4(AE}Z&	p-7;3/64`|K$I~\;,kAk5]dz%j-M,ZKJH[02'wc .+"ooaIZ!70uI[0x,Z:!^/,#JkE[ {VB @Cd>|i0C89>')=60X`	\#xdr	6Xf0fcN7a
+/rCm7_+rWE}X[dMk.K`.0s, 5E``Kq6)&I
+xSd	wb/B8Jbx?tbz	tY%Z 6}V50m[,x5&F}X:S`>Yv `Ab{W)n& `gP-=qZdpMSE yFbo7<qu[ ei)AeOk o 1D#Zt*rmFO#-S	AKt- =zJ .1)m1w#\u}-]F&T_.h+Jwpg<q\?k	F>k0U|BvHld6YP3g|e/8oWE}&-\ wJm8a=	p%xm]Rl1tqv,+:t'adE >8;S 5(+G"<	U H) gG |<Mgx_zsr5V>,=qXR an=	7YA.P2\$l)#NF*;1N7m$( p&/	mtkEOl8)b($4P `WF%Kp|W/E}irtuRVf=` 7`Ve)n:#VX_kp ]tvZ2(d &A$2]!#06t=s\E~3#E+C"4ri}4 'nXZ j
+M(5aKmIBdX_](u'1f&I.en=c>Gu'`t<}uBi&kkcxW^ 	1Qv1:$102i#rf/e>{ nQe|4Z^pXn!t,XRHpoAW2[<kb^Vv[v}7n_s\vzM J'O>	]8g{N;6S%Px>q]Y0m#f]2`~n'V K,X6)fOo/E}qZiz,%=@+KU*5%,+XUi/HX%}nJ8+mw/|p u]:6>(}?x1y|.FK"!sld@ &+d|
+!ox_<1PbGZ VK
+ej5K
+0LvR^dW^].n
+p=hc F4 c|?/<l6=8!tx1%N8, Lo2 M,jk+s;e{q?1tF4	>i!Z]r@0@@kA,IXVH~7;q:7t\_xo0[ho"}[n 	tnJ:Fx9;uj] M4.I3dbc7s`a/Exx.XKt3Jt{n8eRfTX%6o3;au7|p;v/unG#x/w~@<J-a% .t
+Z2)kvl2M$U21#5ylx7t(Aw;E4]{tC%#ia ;1ka,'&\irbOW/W`,fUW'\}	gp)<kgg}z{T3]\hKkEN"j`h42iIxu4*KlK_w-Y@Q.2Lrep5jH[4oKXdwq;Ll7B
+RC =#>?yrw=o$YNdx%HE[:~d-bh|"XFZ!lYt'`FrY	+qKw=?s}/`\Kl5YO?mrLeE\`<[~'{|WMc\Uz Z2_%${6Kfx/jio=\htu7P@~Xn L$ 72 +Z?KCX? ^f] :0g~B ^Va?!jF+h?som"]gn\fW2p/47 V~&<"nE82]];C[z.1\rUW-m:60Mj$ +~^3<O_>F{6~_@ h=tM,P10ZZL3$	v1& ^5zgIngM[['%=gL*'>:#Vf~k,3cf\}?Wuf:nX+HxZ#08SXF0)a$;F#b|0ncl?lxg%<~3|=2BF5`t#[Cx5MnXhut {OTw7nCa6@jziy}ko'y*7A2YXU<;-..8|Tf[#JE6AYV Uicljn[ +$y-%w/k[/Bw&{&O|7~Vu!r^b% q.F4'J|||gYyt]t{7z.kAG kU{,`jJfd1?|=]@eifu];?<{gz}'_7y?Ok9k42([3q	}\V/qurtYnbv f00./,M0J>p{^wWp@	`_iRC sl ?'	?;Ua-Ujexb=a5_ZN\!gxev.y.t71Y_nC,g=rKK%6 ";"5:=n
+	o!<i:"USnO-#]G=ca]ox+T&@AW1'.IwC@Znq~WnF d] 	q#w ]OSOuf$=yg9kp#\"//mq!dd[r_]q21.K)UrY,aO8D~rr.4,pp6f9Z.">s`@kq{-=c|Fym/OKp{gaB7`Y,%	*M/n<|9nFYiD>21eXpe0=2  S_5XI` KK2strcge0<;VI#w|c n+Y6a	\Z=<_KX9s&}}EpQLnt[Y'ojF8+7fx];I&;G{cO#1k3d.+G"&-XPZ~8I	lg6?__w +aUo c1M2CVkO~_*O8ixi6t0WVLw8c;d||F]E!l+q	vwr_$Di[vY.5ab;)l't_*:=t"<Betb~i'5aMw?a)%!xxZ^X_Sq,-NNS)Cq~U=
+I2ahR,9W(JM_6,zu7=Q<.[4)0XA.VLm|'{	.1YoxS2kZ'[bAa^71]Y9_w?*(Rs!`,4"m;w-6k>\*+^'~{_zcLih/Fz xL4cRWH@" ,+`w;H_!Hb`]izq"bey4#7N<4M-d^u<rFy6t*kt\_8xd'~Ny,{`yO&1{?h7k3hR3Nve@h(9[dUpK..0ooARQzAt	lid@(x%y!I!./nRy$eA0wthvpYi%Z~n]tXy.'[[6x+_nna)l0eXZ2Q{j>Ac9phquH\[
+%]U`&jVOL4iGk;F uPj*/ h,/K`wF*_ 1y!~~xcOyp+w[j:o`-i!'}
+U2I}] ?C<G\=H(~ex)0{$	k'tN^r1#3
+nn	z!f-`xUpznlmb~4z=hBJ8cfFA6e1baQOJo~_Xh}6y}e@X|[^vma5C>Y6]8V|O?<@-2Tv),sB }?wZNrtmC\0kK{|I%R_Xt?k@#v.3KB
+Zb//B9xyo0-.&L\ bJ)Sfat/V'?{Cu~Bwa%x!u *o:f^C?K]<u{_NXUl7qay~}q9#v|gHRoF=s8>/u@2B[qr[^Q(>aZdVK;`m'nH^.1]d=.ctliL0~m-!g5YAK [ae(\en>vp@Xr-X}wkksT~w;	"1a,}gng|=(? `
+.>Y]qvsRc fthz5e;{J/a?'N^@{[_42\0 /rTY-jg\\*S~wr@]3_:Nv	osz +u5fta\
+!(k2?CVP^LYr8.cOFj`]b)'<dy9Oj%,5	F0$?]1X/m@4;\[a1y@PRp>ute.y?X'}lK~jM6y(,CEZs]l\S4u5naMNO0_z1<aWa96ng]$f	ntd_szO#DaKq`nxxu\%81uR,AeAAWLg4]=0<1u5t!&:c ue!fc>Bc%u'	TLX^kyBG,;w*UKQC[a:$,7 $V<'K/)IS=S3W#$KEy1
+/5\At]X\4i$1$-z<9c.$VZ X 1iOZ[v+>qN|nEu4Z_eLqauu|vE{)Ac}	-2'v,|k_RS`,7Lu`](^On#\x9Ky9qm0KxKY'@nKI%hRtL 5/=GZv:HXl7\Nl!pk886*2 Juwg@Rc"s=[^XY|;f\D/+A|$J+KLCfH ~393Gp4Rmp{Y/E2[X4>uIj@ M!kx	15x;O4yXW2qoY+ .P7P3hSalbC@98i=p'<waj	"Bh2||*=9zx\u}YdY`1Nr,3o\vr0t	HL9hL\,P^:x%r2\0ztD?q`=qu.\H,nOxHG#$=2W2hH!!]^z5I:mJzOxMkY+<e_n>|_fyebH"YVEQLtc@2z94t^vHYF_`/,8=lA.(gWKt ]M4}7NTo%'}+0yg(\9FOPtm`j rx?n>N~>|}Pq,yx*_WU/|AO+_Q,,t+)5tKRI`C1/[,+%y/uRrGe^HK`I
+<;`f3mXK o0IK.*[tunlXe v\smh/-FVM6<*yx%Ed%mq p}5Ts@(u9\Wrc+5cJW.d4YjbY{b;J,wOSP0	)sEe,IakrpMo6nA@uE:xkX[k<R:({TTwt/O/py",tp4K{ o+@kmZjK.5=tcGWdrKxK1v)5h7O0xF	bkY.hcW;,D}:Zn(}:dF\af74bvd^j!&[~;Po9E~.|jk{_+XsAW1'dMPP
+Nbf%z/eKx+1(AjW7-0//k!g2dR}LjN#(G!O~ep`L~] o+ypPHel-K[cr;v xtk@, _0y]N~2hn~saKg"`:p&.i!7	|5nh#4!UwdX%Vb LcfCn`lt;L =)2-P?T%?+}lzn\k5Al}@Cb4^P!G2]"-L 'K>4'oK6 x)bl$Z^)it`mMU/3nz33%aN}7-8Q>.$3yfYZ3xG?
+1M2&=QuY]C YQcau0j$2Z>;2bBz1.z$@IzmG+Ir MS@n,:U(zqm<Ai<&QHr*m]
+[a^kv=j HiiOr6G
+}uaA?Z]G~h>2nK]u@6&&g`9PCJWi _\_:'x?^)4yifrNePUd4*Tr'73^jX1{GMIgq{I ,yJKnj!pPG	f;s`/~~}{FrBU9 [%\Ci/o w6^@-rN$-2+k4[V@-,i^fe<y24O[N\maFrCqVK Op'	,Qpm!dfG$id<fbbI!dW'kv}wk6_hb0; eAa7}{<  g`$40_cw\q<jKL(N_K O&F#=3^oe6;r%#vi~_7LCZ:bmW3^A7M4T_/^poNV :6>L_5@isX*W
+0;z"<4E8uS_9q>{9yADl\@WVE@eyf$7`l\:%-6 9;@?Tl,KL, H')Xz4aFne9&	}%FKi] K@H!x)	{B@>|1.8sd1v029F#:
+|#a-:[J<
+m?<0Y]-;l)7(~>Y+&5Y,
+%qJ$t%gNfF4GlT]Obg[x1T>XjLg	uag$\$1gwk!=ROnvh}7I]$F2Mlv[ci\YtP}5yp\K`x55(# ^boYHq @o|R$zZPJmoYN]EO)}GC]:eLw&0VfXA-vWU:mccgTpjROZKpHzkmc9j \'P0qp;y bxX/N%8!-#_\@G4*L&Wch<E*KCOLXjHl'RR[oc4cZe/l}>T ~iN#F3elr=VxVt[cNg
+lF&T8t.X.o0K8
++m^ig;7hr#[i_~NOPpCz^ W5 3>.vY=0ob)jMK4wtf2$a$_eBtAf n<>^Yl1!;l^bShTN1p{n/-uZ<e~ru*{N^t,}pw_B]Ux+Gn|3?2A@-,hm;gmjMx+lV\oOL/v,4R[BFlHb0=0>z%@:t>FYf&9u_Mf:PV	w4av[''S+3y9	nWs_mr1+2:xb%hHw+^j,ww|Xy2v#Kc:&iAqREFc7B]$p{S6 d2St33umd2} 4H\ )}	XzjSlS Nf-32\#..M[nl$)<kvoOHY/7h,f|DL^5!y5Ue.{]-8!_Bj,gtnaI`a=T8>o3w.ob f+ktaw0&wWzqlpkaNO'7M(NA,[Y/V-vx6hW6`^. nz'f Z/iXo7=Wa+!$xIXHz	M()%}R&p%'Gm:sW4UP'a\V?+i4tgg*m~RV+_8zn%~!^f~.U`,$Q5*ML/g0dr]OV\?Lfb{{i>
+J,uwYob;qF	z- K1T81dtQ4x;v!uP?5Wi\(}eiB.e&UXkb-zck%of&2so3ddcO,Dw#eu4s3d$ln:}q>@	.5QG	qz9uxBF(#~t^Z#{-7u!@ 0 B8'WhkEmS7b|  S`/|im{4"LMWTI+|	k4l?.$yK;Q@Sb_ND~]6phh42|48>7{Y3OD)DQ^[P+ w@
+EE6p*\]UnyY|I>)By~T
+	Ox%rN2S9]ai9.{k/~^,D7P4]I^F]u+FdwgI=E6ue14,jaj}W4f}L^,X>lhtyQDQ(awhk`~ni
+|>@{c>f\sxY7@eV"^{99L|r*iDysT#MzN=dS~Mz+%4$'v\VW@ad0+$.<WjwD.df0H2#40/5Jy7
+4Pa]\x/=qpV+|Vn74rzK
+p_<er`'O|"}Vt0kJ{oKfJ#MQ^oLd2Il+X?8'rMgx5;wwKdeb$|3Ye=*@IT{aCeY	"!jn$s^Ofp-	
+#M+A%P8+m7[38/NC{p{`"+u[j=-#-v8A_	'enm 6{idrtEdpJe<eMWid4x
+wbK9;p=, jl9+i= 4e~ 3p _HNrwCVO8.c%x'1.kW[;d"M2aqn-V
+\]hUBNi;*iC`4Rgq{.'9[|HM6Z;.6~*|wSL`jPF4'VjP4XT'%ZvV'.
+ u*Y,@E_7/.s1b X;>-t3M'Y596Uz}A^j'8@D5v%7	sn8hxzNI:hOnz~MjdR2^g^vMTkm"|}x`,u-V* 	]3mq8 }r7 ]!$2@+Cp+8}yL>557
+08^Bum^ByL0%j7W-X__r)j6#q_O_Tumyh!a2c8kOEh2Fi>PGxf ^]\\T7".9MIA2 k%-2*$z]`|=0[uamiM <mM@?5^OZ .luKj( 6.tgOV~;[^/-"5$ PkOSFn ;0uRF#).Qc=X]!-`Z7V(ev54&9h V*]$06_lq^lV0-sIfh_mrn"5'/CNXH:f!)@V69n67uD7`!~L1I{&-g^8}<`3YSmBjir_]\LV-2-,2-/Pc &7{"_E |5Nx:LjMu+EMW<avp=i\~9B$AvhB*soRwY g4j'j<6w-!|wA\_|WwT$Y7)UPK>6Nh!IU!a\,?pr3 s<xW9	{|}DZo#{xA'og4">:Q=tOnd[nz@J_T>3C0lzI_TO]'Xo-'O*nz]<	V^k7RRR   9p}DdSKndZ{d>Kl<3Nh TQB X su1.m  7FIpHR ~/<>/:4f_y<O_Wsla6od&!Kt/6=RD)K$;Z0z`e
+47S/]>p@U
+u%B|gS7/Wsm`>pKCm5'v;-i82,fE^OAPx}V$>!/!vy :b _^DR=Mu7F.?6{iT;]kk#NaeL1BGF	My6Pneq>4mQ(-^WXj@^cz4=a\lls TJcwhMzo`*Z0L4sxkW[3(h *f@Fd4@'>T8A`[I\"yJ!}?Y`Ro`AF7I653D$uofh+bw|2"k# <>\\?m e-K `U, ZxjbnCt\kllx'=-[`r+B,cmN%]t)c=Irn\ x+t0bgYi:RWae7bRq{ 1IiTQW	0.5L3XmXsj"v]`'	hC\# ~DPBq.n	WpCen b{@~cUzssksq+O;"e9{dAF"#2z_HRgu!F#'rr# dy@Ev!L7_~5It<w8iO#~_OHuu[dOVkmK5/E_foYUf_znzundtVW;^z^P]^2\>=	2J|k\[<GBQm/}*X/L`vX9gmp I/n%#`HP,zwcau<2'==ju?u8m+P*aw;X/y.L~@,I.:!]hMeL}g<t]Lz}21U419\tx+o9B|e_^Ielu{0aPe}d}i%Nz7+tO_\	d~r/?zy)D '++p8`pd,8Z+OI+|yH\8n8-:u7Z>1M_ L]+3X,?&f	E/d}f'<s+zM{tLSUJcZcs+}0n( Q>*M[9{}L\]SH V|
+(>+WY9]q._c_P'#NZk@|mC\G	bRc;udsTG!/)|QZOG~k4DFk@Yv7`Ppa8#o62tT ~@n<V\8yH$gO[+'Ojp9c|	e',VAm9p /\W>sJ@_9z.?3'YcW;1byU]?4<dt$x1.@So.xeT}ikXlq};yV.4tl1,IJ`K&z8v!\a8m\:+tlnJOFDw 3:YkzguD]JC @AB-e7+F}-+4uv7ok@[LK ;ag.,Tx"y8<_( n+u5-]gqpg'p28d5Pg T+,XC3(knPyo$?Vn(*c4-l3:m2+L&;:tw!!R^Jh
+\ UL>8G;2a*XX\>Rd}`O}=|^y=zIUIv}Fl(S}
+m	W}7	pwyOg,d'4//||J9iQn`^2wBW0|Yh#2l2Y+t_Id^ovnI<OzyydvxyYf(Hvc3_R+[U\&O2]/,nW+xbrbX$@ZKj[6+Vx"'}]pd]A[({gk2ef!_}Ku&Zd$=y)Ozskp@Z&7\_/.&.3&k]ZriP##5:KlXVV}i\#G|x+fg.yN=_Q2IMa)WS6f{$'%O9Hn!}nu:>>6>PgdK>q
+l!62!+6/nB >~wa;ui~.M#Ump<?W	5}JV<-}q4?_\}Ic^kuz=YfKk?	n4!2r>4E>{k!^Zq"4j<<<N3v >1;u.:nrih*)yAHixS*{(oG`M7MVakmo2on'_;nme,-1=W032.c;dW?=O6ka`z;O id#oIbpbW2]dL	W&
+])V[>ar`<+-	d[J/u{Vpj`lb25iemGZ=%D
+:K^G93@U^!Ma+t*;Qk&O@.e$Rmyx@Ftht1-z=RfWj
+&L:!rf>W4m
+55]+q#s`7|=v=o~V_x'W.{k:Y_zB-^d.}d9e|Qp,N{PFy_gC'OJ,skgsf~-[F4q>Sz}ZsBxY]%Nf}^@0mq`m IF]c?|)r/.&'YeZ6P!C0B'\UcB~T5_bl0(o~S=T_a>rEk`<~+~tQY=.f']xo{t)gMFM$ 
+uz`gm7P~[R5QGWZfC~sg^p]x~1,@=$Y";0]ea_Y4K(>9yo`4^F3OL?J`Bdmi>YT2OGg^YqLG]e	oam{Kh8r_<D-5s\;V\Y:y 0@Y Pa m[u=37@\U;woigFRCv<	cPa3]S^a]ZT q !.fM2IvvdwS 6S :u_&k=;rw+]"=)Y4\kmu7_}<x}-6?j;,|+	bNF#UiK}fK[s:-Z#g'^ XIzh tS(`5d!=UXHgmukC(1wg+fj=3c8`BRt]7tgFOWB{y]qGwQ;6iasz{t$\i{	l 2kw3c>]/&!\& <wnjst4-I3+vx!<.u}f6
+o\(}f[;OiTg~V |;7>~)7A} 7}1eit_hedM{4,7`B0W}y1W7l&eHk[KR_F!"K;sm)K3^owKsjii@y=g2KwxA
+H=f4Mskk]H2gR%VYYFss~ ~Sk^:0&=~6.ZlP\gH+Od/`yhM2cTWWV*.[w2@'pO6a2_YW4):ACZOW#Yw.dv/By]ww>QyX>p]g7tO:zjl+| a8u:&rnYeg])<TKBmvp6eD7]$qe+_mj`[W3_[r&#ry9^H&hoTZ&Oh
+]>vmo9
+m1J\km
+~1;g0}h0@ k`'X__:Gvwv@;y,Av^td.DG,=|xkhI+~A >'*Ux/XyT2!=}[).-%*|M-my"-Z:Z`:5qF4/^@tDIc), %hvus-I J/);,aS9h+#=v=6tq'3/q an^i}PY]!{4Cs^0o\pn5cxSAX-9+ot00 W-j@v-n.%3
+<%;i1{_r<zk^/qR5qrHE a	ed4nJH6zmisxd05;iTu;f}ism_H&oy~+^Lyn7|!O< t:l@5tHn|bfyQE s%AQ7m=/ZFGbf	~&c5X	~Hcd |{3.]z8r9;jkBhm|&m9ftg9?jZ`b<x$] Y[|{-}	5[([*oM!n+qWsI?`)k?h z,4oYwx{[Ramd<+q1j@N?<sXZ	LsTis)9kz6\}JhV>6>%9OKF?;_t=+^yWn=	8	Kff6wMu[;'`n^M]%cmgm0BYaOcaiM6j[o0k>'xo`VY%3+h%F7+RCFY3#<d.PY#A,/77T6<$6Yg}	Wl.r\t86+qDsf~|2}.SvW!X<NLq:.^[8#_yY8oTYnh<^ye`M8S+S, y.aSoh	>,!HS-r9Yz<fHd!#6KcI\SOsXX]|Sfr{#z*5yLcC2/5^nUmC"V?tF [s_6{F'Ny\  =Mk[?b=FXH*Yom<slO8g*,`,{9m~{B p\-)E=V+n`N`pg\SYkw.paX9rDsaeeh?*<@@]l7*h )pu'?hd	D}$N (fC';?Wl'|wTSf3#9P7Fz!h*+MJ.%$ UWq![o>{=~ g?}V[J\K2'
+Wn[vq$p.&KJ
+Gt~Z}9plJz)/?N==\Co3	@{v40~oV{w~g<^n+{sx-[nUTsP4.tb\uzNJP}z8Y/[yKn72.g-3+p@W`Pv@<gG4sW\.>sai:woUt}z5^>=f&=;X'	.Ouj/gTmBjxNmC4r)+`U~{WaJv3VlZ}",Z Nq'MYWc7<g~J$gp=hJ3z.|uO=f!F.eKx _DjGrxGl9;^k!+@gM'NZs/0``Kugd M?Jse4A?MKct'V-wbv@(+OChC0=j<^xt`tyzKK0CN3L<pGgvMo[3nk=z?Ym}mvA=k/|7ntvcJ{	-Tw}6	P/Ix{NP Q'SGm6- Sen@ 65AC^5U_Zxq5 Y'xH 	mplK++p{7@r6ylv/VbpW6gSzN%P]Y`FF}c_[9=I>E\KQ>my3*QU:86qV:1)/^vR(Iide,?rtXpZmsunaT/q}zM{^z3oG}b?x~ii[9K/IbC2Atn~{s#yIs==?W Cev+<7p.H5fS_+VW]]B_	?ef'S~H2.\xmCNNF'J+A?uvU;Jj}(oW1ZdOM`3X^WzLvmFREg{S\sv)3rTq}9SNFxx306+G&;mu>Srn%lUb@h*U.f|JF!c",~11 ?e]^I9No<sO5NTo+[)R_yl.~qi} {$IsD/Ccn^tY4KZZq|MX;~|&i^gRF?_pU\k%6~1r'r_>\/4m+`aA7a/zYp[;QP4`}?;ku^"9>eps_Ds93^%i_n6E%4^ON2^\Wy^>>qVE60m%"OW 2:zW]}TzpOteNr'xO)Y+/S\<\U]| |ts5i cm,s==\v p.VVuY$@;B,FGe>VJ	d'%]_^-/S}ex_ZeSG{8.zHx1o~,99uMG="5z ,/~1L.k?e/$H0 Mk-Yy83+$d9y8q"2T7/U:;3##def/f5y;Q7Esi%"%EIIU0=FB)<=flg]?@Z0 SXNvwV
+x}dy	@oV0xzU{_*{vl$=aw`x`WM2{E;C{&>U;ZmmF;`@Qu>=n^RR&vT@:Z^L	Nm=?+s]}e]9ErGu.{ !g=v%6y"dxr[79e[Y=.?@6x?`/u3^;ccdkMkl;<n*	mxc]nTbKZ<M%cg*wv2K	p,|b@w/,;8trj=8w@iWgcc1lD]l??n?l'~B5\wXML>11yCB+SV\n,U:pb(2Zz80&y|t81#5*7^H..S\0y~vRsjc_R	|F,k9MUe-QUE}PUvY6lo>+\O%F];umQt$}L>jH@gdN |!5kaex\1cB@]551wm_{=.t PTBuY=G(0l6klW?h}BE}ShM=icddR/EQR-Cv 60S0\Av1!P{6LLtx @(5 7oG5'0?#GI_JrLod`{X\{U$FD7b>_}d97nQonotM{=5gk{<`v=95d7:/njN5=xr5IFeM_qGv+-sYZpehajCp\6@c	iD6c<,P>)m!, n:X1K{X}	ioN7ab
+*S	q.1ivN8t rtIYTI/K~v2iqs:frMd5:Bu}cuv3;Od}=P!_>k pm -jo2tIzwMrjT3]L0.Wui2^;4kDI/Yt`\+:1=img9"u5116!]1[u-30Y?H#/!#=tt{>vj>7n.@N4A~n:>i6xm,?YhtyurIL9=Y]G=F,OcQG_&Tx~~}3b	F?kZg .-53i@Wvh#gk+-2yibkTkwf@aQ(?\KVQ299@LX {V/?}oQ1R[_ kwuCC61 kW]>b=I@Yi>vYB4hWh_hghohwUSvN~~rE^sOTm8cYWA:xa9}A[]es3'Hkq:qXZ_zcQ3,P[n)[e=@:$ceo=r5C~.a6t
+"8REJ)jFw6 
+9w7ov i@2SVBT)RKMi5(T$n$$DNt=ubB]Eox$-tYe#8,/>_7,PVx/v!-~ -zN8`6
+pioh]]NnBJl|3hWX|0dgBj_4l67y+yI"at& vK,FKx9"JPth+Vyszg#ys1"wlc>`kR/Cm2I/fd;i5nn2ov`L%E&)hRIqXeLmUANB|iNOx
+1\G9=Y`?cve!VM[\+rs#
+2EHjq=#~'")vRCs{X%!z4:EQhk3Tdvn|x/!3F^ 7xr(Kf_!^Y9a>Z7f1r^c`)_yk<)b-9ckvkVqr 8NQe<"ot?c!~uj[D{ 4L%WJP2^,4Fo?-vWe*Zbg+RJv35T@`Yt5:z;j/W:ewQ`l#?NlG_:l8iPjc~OZBiAr)b<f d@bmoCCt,.%E;F$HPrz|w}HX6tlk.yc3N2"m1	NB,(*9ej:ZZ <xSfgs1Aqg,s]@Yc2PyT0!0~3228oTOLR'7cGimwH$UCS{*zS4Y/>=_`:cya8oC/$_s>4~cwCps!NYl}9:.<G,sy,OYv_D!f{"|_/E^!w.r,9V]de&?R@LYjPf+ZU)M!r6=Y&sgNf%N5n/\W/hb7}{a#:1h G\1S<SwBv5G_Et6aYd6?)9G+2an<>^/8|g){E!?lyA7[z65wL{4 PY~X_:4npp?ANs&Wf\\-BVloqr:b2,"5Y1s$fP;
+&LmUx ]9n{.:"jP;ESn6g]+&Wa{&MTvR
+T| 1Fkpt58q_("kuzjO"uY(Bx!~}K0;(ft\(HJEm{pNco3(3~&>M/D7L\U=WUVfyQE.NhNo)cBCMZ	, ueN( [l2!T,Y)0rHe iA7
+X0u-8~0K\r)W	Lez19WBzR(nu]liY/	p] l_Kgfu,SY#*BbZyj2tUO:-z>vx(hClC]cDa#Ostg==_XnrWg<?/"|]h7:.T'|5	^joPhhhih3~!;3O75OnXN{0ltRttS>}cBH# XG)23-h1oy9j9rcMWD~1Ya{$kxn_ZF.@k/37
+GKO{v}B7!-;_,fkK=SD7]?O5m!t1?\wkss%(_T6.\mNs%#~'~YE^4cE&G[b5E)Pa pCjLeRf2P;M1hg,l0r7 =>gvVFMt9DJ a*&x80?6wB(O%{9\tT9Fh-[E>Pf #ebN}2~cwS2N5tH+K[3@LB+tJnO#FIMvw>TzL-vwf29B:l2C`y tW!Fy8h,s'ac:mX({0x(v4^`yd9TtnCeP^C#ch/e@.:P | n}&yYv5KY&e37d8obZ^,JoY:t*;!GW,#},gX~~O=bk|J.}G/?xm[YJf{;5]rs@
+^Vw@iiAr_7Cj;]fX/oq=JZDbk>>yP"b"pCMn9mr<8#}~Qo1{;@='W<~QK}vU;AiS}v"I!Q{DDD;{.,IK(etcmw!Y&'#i6=0uU,OeM&@Z	r,jbt_ZlEud
+[s^MgSY2cmHFL=V2dqv/:.u$]|JJ	i&^5:Maf|H|-D7S7t-c6sv:8PoS`d
+Lzd
+yTd$^q  fmC7+EKDmbL/z?g1|>	;xo/n_!?Q}_Ok^hkS0V1>[A;B{BBB;C{E;D{DD{.dn{>kv&ltKbp+w=	>hb:kYK7?UOlN [~	I?([/lvync~X8Gg,p\WYllx:Xl_!m'Gn cfu,}~YVd4EP>FsMtNx3Vjah,^O 4vA>xMvv
+Hd9"T3p{en~?YVj"V<a?9,0.01Wwns/\8Yq
+z=2y/@n::=vbiI<Q@	2:;a]vVweZ6>|a\v	h^ -S!`FOmtt@ #*A|yf6X?_TZ9lcuC 9Y[#5Nxb V"0[]3oS;nnVkq9DR;&9hhp!qh|wkgxW
+q]hP6_w8IEvV?Mu.t|{=4bck2{|s:\s.=>2a+cLyTXE_
+;7.&..:U/n{t$]m]v,OOuN>Gi~^qDL<EF8[B@,B*B;?!2>[(PCzd=z[_>YKCg[Pl[HV, 
+/9L8:|<#YN]d jl+4-FFSE:o;//e]H^#>N[YUs1aY3a@=tO*0_zmL}-icgkQi]q*4rqs6<&O#uk/E^Nyq_h[ {i?
+h4]bd"0^e K<G}M;xNT[{{{p)gRr[>]<+=}& "/SRD:.w_w JKE@}-Fv^	GG`N]yI$6>fH>Hl6X?BVMC^:Mb$nwvtvse8l^3oO/*ySiL3iNEmNDp!KonBrG,y[~6m,YO}co0cv	q=C{Gu1&[yC.Vv]#'ighohwWM;<y;6QH;KS(m5}E|D4 Zn@P`BxHHKrN:ctX =Y (bT BdX`DI<W78_gs_yL7m	\Wyv i?vv3vvlg]jX>[/=qvM?Foam6h_FNm %=~Uz$/!]O9EoehU"9B@k/6@eMT@#{E6"pnduHWL)[j+-,%d9.	13>8MvJqI65%qYoU5s@_+LYC		
+^;n,;~r7cVQ63eo~EKUz	3=v	_gi>bidj?^X%/(k@B=mvV}z1&=_zv]cYEiYSs=m%	m?!^;1+rh`L[gae2oc-;am^7RYi6VNh6UUH3sb[0iKY6@R%@_#$yS>`L.?p*\0^6}"f2Y1,&AMSexWZ*@E^eAu<jCg]\f6x6#MPh{91<+cd?tn:\^=sMvACLhG \lNx[S]q@Of3OyO&hD]AD<ge<~Lt[xY>)/wz2?Eik#`lc=1]6Thrw[{y N_q_ky[g!%:8W2Cei\"ED5"Cm@fn+ >OSexKJc6|y9mUF:3:B}jCm> _E%1_5zU~z
+*:L	m +`2]Yc_k0cLze@D)1R!S&!SrRrN$w]}(]M}v1eWoP~D'NL"ptQM:3a)>1NXgJsxl%@gP)!t1wvI'uyYhk6pC*qtqM/` !-5K1.lF#zvr<[v.")9}Hmft:&T54c+01F%kBZ;"&R)=?AoS|PgW7DvxLw?zw![ck+>71*Y`PP/Dran_.tI Fh%y4VP3lWlU!7A2X/IKJ<7)f$R9sCc)aH57:!/<gLi~9M_0e32e	%VT0(%0M	m\RND]t E[%mNR{UYJ~LZC-}v%3vcA1]=Wl"T+9 E\}$7>PUT|60pP\,B+q	R1,ArC_YK#pua=c,v	}%Lst\VN=hh'PCA;!}\O%WHl875Z|F%F9@9b&LE)*t~ 7J[}b,p"s9?B36*,F49)bDu=?Ub!^Et4(kyovvlyf:AS=6eFiVuVENo\
+^W_d&su_!S_75wW,amECH`whqYomcBYZ]l$#f2uP?$0 ^(aHC(	kbGUM>4w<961>HksAv.5^=2x<GJE6	]1	r:pl,{aY#]`i~I'jLRXzs!U~vo~5=zpyms/_RNo]r4w~Hl5B_i|% $8"j]b"."CunGmCIu.K<K&9E^?p"tH}re:Oc#	wUoL4|m]Gh[znu_!&"[{0lC[wU41gBncFdZ17nc2}$gKP><pxAr(/^R.fp-+:.f+%L!&Rehw9{S:_EB[g1Ie>'e!)a_x12v"n1)[4--	tLq3	Dp&1Pk`FbVod/3&'Cb,I>[M,znc}Va#^Mm.(8:Zn_J^am3!xK0R39DbCz~ZwCg+ad_IZjQldW;^_ #u*]s:O.@:DXb	yjCmapt!1Xjg^_5||M.9=d.r>g>d^.}b!I+t/4	=_"N2,e6s]=n&zO	zf)4O#T`B1.*B'CFL+|ZvpSn?Jbxu,VMW	 5qitw7mmeH^t^z:IAHpA@h>eZ&37l0GEu):JynL^x,cEG@7-fJm.-8uX540b04
+0hu(
+9ySVCWX]e}-_5Hp)
+N gL:/b`di%EAfPshRF PVb#/3e~V2	wOX {h,9cs|5>v[ctctx/@*Wu+-_3#Jp<eT@tB.t,1ulB;>+nWmfif;ZtTHz3bOnc/sH??1".=Na,G:m1ia{`NKtQs>.-dV=D.=uirvt)]W;vkK1izx}w/_[ /< sz!=E
+ZRCm:,R`c r,"/Du^1Qr<]st1x#u~.:ZvVGvX]_&{};q[ok {->plbfTYC3/}.^pn+z$^d,!p7a6y7vOPoSa(bo0BO_H`AW-W..B6VMMlwJl.t]nQJ3o	x{|U
+K[|237^L!E,Xwqe_N0_ 2`X1P?fh{mPj q":}k}~}ty@%~`Lt]\mmnm@wq
+xr:zdc	t{,z+f5P@|^Y(%7J~da uXglcls Qc<;jy7Z_u8C'[?!) ughJ[.l]=`0^@g+@wW-{O^x<|z/6K,nU`d3cR2`p~Mw3v!4/cmZw |}xS!y/')x4J;+0zm[#My#UX@%<euK6`:>;d.o?.yVlme,o0#]C	?_6e4r~%7<Fa20x8oc>4FnO@7+E8=x'Z4AJvNz4kLw]b^wO.y .:&-x[n.O"S4 Nd .W 	l%0`gY L?zCz`K.dc<(pO~:1!r_4?g}zh!k&4B"$XQ%<}3%nfavWhW0:
+Q(+DE!oE*l6TIj7+V!ucXJZED!#:OwYk4wt&H|r=m:wCy:/j|xXWLe-/#.Gut!_Y;/s(:uBv1X&8fY_	fUmk"h#]nIx^ = =[@d)>)%ivTU|<
+*L_%20c-;R+cC1  Kn# Ho ;p`qKiSDl+2V[Y!3sZF'/E@@[XZO<3b	|s_aQ-Jm,"hx~9  /70}[jzlgNwh;	\$7 K[>	tV	3MVZ.d`ZyAO
+p0CGB\ py0K@{avy%=%w\YW7{Y5zk6|.LMcPMl:vN[d	uXn1v4rP<gw^w7cuco}nR|n_RB/bCvlbV`&B7eL*>vKm,f"hV1njunLZ|%^j|bFSs~=~YpFOjwyQ)X?(PY{EvsAbBR#U)ot%1K~1&{_!oF (lnV.F0Jx>	;^
+p	q9~9:mJcb2Wbomj {Xg VFBH
+qB^c wRBto~e%}L/Y |!@Uxtyf-  )xQ|hvi 9bj@Xql?i [.^3
+a
+"7Zhs% `;A1t*o~1Ze,ws"*N7|,xdZ*%Vs"4 f]<Y:_mSs:kuaI7t'?t5cKwU{_.13Zuw\5m Y[
+Z
+=<\ 6w*@ZlCJ{@mmlPf 1MK;"kk^r `&b*@2Q69:flvF"l24>o#zgz$U?\rl3 1Y=xwlf\WHGHx@Wv,&~R9vZ	)nw>C[\Rh-Miz 66GcneY5kjr|oPc/=Iqbv>zdY/;lL4. 777V{L^KykbJ@.=+VpzNb{I$cAi{1[|WPV3w]vbwxt0>}Fbv~6 `[AJ@WLg+' gquX4ad+3r?M1<*C^Q4cm2-{H72 -/4\^ ZnP`[gHb2f;dIjpg: T[nS`(*,foYQ/;2j}S?	_+ fx4l20?IA?&wepQO7Af jLfzjt-%luvhscu`L	o>AKXG _o-
+|q9/t!q;H[,aj|Z6 6XY 	d-YOz#b[[\7\4:XyKe[3,l	`'t%:t*0Rd"#N%2'c	x?/SE]|d-8z e` ;y 5Lp8l	,/q~XA<)YtGJ~4E1: 2"MYD-h}nXZ >$6bk!s6!C.'g	x?A=PB PUr9FzHCAk]g@cn~ faJ \;Wq&</i*IPJz4A	st}awf4B;+pPyk, 3hl DWo%u-WX.4+	h{Wc]cs P=KO~fwoqoIW2pk+H%LGIm
+ oM0_b^m[33re<,QF]Yne?%8[#B<N$j_sHj"0kuY`5Rr&XU`
+Yt\l` ]LV }X,Y},wk@E]D40i	x?&MO=j4 J~ ey.@@Mop% 0sFV`t@Wm36oIb/lqP9;Z}[v*)_.67`F2\]S\NH	t -8 w VL,;w:$"=Hzg~b5~ mos #[p
+5AYa[ 6s\)^U8@>O8m}elzc4 I`=[Lbf{uTUg*	Kj%G`1T QCpdr?]K)[|_h `#r0/}f! i[	60v2by0eV2p3an z~\0&2ZBI(Rk~, ZGnh-uH*1\[q[-
+\s~(>eFkkx,YD1=x}xrft1Rc)	WvdJ,LF& mi[5_e;Aj^
+M]0D+xJS~Ixk!	E?x>ltDBXKV@VO
+<`-"*0\|]tfSaia~DL&L-,:[ 4Zg)iAK3d>os=px>}x('?`.iQ! s	U0`D2rm]@u}.m*_;SI(!K`4,j dW@yM3mg*_9<hK!M:+c 3$Gyjl Lo173L73&QljKVbZ,e[
+ tsr-8^~F-1$xpB\_g^oR&+^b!$1 \ +<K4xP;05!80 AP0(_j4e2/mB
+ 23)]	|hzK hQF=~jwB'~F`m"#zX`E+U[C9(@UJ{Lu (m1 E>\{+HRNy`N }pq0f|Hb
+p!c>a>t-.o"Z.\z,]Z&Y'A}=1_Vt=4<-7|-6 `9<%Pe-Gh5LYlbX<s;72P,ZI]e_!ZJv.!!T`e.D$:s jv|*'dO24KGl
+ v.:r*;8gt_ Ue,W?$~-gz<\O?& ,t/\
+|-fzy>%[,y06`
+- TX`9 Ui@vNX/R]rn^Vek	W;: 	,eJ_siilZe*2sb bBg -@\.AF(KlpMw%YYSb} l_|f0 M |@inh  JA7+"9m]i`{~`m`\=^s g-KYDYnn4
+l^t*`p5KsYxx(op?uk} XcnE0  l04 p | ,,3"Pa5@57	|M4JeV@xYeKUCt)_6v W]c\7[NU]vAJ	):i**k%}v+iB/ _5 F=`r
+QfaNW+FlX&hur	 UYmmLTsP2_Vkm.Uwv
+A5nD\'q1+kRsoZ
+_;) ~ F^,n\]t;;.M;4?[5RKb5vdlWlvgU]k.2[ev2f6vU]oM`{Hddj {r	{ ?\XnSj	xO`;Ga6&80:20!1#h}9pj@x	m9wpIP]ufnzgjU#0X{H	>33-]ta[B%eV%U[cD6%=/?c & fdxB|H ,hIelc>3 E`<Rma62K&[v%.R+lNP1)F`zYM[[	poqUF ;	o[[P571gb:_@xq aD+WSa0row5alK $ @N5ZVL`KpX@&[Yfz&P]vTX*6[z-;56l"XAahoan-)27,gz .!&d=4rm|_<4PC[[
+\0K&HX99-+Pvf28sj$;;f4m!kye+@vA[]`|- GFQ;NGlmYmK{-x@fC_0o-+I)	-_ b!M;;;LYUay -;2ecCj@ /u-DQ$'fG{.vkcn@[sd#a^|F|2Ge*77L
+*,HTur
+XdV;Ph{Oo$-'{,4hk{8/.i0;vMa +O<!c 3oH,2vX_maW<6#Z`kf`NlK{=${wEhd?jot]0||i<z!2[wyhp%M,	_4V@slf3@d -+u0Nc Kst@4/K}7YF2b}_v2dk;`k2Xk^rh^7h;!gN25;fHJ@l%Mv"Q }}n16<uu;z'M,nDl!5M1#zDR=FKS'b&8-oOg	/mO&LysM,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%K,Yd%?Dh
+    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/icon_schedule.png XBMC/skin/PM3.HD/media/icon_schedule.png
--- XBMC-unpatched/skin/PM3.HD/media/icon_schedule.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/icon_schedule.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,81 @@
+PNG
+
+   IHDR   s   s   C=   gAMA  a   	pHYs  `  `zxE   tIME.0  VMIDATx^tg$qbc66@Q"z{z7 hcp^f4Z{}*{}'	||'	||'	||'	||'=q"`2mc%K<VVwNkVwpq2c/Xs7o?/~oO>m_lviuy{~7O#!o=MH='qu~>~[kZ)gYI68?7}XeGe6W7u[9xZ5)x\gx^g!xQ~xYx]W.x]f7	$x/cak[oyZl(lyqV6]Z_g85,Xr)rNLKx4OA-7Q_W5]U%+(DuNjcPPT$27]QGFm)CbIGoxOtP<4n-6gEXo5cc3v96ggM4!806O<zz][BmMnTW5e(/GqArQD&"')aEf?RC<hHwE5G$y#N!1$]+;Ej9FjZhLYWEx9s?u[Z^2Y3{DL?A^8.N%=Ox	?]7hFeE9JPVZ\Evz*r2kFR !!,^qG:"=4</p>Srrn<
+R\CKzd	".-GU:57}nH>]N6u~Kf$?72XYs#a2dzwlZ2c<?gOPACz^[T(JZJ4/?yBzj*2L	1ELdC _x ~nz	npWs'awl#{p>Xz65e8q>Nm^c9h3f vs1.X~';Zsn#gwmZt|pM#{pu9|G/_/<#T@>zT=zzaBo
+(*!QPX\ddf!##		d$ ",
+7w\GG\`6q<zWc8t(:ge`M~,\ !t6,Mg``2,Sc4Y>Vusq|B-n^emqV8F/v-[o}t	_z{`+	/)>O>Za:AA";/9F:&$+QGphCsIl} V`c?j?b6lVmV{{~;nv^cyXxV/5fcX6{
+V3'`q3e4Me3btsdSlh31_[dN=j_4imh-n-E5z&xF>8v
+>DzmF[(.DqY
+KJ[Pfd#%=It)iCxT"p{5:	k8w\%w]G BrBbV%s~-g:`^l%]aiJlZk.]E[`YXb1-&b;m&bhL?Ga?r8F0q4r.16j|A_7o_|>c34+jwoZk.?k|||~xM+/s<|AMqB-,)CRh2sJwDDewWo]`{2<HFJm$EbCEzBtz%S+~yuHA`h2^vam\Uc9gYSh$,9K4NCN'0: #F`1l&6:,,~5d~>%?6)l]Kg~*a	3}A{(9?&G7G:T0(*!
+\/@va12rqi:g~*"BBWG}{/ChzxCS_B}7W}+!mfT#"m=[6m%|B'sht48xh6_?g4O?}sQ0f4yt=Ot?4O/>o0uTg;4oNevYTUgg5f`6V& 3upm$Z\"d $1{`r	m@&!W#2g8p.zNW\IOhir4&]GbQ-
+k "`=x}
+k/8w 10~zT=v-9.~~Kn'nZn1;fgWZe
+T?u.)>}Hu@0oAAe5+WKkqFH.F'/C@\$?
+.nX$$#=3Y9LFBcp;ta/">"*GN?{t>lX,\0{X}?RNL1c`<x :kZ%{*P077CVmGDN1e4?0U
+r:_%>}*iK 5ZrR*qU;q1(ew3A2T{e5.|	jn2Bhx{+>iTw$U!.=#p1=scAlpzkEF
+B)v2x 1Iav7`]TS|hI-9f:cp0OlR|7Zo^Syt5]Ui~8qTN&E/(STJ~6?O^1Ys?uJ=Ru}nI	O
+@wu7EMDCti8]=mVC.ZV3?t9hPaGnf>L
+f3?>-@*j;a8cc?$?p	*T[Qc?iTg*Pri5YJjn#k0`z@dW=zjQ2gXrrRub;T;{]{7 !|#pq8^}
+0{Lbi<_USZeja`#nR]z7+E	|+=Yc4*/SItbS3FOh	*~@u3@(&@q?	WCWC",(PH7<V;>Z~3~jPU
+s 	P7	
+/y13NLB]:s"~P)gHO&Mo]{fD+Y3cT<eaC4E`:_*@	LgQ/{ .*7*7_/b4B+ZxN_p{9b+(cA`n J
+TrrB
+G=CwAWd?z8y"S->m,Y%5z}7)}wm;ux'T kg
+}'L4'NeQnVj @fxZ8eKL;+n9(\5 D)ROZ,_GL(6slA=zTn}SQT](@=Dx1u}`H<.sXrN/t
+U)&S2i<f
+&3-a*S;nrls	8prf|T@YR;k{p!$.U=x'U;^	D@r#nF[wb.+c8]E7y<nO Hwg8/0q8|]I'a'LmOx6+a[7=&tQ&]0 dG5P{9n?Gun2S!F2neI[$fO(c%P}ojQ~z}U2WoT {_	j@}Q@VJmd~6kps5BaT+~q4pFpd*O2L>TScE'xf,/nAhzh0R2u*vLUs*S[mM,%S+>H)`t3y6]PE@69+"$9uTPSU#+OT7 32c4fQ-VnThYw0+G7}Yhpei6L0	Kn?'?i_??07x?}}:q}R-a9o!c!UiQ@XR1KV!9DUL%y'MW2]}s1ZB`XvNXlZtbm5jKIYdG1FRLC(6_^T'NWX9w	+,q0y1a3+DO7x_@,Y|-.]\[/{AO4vf20[Qmxon6;}Lm!A\@lZkQicQb,?ebNrUpxVK\CG~tz\qRQk8A9;` {S4s%!V;pttj_7;gNPon\|mkf/\@~	nVu0234.0%5cm9WSLmWf26>{1afm--WPm@L\&
+5f@H@y=&YDkL~&BPOFDfZ4('gFkW10z);3`	Cc ?~O
+s
+ANXZgk#6}>#'\,)TZZ-q'q4	tiV{GOD&50Q%8]Au|k9oib>!l+9Z`*RR]Uqb.8bjlbP1**aEwoPO$-
+N;Ge0g>:G#s4h 'llk6FkCO| kvWc7TnY/kB`<Q@Q\uzk#<2up6+4'Bx
+\u,wFO f}N=hx7%y.?pn39+.KLW.x2,si1jh4pg0{mOS=679Jz| SW_h{*s4TfBDZ<T.a.U"ITWy#ym<6!R*Ule``ErUhje?,%@i1TnQ%?g{G]Flz	+DvQajJ7;F,wi;5f}&^<S`~UO_-w
+Vmv3Qy'Ug6he	+@bKYMJ/[V`4j,#uPA>fRQ9OV#{*` HAb+Jh<J(4'\p\`6j4ia#sd(c=Tq_AehxS
+f([G@PC[P$+@[VsvTu8 [O	j^U3.`0`(a{SSTV	+L_R S~04Z k>mPPsP8)@&L^RoDH*^8w5vLdDFM`qs(5SAPzR}GLqk14j'cG:2 2 4PvHHDdZ0C~0<%,t)L?KvvAaXftO3m]:{?A>i>{Z^}/@(,Be1)6zy.NNT[O	W|]{cwi|8LO:t1'ezu_gn]J:k!`*(+LF["<6ca@bXg63bzzq> Vbs,Ven,g`k7`X	ckcO+*VT!CIUY	.0(9[r8JCrNgFWp'lMJCZm2iLsGz+f}-]X4H7+-DRk}PT9T`\|60xD>ypW!	lfx,s}>}qxY7S&,C_Xl+r[Sr !.tk)cl;B}FRcT2LP*kdd6x$8s:V*Y[vawHj58v.6a0V`{e`k>qKf@2eW"KkD?HSZI|`\a3=wy0L}aI#vlG1+LBg@t|>Tc^_*W9kpX
+vhI0T\[T>xR9}p03-GfvJ+:w=MSPy@`2?2;t`J``XByTXsC(];d|zZt#fcQDaiE=?ab8?[qjDt+^sn:Jb> YzlQ	TiTpEl\< 0MuQTS7~H/+e/<"S]unt+YdP`c8`e7=}Bu0%:e!,Z?*<+aHu,#Y5f%M]W]kNL,5}Mp?I`	47G8c]vYx}8~N1U7sX=KT"^)HH~ST%s%f]w !0*x8aYwqE?	# }bHL|Sr7 %-O T (\$$)E<.((#j{.B=~lR>4={vGU)a nvC'mTs{>SPzP,\~J=-\F%7n9/#x}lL/-d	ML.LOi7E]Z)@;uH0?-.Q$1hK )
+T4& jmo34aC|K_K>*"kz[\$#M;p/e\}BsmicOE2
+L[nPK)9F%p5!2i?SF LM{;~Nc	0R3-8$4)pDPx28Va*J|rCQj=ii+>YoToRb~m.41q6>G=Ssu1TG\ H^k<2iU?2<
+cT7L~&w,}F@|p|]+~PD!,&Y~/&(<"* T0%O$L(1LAUpqoo[s3a{~klEYB 2/6K+p(P!pUs6\T}|nLj|rYK%H8sHTo27a[OC`|\/3{tBs'|cO>1'$C85(@j T3+9Lpbbl\dlb?28ao?|sy kmQK*R sz
+~@4@ibLBSrLzcz\.p8yGQ8aVnuJV;v3({;7OeFwd2W_^'YA{1]g*`ZRzKBw?S*'j?V()qMXm13A~>:wwa`1a.r=@S0@)6)OJ3)* RE	5k,T8WG(iLY iBlI7Vd-_7G3D4=spKSYepptGhlr2$R;Tm47Js/*7q>,:4QK.70x(Jdw.f{<
+!**|NT68!BT#wk,i{$'a\|;}LIe8(0ROnZ]:^ng|Es"_\y[
+M*JT[ha6+)	PH6V'%whkaN2#?Irz;-;m9q{S)(uj_;e'Wq{%39fN8")8|#ZSi27gWoaSTAa3{tUPt^try.j|}GyB:X;E%3q1P2( M4	tE/1qD:t gOc|L3l:w%'WS*e>Fbl4s'TT$DJz:89p)Ms6A5^hO5CP[\caf`]@}C#@Y/zL}8])w]e[dSU8PMZS!W^US/bMb,a1;8f>BH` {x0gcFvpQ.L?s8	'F^g/4!:#/:Zb}z*@{2yq\|QEB'DhtYc3H'1S
+8Y$S.WTRp0%nr|oH&Oh~t
+[86.[Fa1S;
+#L?:c,&Ti32h	.b[.\gB7b$0S`0p@T)lp^F@ev`q+Iu~mb@z?^c9|4S$\3`fsR2dflWK	dzo\,Jr5nl/rzl^:G,ccQxFR):pORYq#(,Y\9>#s2h:<~M|WL#Gt^Ou%O$`T7Q(KY\iuv=Qr$QUQo* 5] "[ISWnp6:m;twC<'VkjTnV6FAHRJ}*#-,{&l]pn8R3pY$4LsCY*32Gu6'8f{a gHWSGe1%ThWx6,%o@L'^`\T	W	;!"?+wF8b[`!1%K[f6.OZJxT)c?<}+gRs8Y,xE/C
+SGero&9lp/YoD_`hLu&={BpN5qOu%"7]H*Dzv&uwLzt	1'3n^)Kor0n's@+K3DeI}N@U@UpV;Xd|&"2>q9vg/^FqDFc0f4Jn2v67Q3*O1saoP\q`QO8^46vW1L;mF{BxIizK^T\tbUAJ!KvtbpjZ0~/A=E
+.?Zj jAL 6<@UUjLTXLR"Xpca1Usen}9-6W\=
+ca~+cI1 [&qm67XM(|+KY~WzhW~6_I!Ul2ct+m6 bfdeqs*)s*J
+Y=A5
+./L4lM'gO:81Gqa7k0i9mBc~*0r^=wn-L}0AR'n;MN^u|3Dw NewN?VJkz\8bPN<HQFTt2ZJ\2| F	G	r^R-L(`uruSQ%y&<s\) QXdh6l2e
+}wZW+L#*XVY8on{j%,5c7TU;m#W_dD*T ?dgfrlWC~*w0xR>Us7dt}Q1'LO89[0YyTTg1Oh%(j7	LSvpg%O],bK0l]HCJ<>;5d+n9MJOnv6R$)D*yW$RgV:d $GBdVy2I5o"%^2[AnMYc?5~=9Et-mW}ew&k|WZW/&qQnB8_]	f~4R5S796pj\U"hF]>Q.Hn>t?)V)0+Ls#Kk8}jm#'gNlEubt'-8fvnIe`g_; cB_mA"ro\lSZsBn~&)l2QASe64EN72P@jSc:*'UVS
+{lF 	;purT@69w* Ul6{p.^q*[Vx*.Z1cJ*VcIcFt0L1H^y*c e6vqCavI\PjI7+;RVp;B.Km&wNg`RYWX7f:4Mw{<jR; !$"LmDB';>1n8iCsL|rRRG"P}#;1|bpOThaM}:_h1{D c``7nm6SmK.w%n\yRRW5<E4jLDH 7D^w@%IdG{x(7f?>D
+feIuoxTpCha*y~KBY4}"Sy#~ukjW_)bpCL2C{Laqa*92iH:T^F8t 98CQ!v9QVR:^R*e ZCY!e >
+ 5^=}j1RVvC*p1= Y![{$!?^@1'<X1gJuN&=.cC3^0|e-T0uD!}1csSlZ\&zzq246;piEnJB'<yvhDBuW,Ph`
+HW{	Ler#Q^\HS\4nVp||{s?p)abL5x|;g&S;^0v9kz8&hzH/.ChJY,730@'X#k0Y+%H)BBV!>:^*eP"cg'`=XV} U7jU^:UB5v.'.GU#&,|OfuvRk/$m4<3w=a|F`q	?TWF?b.c4,rt,RyS_t={7MSNnZ2m+n[~ca1rf0w'bq=`E.
+Jd2Cby:E$%Gr]LSIR6q25D26!AUjU0?P%AJHRL/B/2bcxzusnVcv7	H?2~#)tm]&t-EUZf}c8l2b jGs,28w,DW[Sn
+qcOKt\/? *iAraL}SS50Cqcq07QI`*RW}Px??Fv[j#x[/ea	m!7M,F3 {6
+jG7[=HLiLsl\AqHb'^ LFIL\_:Cctg0.wK2fA:w|PVYVVqn)8 VBf0	%lej$ $PT
+ld?77>f<ax*(sRYMlL,zy<rBlY61od0f0kmVIeeDl t#yZU8nMK%Fq#h'?X;_AqLn&,	}?fJ	Ff,11LMt1]0$X=#4P_8Au$l`4=su)IHYXO	EjX8]/#xeZ.+}|l]>K-0Mbv`9Zmtha.qc'*/0i[)2I^;a)&]l'BEJv2.y?{\gv(3 vL*`QR9QiRG{5%h6n(%jy4| ^,x`+N@ab"EB@ *[	C6t1vY+|V6>t?7`;%aul2~rMF|x#7-s-a<+P3e.{a@4jxMv<Mq T+Kxj*50>;0etN:<QIw_spBX!bJn!*9k)
+
+ad\BxCqfJhrQ7f{/n\+nlY_1l@dc}@c[c',/3	C`xl]lFe/2_DDP,#A(%>?D|@xv6D]-@EqnTMYWNtjR~XANXWSv%R`7tm5 kAr,LR*/{u8!%58\a1vO
+eO6f~s[akHwcg.;hLN.d@r!2x!\]F*A~Ws7]Yx5JGbR)
+2u@9d=QNww8/RLm5'Zusm@hr]rNr%$%qq7]v`}66:9m'@W`E\:8Oi&(-;qAmQ.7	Tg`9aZXJFEa` yfF8~Ci!,2g2K@j^j6uuy{kHLUV4Nxy<eHzJZ/e\{M!"`{TS<; dQW,6,49i'B9[ki72_Tetj]Zs#\Qgs8c}o3Y[>;Wr`(a
+pZXp0iAq<4-.9|7{) S+qZ_s&M@+68,A;K#%?TI;prCst$Ad.,*sQY3zn|`mB=kD[W%Z+?~2_4mx38fCg0d1saXTaj\(4 JQ c$3x"m8AF
+TF<.9#=!eX6,RmIKcUkLNFwn@sF4&|N{e*j>,r:h_\\@>xmo;=>eWp%,fRRtA+[{3.P6;7*-oN:_d*T.8~	lVOc=0	<0SFkQW
+K`lr	NnJDiMw.4dQOSvuL>YxrW#UF >,m.yWL*[nBUT.?im)S?Wo\9wN-tv&@vTas')Of?R 5:W+'*e#<uKx"*9CKhG50	1&0 1l	S#i{t>-YP%.&3s*xhSBe;;y)jJ
+wiR!g\n2\ur\H[! yn)UYTj9QX9un=4\th;l%P :q<y OgI>d`2
+C]10on<.IPN2*}cX^8Ba=|ro]9.0kY0<,`z7q}->sGo@"\*)uZZ\[B<@qD)V7 Ha} qr/<\=
+ne0yX/f:}TQ{cjjp@]d18V1Z)E
+_ ^K=~8~
+RQ$qNF
+I+p:Shvi1.2Vs+VqnpR6h-|qAm-i=3cs >nBv
+Gmp:@+@wo5yOu*c
+[BLg4CXlWs3pb"x3uX-n@P *IDA@9{B+OK!njuOE,L#XNV]~gO6oJB,DQ&*(cNY5.t;szru.C#8xVT%\na
+u;&EE6]#&.<xgRLVNuMF0m7'7-c	3sd9%"a&^`Led2@u*]1!wT-W.{in`RyPUb-(VMZJ8El`~DuNx ?{kGQ_<]8sv?/uj<OpzhK{6GI~Q#-aP)*M{>X?	MsSBK(KTBH`I) EJTi e\Jt
+Ia_M>g&
+Q3 6wOe6p{tk'1pfsZTCPsKy|5
+TW0-LIg1 7xLGqY7s<Kp8p%0Cx(g!
+o<vdl}~c0H#17~;?L"i:b#mT:+dKUR
+'@}!	TN^ca@dfVx ia|na/lK)-$|<EJ1M"J(J.)ddZE7ZmiY{*Sj|E:]br1Ngs@O"$#XQF@tAzI+x=[trM071a{2r'}\	tt*o_+vth@Q!Gx)aA#@JgFh@fGx5e,08]#q#SQ&*Vh%UVIVHB*zK:]jahRp$" Il lKOE-]xu>GgtO*(#(AaD@8->|lj5?#'cff|p3`^FwM6
+5Sqj]67k:  (fF#;b9Q\DrhrD>-/*@]s#?WqJ=S53/	QI$HE<OLF\xh_c/5k<ceL`yJjt/{ynTHu9Gg		WN)|Bc#Q^ 8[=o@Cl30y`W}#BgH^1!VJR	12xA $,\s,1	bS~Ms|*6PC|M9U0	-)8`opqdap)Lodf-2=/ ]"" )\9TH&x+qr-^ysGmKm[gO}%khXTK{7!6ai02'3,^sC	b>XAlb(B0V/ Tt<|Ns7rA6.TNNXQ})w@r|yCEz]D6f{Eid\=D`zlNl_f%K-r2eZSG8L[_]fbpof=t/Dc`5'a>E<w$)i
+LF!&F)bCQG	h!YD0ZDQ~(Ea!?ytC^+.!\2:PB?;\EE{C5wnjy4n$o77w'X9L^%6E(7'Z*ccVT^N)nxOh yd\	@)E\(!TbB-GYL J	4)VB0Cq=.("<+GQlq2>/[38+J[2v4N_O>0&^='V0x2x*5 eL"	PGhyv"->EZ1&0Kx-UF dY\ ciYA+'r-k(sC	>)	bQ=/ ^5/#qt&l\EJ2ru#'L4yw/O?ao7[Lx{z-qtfG7+VzQrP"cP5LY"XCE5TF2(	;~r?xN=^ls;e.d_zBt{[	fD9E51*Ej\k{fN5$<NpZJbBW.|8/QqMx3ad	[)YhYisO\Ji<jn3T3cM:Z$yd<Q@;RQF(X*cw(
+.3ECYDp$.= _|U-;5}r3#__f6~RIt=.3 ){ AI#+*KuoljUW[tyN13	?	-><e<8{]?D_:CNq>>qck".Xz=~P1?;].<~yf[3sv2c1#_O>>O>>O>>O>T +x+    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/keyboard-btn-space-focus2.png XBMC/skin/PM3.HD/media/keyboard-btn-space-focus2.png
--- XBMC-unpatched/skin/PM3.HD/media/keyboard-btn-space-focus2.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/keyboard-btn-space-focus2.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,15 @@
+PNG
+
+   IHDR            	pHYs  N   N }  
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   gAMA  |Q    cHRM  z%        u0  `  :  o_F  pIDATxAKA'4]PM.AJ )b!;9<aaaX|'>5H0:f^Z[`T0@;sx^aTK
+bNqGLY;2NA~f* q\Nbf/K%&Kuw};Od~*#&d%,dd KY22Ade'thz4,
+UEFM/X3h9DfG@hLiR^(OU62;)5q *Q>.iZt:Eu@KR~   7D,5.    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/osd_button_channels.png XBMC/skin/PM3.HD/media/osd_button_channels.png
--- XBMC-unpatched/skin/PM3.HD/media/osd_button_channels.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/osd_button_channels.png	2009-04-04 05:30:30.000000000 +0200
@@ -0,0 +1,55 @@
+PNG
+
+   IHDR   d   b   vI  
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIMEj5    IDATx}yeUu;TU6*O81fHD3
+QQ!Q"
+Y	c(PAhhk9gksNu5(
+.[UTuon^u~6nryQBX7-:6|+Dt_!j?g?aq]H?eKpV?A7?/}tr,"VoB`fD @ 01|X88ac`^Y?1{IdK^Ya+~@jCXa0~N#F$su< km_m^uj ll;j<^:lV cYf`,0Eca b5FkNP g f H puP%YA}~w	.3yh -!C`#`fXC`FaC`fP2i"&S Htz8 !B0L0Y^FY:9[0yi WfUO=]< R4z	[zKQ'A!
+H  !KptRaa~SugmO<sWK~y!`^d`l2Dc!yjbu>'@@DWGp;xB@*+LF#dy,.UBU0[WzXnK?m^,7fMknBW%D	7,f@SD @    w5|U9rZ7~=w;Q;9u[AmN|;e_G\7^"C^rB!%X:d%C4j?i  5PA  !TU*kr2E x4h<EY:xZ<aX?O ~w?8`,c5PSW-iS+,M#Oc H50U5) GEZM'%PW	z*k36KnyOSwya+2 )!zD]m 0^)uWj!%1PH@!xh dd<#u/|YMo~KYe8G 5)DoA[]u#@_7yIsB2Z=!!j=00\-kAps@UyL=lpm:/y z_;s2[z3,W#d9G/A'gAd 6R> 	Ba:]!3e{#z9	5PW%e{[x/!b~zIU2<'!/EyN'#SRXYK}^[ #?B!flc4<rRoXjjl~_ yrs`@^  Bc5FAs}b3%o
+_1[3`:aK/EIa<%{1Cs m`f-UY=#~9_7AN?[:Wa=1E +l96!z#5DA5BH{EC0L89yBB6&6j~ ",.N_={y^g>217u<{`=j<"orH5IM/(gtLS/;I 
+Mr	6QNTRw^j/5 m(~`b4ZG?.3Os-c9CCUYlMB(b}r3- I $z
+.]Ck@mRQc'#:_*hy#?.O|~~As/B@ bU4XHn(JE!Qk4M@mc7M0if)R/_Pyjy|#p5=ug7QF36*E&Qm?$^x@k#5pA!^8h&?A@6!Q.,., G7A?8,&o8dm&&{8K3ZuD$:Yy?hUjNaX&i{d=;G</>/~ub5oq:}G_zhr><1cC6!G6B5q|/ Q("k/aCr5]yFP_?<gV_1OhQM
+ ,w1\Q40s`L[0Y0 MM-)qCby!("$>-mKMXSkWc}_=sFO;{?ny0k!Hn1;38G383=ulE*a59skX"e30,5$t0A(C ^oDp1@6S^hMzp!G/|_vY\cv/n475dq$7SX+H/X
+~(t%L CF`I@f#Pa6p!w<
+|o`  
+vd`DMFUxaaasx-?0k.S}6}_F\CRCCTm.{:S7{5FHq?,$h/q' =fX3H@f-6Y3A|jD!9&kgbiiP2B]cp3	!orQ kdvlk4M^&&O#V&m ;!@( !5 v# b#V&:,ZkE^` "e,c5<j.w^}_iqss	M_3V4[w*Q]*!  *&gEvv! p;-AI	8iY&2F, bphS*F-`|Jy+0u	 +{'\&G3[HsvC["T!Bf"[lFa67*qA-1d+":15E=, 	@*sw>?Vo|0{dYlHAlQDl{%1rnBOp8*//B=pu *X@N~@iiA>|a.4=}~W:6:PHzBUP A~67	>
+_Gp~ 
+|c5yjR96JF3L\m. XUhW_seD-JvkE;/L38TR#5E171 ;k8hKKkglP<:{gWO$<z+%Yk*? \8Qt<H4NqJkw>:ObL8W<&c4`2{C6u*J*g:{ mh!XQA,sB.vn-,vj,-K-S9o  ~l_{1]v}@YQ^p_IZ~p8xE7<,JLp?
+puWT /y%p9!*8IDP2^xHC=`]43,-_92oUx8o;."$ 7'pD  k$\}OJGK1-;}HC |i&
+>66;37#<u'}/xan7!2PB&`7(bV8al `Yn{D+}F`[gio|ZYq?Y%MT)TQ$nBSBbAXp5"uOL&cS
+hh)-KiT\U9F #(}T*y3EbEk	|FNe:
+]w2[z  [\w O1ef2C`by67ps\p77PNrFf$J!	%Pn|u+gkn3qA|At!;H*XB$@t8(e]c4F[(%?khtyfhZ6Lz#5^+%5k.7@]	P	qenfskWOLDi\o=j>, )x&tT1Z4x_Vk;U;/>}gy  <:V
+1^Z99>X dZ(r$Lbg 2{v-O|c$805 GwwT]lm4Ebq;s=:8HKM~+6ln5D5b+Fwc5S:ctE70-!1*upo#0f18vH	"![b{(B94y(l	{L,3,m/ pUO!
+-M6L>i 6Fc PYs~5fVmz3aYY>>1O}:!{=Wp:*PD7@n<F1v'qL2ZJK{ Ogj66l$GXC6%x, ;r~b00fY).k~s:	wojk8\=g<w-j`kTADB %6\HZyh3k<wW7kd4:nwd:Pl4!3A2jy$FHIYE`Q=\*;}wUFL&J6. Kk~K_^df#H$b^Bc:h<m	YnPV+}\oi@U!gmj(\cIa+zQb^aaa
+p)L,G`-<!NgN"Q:0ZRyo8;Qp1vq2M{;a$j*fh	dcU<(2r\-fF;{$F(YCvGp Yw3]]#[bO$"{o'|5)$PZp%@fuNXch1wpmib!Xf-v-H<y>H2l,Bh P%l>Fs,07&^ CQ(f$|Zt^$ :,Q*K'=j*Zdt0PZOtR~!unml2;"N	3ZV9XP ~=74sssR<{?p~^_!1bA/>fM&SzjP3U~hY:}C"!wS/	>Q\ n.aqZ[n 0DA(6*2qpa	g}Wa+yu9jk0Q}Z@oG5L!Ud~v!k79EZ6'w[d7,q
+nRoUFy1A%	]ka>BxH 0c0+|3@UpN c8rynTQC8euzJ(->5DEyIb*$t@Zp]|570{!zDS8n&8*pOrrcm]GPw3<VIws3,0>X>`N02LO}ek3CC*I!WLH/}ooI;	>[UU641!i1a$D1Z-Ck,n
+g8?^Ans
+`A@h07a~!u:sa0gz}Ep6$zE0!q*<Gj`5o3J2.gbw~A)_O=, 1lQF-w#8_"K]f2@/(	u)4bYz w`dY(T|X-,u"$-gVAY+|	EqBBRjBslV^? $hSa,!6c=<	,i_0`^Q>mWI "]@D+Kw#N'JrDNR9W}y f	{\<T5JvFB}!9``CFo}DrVpyG?2CS&ZiL60U>thERhXb!,)$0QP}pa,G/<b}cl|6/y-zA}zqRdEQ1A^#ABgvfImE5+YVIiV$\ee	z&+kLd'cA C%J7 01??WQ@R*`C"@!ER34D(@PK83 QA >vS-F|hH7
+l+LxBJ$MBWLL"RF0'gE8G1j$'yaQzY=0a~w gh7HC0Sm<@XqV bp%?	7U6  vIDATQJZaRXa+0p-QV>i|dktq5H*'=	-'V&O0t.Ym9aS l|Y.bX7'
+a"5JX:SVcav/3
+S&|?vJXL-(z}ZRn]i+86F)AiN=CA)E"Z;uB"nR#aMvdnoRgsAA*z	9V_-@F}r}^>(5JBId<FDGmZ3rT0	bD|fIuh&*nLV1BO{pKP-
+<@,H\g+t*1
+M10M@#g14Tm%69WBNb^.bYxP)&!<Uw)90.#co+23('>Y~ng	Y\b $SH!M:w~6tR9u)\%:>%0pAr_(4R.929zL be{QvWI36^E6\IdxaM;yo>g'?XU$#SMiU&Ib1HCPS	=OMjrT0 B"{)0A^2`^<2:Zu@`zMu;I%~~1H~2oR5#q(8
+45N?$ r30;[$AJ;XePS7G 6}Y^-f [P%+	Y)q<NE;g?'<~ CKB&	Md`iBp\1a=gia(zZy	lC=lDAd(zc4;]?\5ClS}UI}OL=9`=>z*{_	qXE_'Z8PP.9%(\ZH?49|5Ez<?{?&	^z#WB <(/GV6AAaE7lo\>M#&Bj&=Hi!VC39 9+0yq<Fa1=}vso~[jq*^CUB '8qnO ?[8!-gX&1I8z3!.p,au!D/<FMOk?x~v/|U-c:[FYMQU::4)4t8h1(=}&cxYVrx^Mo{+	w$SKXHfg\GnEP/t|i`8Zc{l9Hj_#8_{sJ*TF.DN0i(w@U~ok)>3nt;E)_#?C.!DuC &n<_&w~!I4w`1F T*W6n[f #tFVTv+-cuGf|;wSNhz	`2L. `2FeW?9Pp. a|DX@>Paz}F'}V)I n`J)UUnltZr{]!81"N"`P L+qB;c\@kx<+O>2f S)&EM+E4f!#U(4"YWYTaxIsLTPKk5t6nue[};OF`x,@OrTO  	0{5</+=	l6x,od\,n*o"jSFfi" LTd,AEr8:bo#3\?M3'!
+S@YyM/u<z{EQl##
+djTa>B)`Uz(YdxREd,JAY-5ZUzZ!pj^crXc Ica'%f-<3Q*[:$t*M&c|f$KL2=@	
+NC(hrDC@:;J<j X;@f2,XhDAHG)l$)_6b=V}LG4,AxbuFjeW\+L'%9o^)ol6;1J;t!d!&JKEf-i;-,Y0;QABA<-&#MTr:,4KA&$CJ&k'9f@"`LF!PW@]!u ?:#^2/_~3m`aLb	Jl!%D46)@0d K40<C#E9YF*{,dPm6Y5L-s}=9>_J/%FXJ,m5G*g_p_.x}~U*lFW&ib(}R|rRP9LdR93yrc(Ul`q79%tVaO~V"$t LHhw_T0f`4P}rC^3;e<!8wQ NB6DB LT;f,!/}|mT Yjq1aa&8)$%iNBY]kKB
+C2 x? <m^,J)z,1*Gzps=K&rB-xu@U9TepiLju:SGamiU&TEj@@vA=Lw5l=f44	>O?G<mz]z}X?>LgBtfV2.!+%v!3cg?6FnZ6y)YNELD IXBi_1.Zr#	"`F(D347CP	`4aGG<1Jo)h^1]lllTL)L qbF= U1B'=q{"NS|Eiw@vE	-& t`X9,*Ec,0='m/g\P:Y"+!JS1B52S=c2j]{cA&$]!bbMH4sua/71&ojfV+WLe	G%z^_VRn&&-}Bp%>J,LUFhOAJGllw!/J_H|>k;%!P	r5fORPr`2vpe>>?|3^kzL~N9sp},,vF;e2.^@a6p1(n$4z1< sAfpZ#
+Tx8D;w_^%k[cTi+33^?N<gcG=`fwLzju1`y~Y3z8//H:E~! iFtW
+RFG<8Hr#8^jm95-7'{&]G@'y@`0CldtT@+JgL|jZE[Re7QGp~#({ )J5DU%P,`:ah<w^eXw4`gs7ATas`V(P}cPfQPq+_H`OH[u<"xn%{UE=MgI|C9S\= M~1L!$+E@6iNi5FrjA"01,a iZPG]a#0EY(2 abExCU+!TX}:)S/{S6mf63[2=x
+GFz=<A@*U"X:RDtw\,2`#wHaJUPf
+9o{gzSx!$#m&j.>8r@dOt^a:wI.VP| X%[tOQ#H01SZP5f)&1at|7I`xHE#M
+JB2~ke*DQ1
+BF=ZO1\J2`v_=g&5 g	)_zqO6^^E^ s%C[C2!' tU4AF^)i_'`5DxDKgg/nM;Qns$=-dKK /2y,y#
+,1xU"kXRiS,2S860j* "7|.mY[tkx)f2,F(CgkTxW"jzQ;p8(nczgnkq0H EDG{Wa BP5'0CK[xYOI0CG.xW!AU/mlwy};n^Z}*rF>rpR{li?*noK9 s
+!p?ogs}j}l92xI$c4b;w`$;xr~|aPlLz/z`[<'.axw    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/osd_button_epg.png XBMC/skin/PM3.HD/media/osd_button_epg.png
--- XBMC-unpatched/skin/PM3.HD/media/osd_button_epg.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/osd_button_epg.png	2009-04-04 05:37:25.000000000 +0200
@@ -0,0 +1,42 @@
+PNG
+
+   IHDR   G   H     
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIME%  SIDATxy]W}?-][k,Ye-cc'que*I&	'I*@$HB&adc$Y_wn^d[![^=-7>fO=nnrBRZ+8R/Ae>vxcx*&~`|W}GO_?>5l N\!J$)Zk8KzY6w>}oxwIW6mR =RTvNWv=OLuspHR F`4Qleor#CCW</$M#Gv;wter
+E9*A:R ;49XhDj-ts\?o>7f*{>}tld[e2PoByAz#p\ekHsZk6JSHSE@+XE8j!j]9?_z5=RLT2?KG<UR3l HWJ+p\pS:GXpdfI4Il0TMEJY`i0kw.;8O}|`jvOn]8krf|\&i|]\i9]I1I:bqZV$&
+aKj*ZSC~}UGvJ3g;crvrZJGx.~Zfu.
+{\ 61Fv:&I 5eNl(E2=]_u'^8%-Sc7MmnFuChpdE8N'3,9n@H#Be/QZ[a&4Q	f3Q4	b|b+7\[{g/#?@Pp)$/p}g}elp`9,q`Hc:9CD
+	 1;UnZV4*~~HXp~T-yI_TstI$A <#u0#YOL%/am`rd+-l(n
+'qcge?;0?<n?<xI/3N7`bQAAyED-- !aMFfmNdL?488FJplfDkMZ7~~myzEwO//(T7(CJFS-:FJp]@*9i $O*h}Em=rIoR1-'069X) 17D;N<6i^T*HSI(XN7~F@#F/RA 9=2?YZJ\pr] 4
+=y{5.\e^]Fz/9 qsr$xpNv-Jbv[$c#T~2*By	6/
+%1`?V3$ST&qqk+2fH}62CNdErp$5*!5xeeV+<K6xom_IS(1&Hd6 eL.<;p/neBZjy^;c|iA2)_xz?}K*^u$&lD"H/;BZmSwvX9R:JW 1*+)&JhW&NljLyo^y'B(T[Rmway-[ F@#|#PSR(1Zij,JLd
+E<?5r.M|_puJB7IbJm	s2hV :](Eh
+yZZCOq8x(-3:v/sfo[6n7z{aKA HA}|g-Da
+3UG<Hi+{w3w3]$UZ+9x9S{R0\yw|u.-[n|TYbE*T0Jt`"g;gDkMt-J1`.LkReKwzm<8MuF,ZH
+yvf`*U(rh}	
+CSeu;g29w(RHPAR&:w={ndrAzyj$Q$HL Oj[d`BSeDD.LfSDGH<FP8Xa@fNusdK>,&HRM+N4,W
+/9#;n;G%B63\HD.`$i(P9XT;#}<)| zvz^hzk3S|i$4OSL_y=F;'':O;T&iL
+b}j$`1s7p\~?pOlj"WG <uyrD;()n1oVOwaRx,)a~8tG)k#a^&9cmMsMB:fhqwqBLjX$
+JENWhPR0D9XA;H+Z p#fk/1:b>J9X.mkc|ri$J}k)z=IlUq\\(}xv?;~=uW>zgj(gfRqmMJZ|9D]N_izEJ9*,#OaNJ OIfR9<EkJ_Nz.|qyZa7Up+^UY6p=]Ki51^j>,|Gg^1s ^{/)wD iRSB9X	@30pz8Cz1]~(oEvM7:tQY"jtS(LMo~Zf
+A.3[3& s;y{.x==q(cEHT1zd'~3SLFGvl[49c"V"jh%Hbqkl%(m Ss'8t=PjF&:6]J%O=w//|<%S,_~c[H4Ip~|846C8Xt7O/3y^5Q.ss,,,pa`Z;J<}Oy.a$M[x\6#'Bmt70~7h+8X+/Tk!QXgz0^ $kr6S(%!\V)ji2Ih[q#O<8Rxzf6*FTR0>qXs++sT<Ox)GN|=Q\"pW{{^MZMU!L*+I"IBtYMo`FXD	tMO"7_s?''Qxj^<u#'g]L7P{ *Q"S=/}N~uSvy>[L	#AD&FB+aIq--8or.SpnI~]Mp?1>ytlVg{X?6G)E-nex`rr3)w66`pe^bIo4Y3lZz<KR=OO20i:w~,o>g|9Jj1} 	l;vWI5V8GG1af4k5jm+PzM09Yc?v_}UO>zbIg+{|?gef~=L2-X>y'Ng[Y-u ?O06I5'(^U"tn{[r_8kWn;O$ M$E?wO93<a#R"UV` m'Yr;iZ*|rrj}#N<BorNIhVIUWYH@(^
+~4#'
+WXtlZ&:<@u![f^g\Mx7*3b[tS-*Tj#Z49Hqcb)_# G?}|*p6oVE02'H+s<c{\\vq`g-B+ZYPKPp(d~z0LkQYpgA/dWw,Xb?8[$WF{p]ph	]KX6R+7I#zTFF-$~AJ%B.#|(I|gm*Gq`G6K+grvdjY:ro_j5GiZ	 j/]'.v|}o>9N9vk+L 
+8R#YW"u.Sv2B"	HGF!q=%o>3;H{K5l~;!J0bst@p^NV)|iu=*IJd\ 4R8%B%(<xgk{c;HV0ZG95MiF'U8YM$jm!Bfgq>9<i&HjG 0! Q(O%1I(37RY8w8;vV&s&Ltr3/X;v2\eZZ*l%7TX[|jur(=D$9xSU23w(4Es#CqM2@rQvP:J90k#IbG3^OD|-x-=8$M<:js gmi$(HP0: Ld)Vqfi4CyyoINh?/8y^cPQ(?51`g_8$V$Dmf-uMX"	!N&>qB&;`v]#JI\edZYj3T.@0oHSM2>8eSKW" LM@iFQ
+a#H{,32w^~;5Z	d^YNI5o,?)K}a*LO)RJ[WJv3Yn`8ycJ8mvIG%mG:Oh$(i|(kgK=C'I@j;a]2\,o%0D" QLslXJtHre{-Zc7;EI4I,T{YVp$ue[ :~JeN0_$fj2s/S[Lf(VK
+Zw|e9 }U*L
+%ip;2-;=m:NRt(729I#(3eid i54?nW4NyhQ]PDu:37&!ir,%\JjOW{Tgji}$)1-h6QWJ{mzc8n/I;':cs9!J+/"yj72aKR4AWS\o~Y.8KJg}8V6#53hm`Qv"*-Jo$sCY^T5TGq~%s.}"~3=JXMp ;5T5t3.O)-[r`4a(ida>ea&'-+|]w~fR\v[p6W,z)u\.1fKuX0VuU:sPT~G>kz/Y0Mlg?D[856D/!+)MWoI q$CMiyT{q+RsZ	3L3eA{SATd?h5}V&6
+$	[fCh()Wn_^1V__S6B.&L<A&TG&&eBuAJZF]Si[w><bcvcj!\**;]u"0[dHX
+0VEl]|{N^NqTU9*6R6Di\DbL aCgH4v(~?zN5]6pV.]pSi?u03qc15`$5DXF349(t1t
+#(s`_{]jt=&zF)Uyj$12H$!,!WDSdqq}?@z9tD
+/$4SIZf"I"4mAtaQAQ:^r|>){+r/hGD24Y7jkNc-q&e*UJ<Z(+2Hq)A;O&h$QdFnHSXbBMS{}1ew}.a"?|pv"M3
+uOv}`{ qRQ(h5L!Hx#u\'S
+>2E4]*9p\6pK~5C__]W.GI]J%     IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/osd_button_portal.png XBMC/skin/PM3.HD/media/osd_button_portal.png
--- XBMC-unpatched/skin/PM3.HD/media/osd_button_portal.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/osd_button_portal.png	2009-04-04 05:50:58.000000000 +0200
@@ -0,0 +1,62 @@
+PNG
+
+   IHDR   T   N   &1<  
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIME2:=J    IDATx|geWuw/UNjV+6JB@H0xf5c1`360#$Z"P_~7>*Hlxkzs77e1"-W[u:9;_u{]122C'-op}?O?O|v)wQc<~-f'FTJ
+a;w=}B_<n06PIH D1!CwR} <^_~,}a'=  Yf!RC;P_h{o\	|> T*IjGml9;.Nd-\~~g"M{*,@%@'!%@P}9 =3?DR)@u?2pzVB
+dAi  17[W/N /?OGN_48CS/^_oJiQBg+/~.4`&QD-Z3mO{E^O|i!w<kg=JCx(/}/4xY$`-Ak $VLxY WmA/]<:k=_\10\e|CH .PP31S
+Dl5#}cAN_53?(f(,2cK@t_Z	(O@+@)[hEmj42=Op]~?#cML<K 	aad4x^J =;fpc_ eGf_hJ@o?7z'q=;Oz[(
+|_5*!bz
+'"@2xw@t D_BTGrzJfK+uq;o|l=_(8utr]N[Ro,nln7d i)h08ie19
+~@T
+PL! ) gvy K	IlMfafc=~7oV,Ws3nXPVQ+t72s<VeZ&]jt)Gf1;yfnEI7&VlmP/{4Wtr=AT5(r`(h2d@uvG^#3K%a=OBJWJB*	%_~{d !,YA&DJ)(%B%2$,>8$<s]X2ssg`),Q* RG|pf'_o!$)%w$M@b1pz_*-=7@t*$&3Mba|6kyqj_mW{UT>%&AjIK	)";[8 8$	<s"tO)y IV-5*%]b'" 1X! 2+?/R:P5A P8:3 <VKCB+Z@PBUwOiB
+V%%VXZnJ	@}L%
+R$swt'&"p$b%AIaIh#]x) ~~7x(W%@uIIq{ 8)e
+! Aa%'%9h9	w/vXskZ$$WfE=\IvvQ7XZ0;yRCjKf	^ $JeR1- =VA\p.$
+8 A){v~xiR/`E#A gA*&gFM>P.k,~ L4 r92jx>aIH?! S.S
+(Ex!yS~"ZVvwpR ,{ c,  -X?t'#IbG!AQ_jzs# x2(A =Z}n:[
+=>0Da)/5Q,nb=9kUZp!R8&)QO]$:mH#0yST Air\#7C|wK 	 gJ.A6)	AI t_C %J%g@Je@P!pCNWa^y}NP..))M<,tIX2(t%OK+>fn8v^!WE-_+:`Lt=_hi4{ 9`.;qU:KRro`22wI8ZD v!Yf dP	GQo.:PB_15j BA#sy*,50
+NGz>\9EnU*'.iw8Z$P^T7o-Rd-2:APZZ|Y4r0\Xt~`U'~j1r">4_Nv_9nV*!JSGfz~X$eR@((91JOyAda Z2|U _@BBBJTaa1u uEVija2	c59PWe2( ]b$K\{(C6#GMG`Y]BuJjZAz"n65cz M0T;Z>  JMZH. qZpC-fP,peQZ@:O],JdT$J'-5	hmBJ~/;Dl~b19Zd<`t&T0^cQOhljV{if4n\Tqv40@Z#D)
+6?BP-sztM3,0X Yhk<E	'RO;'@XbG[%XrTHsFbs|B&*FtP1V~3_T8nP&M'QD. M[rk.$`&zxC[d ueuUBcvK: ~u~74!d_LIyYi%$&
+
+$V
+h!`EN]cCfKqFXCKPQY"36.
+O!`moLF'D,Xm+DYfg
+C[QA /alsW{l|$41HSBdn&\F.q}/ H[  c	5.1__oF/==s[.Z`19zq%4v5Bo 0X,Hb4882aseb8'JoISf4T#K	XcZ-cDq(JDAJ2	0e@h#P4>	mL*HamhD;K (O[D@ ,0TcWa9(%Ko<3qxf'}yqKq7sK&=BXh4zr+'
+!AfR?/M,L"x*HJ	Z^% iBjlE;8loP	2P X:	j=PR\6CL[Z8c^	c^M&sYO.pa$@I<nUC'"khwTV^K$~.AI"p>*ce5i
+brTU1V ,uW,S1	CE_M@QDkArHw:R]KPw"M3I^zcxfH6#	p#>1R=;|_Y<*ucczrU@f5ov<cRP[7$J%Ld'eo|=
+A]6$30Zk# f @e=lO@ZA7=>g I6B]D=y8%E: Y9F0V;'w,$CY-  8'w	w;qIi_gvh=RC5*XGz{$*xa"M5" (*&4]XVdaublz;d	/%Gn5@mHMvD8ZmD	qa&4#$	0(&F/SqClEy)AJ$aq |o ~5?/XLk	Z"Yc:P>.pnsn=-R
+D_h,v(Zi,McP_X2~l^CK_?`py+Bo!J:Fatz7R0$I2G=nl{fq
+%qZGb|$l9
+lt>^;Kc 1z4^K)n+
+OR2k{*G*As-$R4H3ceo#]Y"K[@vleHbH:?k!4XlN6hL^hdCx^}S;$6$1sQ /)p{pKWC7a~xE0{f7y8NmC'R0M4L-2/K
+!Ja'$"TJ	F]F5XzgfEfO2F/y&F/%=e,p,0V;Il`iUY zXh>q^*xfN4!jhvbni|vs6-RYnCmpPjO@;Av$I"ZKL]9 CHL\h40" _N3I!53no=zmLdJUh3L4l2q67R9wbjn	 z=zQPyRZB
+vu){IqTyU'm-IYJ&.fZ`[0>pL~% Fkbn5<& 2yI(
+AlMLs0?V4cVi`"d	f)HWhF).\9MRK)
+^f,j/+
+Li"eC-kf1A he+N\N:`-*4:!,HScl$z&g]'ji= :,$vc_D%]kn:EROl@jNkN0Fpa=%];G-_ZB3C/VW]L(\9dpF0,vD'!mFhugXnjyWF6yhvfC\_"
+he,#K)&#X	q'cBBH-gIo=V:J0Bo4a7)8M4D-vtZ%4[uq4.jquoEEud]a[u&6O\/r[yz.A,MivRd#o{*EpH<UJ84^)Ae~w}uNS4Xj2V f@{YH<%ht>2L\`lq`ja<3X_wmwrivo!DtG2cgwy-<I<VDgKH3Xx
+Z@j	"*Ca]VF#L|l	&a(CG$R@]>SbSM.Vx}GA8LA+!s[@P,+QWf	&po4cKUO)dghByTERW?g>(]DC>'(
+
++J`_R8
+Ohpp)A(T{jjY
+NY+`-OxW:uY8@~N*Css *~yR0K,e1^;n.==1J9ZKd6BE_(d_Vk	+7vb WnK$VEW:d>e0HS .X41+ZZ(y$'i"5IFEH|L_B^InQ%kJIn-&[dA4FDd4# AYqW=?.e;>|ruC5P{]P(E,whvC{.@b	BQy03\G;L%[5+V$I:^tP
+j-=Yh,&ppbcE2!cyE
+J0R4!)'n,vFIZH,w\
+R9+)::7BpWEE$d_-E%YOeGsVeLn})QIroHdi+[z]$fej	EX#$ DDqj?WKK{Vr3})D,k K	HZ(4E_l-!UF+xm?2lf&^/N_W5B=&
+iV` M2%Xu&	{d8r%rQ'`@8d]?eN
+||2oehgL^F[<G#8Hb-5Wb@^F4c(+)Ad3]dhE^yR\'9Kh-yF B$,A-EIQ "	ID"B/[}+bD","Ia]$rl~&%|O BM(c9V
+2-vWRk2Y	-n b^h}=,%D]Bc~?qUw_l"4~nOb	>%(<_AU>|Z5&1_fLu  IDATXr:[TsB!
+Qmh8Zy#y[!f#B?j8v=/QIEQ	l)AaEkX}3_!a]u(n ]W8}?x*!*fQ,< bM-Mz=_mgWY47YEGHb$+4~a|-y;seVp:~QLNUsGd1Rnd>_@A=9n{ih,ZMVka)OiV4uJ0<d#BYq9UuS^FDu2sLTn(ng>YX? d8JlBE{[[EngtEW=l\sex%K?W2o,HV HV~&pcgt=_eI[:roAX|g8"D&Es07E$Wl?s cof7T2A	Bvs)\6a6CN\&
+*Vt )/+5BNXreIg@c1n"]djo. o>l[\r2	5*%-:T@&u7_.lC//s%?s$1!G:nvbgm}K-2B]HiKBP|/W(s yI$DE;:*6[p5\R^l$MdZ"rJ'K5f,az]v+AfL\r0o_{nIj<(08,P(UAj_Y9;kkN\j:5} .|5MlD@713eY)GlbYoq_ves#4~tjC#C@"M+"ebZ| X1pY`d\I
+$Ez)|xrWW?a;:/>WuS&.2d0008U^QCWVjU4R !s|WK[XFn >} #ekL$Ed:3H@a %y(8'?;1pVJ(WJyq1h PY`n sn(e#2B=J<{hp_x6C}{Z1CAR%+@P}IEenrRQSW$@;3@D=1K$D]5r8zML?^6}_$*5\1(n?SNPAPEQ11_e}W}7-XYhw7><R[E]sr#{nlf q!Ar\A@voe{+[$E
+5ucZv]z;?]^	?~z}'nTBGuQg<cpeV+z	 U7n^-1\[{~oo|Wl , 1wJdhzQ,8vPeo.9?$]~yejGYC"&h_"sRa}hdF6=P14K~?~wjKZLl*GkkWU*Vw_x	</n    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/osd_button_txt.png XBMC/skin/PM3.HD/media/osd_button_txt.png
--- XBMC-unpatched/skin/PM3.HD/media/osd_button_txt.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/osd_button_txt.png	2009-04-04 05:18:23.000000000 +0200
@@ -0,0 +1,55 @@
+PNG
+
+   IHDR   M   O   H  
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIMEzf    IDATx|i\Wu9Yx`80C4H,H&$`@^t@VbHc@plclK%YeIO{^U{;TI`YW{o}o77_<xXeNn]t|m|K<:jmw`U['^EGi9vNwJK`86hg|s7?hGszsGvWxrjruEm?:NwfiY		 + `R c=	hT;E=!XgEGNT+GK{1I+51'if@ V
+f3  XAi*Hc4%jG-?=Ck;_{:xxKA!bd"k dE &("r f<  -ozT6?2&zRnz4MZI]b}bh0kr@XcHo8)$``u\YjzS';e~w1@Pj ]<%hW9#*+.4}fJ`<o
+^wpw_]'0FTSE"/QpKG$xv<D-XVz?|oGwe3"z A{
+ P?V^ID^:4r&HB@dv:7~?09%"B-0 0sghxS	\w
+u`D F M0n?zmwJ16^ATQ#r+$!#	:$Z;!oSec F&AN
+*(4 Mdx{#iS}Gy~QWU/BTa^@hJQYh?="V*V*!(o.q]O8h7|u|JUR%Tj
+*A"BAD!r/Bbc 'Y(YH! XIaSwO(h}ngN:1@P1uBJp8X',a0/C^3u,D (4Do;c{nQ3uF5ReBeORC)*UPos! A*Ke~{a)B"
+8Gp?}xBPk2Fh 80|HGQ~H.'9TG@I|bBoyb@o{UZM FQk(Tj>&z(,<cKIeKgr* Mn&9 nm{~3dPo0juxI#BAdW$JNKJ7YfiIp|9Kv\}=i4"D5BF	:Z#Tk@F#R\PndY$veM}7b|65hAg+SDz3 *U'YA2y)*[z2OWzw
+ e&t;K_Qcb*y;A_f"U*2k$Eb~- wP'7Y.ssy35VU*>]KtXKNw$G$C u@>JdtRoj+10@:
+!I.=XgUF )(@<Y$F#kC2`lUuht F+xgrE'S}j<_!N)XX;'8.:h!Ak#2 y%"Z8i4"}9~ot95|
+h-yJ\r	)"#rEI B"{VjY42<T	D"R>Y7ZV&b	*M@$dea	fb KyPf;"X1aoD#t)*WX$uN,@Le!X,,D\%)@kfmS[12: *ta	;e	uIp@PIsG<b$L8+-q7s&rG.##Om8K#7
+mKy 1Ve#h7=d_|*PIP	[~65+^,&xS"I'C.	``TchU.FG1Tu$f v g:IY,Nm9[W<XB
+(j7N\Ef}BDJ.XbDjL!)DL1aLiWTqtv{y(% -T
+JHbECQFRH{KpuA2^2XO/,ctaC8,%'RV	s6?TbpZ&IvwAQhu(FzELJm_ X\:>o^tTL 1"[DA]kkK G2mc'g&'q`8hj+B^i8P\D!TMw`7`Kp{svM	Q0}q~&MF "/1|(rEXfe &QWz{\i5k4(g *zBnCs^Fe*OAr] O0~1z)<0OSsk;0` fbF
+l*X\:fu=jLy C7Xu]
+"!'WcIe8\x41T7nxKAA28Nq]H[kN l^rTUxXL!5c6y0``E8i*y"$ RPKK]jN&05 {+>m{j238c(p1p?f:08RSwCqib[!`E
+#'AwR:3ja!LGCzau+!=B|u"DWmATf7IyCvEtItvW*vO?vR+|.HuH>r1f:carn)|oK_u
+R8.(0b/~^[%mU{V}bvwn8sH.0 I-wcp^j8C'{2) D{;:3.|':C ";rzK[9`,amV<i)])c_
+BAitkA` ~v8S '"/[8Qpb!V.G[$``kE&H+ V$8EXw9bq{ DZxY%._nB)?{@5ll6~JKI &@DX$k`bJml^w5$eA9!"2TITZXHU("cz{XIqSa3:H4h4,IAqjv^,l"{.#`E"AKl~)H4x&cb;} "ZL
+1n!Z00MxV045H$t{N:W6c`!Z5vBs8/yu}yc	
+K+= 5AY}a|AEt69MDv$6]xFdQu+rM^)
+nM@bEni6Vc?;p+k0NlQ?Mu=^9_UuUX'^t  L2+WOYR,34_VuUfm?'R|GJ\?R
+%DKhs Dr(vpiwj[1=so[gu:f
+P&A b@@+^z9[75^5M8YI`w~aT^+WAQ8T|!/@vw!PRM4b}taDB,t=2g 4j+ur@eCqVj&/fAI@5V/CsK*Z?q~/^_$?iW?Hqd8p,sf {CQ!WhBuy_ECY^Q(5(k`
+zbk!m(h@qN3/PHM?xb~P"giQN*?V@1o9goG^YHZk_%lx9_c @`Q+\ki@P;Tj*tLgX	ic c#]+:)}T4\S;S>4*{*NrB3$iY px"DvH|~r<mk='gJy@xYP9`!XGo{kr	4PE4fg4~U+$IN21He;qsO1[>)C-W"RN]$,.C 3 8p
+Vx~qKxk}GBzlIE`Egz~;,!09SeX@1dL9dNGiw#x	b("`/^L vn:#L}kYMVqN _;#$
+&qZS.AGN]-);$bLTJ4*G..*d R9/@< T*@`o<cck&IIQJKYw -2XT> y$,G;[}U6(KEI! g5Hh4"~7l-
++|L&IZVcQFz`Q.g '3jd5R!bLgeK?U1	 $P[qJ"iLN # j5NbT5obqw^Jc*S{vC |`(P8aAFa]0Za~/TnfPD{M7Z" UUI{{_ttL6ci\xB%OwX>!A2TZA=r\wfC ;UHP!B8RrQHD*eRu]FKg4no=c<gWs7V<#Sf|=$0'Sl(g	BqL
+qyhe twM%i z $q3dyhks+0p*wSj
+J;|+V3r)h#|xN-:TnNh4CL}_/P5IXOc$'Q6+(@Z8o($! MU[4gPnW>)F >4FTkzCcnvQ8 /%iW_xU_97$YJ%y.
+>$PD;ZQi|JFp2(b0
+Ur^(<}6*A2J	:5Vw??+^@ W1[FAi!cuY9_K:9=?mk#~uAiWrgLSnQs7hHd;- `yO6@<cA2p[6)`R*2J[)}ZIfC;3VPb;fGd71K02kWnUhT+nV#
+VC'v-Xc[mfO'Dn3%<\$@_[IU,V4Xf*CnZw}8-^7]0	}5M|/ojVyb~~
+sKq	:ISfRXAfmtEycHVVfSO
+xN$b-X	ps\DG`{:/-::z[Hf=udP+b0)
+AF
+ZK\w@[j-^>:/Aob }kw?9tED,t .o^1 =%Q|35c	&%_6	!MIHc2 
+LVVk'Ov5zg.E^G_S-djmlhJ9qe~ ft1H!X0aI&f1!0!K~	qc4D @$=>;wr7uGwk@)U4pi80-TG(w
+(wZv//6Cu91lIB8?}zGE4C7NkSUiW{a`!VP$&Z'\jY|Uqbn/D\@wS!
+@ I#A_!! =zJ	83U9PT4s8:.Aj?9./_q#1oK9<,HSr]`=r\d^7'3_/iY'4FQo2juM	{+2ohd		dS='qeIY
+$u3;fTb:&wCyCF}WX=9F7ad\wJy;5T `  IDAT&-@s`qYKH@CZ Qz!X=PH;saoO]gz5QodRsU0RS:t2P%i2~KV1\Qxg@/{gseuyI7>&F!7uXS98*R(#PSe@K5G264N=,=}n?7=_/3/ TQZ(Q0Ty{bjK ~9rHP=g{ AoSv]Djdz O	CWkl;/eRV!4@9L+kKLf-y54oHc6V>89[>ON%MpM%}jb[@L+$0
+K6fE<iIdw3gK.    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/osd_panel_tv.png XBMC/skin/PM3.HD/media/osd_panel_tv.png
--- XBMC-unpatched/skin/PM3.HD/media/osd_panel_tv.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/osd_panel_tv.png	2009-04-04 04:42:26.000000000 +0200
@@ -0,0 +1,392 @@
+PNG
+
+   IHDR  {  u   	4J{  
+OiCCPPhotoshop ICC profile  xSgTS=BKKoR RB&*!	J!QEEQ,
+!{k>H3Q5B.@
+$p d!s# ~<<+" x M0B\t8K @zB @F&S  `cb P- `' { [!  eD h; VE X0 fK9 - 0IWfH    0Q) { `##x  FW<+*  x<$9E[-qWW.(I+6aa@.y24  x6_-"bbp@  t~,/;m%h^uf@ Wp~<<EJB[aW}g_Wl~<$2]GL	bG"IbX*QqD2"B)%d,>5 j>{-]cK'Xt  o(hw?G% fIq  ^D$.T?  D*A,`6B$BB
+dr`)B(*`/@4Qhp.U=pa(	Aa!bX#!H$ Q"K5H1RT UH=r9\F; 2G1Q=C7Fdt1r=6h>C03l0.B8,	c"VcwE	6wB aAHXLXNH $4	7	Q'"K&b21XH,#/{C7$C2'ITFnR#,4H#dk9, +3![
+b@qS(RjJ4e2AURT5ZBRQ4u9IKhhitNWGwg(gwLT071oUX**|
+J&*/TUUT^S}FU3S	UPSSg;goT?~YYLOCQ_ cx,!ku5&|v*=9C3J3WRf?qtN	(~))4L1e\kXHQG6EYAJ'\'GgSS
+M=:.kDwn^Loy}/TmGX$<5qo</QC]@Caa<FFi\$mm&&!&KMMRM);L;L5=12`ZxZ,eIZYnZ9YXUZ]F%NNgm}agbg}}=Z~sr:V:?}/gX3)iSGggsK.>.Jtq]z6i4)Y3sCQ?0k~OCOg#/c/Wwa>>r><72Y_7Oo_C#dz %gA[z|!?:eAAA!h!iP~aa~'W?pX15wCsDDDg1O9-J5*>.j<74?.fYXXIlK9.*6nl{/]py.,:@LN8A*%w%
+yg"/6C\*NH*Mz5y$3,'LL:v m2=:1qB!Mggfven/kY-
+BTZ(*geWf9+7KW-Xj9<qy
++V<*mOW~&zMk^kU
+}]OX/Ya>(xodff-[nVE/(C<e;?TTTT6an{4[>UUMfeI?m]Nmq#=TR+Gw-6U#pDy	:v{vg/jBFS[b[O>zG4<YyJTig}~.`{cjotE;;\tWW:_mt<O\kz{f7y9=zo~r'w'O_@AC?[jwGC8>99?rCd&/~m|x31^VwwO| (hSc3-   bKGD      	pHYs        tIME*7    IDATxwYu{o3=9hFq4L6e^b`|m>%,xm.*K8FH#&J:UU]if%p<LwUuuUuz2[N.N0qc	ME0q3
+,Ab  0{aY!W{Bwyy!3d&Y&%Yy-5IU[*GJJxnxVv"/L^Sb _I@,yO=5_yc&`/IyR'+\/5 tO `\,dv	{5"^z1{b((\<jJ==5b-H'o0l:v'R<aVb .BS)>zbIR|peUUE5>B):1-zW=z!. P<G&Q	vC~Bs.S{Z=-B;O& ,544jk+[[jkjjZZZjCPu 0Jb'I7??>t;YO6	{>&{Zs3K oim-hjnhijl	+}^Q>'+Oi?~_wb5G}NM@>FBZ3 BBp(X&o.WUWTV*^R 9J4a0`0 Y?~ >djd|&`/7
+B=shtg***=}]koinhlmmUeAYT3s@>%\:W'pe*.^|
+f|5X7lwhN>}{' (H&`/BL.=Oomm/=}}uuuM$$$Ty\NU\K.qLLO,EH$ r6$B	@ 0a`Y;whl?_3|+7./L^o^=+ x5ux{^U%fX,~GD2H$0??L`jjSS|
+^4ffq}nssb05B@$I`{	WeYbZ;?z-[wddwCCCg <\B&`/@O=_o^7`69`88m/Z$0SS8u4Ngfq}nbHh`92! 1((6Iv=)2f5Ma>61666rwuC0{a77y@O
+H5,Oug<c@32F!Ho;4WQ:^9!.8\<# ]ZZ|?~}N~w9rdEVWo	v~C5?N =9I9??5af	 	qIp
+Ib`S ;}y.n$q5)! nuMC,;z>Abl{[cyts=So>	r$;SL_W?T^VNp ix$	c7|#<|~TUc,c/T/^NO
+'<@H2EX>yVTT4wkE6La~#'9l/^rw>9%A7qrnz$	?k?".";K%)`'O<'2}$	{b  vg=r9P&daQ	'3YW/06n_=pEGbw ^k<?x9.?igeN0OqRZeqpS_% a@O$/yGsv,,.c)G0m@b|k>0:Gb8y4^vD IFDi$6{^Ygnr0`&u'@Zhzf}N L8O9so|oebE<^E0skOU|rwF	 -N/'0avC_hT\:=7P(l,>/ .w4$RJ|sYt*8xni'8pw_,|H0+*Ed\2x0 #GOQ~{)'H-re#tL|px9cL[vS|2NHd57ft~K_+P;$9q+S&!Oc{e|j];OP	j{;>[!;wi7_\#(~? H6$c0	i4L;i,;t4$C),I]v`O	NKZ n)Ggtp!#gGF*2"7Dayg6C?=;wrB&`/K8@_QJw^!ed{?xeZ')rS!4a3X(I]d[^o@/L{---===-Z#8y*,H=]x'?uXZZ<9 iX\ZvJd|yRI6]96	Xq-La~c2N.p2V544iA:
+K,+% 'f&0xT>O@E8.(Fq/G>BX\ZG9|1'Ig=r
+&L^J$ wR!<^9{Kl	T7fEo ]6
+i&B |0B!d,'Oe-""tR<R(;r810j89]w/myh_]@Dxatwnq`i~~luPX,SNg"(]!&`/FI9+) AVxns40{
+8yCMEn|> .EotD,COW'|r|D#,CBYjX	GxqP(:h	*9dBK
+u2UU=H$scff6nIx8K w[}p`}MWae>C a7d$I'3Z[9dUJy~?xViXXX ,^r(%eA4DQ,,.bgz_MtwuBVUlP-MW>?cf7X)15=n M=nKa PaO}!,iR5E@x:VH{g9"hnjWO}'[k2^;p _> jtWX$L`N'-G8"g0{a/TxPF@.//9TYiND_VY\UuTU=3/5m9??_q/x
+W' Iw_F/]BV<k.$U_,3{{z;	!	a/$O5 9b24XFv|Z{:x<
+B`l$L 0,-_"^{OO}l3L\<3 <Y\2fmq}8\Q5	[+i)Pc72bd1MxQ
+YbyEqXV	t$ajv-14`G-o2> c;`i{  `u@,JnQN[}}]cggg3hZan7o7% ~S
+b(,pk2,mEF{J {!uGml;Z1ajj1v
+.\ @1>~ P^^lmA!pur2})e=VxgK:AUU7DaduR0IBuM5~Os3Q|[R;VX YYh4&T<~" TU%h;eN<q}2eiF&hSTVT"|eZ%E(3#055]P*\|nWc-6nv)8** yhZb|B	8Ngx&`/l/AK ?p(
+x&@T<4E|y[wE_2pur
+gO'G>pm->3'?@$lq$NP'8%=_~}}}}UmH L^syq:nSSEE8 IDc%K,-)$2N$'z/$~w =;`U-n[ ?/@hBRce'SV,I+7a5)xR?^OV d|2V$@YyuPe	x"3>CL" 92Ma:|FeU4`xwkF9_>+x\uJ><+cre-vgC=H=KYzB0y9zzU6AsS#|$UIQ<%Oi&&'qyx}~:;]M8y>9LCg?= pu2Iigavv'NrlC8{!a5 9t]ZPf>y y<3KU._[8;3?}gzB`{, lP p6|@o,!GOm{KjQoO&EQ(~) /L^x]J^ 8chI{[&.Q;!5`i"dUEB<wwc|+z+&`cdyKF)#SGGO[V oTmw_+B%$#$C@uM*!KNZ@-i%B
+
+J)dYF O~0^r_"sj`F"ebfTEF2\(]mveE9w^ow-
+&`/ds<<sxT/(eX,4-	9P^^zT/K?hB1w}W:X_CK;	|>(]9*.{RG
+V/WUVz`Y	e6Fz<hii+g|]~@,{aeE?~|+_3rtR,,,pj[+`.L^=BG>Y!*x=^
+ i,%1"euOn^zWDBn~->?9woc8UP=&`/l///'`**~EQA$	`&gANlp765uF][ty83&cjk[Z`n`	VP[p@%R0&2-DB$KAmMgypj#iKv2P}tgy^st'-PE0{aj
+-}uuQB(evNYy	A(BsS#TeDd891`*9pfE$/a5Y0194ka/cGI'g% Z[[!PwBnXB(*Z[[ 'K$V(`t<PZ"TC']Oh)p`XOX)uQPg`
+ x^Pb3JiZ&DSJP972\&3XjDd~}pumhii0S&IZCQP PD<43>mhhBUeB,h(q|gH9N+{zzSwCdE @UU,Y@,^U$hZIXB}m-$Iyp{s+*=HE-i4L;~sl$PR:Laml
+EM	&`/hB^~U@ Avx<*dIe2"rw Zam><wt$'5;kg&{a1=.
+eK-@pp\9h6*8RC7r^e[qMtk%`=-+)
+#spJ#aV,CK!xco<J$EIAPdI%'W2*'E-B{_%UbQb!lbBHDq:;[O>~%,}apPUHs[P9XzTW^(2mqgulLzrr!2lqHJ6jjG!!U@U:sX^ SlzlCYrNax<{GfM2[VeP*4MFh *QQYz(CtsV&qv;B@,	0aZ&`	'3UzzxQU(
+&1P'\Tba@5		DcQbqDQDQ	$4isFFcYlIm[I|='~aVD/7	IAx< !H$2	GkK<h\/$iua *IzB]M
+r~
+E Ivq(AJJUaG	%4DQ,,.a~aSS3:1I]cGpo\ee&`/l%^}.TD8eRS2_2H$a)LB[[>-DU]nH$4p dhnp    IDATn@kkjkQAUU0&el[aua 0LXJI;2Y!I|/BehR$nNFx&L^Xn)f8l$$e,49,KN	tpRhIKK3eAM^s}eDAe`lXu(*(c8q%bbj
+S3k""c1$40XhD"CQT|^A.+GuujkjPYFKS3@_v<U-0<<|ze,L^X|Bt4bjbAer:qQWWJH`xazcVP__&1XD"Kc9/b''133%cqaONh2CWp&e??,Ixhin5oQUU:mm"!x\.?771>Jm%a2MXigVp-+/Gsc#d(	J2jmf@, 5xge!0NF1r8z8=+W1 CaD%U,%~ZHT;XN=c'N'4?/`/Tu*i!LTX,=yCLH,i$g:^EA$f&qe!2LTT=ahmn!	M+8qj{pr4' !d$AUx<yEE]`ER)c`<}ggggMMM
+0{adhZL>6yO,%
+A%CUTLBRJ@(;i^/;g]uX>o/z!~9B{[^8X,SgA<A]H L)xH|/%SgSORJOUVV6]6|#LeV9=rx4M#I	E!Q]@+ .ML  o`h:p/}	6"X<'s<<I2!/or@T9?j[yEQp),E"[:88C
+n/L^/y\DYd?'N\[lkk%)cY"aR{#X58~4#GO'~;&HaZ4vx%P=|!;%^sWdufd0!B&`/%%w:dqq1>444=\Fo8#iyN"TBKs3&<s+~/xsP p)P0+>-yZz,i,/Jeb~aG}__w0,_\\!zI	[mL;=-BA*aPf6R
+U~N>*V3oC4!H9}tS<7e'@d(e<>/sx 5}M;	 0{ayx^TS }M"C ](  P
+-/~;jaq+W<?p)B,+/M,P$q+	t!C^/*PWSFtv$	 iIj/7qM,82tc  g-w/L^XAB=ztnjj*VSSMr;x^EV
+N(rPB1zio|G)*xl/[hefy;^aL(A0Dkm-hnnB0Kmqi)O|x	9Ix'elr('3V=-1LOOG=:?qtC$R	jZNce`x\M8 ep\uLSMpnvc ~?&imE{{Z[*~0f0M^pfd:Jg,Ipu1|i^ 0{ai(@oe-$VH,2
+CUVL 7,__C:BA`!H@x=---XhG{[+jQ
+A'`r{_l=0$J<#I(t!E/L_aqUv+GJhwQ	@8G"G+~
+Z H.Bt'x<aMk+V|($ia`zft2({`,_c8p(rU(_;:::
+;)Z%L^XI~oy'IGB!%He99q8G4Ey8Q,(p(3p2,>QI^s/E]I\>%75%/~zP]UyP3E3gqt@<_P&`/l+i&oR[:q;wax`&(MH$]&P \9$Q<4NN`8p.czf'48cL2q	uh_,Iv$	W'prxwHu"G|Y-<8SDx0tI<pbnK NH>?91s.`zzuuuXXX_#p(._+W1s"G 2dGNET!u#uhrJ)1tD{{{;z}aOC}6<|{L,XXZB@A4bq1|~%^mkQeD
+tKi\
+4{~c`ai	xN@c)/]QUx<TP,N	S m'?RM$$p! OUWW	F)xJ8(A1?gsx<nH2,$I0-ZBRj20&}>Wj;R,.Ep00&15;J)~? |>TEk4	S|0I#A_/ ,jWK9&{(:~	Ms	@ma2N!Ew3{222xu8$1vq00;$hniAe!Fi:v>} *M]&abr
+Oc]GzfR%\2lAYT_h u"tcuiZCnPJ QPT?7jkkP_WX|_'BlJpr4 '5"
+:7ex%x2]'3leWKz#2],D4-C!",C[K3T9A8iHf{2]$~9L7G  [6[IIMu2qpf7;#L^X P<, X pi0xZa:^/dEF"G4%TJ`
+YUWuA^Xpvz{9E,Itq1>X<-PUdYC3(]@/ ='KKrNtb9)kdY,+0Lv(%h[eR<v4up9!;w8$9;w	U+Wq~t=]a++8;2W3GB&`/,'a
+u.--92eYaYV@	|	%hllBMU%(.)'K
+A|ibh8$at)7t:^R|> =MD>1Y;~5UUXcnG09=Od] gM~w)!k +s=SKJ
+(XXiZ>PYYF ;IdO laQ}> F,EdquE7fQ
+M0t8 a%xJRJEt5Vlg^87v oPrH|R8IK=44MxUFi	'81Vl<%IKya0*I t]G{[6?M z0>iit&Yl:e3cp`RGSK2t!o``jK^~Ns$	`A5xFA]I($k#P"IS>s]
+aYap?+_z{{`_m?2,..X$1:{S2']sqgO"+8u4][}.o_TV/`lr)R%cggg#CCCi85
+&1bF`BOm(s*D"?qm-hjl:;c][P<*^{/aB3uG6b~~.';)&spikCKSVc$	;y*cWUg re{md_qp3q#4**dYB<YW_HNZjQ9#i-=J)6m\#GeE8mKM5 nY%^~0?7x<H$E,--A4^_{:k=h<02rJ|^{6YJ\o"S$^f7CWdKEQ5C(E8Fkk}ah:G]9yK)Ku;:6nXuy&p <\sh_#X)cN|qR:z{{<#G<)S=%Y,R/:E#v{a/F{og]Oc:(PUQc1^/LRT*	tuHM.\Ylkv0I.O98b|[RJun"OCUuw[]C(8v"~#yy<ag^p|;)0}*nx_
+WV8O/S=gAiM+K`$fg8ea du:0}^1055gsF0Z{xb
+['xHh	/-""4x!Huu*Me]g2k~,%)SM)&crI/Re&gY7z[xO=I'n_f![8p`fuI99r(0)G$CqBQ[]S.4_]B"J(x_9vlDdP8Q1v%9XZZu\<.8s"{Wb~au`0XK2Byey_G	$=IYGyIuygIpRJLF)d'J}OuPUUF:~vuC0t8$I_8!k$($&Ar/17?r/Q9.ajj`Z(W{w oxkR[ZZ>u_>!OVn!dy,hs.	4~"YOn)* $z/ J@92+WB $Y=JkA!}MTEMbewqR 13#'5x{~qSv8;2p%LLM8LLb(u|,Kf=+REU:D"J}_M<:Si AQ3p8\a6TUU5MY---.\>}s8"q)Q+n&sOIPY*+Hh:|>?,&"I2:::yMd^$\J$\x	SSShinXI]sqvcc<b8_e@ 3W!O<n%9;wnG?`{$B
+>b'y<\{rv@wuumw}$
+|</~=4^y
+]7Fu]O:th1J8(x[qpDmmm=n']<f8ygP8i#c	c%	L Iq=~(I{x+3:-[H$Gx{[KcJjrw PikW;z;jkWFn_>~G :405 ={&_m`IKKXk?#?Lu>?s$+]/5H4-w4#f{{@Q@\>IRy{) Wm]@=]n^lyz`X;QU~Mmk7dEEE^{/}C/_(9oHUTZB?_re(C%I"$0t$4>x<F+aYVF0Be!t+|X!H<$1(P.R9r0HNtcLm[{tcB>i,'pW6m400imm~?_vn~8e0M` UUU(\7n~_[z^2Cq3{n_,QZLFGG][(
+,B"ee49(unR={pGE$a1bg~P6sc,IZAq^e,I8y<Eq(.^vkE$GY^d$6uukm{[eY\~c85|_KXL~G]m-jj~nnG}}mYb@    IDATow}D"o["`*Fca/h4py"#s]
+ R5(1IGd7].kvLryC|;uk-iel[q5+y&
+F
+cc|eh45	vxnYo=I'C!;wy-ffa c'Nbb1AK24`FSC6{/z!TEk^wYvCU{OM'_JR43g{]eHC4Cuu%<x" H$J\2%x1CJzIaZ0Q]Y0*+{}}z=%Zi:DhK(17ssv}ssD'lQHRY};p{Z<fhT	&9
+g. <]]]vsM5+Igf0|,;=|XQ'2vAt	@I9'eajfx/jz+NLL\X.{!-.2^(!@80p(I99`&DeexTUU	aY1 3 JuluRBX	mhomv46#\Q`  I-87xBCfLD,NL1OLa~an%="KP*D5o1rxlR(,}^ow6n=	vBk{zw}6nZ_UUUcrj
+Gg~o{W.;)sFv#%CEa<}-[nyfVGrt?=n^GB
+*S:~D/
+b%'i		QFf<H,$8Cu(FlFKs`]6-a4-h&	iX0LJ IB aw YfgE\2S##8smr-MM.v2so|3|}!9 :^%)7la[{[<1:}{Cqr4N O9p0g%t?</Nmjm/g>Wo3nw/`pH{xk#6%tza&#u|>/
+;:{1I
+$t8H;}6Q[[I`tCw<s3P(GqR!P0fkP[,CcNta0t]'Kk:JUWN	99G0t8:>[49th+umPhhWWmmppsm]MMMWrp0LMOt0N*
+O^\djZ7{2D"xy?}w`~@@{.se,Pw/|a9rg@ EP]]Qp9N;a	rz3.-PE^[g?-d	n?i$	(	(+Ab C):g(;e+z;1&$R!KnB(7!		$Md^WgI<jgwys0U(
+, aad`v8(0-+PSV=t:>=s
+KQ"2'DC^	$f]p-]ZZZI::oh38t'N	CEA37#	pO2a'2)D%h2GO~Xz=4d	]Kj`hf&Gf&Z,nwb19*~0edgzN4m<J	AkW+bIiLK"8N6	^zJo_R68Qiq$.(^9L`2<V`CCC+.PUuE(?_t`
+e1
+O@tS0f
+wF}ffeYrf.ZhFYY,0i}74I3hnmuRh4hxgPJEh >	:lT0O0^== @bbbO><8xDn\sA%#EKPOqt:-2p\`rCHD$/4'#`wyKi;RyRt@h4rpB1,NX9_\8$991OzIU	;IFR\qL0%&bZI1l6::x(?0N*I JT|D4NH>D N zh4g1x.Z48=--e"In7@eU5l 9^kPMcI }`SU:+h6+/k {|Kq=:Xb{R4|DOm555C qF(Sp:0 oJiu(*,SE]nDQEUW`4rpR@xHgsp" 07 @8&*WN,S:iF%(,.Bo_Z$$buk%$&l|wNxR`H8t!2@`KB%%%,X0sAYsq=N>~ o`hkx$$UsI{\}uwx{:eepW0/%_JMXre0V7m|qFH6??8['lvdwf$%%rt*KN !G8hx*P,N&(iaawptB<`Zz8p@ad##=#6
+S|fMY}/564l#(
+OU; ,s-?~yfOX,IBn__?P}*UZ4bIIeO~SgjVt!D^@OPt*wkFj^~?S kimkGKYK/K[[ZeS=Ak;o9[W182331<8.HE%(.. ;W	n[Uu,$|:</cpeP(\.\.7<5aDNz)]"dD||YasuB?0:6	Adfah:q$YLa9?YS:n}hhlD_o?02:`O??80P|&6Mjj0k9+7iiiI2E48Zu'NF5R7fW^=xc\ iJ7r};d  ~_z!+sWIS{.. W?x@U>A@'WWB99&lbxqk9<dfCfF:k=Ckt PYb%!2b[ :q5,Z[[qS'
+un,+g23(|[@XVnN)$IE`DZFJKc^Y,^3f 3#cR'ftYuCa9|9te}0XIII3g*>ozIIIqZZZ\ChljS58V3ga U2$/(^
+Alb1b3<3Q_  oRGSM.1k	5>u4i)9-5!D*Bb2G.)z<A_xNJ	*+W..Lwuq>3@I+,`0a46c}8x `hxc&8*3zR:7 aX*I z<p	:_ W^^Ol?=68N|}7n|nBVp@>G_PP>c7oFiiiqZZZF1LB$	-mmoDjT8sW4 [aM15gbp89C+	Y>pqX;|".++[Y[[i_}xZsU]]=xw@9d\;]NVX|<eCaa!LFFTObq9<o!99vCDJ";dzP
+mg#q{8p`/<:-} SypguUt*# ai G67<{]nE|\r&tMBp-\5 oyC\AAAJqqq~YYYKgYzj8Ccs3qF`6D!\{HAF>_{5_			*3\Ww:8Us^RNf L^P5U}^QG4pZ@x`M(v1{l#0n5O'egIeq:hx| anYcoPdgF,8\NowR9J!( H3}^Nn \1,V5  9n#<a2q{k`2'<CCBWw7)~m7xk>vp8s>Skp|za9@Ay&jI?o'Q	vgl~qNXj'mxH>/_} [o9=DA1=SVVe[:*QKpN2xvox!H"al6&^K$J7(DUzo&N<A/{^7K(Q(
+%$0(>f(`4ajC;z-Z{?r(h4q)(J;?	 hk@cS3OQ[wm+R9kZ
+!
+/[>D\\
+S$Uo5q| ###]sBHU1
+FK~8w`^np`;66&zmF'"<H>H
+IT2:2=S5H6;rsYnm*l!`YR,}}}0r'H+3aH($)}s{
+h,0,` *Bx =$A!NJS.FTBSSlFQQq"-BH#G#333"?03gks/_%7m9[P
+Zh4,7?,O& z_xGSS23dL/)C$I0Y&!h?WG2NN:c_Vx?yf G\xIF~ArTqzt},#UF^N|X|)Xu<E2U1'8<|$_Q7}uY`F 
+){1\NEy{vDSS#Mv&	YY xk48ZqFoh^zkMFwO<3^NGY	h23udqX?H)@?C044yesft9{mC`5-r	^M (WGLY+Wv0@Ed6ndQ`cGNxW\Rzhoo@o2<$y`9 Y+{M@1w+?!r|hpyQ%e> thuZE	3fTA!l7q
+gsCc,ZBK{H@;:q`+/GA4. "nt}Dprq7 Mq:sI%{DEc v(V%juZPEQw);<xFlO==4d0*
+a}Cu#>^(0a^+!5$J!1 V6ic8}
+A<MA$'%%s(gTX=vH#t6s`Xm$(F$nzuAhdJ\_s	u?PSD=/%x<`0q
+\Er0wtZ
+$aAs:KhPP+/AMO|H{,I!*
+/0(Ls`8BKq<cii|#wbP__;qelan#+#gkt=H<L+0jv*XqVm"4c`` Gpm`aX5\6SA,Y3 eKyo/M>}	CC.K\xIv^~#{KHMIHm|r$uu16:&m t:\nG~8QNz\QK-eD7UEZ ~w!oS%-'X	4[S{AXQ9;>0-_p,ann.mFJR"jj#A	_?tM+wsp7 bARx}-\i\9RRTo=<4 ;;s    IDATgwAwt;	_ 0'kxdhc#Q<4+3xLAJv$
+zr.<_NaR3I`jo]LUA#P<)TZ'zKy!
+BG8 s7b
+:eggtyHJ4ldDK_Y@?+1(i~3S}wrzWT	KxwP}$KiF*dFV\^^IKKK[*r.?'GmX NYzu(QFr:a4!Ev9raJLy%CSc;:|<S8zfSe.bDIFllA|K`t*p=U exgQx' sp<BMi,_[dgctd=`9.H3e2`dJ%Gcs1h0?)bc'ILL@jJ
+F~&b~}\f5>~[xQy38Zu#!` WX|BP	O%t22\|(uXvmh 9A%	n!#0e0883gP
+?qaMb
+ 
+^G377BFu$(@;LuA	A@@P[wU*hBtQL/)AZ;e8A$eTXyk7;:t}]GU'p%tBx<[Z{he7Q[w.br'n!55b^{wA;4s	9g	^s|9ae9YYDaD	mHrQXXe@S<rshobO?Oo^M7r`#M+.A[h HCeP2)	uR!Anp-<:r,X0v,"3#--88/pT$Y@[{>sm(p6t:DD07D7m[3"!AKay: y3?/Th"S*WwgsRv93)Us	wEFyLq3gPEBHl&"$Ab||`XXVG39/kUS)jX*i(cP*L=)h=]G
+P PPJJWViKq'd2+$I0gBzO:-|vL52[~y9h Il	,j,*|G{ ?oVQZR8#{U@NEzF+Bv2f#<z.uunK(IDj n;XG'h}> "\dZMP? Iv) Q3i'Wo)#!Db4zb]F#jj_*L,Y6k@(uS.=Uod~Mp1}wNVN3'q0^~vjq*	FtvuF(*, 3xT;u,z_*xsBr8y[n"rI\L'L&HJH	z>~($	 BDxD 7xo5%QF|> WO(dWT$AC
+80P'y_}lJ@i *vj1.7[z=kJKK`Zq+Q6w\NWN&:zTT 		V_|h=S/u"11##'x?X"N: X|Y|n eKNi	h97[|bplF)YiisF'%-@ !zElpDhwtvP*ADx<mu?47c|
+e}rpoB. @"4ru$;) K _xT3	
+If}rND6mO~Ox;hVZ;N4'.7<._	24~#\ZfcE?s.}KBk[[ $ipmw8  FqN< 7wNdwf BNz:r6xdX~	og&Dslc}"v	3 D"<(.N 9c\R@tv2S*\Hc0S46:7vP*;PwRI:>H E|PQ9}wDtxvZ-,^\*H)A $z|-m`wv*_ (=_oCe1  Rx"!Y3Y 7YbB]*#rM[T]&3o9GG{X>sAmP-(SI  >}zW\]\\M/`pu57t)EM2 hu9{o|T$yr$1!>`
+^3gUB%74(%@1r<]
+`/yyy(*,8-]Ep\4<nlx; `PX.x;~Be`<<(,;?R;nCrRRwvu}W_vPk 9/s!TO	b]Dn7\su#e(Ad==\L	,TSRRRRZzzrAAaj<Kn~~RvNnBVF111Ah6ks q7^^WJO@uJ%e{S)TU'c	Q'HTSWf+^	U +MUJO_"HJ%,`xGedge[M-mHX&#trAsX+*|{|)vjC; \rE5c:J\j\3 t=O}+V.m_ 6~	XnCx<fdefcC4F&?t 6\S^^~0B@K1E LT }ea66?7(3%QZZWPf2x$ ym"mmx<)c8qx i?!Aft_qa$p*S ^FE#8]])%Ar}3zt
+S'O?1^m(L&3GEIQ1{T@][]$?}V+6om$	f9pgd[cO3XX67_?gHD;74nw 3#fl^myO|_6m_z;he~,_<VC9vRttl=['fvB:Oc'1A(S){w`.-j;oILLHH*--_l1'Z:Fduob{#os R7}<`yx|;&\0p42kVpuS4<{vV9vO 9b5(++CVv6'%IcUw>j`Qla9EQqF\wu!vnzww1<?} >{^NLT###S6V+VYs}WB O{8|"@Il"l}]YOHeV^}7oXBae<W:I,T3 k]W^^~T	U&)'?5'S\b-{,tK4@L4O xd MMKOHHHHOOOUTT`6-I&KX%@,1T(AhbcY%#S1<8>45`55A||<>/zPg).MK@J>\0.</wg@'^y7aZzj6KO>F|\hok}tN2sccXt1v~);aaz=86c>_|9I |K?xZb^VbttTU< @bfeuZ->{l"f+h6|y+jjRp(lxoo7  ^|yg ^
+|id;x XDNEKbR& ]T48mJjj|%^X\YPPf7LV~ N *muF*zCqCk[;vtvw)T_D8F%x'P_pS8@MZB6~ca$7,sNN^GZ::qMp8|N9.
+6lxW/|3d$IM084AWau<(*(@RR**a||:Z=Zm=sfu;|'6oG**008eqlKQC,^ w;?VKiq-GWwf-X/gG+ayHKKESKv= u"<>~+'fyT!ys -J|"z=	's zd1%fL13++;+('--=;3+#l2Fw AH%~H&.YVYUp1~ut	MhjmCGG'1:6*I l6|@ aj4DCCH6,
+[D+#
+Mw1=g.VY(..`mKFF&f
+e%aZ+H"n6|a;t]6;jv%}gkMmG9tBA~048Dl<x}x?mQy###5|m'({dd- h8W 	*fY{0{\zc]z:]`{UYaDJrg/_|;@vSxr =|2h=E:DCBB9##3%---8+#33cZAA^ffVfzzlN4zXQrjlDie) @166tMhliE[[{z044&X ,tPr,T}CDkkK=d~KYxA O9=!r!03gV^VBjjzRueYjTUV@!	-BzZZ--xlWnn.1fb8z82kj4:vcA<,('-TVGb{.oh^YUSJ
+b=xLx
+W_ygaQ{/*8,a#_G%+.j\b9V,]&s7WzO@Me8A[n C|
+kB's#FlsJh*{O*!X,q	$`1i4zH!$pfG^>%,Xp
+mBwo;v0Xnjd/Nsdd`_lE)$IVC[[+N:ocp'	zPh4`0Bvkx<CggN??		F>+tlot
+A2nhZ`eQTTG '78vLw,FFFoAluqbr<1bhjn$r.CCqt #==c9sz)fN/EfF:>t8YScUWO(@y{.\b9[{56oJpA+e9f8J3egO/U3Z$8\Q{\nZO<o=A/D/cQL$gb Xs	J! amJjZ|bb9-===???+'/7#'7/+=-=/+;;-))hj,8*JlEvzYp% IG?.mD__FFp:A F,xZVI
+H42P'Hvb%0	ay&9Gu/m&6ymih dge3,]\na),o-<a}Vp`Ac_;jHM=G($8W;B 'NCdsrWaX+!a6pvjahVmD	--1`f|G0$`8 >b,]i)Zs~]{<+Vag5l>4[>nqaxx$9hpcOBRIII+.Q~4a*T&RL+b"juI)$KJJjzIiiffVVfAAavjjjNfvNd7a!I">@,y:Bw{$XcBO_?:::vwU4
+YE|aE|7o,^}%I_Jq+V(Y*R#P0h7T/    IDATxoJ,_]a|TWWa@$Ut	5xz;oNk?},466=Ci>q
+]]
+],a=n=}o?6mOm]'{~(A\}CNv6{x=wN9YXt	-,5Wca^ccHGo_ {84RLACc#{zq(?@2>F53Il,9U- OLRS21-??'55-;=#=)d2#:92!z!sO2 -gLJ$I<t:N (  cp9D8N\, kNdO$PEX,A0,p9C{[+o6F!UgK23.6Lit,fDv~>:bYW^*ey}u,v4:;:_	
+V3gLqWw7*!ezZ*6smhimsR x> N'CV8`XbRlWg	\7Nk{;*ZG*0:::8}Inw`xd7ZrFv%D(;j6Q	%Bi`INI1gddddfffdffMJNNN0LZN).B"A '(uB(5m
+R908)4	F!NEff&?_%aX13(#Gqqq>F$0E1Thv(,,G2\p:%Jlg(`xx86`EGgU|'8SSweEBY"`355r.
+A9pOz~)Z7++fvKaIHX@07niV/& /pqur2,Y :FV.[6(Z=e#GF&Hirc _ndVIIIvMMM'`"X>Z2gAqqhJ$%%&ZRMxsBI*6PQ([epB1Q"h/50!\.'F022>tuh@Oo;:`Ij1S_^1{9tVPA@ jo9xl.8UN'UJhhWH(25uPh>l	;PSsZ](	x}`Rv47`@6-z^}y$*TD(0# "ZU%KC@3;;gj ))	rqD S*79xz}`%]v3Qa`X5V._f #=^_XihxBZ~2V@EU]4ME=7Ed-g|9SXT4mYEEy'&Y8hcY|JURK{g~ppeZq#COO:::` ##vE-,BH0 ]]=8/Lx%:'4(2cl9crBL	TOjEBBB6uuu'?Q!p;Fn]reK)vKfFee-WmxN*6?{ Emm-8BT?693ghWQ]{[|8qdd<]t
+kZj*JK{`\]4e=)r#n@4h:LU/]Js		 >jwFl6vWj:%G)x	lLOF\A8?0tvvE__FGF`U$Y`_2adn^xaxj#Vw(s=4zE#{2$	%%aE=#1E?s0f992nB%#ib&D#YoPl>c|?IJz5**+&6Tu	Y(,n~!iiiD~^`w8}wc;syYy)4 ??`]{"8$K%:l6cxXQn{dW|0}$-:4I M,(m~~Ay/g@Jx<p80ntw}}V+\.$AI(A7@o7|z1D4'%yA*QLq,` (Vwy%Uy13w.*8
++mv;BOz<YfR 0RRR_p!y--I~xGF&^"5ZGjX,hmmEJj
+2PT0,|G&>= < ^J)x^9Z  =-#;{m7we Q*t,&2*LMf0ZP@"QSq=!g>ioM2IxNvTPhZCr122DEOOjp<W-eA$|C
+I#cQT#$rjFpLR(xT	  h5QWUv*(CT0kVE
+6)jE^}:o/!w/(^ibTM;['x{yVCXw	{%ZDss3z=Vt:?y{NV+FoYF.};o${g11uu0ol2 vL0 	TXU8At=#ulRGq[g~l6EJ(4krS8w--are	&GQN/ Qs(`O'$zr1 ?""23..$iRTAzg%+|WwW}mMl>ZY0|?U*]Jgn,	f\}UK
+o|8hQ9&Y,4lLEE`;}wxV`ll&	'xdIbA jjd.;ihjn	_SGHyU>N/!t0?G@VD@q82/#,IH oow_Uu.}t{Vy.#^uQ@N#BVb%)n[o((?33M<.pEA	$^{}^_FG "nz"`SK:c=.+2b=]cVH$8}YT
+,kE8(P(h<>S4}hl5ax|k`bX/B *D"	I>_	jkk0081Rs&oy^:U,WAE<tSSS<VQQEQP?^dG(2mx_{IqqTTg9J).	q
+8:JUXqd~'Jr}W4b(>zaaWhdYpK?} _>t"c51m]9d?{+}3(-+AYE9|>$- :"SNh"JK|P5f"ZR&,z"-P/udYF"GF0{BL'SR o:raRi>y
+Y5GgWvD?1c8:,dUQs$sl 8tPc>S)2Tk\n-P(Oz;f_o_r 
+D8XEUNiSez"={2_
+^]Gv*Z ozyb{'~|W^6;;E
+!L-2[P'o`hx(+/(
+ei%"#L"e*gBK^l[JXn{e02	
+ ~b(B8Y<.ua-0wH>t>[-:	;KApjo+'3!(UidC d":eeeP^5Ul^%co[qvg;PQUY0$	ohS;DAg8IiO)_QylEBz9MU6c4h^zR^^^y*E:F$_mmKvb>O_";rc{F< r3Di9W {3J&[e=*q*YA4Kxr+`6zj*e>>M>i?VXiQ)DmoE:]X$~>,#Aeu.^K{:1-LK@u)^QQ
+
+^Q]Uypo?~/**+QLJKKN[s0<:
+ hkm$t,	L=aA|_w-[0u`O
+7b{4o| A$Oxk9gY 2aonQZYs
+qu=eP*eRbrJ
+\(NQ&STLPqX \p>8b@ToS.cYi<j{m>Ga
+xgzrOctt,?!:2xcMN .Rdl`LgH[v@|hR+s"$a;w<8:*!DCCC |q9vy'J-81L;P8GXP<pssbbJ;	ok><xg;2kpkPJ eEkFFP2HU
+IEU5,K,*
+Ue":86Xj@,ir,YY4j"h bFx?)'e3>vPUn_|icffTlWDU	#Kc!8'N H82xPZRb(rG 5 2;sndci&NANP88cJ(H2~uWqSr`_! NY1#>o}n #]tx|k~Z?5xe5#r3|-7	G&s(sD9N|({ukyK.4{WG`f<a]?x,s["AkvE)u{RqsSvcfzkE<fv 'GB^Ry5eNoI&5`A:WgP9cUtZF"w>OO=k t"fYOdk@|ro*v<o~>x]Zyp`j4 ;)b<qY[fJ3'<=cd/gW1mP_SS<Ce%ZoXn3<#v 
+=ua%PJ	k$!L2KB6*5D*8AQ._EEN/|94J,X~)F$I:QWG~~{@FFxz|K.> *N~yR"@wyRhcK.<_$ Jhi	XpPs?##R&@DfX<(\`>~	H7\k%5l+g oyhsg>*{@,<k\Z[YN;8221Na<OB0nc]c[ar&Fp<^P`(;kn1|glQ}bb9wq]WHTFD#wx"6Yv0qG8&!6U 2uZdLbT2eyre^
+rlrh\=qFd>a1A8bZ4i+o&L m3! 0a FGm3Wrww1md2!sZEw:qNyAD @us3ff"3	<xp ^ !7OEO~|```;]U+~g7/lSVX.XF-j=QWZR_w}|VnF9RnFqRrzunGTcb"fBx<Db4
+G$M6Y89#FQq,=4@-pEZ@AFVl|gC5.!QjI^UU"R6/%I<}m!8H*$_7SU1u8  O	A2oy?oY}k-w>"oqmtNYOzi'(b*zavc_zpkR@y(>8q843iav*m.AZf_!LfDa.gu.P5 ZeL||yAz!]RwbT\Gvl5cYuK/;&G.Y*
+TUV~\!f5zC$(-<V0FEm>t-M'd    IDATyk_ ~^Z[Is'?b*Jp(U>w]{^zqB21=GieETR*9E<UAZNpC%WvRH4}r M(Y+EVq|^fffXWWU(>0Efm&')QPDc3e1gknhjN3V29`^yUy`Fsy\pqh>x%7!~eLa13?<3WC	yDRw%UU5v[}zz:aj
+VEW9Pe.{Q?~~N\~yzk-DThkNq:HjbKhR_%EExn.IrN.Up~	!F"W~(FFvz80	dYA0B,7 J4CS*P]S,D-IB,	SGgJ
+JY.`]Y`_VV%F(b4"4M#GaYVh4$l3\x3xL5[)9"}-2DFi95(jj>X-M~hV#bO@4
+-0]tn	%>VUa~u/Xx1gOzw|`d-z/A/M?3/n)))#Hxlxg#9mh\k8M!tIrI$	j$~J8H$())abCB	V
+vBEy9#PT@PU&2-$jYia
+(L# ia,y\|miO3cjngELxuSi6DozD4%kA+ArG9YmEa|EU(]]	Jm2Vz\xR/j*VtuvMfJ)g}?L@OMQ9wp
+}>
+b*3o3N,qE(Hh.<`~r|VAMtYxMEW [FBB8cXS4/@KK38L
+PUUp`g0B @2JKK|>D7Y%83?@jPqIF(-]Ti,)*ts`S}x^E,Yz&}]#*G VT%%d2	YQ!I"R)	u,:\ F)5F.I Hk`em0Ni@<:#IBJ,hh@G{M2TDHP1666>{?(JZcH+('_N\:GQw&1p8v88Apy79-e^V Ub bK@ 7~&182
+T*i*e
+r
+<o`(QVV=={oVk"<ZZZ
+QbYf/z)`^wC9wJ)8tljZ 5!TU-sDj)C8dh B)t:_u6m^M6w(h:OVa(ZvD#8dEs$APmq C* pnR5UXvtw/hjlBeUe)t(~G^/~"wz3Q)pqIrfekL'4S*%4OSfI@U1;3"{IBYy5`"`3RH0<4cxxb!4\QA(2"rwY<?+o!
+phZ ##5 oR8&7JZ(O?,Ly+l3FhB3T8q\LB@?a  (z{K#[I6MbDPU\@zBEq/f^[]tuvb.,\TVVJUR32b]_~v:m#k  ^6r,F%I('z8k>6:E"sB%2y!G&&lph>*&:"G:!)X$/}_"H=c1?}eC "-Xt	<^5K3pB~	yazf 2i&mVCOL70b*8JuS*Xa>q'^|%uNjLTJpv&5vjdy9$q)@gkAk%0Q wt8qyq=Cf&-,H]9x\W]MZTTVTJA5).c,##
+c`` mSizz_{e+9b9T(O_|>E<TEE8BZm=fbRjo4#I*+Q2}6F4(O>unit<\h` N$qY9#LL1==F9J ix,9	hUFR&}VRp8H$rIZj0E{IF7k_z8b//g ]6mrM'(yghsf$5=;H=pc4@'3QlVo%&,/]]X.7 wSm+`0	Bl?b`e{!/|R(qq/HH*F(+C]$'kFn=u:s79PW7yc@A2(x'3EZKx*Qh	p|  q%IKIha%Y84)E2qehii*s#S]"H@9F%(UL?S(g}Sx}^DMz{P3\j
+Ib[N&
+oN<uDlX4
+N13;;C47C[ed&wH)Yaay]hMX(//7BU~cjzPG I.x/e?+&WHhYDdB%YtA[
+N3 }1	Ys'1#Lb~]!3!D ?_|7"I9S)]?o~C'?!d"HHIU3I/.IzW^}=+HT*)VOs=_WcCxP0]}w"0i^7Uh<QPE<,J9pTUYnSkd=KuVsy&v9l5*LC3<^/zK.u4ps(BbQ@(l$S; 9-z7&B%g\Ui
+ftvvu0UEdeP'!28FEe&=o1MS6N89P 97;([*P)NCrIp{a(9iI Iy:N~xSSG(uWeKX,</pG?H`$+
+Vc.DR|_wH&L[DU5lEN2XL9OSu(MR$/ GcTaTN{[+H&4'Liga[QXT ^#PUwo%/m[a'}M;Co|>,^K.+h|TWWCQ8-iOp\v.fa!8fLQbXkqx\"J.TUa^M;w5B4E]]x0+eNr`0r JDIC(6KoMX^x3*9Ak7P>9Z9zT?kuDWgyBFiS=@hT>K/ 3-a`pI.,]k_{o_b
+
+MnSR^jC!K%U)ESXlQ+A2u)@[kI5V<G-`"|<4L]rf!$}yo"V?
+pj[%=cy
+ Y<
+1&@)Uq:)C0yO5EsS']j+*]H-L9jpKJTWa|`V5RPA\NR8
+x$\<^9t:_~?	S_N@*B}.9Y;vl" G8KrQwJTyHdQa^]]]()1P8C4:[P^^*LMC!=Wl8n@dwR3K_W|_BBaPi/S,~>:yV+k\01,`xG0P{qb0(Z!7@A+"k@Q8FoZPx",ojlC,3E+}bp>#XKm="zM!">8>errcKA-JXObg
+E>/j+X_Vt-\,hjBeeBNJ2l 1FLN"B<aZv<vug]{{!O$S4QD!?<;;ti]3K7Iuj=@d\U+W`^,A}|0e2e~^AaZ"@ K\-v!CT~X<k|kAw"D"9	Okdx(-+K{{z]2FFpH%%Zq*J0;;"3EkfHI*
+GQTZ*aS*(-+%}[<4[aE\E0rb1|y}:E-s&0QJ&qbhHkz17.N:gjt"wQDMY
+;:rHQd'	bdtD8(yv ps$7fsDYtg];UUMhWD);qs2B+FB  ?59L9FJZFs.X#$/)y^cAS.444k^Vl'}}05% d;<LO/0G4X?-hnir
+Ge^]r	$Q]>uZ|?NcbG`eo544pCUTx<]7z2f'Ck	ZVSePH*o P\pEXGI>%??a-qN%bh] EW|tRs-u8t`S245]]]hmkC}}=JJ!biEE,,FG0%T#(2^/D^;xAD^\kmFa :=u+=->GVtU+	sdxQQ^@ `3bIzc!}UsgD2#GE}mw`,+_[o/~DG*-hos9_iD1PgW((/~"x'/`kpfpjLYRc[}SSq V,_n|Qp!y3Q T
+{zgfg!{o<(GTEs$P&6 7n=blloobEc6dikQXkBqy tP4s<%y\*/CZ4/XNtvtz \G4,FGG1>>iD6Fx( Vu&	 $oOMM5Pl
+p
+F=)B; <p`q k**Q?SSSsqyB+RUe%dYF{{p=hh~`3D&3wn p?q8oyQ(
+8qfATzOgs#;yn8."V#-HRBnU'xnr:wMGk^{5V.Wd2t:e8Z[CG]}h8BH?!)^}"AE(+Wha	M=jkQPAfc,<dEe$*el1M+
+dYE"p&?11co/NhJYVX>Pgd2s=>aJq %-SsG/qF1C8$^++T_VtvtMMM1*^
+0331''13;X42Q#zK]pF9M$r(
+>G0v@]Y1}/FSoUjd_4irtZi v	;wu% \W^%<(WbF?|l:i9{ ,^d5\cb0<23~>bxx_	 p<`4#^zet)\yUXp!xG2|eXv&+%h</bxl=0x8sp/BPT
+eY$JUUs1=Bx!~I8~.eqH=uWBBs	,&
+Tb4vg,3>>[H    IDAT67jd13uvLNF<N@\U8HpF#w<tHtU)!HJ<ooh@{{+:;:J(Y}{2*)B&066) E	%9
+^3EtiLQ!p<wgycmz+v>DNUN
+dmt*[`8Q$Ihr56pag+j
+,AccC(8!SpA  3_Y?|!Nx<[#h<C`E(+CG{+8S@r{2v[_wsPQQTN+Q t]7~O\[d
+yoX>v>vGh"x\j~90`l a9|3FUeF!$(U+kbq*=<G!+jnN`@To.:TVD380;w~!S)e^'HXYF&sD!=3mRp;x(!\{1<69<(vujvttCII!2
+Eufu}ccB0D*i$T9b>sHQByH''\ntZkji ;s)o^-6PpjGNcPtrmii)K%UTm-|>_{}N;Ya|\|z~ONW]Q3P8z8XN\:N= 9k\?QZ^
+@}xqp|#hmk3TQ!
+jkaHm%
+TQw(_=K.Ituv[QC"W#8w:m\~Kp3~zvc`nRYM0=7uQXrU=wG|9 e(Gu} #LjD\.As@4)S"L*)LCUmsfq\:>wP_]HXA)6X*YK=nTWnZmmXUUUz=cr=%pORi dEA\Ep@)jki8j/<$X%BQ#Wh{ \o!@o#h4944,c'cAD*GSS#J58_ `fv}am;=l\UUqg?COMMK|{~sE$IVt{EX|YY}}K{zrI,.0A]^<>66nG?bJzLp,;s)}+c~B8xKJBx	Ir3PFF02:VE>LMNvEO:#wYit,
+>G*>wB"];O`mF/f(9$	$	aM+x"&RiE1Mke^"G^y1:6^Naxh-_WhkmA{{;Z[[P?H.7334v^<	,j)L 0 J(Jtdm<cZ6[lS*Gq`zz&?_0==W\y:?^,1E9rH.]`fkxA55<1t9`DY$gfP]UyX`agc}]m;nj%~s$b`phmnDG{jkj0==QK
+jPUzgxw\vpq,'\S#JnH.7YF#p9u"K\$j*g,h_6oG.,CcqVX5k@UT<t*u|rl(j<W,3?!hXDl"U*OJ76lq5#-!A"G< 
+VqE0vf(<JtMh_WP]]<DLMM'n@wB477vJJ|xTcp$GFO15h,UQXWztloS
+&#$l5DE5%i-[g@(^I|Ff wCfD(JJJcYkg	G3b<==( p!|~K =?Ps w2g?LyA?xmP[[]0|T6=x|%Hx7o{B|UZY9q-(ejMh[}h{I?xco/z{xRT*cdx.qsHeVN83O&gp
+. 	m82.s\\.D"x<!$8M>iYX jY1U#0.ESy144K4Vh5V9@:M2&'0;3`(D"EUkvq@|1':XP3>sW3n$9 t
+`(8666=088t#?vtR4]b#\\|kH^iy^:{#\7800H$'A
+I8VqnMOc'?r^u]z	 `vqa0|z}z*S[!J..PEcCzqXE }'uVU+126
+9-C(* .Ex!" 
+xDA BYhHkzDHMv9$, 0McPd"d2F36erZ{Sxx]EUroJG8Cx<n0Z{!t:h4LOOafvRF<<C,3xUI -xH$814z'm<Q\ W$e'_|~TyEDe6Z3Gl+Wi`o$o^/p-BnupD"hj=XI&O%I"vP8
+XkuOD</X-X2b
+Bz .79NX};fNP^^.o MA9p"jj3t:1D<S*LQQ9 YJ&<\.A:
+#1JAQU#~o~P`R!6g!
+^\xPUWUc(hkmEbn|{H3A`6X,E5 f.z5EM{%,4x<.OOF><>4tbSdFXTL1Q|B('Wr(U-
+(lhRjkj:alQzov 6|P?o~@8w{,_g-"N~s: G1EJ;<:m =pZD05_lCsS^-,~?zA	E2@k[=\\n"Ie2kh>5),t@xp38~=Ys)SNT$A%rZL7~P=oXh I8zzkg`^133x<P
+Q^=bBA 0`0+$kKL8M#7jvnyc*lx|llvpp`cOLP(fPW%NE&^<x\j\y}eYN 'RPYQYN'?0J) Bb(r,]=;>{{a|[199U?sjE/^v^&"9C8%(/-;x ,NT<9Nj,(bb]{r.<133) *9LO`]FeY+*Tj!y K3kn(}V'P5Jd2go~]j=WTOcyjXZR8ryu-,czj$BEA477gIqx<@ YRISL`bdd`V0O#j>&$'& 4'xuj-JIW3-)h)iN36g_}&`p{YQ[NPv<t7CUU=v{}_PJ_LMO|6?~\<s-!?Cxnf2GPO8;-EQE^_}tJR`]}%f8z( jd[DFDzC:f	H"71.	tlJ[
+caPP$i&X8rKfx<).BBoY
+(xhjj2!J!!E @0B<7|
+:B`-l4>Vd2GN&3tSK\M=Esi/3GM+b2C"6/9{\Z/bYuCVd<;-xuBp\w'eKzXq?5b?<?"ZYQ 
+<xC*MpWoXYY;k^Y!,q@QCK+5<d2	zfk_Z	Z+Sldll_8<"G8EOCS$/!"@$<H"#33`0H$D2*5WV&ZxvGe$Qj1lbcCQdD"=z?=;3P*9k +y4J_:l
+Es=-MEf@8C9'<mk
+gZ}>W*as<O_23wyqG?zI9mv:k%yO$q|qUi5gfdZ(IN`X7uW[[kk+VX-[HRH&(-+}r0{^F8F"0|:l}!4h;k"nP24C5%)2T26E]<P(n	7 +i#7:O	@xEV0zKv
+<:)9UcWuW3(dlxxxdzp``CC'Q;T2/ bT6u/:mO< ?88566RZd!)f>sj	@9?@0<#O~Fub%q&x`Mk ".UQNm?K7R$Rf_^466C l8xJKZh^|zPCL3VUTQSFpLRl}hDwZiPr&onmP-l\?V^Y5q<#K.O~@K)E`6 F	D#fA,I9"gvj  ND;val2H7oSLkB	DU:!	$j"V4PJ%2^D$q456x"@A ?eexp[[1!"'I\.DkK3NXHQOh1hc[UU!+*387ojkbZ/	;<BII	(H&m^;!]VE4^")P+)I}mQ3D= -_Su15J<>Cqdhg5V_z_<d*e*bw&!JA33)2SBL1FjHIfX%PSd2@G'&''T*a3m3+BE(EP:s'H)[?i;sqBO){8Jz}Z,-2^			@$~@`20 	c$X^dKllRZzWKJrk==BoEeB_qdkZfQ*CoOO	2>?x,$d9?ynF_on||"7`QXc4xfl[Tvd
+G}]o>T3 j
+EQ_EDc1<Qc-FcPn{t A)Z[hOs/ V7|c]s-eWBVyBbJ0VUP*t,j;eL	QB%Tx<Tpj@xo7|@5mJ+{R^}-yFzlC[Oh!OMO]6R%DX{BX:OAG,?|yum4]b9_}{:^N?Y$Mj,b1|B
+G 6R|s^i`?sQAhil1P7jY~KgVZ@C  i2!x'E(FRQe>J(aR4sN	@(,??f&'/gffT*ks-@-Z J{w6
+[7__/i1 3qPs `u.	w$}90t
+W_/k;{N<k-BnP&$ZQd<yitvv1'    IDATo^TgE)5WEHQ0qq7	kc144wX\DwO-4aZ&L.d,[e'EaDNf" x.u}M'Q4me:Ga*m1AQ)smc]jj]M@	EUUcLBA/SSSsjjnM*z&&jZA%N__)f8YrF4M[n a:bI
+}>`EG?<0;Po6<ulKVTvKP~=pEQG#1=~YgsM;!2^[	K%W{^8}NfmRVxvl9[0HU5TTgv|/U'TFg(SM\V?"NcL 2O)X,b'M,b"hD:r\qnn.;59=7>~nqff&L&<
+Y[+X
+~%t)CQ VN@Zz	oK-[{\+ac5cC_9m!8pJ. TxitA('0A|X=6D*q+g)"$
+4OG] }}w\M@	p`2>cYR1#>MpKc
+e$eiX@a0i+h nL# qI0M7QWIUv
+HuT
+n:t_XZZr,\7BB;6x7nD4u^gD"'=UP6Ujjh |is>4J8_W1*|/ym[5Mw-BBe<#(KLHj>kdnxa
+CG*cf.b1,3qzF5YVFL4nxqcc(X\cm:T*]@)-a!J"8,G ;T&WB,civR[nj#gATy| xI1.;J.|w>~3DX7	9
+}HBs&w7]= ~S/??>N*hyFk4j4Q4|T> /y>}7MjeV
+'17?56hDv]'*%e`?fB(G\nK/iE]
+6rsc=Qu>4eBE;Hn8QT*e,,.`-(P*P,xmm6l\fp"Ae!"CVdl/<oYA"R%|={K gnBjn>j]bV(!
+wstjMTK9Jew*{6l8*_J%&7[ 61hgYC { =7@/  CCCwuzCZAXQKgpW	`!d'EC//Lg_B\CqZIA}6d |'.bp BD-KDe##%\Qf1^\gz0. Jso6/
+,qJY(|Tl`ZP1T*,yly.`>~BE-,em2^|e|?T*$
+"PM$sO?TkmV*FA!:Zi&(mZyXWt D?sf"@V!"fpd_
+mrkp7ipHH=}H[,ojZJw~Ptwux}:!oM=bw	k:hSSwwo9Yqi[ #!qA<176|l	LM ZQQ.QTW5qh7%E;Ih/sekK Q0&G9i(nO06:R4{R	@%;~C.EoGa g1f|xZwjm,hh?ySp3cffh8@9D299YLSe{Bgibm\IHgPL&up8'N=/wc5WMo:G;X,"uLx-F<>H==s_7-Cg,"#!
+aJ/x6nX,},?r@a2rJ)vxI<~8.NNBnfOrc1
+A *&)O2LD2MT]-tr7-`|^@UUPJzl5n-o:>dX)e=f*.I)W`2^+?:woz^::33Mmy5(wZe6{o%}l3 _O,}3hd
+t~[,UsFVtMw1IETU##mhIxewl9NYlj&jBo}~\gA'
+$)R4j4Eq||QU0R$	H=UXz#izzqP;g/u{ 70;;Bi@f1T*Kx^y8y/
+$*]SQr ( "?ufRXPQa:tU!HVkq-8p FFaY*
+TW1PUTe,s_|;Pavwq\#}wwwo{^7hZ,\Z@\ !M+iX|-f-{/<8Up!Y/yaAh(i'#v#y^>*vl7]{ o:;q1.X8)vx"Y>d
+Kg@\aYR$DC
+:btub#C]5UFOo/"%	]jDC\$B|*;N{QOG62 "[^`U5T5(`o0>>	LMOcaq|u.
+WJA(`XU@-0m,4Df8o~{N~|KZ2j0a5%Pd/r_'NhVD''QT;s=sC4|NK/%xFvifV5q!);#{/  ^.'W~ty\[e$ }wBo~^+ }Kxk1wV  ah<I7)9-{Vnr
+e	EF4Bg4N`xpFFjth,mt	$EN}s!N#
+!;q=n t`C"U!P0F4$SIbgL&P,avL3	B0z^al0Vcxx`4sasx `YrO@U+_X@g_B!	E`|\:?JxA zPJvO[VFdbb"iZ]t`&y [ QMkJA*!~'6	5; m+ <t:bSh@ohxzjVp*&AobF022XpoN]p8,a]r=rJ?S/6[ntuuc}e_. a jd]C7,&p-G#QD(6OoY&LnrvVm79!@"gK_*x0JY`9.b;gKE<:OP9^7Riv(6BpoV@yoQb_C5'~/#at)Lk_ &4P.+.i-O,pboON>'7l]3<^cucu;?JyDbWp(z1<<chp=\vX4=nPRTp8tJptuv6}idX/"R.9y"A^\ 8UuBTzQlj/DID"}?Dr1)E$ kyVQ+w8|_yv,XaE?=;W^|cdEQ~M=*R.T*|}:(FA%6
+&ES\7N!S	 7z(%](}?x(OP7 %uhXAW,Nahx12
+CA4uWpD.q4Z6l!3|](N159x2$rpSdYDFat } (JX\XR&J8/jADApb`9wm>FSb
+TySXI'k-^z JGPB!]:%>{RzI	 uovVP7eV
+opgvjUmGV@IA*jw{G_p(og5ygz>0Y,AW@D*X,\sn&{;J$QqMkJQuZ"K+2a0z!Y@`wDQSuuZ b(u@_O$XX82KK\uNDc1w5c`g)Z
+6l@___!bM 6q{B.|>Rh?J!H>Yu@@NT uzH-~[DN@ IDIR&7M<sL)l@VaY.jQdY<zxoq=zG6.4mWn~UJ	+vS! 09OO#*@ww>2TWAi"\lg
+w/O{=Ocm7_~>_F8LeByRDe#AN`p`=Fe=$=D%VZU$jUE&G"D<"EXADTU[hBE\s'Nfw^a||vap084Al\ndr/{z]GQ.P,l
+nD-|&p).,fkmB9,xp3=S7 En 
+djyGG;sGOpEv6+QW28@! r~jR(w>1yQb
+M1A[{B9h}eKs;!TTwm%"B#Wt` ?nn&6
+x!;[;k>;O,ZB,$L&mPg.2bT*P.UP.100;}d_eZ(8agnW]UOz*q7E(lLBa,4-9 J"<}`16U#IR`A#3XO>]/>p4MyUU;D7	siVfBg3''[lQ-Ba9FA}w095SGu/)	$!mP`9iZU_8#Ctq"CNu?nB!gntu>bphCCgg0oMJPl`uYNMaZR~	tDd
+|r%A@D2>aj~
+an r(Jm N/nva[7oAPI<pFpU;{.^=VGjrgC~`Z3yn<a4B)DB@$s9LMMG?z?~<#	@!*!.m
+|yn@^9("Hu`UWmk:u{\
++}d+/s>{UUkG	PJZUA&(u|+ipn	H[xmo@|fLG+ZpW*P16AGG'B![UePQhW,V;i<2KH$H&Hg(4H%B8$JIgI-t]jYXaB
+tG; a%|O:X#CB>WiF[\ @A,NpsP/8s^x9^!#b,|wYqgk:_}/>AoNzI0/B
++8~kkwS9
+K0CTu7-Jm,Ex !_2%VRFi0Wp\GqZ {'NIf 
+IDHQ\=]G_6n[4.)-$"l&,6Rl6TWLWjG+InKKpFY	=&L-2VuX(B<j4Q*q=uaHg>o=[SJ0QpI(!(FFF044^t,I`
+`]GZET,b)B|3&G6_f1 ~pQBv !:v}}'OFj+Xd9Asg~zco}mbMBP8\ KEvaX/_`f>Im	'Q    IDATIUAMOL]'sgqxu:, 	#FWgz{z]]]#GE!Z.A%n%8;r
+?;R'^]Q.NJJQTMkP";XiG\1f<7c)|.PVB 
+D2Z{$i!r^|6'p~([U"B0dEA4F8F\aP+\T.0a)Rf	\b	eU0-c%@& ^SXA0YOD	33x)]wom=;	'9{Fp	i?1>s@,:$RA*xs\o, Hc>0VHu][:hBQH1$#R	#Goo:;;
+c:fK0]G(A(TW\P#3!{XD6E:FK*Wl_(Snm-0]r\!SD*)
+naY0Mb	R	B)*
+OD0P0"K_I6lMbwa  L>^PHAHQ2$I/=b<!Q]7_i[NrL( T<\Jp~\C<ZP={31&t`	{PM	Jc7TU>~c|h!a;Z.{~o'|lQR;GhIRx5Cco
+m`p0p:cQtww hG!EqXq[!"+S'6zsNN!4b\TdtS1
+ !z(!Y\7AY; )0dY(d#L%r/5kr4qxeL +
+,,I% `tlC8{@hmx
+\T.bMk-S,B<!.Cq"o:k!?_V<~$*J]V~p#p	A2f >d?>\s}Hwur 	C|	|/yJa+=(u"j ORj OFq3bE{	h]1zWtxldSmJ|/ME?>NZ#t8s*&t&B0Mw2T)B=(A I<"a.9LC72J\:7;[7^	ViZ0up\}4UI,B~~UWP[|^w2kn8",oJ,H,kz q;:rro75r]ri]7m7`|>|@.4D)ERzW5 c8vqL"+VaXKPMKrZsRH\u1}==we}u!BI@mf'b3	qxTM]"J!J!]2-[;O]	i[J4 b1:b0)0taRL<?74;3YJ&l6B!aqqa"	\eU`YI a4-`5]rME[Q(swDf1<{&p*>^0c- 9$Ao]o)'Xhs#@BP.WGk[owwb++ TVjoq-%IC|rePKh{2a6s89$UTunVQd$2hHA$TLgzzzgS1}}F4kl`'v$}\8dJ&J%I/P,@V,>"4PGQgz_u%,,>0$INOstz~n>NKJ	Ky_vwZbi)qmH(fioFgg't+Z~SuS&NT=|`@A+h0@%	p^]	mN e=CowFZ{:W.?`7FkQ@oxC7mwmhh8\QUpJMCRk PJ055x<d"T:R*D,dIB( # 	EOObBa7^k,mq\o;,TUd2o
+PUP QG9&u:axG'vovulifR).,.&/?O%R1f"88hJo~]o{nPBb#BQd ]7a&**0WeR>XZolA\c n	AQ044[`kpu?~9D+{ erkG:x<>s[SdCxusWR4Z>*po>o|P(LV($Ek*jiZ 0:Q+(K0>kAFRHIlCkX^&d5Eu	pZUT@&A*D2B&A!_@M6(3N3z<VwgX&trm@aZ
+B9ffg.^K$U'z9Ot(  'NL=kU\1j* qHx~xPT7OLs;4Xpq8p`nO>	D+klk(r8zX;tk"F+ S4m65k4, c=zs_?O*GK]BUXkG*h8e:{	N&SId2(c'#$%d''2[]7:R[qd(5yeZbD"N1a=ygtK'9`U{:DPQd1T*ePm['etD#*@5Fo.8xYV0M,as'M12<T#4>B$\w`?I9[_BPC]<Q|?Vwu{]zXr`XqS>~OH_m[?mP+xv{4D"<2.sK4[Oj]_J10 {2Im#|.R:ei-uyYQM.Xk|>eN.b{X5B/fgff&'Tj\.fc_&\AfgfBebZD
+YAPQ9+d7mB_o7RKE[	@d?=uM ]@[6pk^l=uO7Lm$^*k`p` |.`?Pp'a:[n|>_	8Gt\~b+ r
+mA`O=`@O>~oR$T]Z83%| I'hEA W:{BU	X=q5N`l)[X@>G&A:F&|>IzD
+)![zEpy{ nV-B%h/DNZqT077^89TSY^4XeI},L
+xjt4]A$%Hi,3cXjFWihf-hNh:
+ =on\k'6mXwandiVb8~df(HR8~d]v_#OF7\}#;fUx=^ TUG?o>080]myHmzE/1XF<3i
+rLQ| P"JANL$k:-jj1($JG$K` 0MjL6]YXXL_X]L&Eg7}z%YUpXict:%AIk/}"-,N[6c{paa2L`z'@ie }eeyaq9r]r`T51}y|~fggSGWz(X$cp` =4& K9b4v<gq.3M_KXfQ*QVat%@VS|E`6By6hE	,DP
+DIi(f2,&&/N,d:3
+15>gyu\k2jyyKj m:bQ,KeC<;?{ P.k0tUw.S6, !']BzIq[oX('}*I@ut~O\$, kFWbgr7	 [?eEY,efs(T	j=fyp/2nPAR]a&|-
+B0WPbX<7?78;3ORU7&Yb{w}  )2J)q'0f2tG5>qFb~1mGpQdM9
+bS_|nr? }3dv,e$u$'Ox{-[w'NxAh^Y =kY|e^uk/k3$LQtX/""
+4{RD5TUE ,qbj
+0V~Aj`*<L|4uMmH+g@)TU5B|fffab2O<vv j8~G&8zG% x|1Y*DM1.3@QA,zfa^=]Dy4o:j#2%$I\< tmcOu"QGW;A<pSJ;n'P9op'-{v=U>nsY\Y=N#@ekDE fAUU+M7XCy(H	ore`Vnu^bY:>7#a(d*4?70598?7JTU}U;z; ki	T|fxx8j ;^'I^P* q)j<EscIy|({o xz,!E}r|Kl:~'??{!_~R:	sbw?__~XT)0fgfa ]a:L%t]q:pJ84 =k8FXus?UoE\nr2~2(TYZL%L&Shko-8ys@jaS1Y	h:gSSSk]U0N7M&S<6 cuVtvD7<\g} 7\w`?D{I.>M%LMM'Omwgv&B>SM	8/PUbzj
+C@X@yhNiz`VEVV*M8U3QiY^A;HrHw4P,*Tjinvnajj*>?7J*qVpoj6fcTuq17;tr1N!/UPBa`b##	p*q)8yaY{Y$I ^ef>T,Gp}=<J7}	hMg?=''[.qb1h[JL.aBX@8e(J6Uwi>cvnP7@EDX5]-weBTYZL&L&]TUqNu;<3R>vvu)*#  .e$qI0`ppGR @O|*ka )2^ze	6WM1:2c}(cGTD,so;g>7kV=#4-_US<=A9sSOPKYHiR4kvrXraAvi	s+YvNApjY|7L0%v4a$T*S..wv!(,6o@o4t- X*dwD3q"H`m8NDQlc'QMA/-e_$bn~/9[nl< +
+^{ ?1=Eqa"zY8ppMkg<EP9o<"k6^wG7wnc$$Fm4pg~Oo!HgP*ULP&0L>OmMl6[D"LSy.WH-nn}#n>6q
+rHm[g{}o
+93=st|K1EQ@&M;)0`@2?Bz*Vv$$%ZS[n).OCso_G	jGz#H_7>>~b`Wh ZhSsA	fygvO~M'a:GF<@5~ipEjOR4Lxb]//LNN.eQ32TV_+{;_4[I8!"6},*P, /as]8iZRpF Avjo7<N3M*"\:o<vZE(T;/M>W{  	?@ {{'G>Y14ei1Nx8x;En@<1r@$VT]\LreYmjRh@.V>|55    IDAT_ZCEg[ ]7L00fcux(biMX $I8Y,,.bHp	OtAal}2=jEq9<xpoM7 cr.l>>6]w	bP:r/$J4	wvvP6erfnFP,*s3/|?C'~O=d\.Xz]?5>&f92FnfWc-@CPakdm
+;w\5mEMY(Xfm]!<??_8Bb+PSr [a\s9x {H(s.(r$m|!|UO_AmNdWA4aRLhJjP{WG0yb+_>aj`__gGG#LJR+U.xb1===3?59L$G?Uc^Ood[sh-$J;Y-6X`{Xunf.a,0p%*$QMv&-x:W7T7^^{<=hC]<8Z>r{1~}X]p?P}r6%V`a^{mk~% (RWwB)%aa\uhO MW==EqHFb)br(4P.sAXV1^FqaziXw!Pzg"
+Wi00<4d2Ipk+EQpW/7tL@C\~.24[~G-^j9T*fb1iZB3TksUk}>{jUOi<?U4MUU">},tP7=AOO6_,4QMIqW0?.Om!VmpV("1 X52nc/~AL+Dgm6h^WVWmALs6J^k ~ ^oA< x{1?Qd.E[Zi1JE0R.Tcf%[#r#eY]xhS J"qX_$ ,J?udIc<oF$ir	qVB)zNs@P,OjsF[}ka;0	A%,6A~QY_HueX`K:@+,RBen\fByftc1m%FUS]+,	y<5\?$Yiu@%3gpky[oBPs4pi5VP*&+MWWP<R3s=c69FV*j07[&??9 &.^L8|Y0M#0@,TI1U]Im5c[;[qm|<uii~~Y3]7^G9Tln~<>+TY](VL :ZnrPC^k 5p#1ymoDdA%n\9`&$AnH$SkegW76m"PfSA2x="bvn[m/'B$DQtFCHwV8a`!0CA-'Y~uwk?{^{z]y-K,9Z,Y$@"Z009t{U]]S>EtN=~8qVqQl829W Yv5F6'xx8^vNpY</&s\bFi]fKfLY2dqKdE^hXT:e)fup^D%tvuyVC +hllBY(H4f{V3+pRYfdYFWW7ZWwN(%	, H:qq;p +v0=<uE hlh^v_LR[Sa\Dd~nw~?p	#{YY&Xg_-"d:v/8Gk1{;xF?L&Nej1nY9c
+"b0+eJ<l aY`HMKBVHq>}c8r(;H&@	"+9**/!$J-w~/]t;bdB\{ n \@A__X^PG*I"hy;j*U?tKK$
+@t}}}+A@Q;S&OSg\5#I^hJi2vR=8|~wDOOYMT(>Qx4$\#uElW<`_;F<>+`gA0^Q RbBvx9^AyzlidUV+if}wOLw	E,xiVOxQUhmmSM[8u4:_S7PEd% caFC=>oWT*sP9 8\~z{C/Q i))QQ(r
+/w.<rkH4MtDffDJ(r)$1456,<,luUndSd]]8|(OA?qprC EQ?u"G!b	p0yR3g%Kf?s\+W>n=n
+-`Tb*EjQxF)GQjpWgg_UIdV2!$	dxc*+><:8M7@	vLTC]?!~Lk+f\(&&KqQk+Z!iMClxnePJ7\s{.7NWuK\NE6GeNeR"un5jTHF.G)BT+,4Pz52usS'O)*	!d,cd
+h$I4)8uSSd[?%N:9eeigX,1D;>G~k|},H&7#AUnBKE
+R?g o. 48m)%4p0^|VT&mN]7NT@$pqs24J#d"I8og#Vr[~F5q144CwW?	M n	z<\/w7!__d/|r9WYR^ub
+]VK87jwmBJ'gYZ8$[j70G__\kur%hjjBey$JF,T5w)#Ms1<C"WW?} u'\wbK{QQQI'7^{Q+}!_h[Lk2UVT{)5/oTb}8 D"(\L%#93 h4X,f
+QB*TQP&}nEUZ1#L-W_n{~(+/G2k[#H,\p `a(1XX:CcPJ0x_/b|x-on>uRE6bc%K##/SUU`	t{"]dG<7'weFy\<4M+wofTWWR	u];fiY_Qdw`3=`a\/6vF?>Ay>J_@Tp}OOl5R0*  TE8Go_o4VL&~OrgL}B5Aq$2p81WJ1E7?0aD(lom2TVQk9yO#Iq/7`?)p=O^de=7GU3gzrIH!2dU!G:RsV 3g
+tqf=6;	LLBd(Xt2[+n	EVu+F`0m4~-ny&=p@ s<e{evp(d^G sv'd_~_4++G^^b/|x@Bv%saEBpw|@^lhHEe8"d	zJ0tB!bLnqX
+K23I!vL]9V4g8R$r|xMzX@ d*?Q{9yJ^vlv+E5yq6qSnE\
+Ey/%/mBJZK5jmj5@$+Z><G*:qJQYQ{e'fs]l{'rP._A7$1$S)h| k_9|~kg9C8S=[~as=c?{I[=0VX`u	;J\T[%K:PMbV]TjP~$)3jVDQ4fWj%pBlvyj:irkO p+n NAtA=\u%[1PTP1o~?<OSl ]H r:P;qb7n=#`T{/e)BB%(RdC[zC*"O@QU"RPQdBP=m]}3e3zF0l+r+l3TQ3,KeK4e~>]v(B *++<wgx|eEA{Gnvk,gp+Ga?Pb+|sQ^^
+ZJC @*3fg184o90qL<OA:-YK|}14]U
+,*p|,b1!ICo[y=$n6PYB(1cJsXc?{Y6lXwC0% /QrF|znjAB!q>vru\MkY1T*a<%Fc`zV3'ey#P
+_oM3t0HY~O9gcY?'L@(,SA/n-shni`63q]"c=hko\E6o}^a^/Tr\=l]N&;%3UbAf` mffkS3J6lqLVj~jLP)&c)1m*&O<E(dd8uw?{(++,C</u[+LWY9x{/\pwfUZCX9"/+ mmm63f=@%fkI $~asJt3_WH?0H$(L%Ji0tg!
+IP>PPeeaj,VAee*+(
+U"Q ZZCxicC8S&lae'`/rh5
+ FVv/e%mp8\V:T
+`x#K LbphSs_$||B,Y4O}J:.>63xQ9r'D{g' Q>cUyJx7Y
+[8Y+'M^~#:X	/yM;:;WL&BqIu3-ahpT
+PB$sB"$Y;HcuT
+d
+C(.lk::Hd d|Y6EgJLm>/b,;pn^%_vYC#{{r O'ff%Q>+9	h>y_p(//G8DG "$jo:4MC*F<@"D<01q$AWft<mN8) )AZXex"_CVKTj&--gFZ*@8I`9I)Oa|TTD,-2W	s63sZ|}Y%[{nx<r lkLY96n\X9"A[  }oH,K}>k04~Z:m!HRD I  Hg5,lN~kx(me!B'UV%XoCa?W=,]~W,?L".I{5vwPrZDb@ MKCQ10bbISiAS(q&pJke1~<
+!>_XUMDc{ P(u7!o>uCf]79 4MiT8CCCTV@Udw:)_q.Z({l
+9~,#/xa8s5ni,wL4#q	)}G=Q|TSA	?]_uJyIs<i"XUt%3#!V-s?Re]]m{.\hL+
+\^%	smB\NN8o0C33\dh[U    IDAT T2  iDVNIQ__55w~l}hLyD_KAS&?):)*i#`/Sf&]H(\u,0l~K1@%	JhjPTJYBxj7lQJm9n;U+]okjnvZ9kUUq6!/} 9O9|,Yr0t$!A"7wm(5>cTOUJYf-@m=x!}5/b1D1u'Z9==xrAbK,cR"."
+6! _d	snfBt]044d`fKH ),c gHt2x,M)b~a>mK1m,^4% dI[9RM7t=S0#`/nBN=,m IH'fy"SAgc@ MM|gt2[FM<+|gl>}>1cVN /Gr~W
++G^E
+b?MmmC>U8f %1}F8$\\2Q}w/DS} jO$?O=wg_|]V{|!gh<qD",Id%tXHy5}{'s.W	uyDwhk91>OOZ%(AoVK%x)Biwnsn|UUEVAd:g-B	*++1c4j^[3)n-gl\=\ WWcYXl)[w/X wSb"L\;`v:p y]a`0Xa
++/7R677$RIIC%5M`FQU5	%Dh5m7B=/I{o%ocKXUa`BM  Hq~x100  E_?dYce^p9s5\3~zQM({	Y7	9immQIrE:tf02$s44D1f.uccy@3;w+~CZW9g;M7mpa<b>^ 3SUim"7.E%X9VWK&gZLl}Hki( $NaH&`=Yl<'NE2@>d`a*}}Y_Ygr^~UD8WcN8y*{>[v>srw}V~/
+8+.^n#Pz+qg_ 8q';}$CtCeiD|$#
+c}M1"~nv$s UUz
+P?c:D||(!|;G$I}Sc	z*VP(</x<9g"1G%]bp/ qX<_fi$Au40#L a|UU$	0p]}`V$t@ KXnwtKvp[?)SpUW_c
+'b~.EQ0AuL0DgP?3p	0Bq~O<_tMk{g<J({KnGBLJRbzf O1441K*QQ]=>Uq[(2Q7e2mJ{n-W|c<f|#E,uw+gL~'>8z8>\F< el,4M~p1{Okb,DVK) FcE@Me@*UP A$S)J(usLe%fje]x?v`C\}oLEy9rxoz|-[8w ZA: Z0{V	x{|84Mk IR~?44MH JfL5\rr#?	b2v/$%T*-,)Hc`p`>^2hjjz+Wk_"Rit
+3pe3g6{yXvgbIc'f::;P?= 68PmnjC[<aBVdocgr_|s\{Uf-!+OF,jLb]fktMky-^E=v~Uy]Lp[D*	HA8c*(Cu=G+W\e~
+qg?F_6[x<[EYOm-iYBI(vDh=/^*\x$	>{ S\*`rO<#G]__V^V4}/pH-R!R&YdOGla+TU8gV(
+"Q1$r5-F"ed100Uk6_ b8N5{0e$lYttv+/U=~.aXk1}AA<neea<_dF>wSduS psF DOo/UU!Ja3;}i~<G#H$ylRahVVV{G=@{.//7wSZ,D]Il9d*N)8 '3#{_y+x1<fk
+G?p}wx-o88^;| P7y2|R{OUq7g%aL<	{qq|cxnf_?Q<'{-gOKsmo{3I,:!<{oA95$/foyt_lpoiih1z\UNp	VAp 7X<Ci,C:m0|Xt	aH$GH@?MSqTklVO>&'GeKO}3'0yR-;[33~b/Au9u=[) nSDb#9CE\tS477w1fSby,C4u~I@T
+7vO$!~x,/Y8|> >U!Jah6KHv@il6[\--H&xj\|n:O*[puO|<{L6ovc18sn+~eIBd *+s&Mj=f ~$ZM+B^EL6jfp)>2sY0=yIIptx`>! '`8|xIE =`c*+1F0kg>qS8q$ @Kk8z8./.+7=z8t@k[;TU*C<} V|_bZ2:<9;088< 6lz}z{	S/E)SaL
+%KH83(h={h<^/G8P4~|o#yq/nm? z\6A;qq18P4P()'lkxAVdGV2zB13[rp"6<v<W
+ ^G	ZoT[i^n3gA>sj+uif@Y:AAcY:AUEE]nTVT 6m\I8|{]3&9q"Xx6mX7ne8}>"x]V]kF+\a`p8}9K,Z9"qXRK'p-N<oi 6t5?0 ]LTfi0g:JiR>m 9zwxj6[7r8poE3>EUq9x7!(N]?!~-`1AOuO%!D^|sX8B8OL9L$8$b3`@"@4X<2UF`:m*^;~>woozzzgH?9;>> 4n~n<Nkfr
+(`B4`!V2*qd(]S}ax/q?f&J}}	af]4p0P@%	1$)G",/aUIA	ASSv><$IU>RqUWb%xG 0s-gp?j8{E[[;v|X$8k8hfv{/  /.pqZ;N%Z8y[*JN
+9IK`*qsNiaVJrR0=zNP2=<
+w iP$xwV0(*m`W	1A+w.T}L@?uT5mv,d
+N&P]] )',r4/}8y${5;)>p~e#8t]GMM5>^uu#V".!;R}%t)[HP1f`C:N4J%!44D//V,[SM`9;s7Jki42DxSA\AommkLHf+`:w3RXH4k|$18}`+>f~83m)xA)E>rz>f:" 0!<{o$Q:bp\I,cz<N*QB7<C$S3@*u"2ArP?Ers~l+m3afdyJ+2=CEe/TVK*S=PDb!	21M~h8D"az(  7
+uuuTk R|^0~Y	*5W)o!`/"GoJZkfIr8	cnp$	D%uxe	$nxCgiMq`*[Js>w$OM5qn+8$`/B@	y3g4J
+$ c$I c5\/+
+a.#W(BqJVX@=}&!o===<s{ebN@$3hgf BdDYr3g,@pgc_[f3fX
+!Eiz,\1^|]]]Euo/m5WSonC;e HppC	%E,$9!cv}&W13q0oC
+|8OS8q+\pD=5+eE`sO5w9J`@3GA(>5q|Va.'i,7{/?rR7s;?0@}4-e ED< _u5YK=;<)!&ryY3L7 )
+"|Os(p`XlC~2hVN f<|"rV\X5`M7o?7w78p(_/`/{)X*1 vwwG$Y2Z uMA4C"5"' BVUkaI(LE5q}9rsQ^9LXY?"Vx~|PUSGPP8JKqd^psS{):dB8]CZFm7o(*tMG]ZcC
+YX"y*\tl;\h^jjj| @-o~Sr>9re8Gr"E\wl``%}O;Ts9yJ&Y!nKcfLYQJqk0n
+B~0fd9?/73~}.'gs+jeppx_55nzw
+@ WH!_tuIxBWl:NiV&nM=})oUw;nT)-GX3Y{	u>ekdrmjv%^	17X\iZ@0]w@mDs o398SVop+m-Y|f]. X,9}gLc0PJSbmTH%7
+pWVa@A4<DH'.2J>{\*{YHVvR"@:BmDm7{m&0p|_Wy5q	-3eD]u33Y[X=j	tf@eLYDGdJ9f0pV9fm,U{Q'%e'VmEvI$I0Tn`J,YxS643`N3{z&QRqkUl\>|c]5T:X=$TECe~?T
+eea|CwO7>xR$QS9d}q{	cn[nxPsdz!.GqC!4MoE|R;
+@d:riWdY;^H$`L-#B({6S{ 9inS  nIDAT3fB'2-L	R$*+0fX0f|Hj'NDS,;*"tJ nWmrnQI\N.g!J!O1Uc|v0f])k"?<_c4JP"E\"CEO@^r54gik&|V33eW1	L<V>!|*K0ZZ)=ky}H9Li/#;)We37~;]H$LS}>z.^jH*QC!,_{|dOU!Q	>O|hz-j%B;5+6fs5}L63fLg?QUHT(88ah:#p1i4Tr! tMJx~$4Y3Q~}t(gRi5"cBMKE1c4apaX|>>mi1(F}syi R y~T[}N{|~gg/_z[883mI!9aPeW_sTEcm.[Y~v @?~Fo$
+B%Hgk%`QM=Js0g`ErR;5MnX(P>|>Biv_F46Ke#'b]w={^>9a6'9".A;8 ~x/e P!1O$C)NRIBcC.l.VJPUS!o?|04(K(/
+0
+tM(0E1}TCapg]U3va^$ ?vsw9r4r,S6k.{b= |C{~T {{{eWH&Ya'$giPIU+1eJR56w^ sPJz
+<'rR4$Y63v8h[ZDHg{y-sFu8Hq@wI2'*,2LK$kmW7?vm+}nT$KXQ;AwqWE}{n[tt*m.z[;3 [
+U4Z2	f $e+/v=0:,AVGA``l/]+]iS"
+s&=L +2}wa<j]8p@m}MgCY7"SN:,+z6g&M5leX5MC]@7t+6o.TJ%H rTd
+8|(<WFgWR4M}X3a=	sfq$	as.eY34Nz BdY*=JSuzw anmRF5yUI^M^^E#Wf<|u_8dkem,i	EIPRtZC}}=V\aWwt
+dAlIY(L&!k5t>
+m"0IEU	6 Rs.~}woOy;O#G-@y:KR{Iq	Y9Z;O.`wzn^"vRmo*K2tCJKRhXr t]@R*	!A5-kVoXn/fFr%cLozV\tlMzB(ITRI|?mw>o)q b6g&d-
+#`/=-31w\]<r}Clj"1+fXz5|k3~>}eR	"CQU(
+UU\*etroZnD>m<x@[v>\}{n/)vwNz{={{w}EwN@3
+ O>fF)4apX$l+V0*,?ggZ\J$TOYfeH<f)*JSN[5Ri0V@*-}P"w>Q]n44>M8viHhjlP^^=4-R"YM$L5;UQ	Y }}Co;b`qNE_Xz^^P5qf KPCI*//N4nJS3vIecY}HH`b'@d3xrltT Hh>}:Zl{3'OX=9A2o:c[Es)Bw*y_	^PUel55S^qkfr0@Z`0f=f=}KLoZ	>E=^}s->yCCCv mR(Yoxmp]^z{<3CG{-B8&;qW^yUVW_6~	5~o|b6pMO9|kmvpf}[NP^5bR^VLq9y"wSV"` &.A	86tU)//W9dI`d 9o'NDcIV9o(Q}q> }".qu_o/o'eW<,7;.*. tP{l+c P9pY! (|R@\b |SvYPKESfK03 ;C)fx1u_L{cd~bx<
+9kEUE!f.w|v}v6JRVeK" 	r^"m-bpo".TE
+z:
+{t4~:Je_/dC"/t #<|f"Dj 
+@% lR`z-f*Y}B 9@T6'fH/erv4E`z6Q8U|yz{"^C\i_/(eS*_|FUfpQy^hH
+"DA SSvgR)Bg%,X/:+`7 !'*.qSnueKoJHKI,W/rP"D\P#SI;S&@u/%MIs<-|)w6![rP^p
+<~)c>D/ /`/B_B P/(A"M
+ .u8(vY;@Fx"D)6Sl+y7PV
+!.|x MCJ|\&iKQn3+h4]w{".:_)-(M3 '.~"D\qR P|\<{P_.!!T%~G`]NQ@d/:w"D'=:^  q. /"Dx/z'8%EWmQ^~!*C
+MO&=%c    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/skin/PM3.HD/media/OverlayRecording.png XBMC/skin/PM3.HD/media/OverlayRecording.png
--- XBMC-unpatched/skin/PM3.HD/media/OverlayRecording.png	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/skin/PM3.HD/media/OverlayRecording.png	2009-03-06 13:43:17.000000000 +0100
@@ -0,0 +1,21 @@
+PNG
+
+   IHDR   7   4   .O   	pHYs       
+MiCCPPhotoshop ICC profile  xSwX>eVBl "#Y a@
+VHU
+H(gAZU\8}zy&j 9R<:OHH g  yx~t?o  p.$P&W   "R .T  Sd
+   ly|B"  I>    (G$@ `UR, @".Y2G vX@` B,  8 C L0_pH K3w!lBa)f	"#HL  8?flko">! N_puk[ V h]3	Z
+zy8@P<
+%b0>3o~@z q@qanvRB1n#)4\,XP"MyRD!2	w ONl~Xv @~- g42y  @+   \L  D*AaD@$<B
+AT:18\p`	Aa!:b""aH4 Q"rBj]H#-r9\@ 2G1Qu@st4]k=Kut }c1fa\E`X&cX5V5cX7va$^lGXLXC%#W	1'"O%zxb:XF&!!%^'_H$N
+!%2IIkHH-S>iL&m O:L	$RJ5e?2BQ:ZImvP/S4u%C-igih/t	EkwHb(k{/LT02goUX**|:V~TUsU?yTU^V}FUP	U6RwRPQ__cFHTc!2eXBrV,kMb[Lvv/{LSCsfffq9J!{--?-jf~7zbrup@,:m:u	6Qu>cy	Gm7046l18cckihhI'&g5x>fob4ek<abi2)kft,9kaEJ6|MV>VyVVI\,mWlPW:vm))Sn1
+9a%m;t;|rtuvlp4Wggs5KvSmnzm=}M.]=AXq/^v^Y^O&0m[{`:>=e>>z"=#~~~;yN`k5/>B	Yroc3g,Z0&L~oLGli})*2.QStqt,Yg;jrvgjlRlcxEt$	=sl3Ttcw<Y5Y|8? BP/OnMOEQJ<V8;}ChOFu3	OR+y#MVDq-9Ri+0(Of++ym#slLRPL/+x[[xHHZ3f#|PxY"E#Sw.1]Rdxi}hPXRUjyRC+W4nZcadUj[V*_pFWN_|ymJHnYJjA_mJtzj5a5[6z]V&w{;+xWkE}nb~GwO{{Ejtol	mR6H:powpZ*A'|{PHy+:u-m=^G~1cu5W(=dN?=yLk]Q]gC?tL_]p"b%K==G~pH[oeW<tM;js.]yn&%vw
+L]zxem``Y	GG#F#d~VysKXyr:#y=}(@PcO>|/%3   gAMA  |Q    cHRM  z%        u0  `  :  o_F  IDATxml[vMieR4TW[5[	R)+4i$6lMMv(PQiQAii m`q^}9OuQ{s=K B@B:h<gY iN,ee/e
+Zh eU
+ifiYS@H3P@h
+ Ph*:	h<l[ a</05	c) <	'16)d	R&&`5p=6
+gIA8MKESz`3%v*(CpM_4@j6w_~_?3^=YC)3k/~M[*q0X3i`YLd_B7vM=	raESk7 7/^k` 7?"eJv
+nx> m0Dvl==oguBw}K1+"mvwm`Bj	m'LJFeHd%lf+0@,VjX-F44T8,+dtTfVFM?6,QD a8p z{fN;$;V%VS|JK
+GWib1Z@waUNp	ljNWX&R+3g8Vfu\ kXV-B	#]*_uIaVW%fYTmSe+1=km>llR_T1lJ7[5[Zrs.]Qe3bdqp_uZi!E+V&*>~%JPF ?sJ<.*V30)3fniK7L2S[o"xpYd {f*npp {/'QR'/G:S^BIr"ahI8%b$WH-'3Czxb
+3%\
+qxHyfij.'+\0c(<)s'`Ms0y>%sO{z<4eEs	YCpxxvP5`L,#h`paJr_u7XL%E$bQ{[wcO"CU_dNnDK M{xa,@.Y<VzPF <!KKs.wfK20%\yU'2ae-;0r?LV)(tsEAIA7JK9%d585+~%H}m:5s^`B4:!	jKOA=pR1KN0>;|	j*L>P.Rb(fH?;9.{aTIX33)`6	Gbn&	?jx4T}U`>wuB{sfS0&RYS _:5tl?m!Z}%,L?.xQ)q{>0W9w@[a}\RfI/[O\)MdGC}Jn[yi^Z6!uYna]f}24\0YCK]o |;65    IENDB`
\ Kein Zeilenumbruch am Dateiende.
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/system/Keymap.xml XBMC/system/Keymap.xml
--- XBMC-unpatched/system/Keymap.xml	2009-04-22 19:10:24.000000000 +0200
+++ XBMC/system/Keymap.xml	2009-04-11 23:36:55.000000000 +0200
@@ -39,9 +39,16 @@
 <keymap>
   <global>
     <remote>
-      <three>VolumeUp</three>
-      <six>VolumeDown</six>
-      <nine>Mute</nine>
+      <zero>number0</zero>
+      <one>number1</one>
+      <two>number2</two>
+      <three>number3</three>
+      <four>number4</four>
+      <five>number5</five>
+      <six>number6</six>
+      <seven>number7</seven>
+      <eight>number8</eight>
+      <nine>number9</nine>
       <play>Play</play>
       <pause>Pause</pause>
       <stop>Stop</stop>
@@ -70,7 +77,7 @@
       <myvideo>XBMC.ActivateWindow(MyVideos)</myvideo>
       <mymusic>XBMC.ActivateWindow(MyMusic)</mymusic>
       <mypictures>XBMC.ActivateWindow(MyPictures)</mypictures>
-      <mytv>XBMC.ActivateWindow(Home)</mytv>
+      <mytv>XBMC.ActivateWindow(MyTV)</mytv>
     </remote>
 
     <gamepad>
@@ -1438,6 +1445,132 @@
   </MyVideoPlaylist>
 
 
+  <TVOSDChannels>
+    <gamepad>
+      <X></X>
+      <Y>AspectRatio</Y>
+      <B>Close</B>
+      <back>Close</back>
+      <start>Close</start>
+      <leftanalogtrigger>AnalogRewind</leftanalogtrigger>
+      <rightanalogtrigger>AnalogFastForward</rightanalogtrigger>
+    </gamepad>
+
+    <joystick name="Microsoft Xbox Controller S">
+      <altname>Mad Catz MicroCON</altname>
+      <altname>Logitech Xbox Cordless Controller</altname>
+      <button id="4"></button>
+      <button id="5">AspectRatio</button>
+      <button id="2">Close</button>
+      <button id="17">Close</button>
+      <button id="19">Close</button>
+    </joystick>
+
+    <joystick name="WiiRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <joystick name="AppleRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <remote>
+      <back>Close</back>
+      <menu>Close</menu>
+      <start>Close</start>
+    </remote>
+
+    <keyboard>
+      <backspace>Close</backspace>
+      <escape>Close</escape>
+    </keyboard>
+  </TVOSDChannels>
+
+
+  <TVOSDGuide>
+    <gamepad>
+      <X></X>
+      <Y>AspectRatio</Y>
+      <B>Close</B>
+      <back>Close</back>
+      <start>Close</start>
+      <leftanalogtrigger>AnalogRewind</leftanalogtrigger>
+      <rightanalogtrigger>AnalogFastForward</rightanalogtrigger>
+    </gamepad>
+
+    <joystick name="Microsoft Xbox Controller S">
+      <altname>Mad Catz MicroCON</altname>
+      <altname>Logitech Xbox Cordless Controller</altname>
+      <button id="4"></button>
+      <button id="5">AspectRatio</button>
+      <button id="2">Close</button>
+      <button id="17">Close</button>
+      <button id="19">Close</button>
+    </joystick>
+
+    <joystick name="WiiRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <joystick name="AppleRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <remote>
+      <back>Close</back>
+      <menu>Close</menu>
+      <start>Close</start>
+    </remote>
+
+    <keyboard>
+      <backspace>Close</backspace>
+      <escape>Close</escape>
+    </keyboard>
+  </TVOSDGuide>
+
+
+  <TVOSDTeletext>
+    <gamepad>
+      <X></X>
+      <Y>AspectRatio</Y>
+      <B>Close</B>
+      <back>Close</back>
+      <start>Close</start>
+      <leftanalogtrigger>AnalogRewind</leftanalogtrigger>
+      <rightanalogtrigger>AnalogFastForward</rightanalogtrigger>
+    </gamepad>
+
+    <joystick name="Microsoft Xbox Controller S">
+      <altname>Mad Catz MicroCON</altname>
+      <altname>Logitech Xbox Cordless Controller</altname>
+      <button id="4"></button>
+      <button id="5">AspectRatio</button>
+      <button id="2">Close</button>
+      <button id="17">Close</button>
+      <button id="19">Close</button>
+    </joystick>
+
+    <joystick name="WiiRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <joystick name="AppleRemote">
+      <button id="6">Close</button>
+    </joystick>
+
+    <remote>
+      <back>Close</back>
+      <menu>Close</menu>
+      <start>Close</start>
+    </remote>
+
+    <keyboard>
+      <backspace>Close</backspace>
+      <escape>Close</escape>
+    </keyboard>
+  </TVOSDTeletext>
+
+
   <VirtualKeyboard>
     <gamepad>
       <start>Enter</start>
@@ -1675,6 +1808,26 @@
     </keyboard>
   </Settings>
 
+  <MyTVSettings>
+    <gamepad>
+      <B>PreviousMenu</B>
+    </gamepad>
+
+    <joystick name="Microsoft Xbox Controller S">
+      <altname>Mad Catz MicroCON</altname>
+      <altname>Logitech Xbox Cordless Controller</altname>
+      <button id="2">PreviousMenu</button>
+    </joystick>
+
+    <remote>
+      <back>PreviousMenu</back>
+    </remote>
+
+    <keyboard>
+      <backspace>PreviousMenu</backspace>
+    </keyboard>
+  </MyTVSettings>
+
   <MyPicturesSettings>
     <gamepad>
       <B>PreviousMenu</B>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/system/Lircmap.xml XBMC/system/Lircmap.xml
--- XBMC-unpatched/system/Lircmap.xml	2009-04-22 19:10:24.000000000 +0200
+++ XBMC/system/Lircmap.xml	2009-03-24 13:30:40.000000000 +0100
@@ -9,6 +9,141 @@
 <!-- For a list of XBMC_COMMAND's check out the <remote> sections of keymap.xml   -->
 
 <lircmap>
+        <remote device="Samsung">
+                <pause>Pause</pause>
+                <stop>Stop</stop>
+                <forward>Forward</forward>
+                <reverse>Rewind</reverse>
+                <left>Left</left>
+                <right>Right</right>
+                <up>Up</up>
+                <down>Down</down>
+                <select>OK</select>
+                <pageplus>Ch+</pageplus>
+                <pageminus>Ch-</pageminus>
+                <back>Back</back>
+                <menu>Menu</menu>
+                <title>Play</title>
+                <info>PIP</info>
+                <skipplus>Next</skipplus>
+                <skipminus>Prev</skipminus>
+                <display>Full</display>
+                <start>TV_Menu</start>
+                <record>Record</record>
+                <volumeplus>Vol+</volumeplus>
+                <volumeminus>Vol-</volumeminus>
+                <mute>Radio</mute>
+                <power>Power</power>
+                <myvideo>Source</myvideo>
+                <mymusic>EPG</mymusic>
+                <mypictures>Text</mypictures>
+                <mytv>Timer</mytv>
+                <one>1</one>
+                <two>2</two>
+                <three>3</three>
+                <four>4</four>
+                <five>5</five>
+                <six>6</six>
+                <seven>7</seven>
+                <eight>8</eight>
+                <nine>9</nine>
+                <zero>0</zero>
+                <mytv>Red</mytv>
+                <mymusic>Green</mymusic>
+                <mypictures>Yellow</mypictures>
+                <myvideo>Blue</myvideo>
+        </remote>
+
+        <remote device="Hauppauge_350">
+                <pause>Pause</pause>
+                <stop>Stop</stop>
+                <forward>Forward</forward>
+                <reverse>Rewind</reverse>
+                <left>Left</left>
+                <right>Right</right>
+                <up>Up</up>
+                <down>Down</down>
+                <select>OK</select>
+                <pageplus>Ch+</pageplus>
+                <pageminus>Ch-</pageminus>
+                <back>Back/Exit</back>
+                <menu>Menu/i</menu>
+                <title>Play</title>
+                <info>#</info>
+                <skipplus>SkipForward</skipplus>
+                <skipminus>Replay/SkipBackward</skipminus>
+                <display>Asterix</display>
+                <start>Prev.Ch</start>
+                <record>Record</record>
+                <volumeplus>Vol+</volumeplus>
+                <volumeminus>Vol-</volumeminus>
+                <mute>Mute</mute>
+                <power>Power</power>
+                <myvideo>Videos</myvideo>
+                <mymusic>Music</mymusic>
+                <mypictures>Pictures</mypictures>
+                <mytv>TV</mytv>
+                <one>1</one>
+                <two>2</two>
+                <three>3</three>
+                <four>4</four>
+                <five>5</five>
+                <six>6</six>
+                <seven>7</seven>
+                <eight>8</eight>
+                <nine>9</nine>
+                <zero>0</zero>
+                <mytv>Red</mytv>
+                <mymusic>Green</mymusic>
+                <mypictures>Yellow</mypictures>
+                <myvideo>Blue</myvideo>
+        </remote>
+
+        <remote device="harmony_kls_vdr">
+                <pause>pause</pause>
+                <stop>stop</stop>
+                <forward>fwd</forward>
+                <reverse>rew</reverse>
+                <left>left</left>
+                <right>right</right>
+                <up>up</up>
+                <down>down</down>
+                <select>ok</select>
+                <pageplus>ch+</pageplus>
+                <pageminus>ch-</pageminus>
+                <back>exit</back>
+                <menu>menu</menu>
+                <title>play</title>
+                <info>info</info>
+                <skipplus>skip</skipplus>
+                <skipminus>replay</skipminus>
+                <display>clear</display>
+                <start>enter</start>
+                <record>rec</record>
+                <volumeplus>vol+</volumeplus>
+                <volumeminus>vol-</volumeminus>
+                <mute>mute</mute>
+                <power>poweroff</power>
+                <myvideo>user4</myvideo>
+                <mymusic>user5</mymusic>
+                <mypictures>user6</mypictures>
+                <mytv>user7</mytv>
+                <one>1</one>
+                <two>2</two>
+                <three>3</three>
+                <four>4</four>
+                <five>5</five>
+                <six>6</six>
+                <seven>7</seven>
+                <eight>8</eight>
+                <nine>9</nine>
+                <zero>0</zero>
+                <mytv>red</mytv>
+                <mymusic>green</mymusic>
+                <mypictures>yellow</mypictures>
+                <myvideo>blue</myvideo>
+        </remote>
+
 	<remote device="mceusb">
 		<pause>Pause</pause>
 		<stop>Stop</stop>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Application.cpp XBMC/xbmc/Application.cpp
--- XBMC-unpatched/xbmc/Application.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Application.cpp	2009-04-22 18:25:41.000000000 +0200
@@ -69,6 +69,7 @@
 #include "ApplicationRenderer.h"
 #include "GUILargeTextureManager.h"
 #include "LastFmManager.h"
+#include "PVRManager.h"
 #include "SmartPlaylist.h"
 #include "FileSystem/RarManager.h"
 #include "PlayList.h"
@@ -144,6 +145,7 @@
 #include "GUIWindowPrograms.h"
 #include "GUIWindowPictures.h"
 #include "GUIWindowScripts.h"
+#include "GUIWindowTV.h"
 #include "GUIWindowWeather.h"
 #include "GUIWindowLoginScreen.h"
 #include "GUIWindowVisualisation.h"
@@ -190,11 +192,17 @@
 #include "GUIDialogSmartPlaylistEditor.h"
 #include "GUIDialogSmartPlaylistRule.h"
 #include "GUIDialogPictureInfo.h"
-#include "GUIDialogPluginSettings.h"
+#include "GUIDialogAddonSettings.h"
 #ifdef HAS_LINUX_NETWORK
 #include "GUIDialogAccessPoints.h"
 #endif
 #include "GUIDialogFullScreenInfo.h"
+#include "GUIDialogTVEPGProgInfo.h"
+#include "GUIDialogTVRecordingInfo.h"
+#include "GUIDialogTVTimerSettings.h"
+#include "GUIDialogTVChannels.h"
+#include "GUIDialogTVGuide.h"
+#include "GUIDialogTVGroupManager.h"
 #include "cores/dlgcache.h"
 
 #ifdef HAS_PERFORMANCE_SAMPLE
@@ -1280,6 +1288,7 @@
     CDirectory::Create("special://xbmc/language");
     CDirectory::Create("special://xbmc/visualisations");
     CDirectory::Create("special://xbmc/sounds");
+	CDirectory::Create("special://xbmc/pvrclients");
     CDirectory::Create(CUtil::AddFileToFolder(g_settings.GetUserDataFolder(),"visualisations"));
   }
 
@@ -1308,6 +1317,13 @@
   m_gWindowManager.Add(new CGUIWindowFileManager);      // window id = 3
   m_gWindowManager.Add(new CGUIWindowVideoFiles);          // window id = 6
   m_gWindowManager.Add(new CGUIWindowSettings);                 // window id = 4
+  m_gWindowManager.Add(new CGUIWindowTV);                       // window id = 9
+  m_gWindowManager.Add(new CGUIDialogTVEPGProgInfo);            // window id = 600
+  m_gWindowManager.Add(new CGUIDialogTVTimerSettings);          // window id = 602
+  m_gWindowManager.Add(new CGUIDialogTVChannels);               // window id = 603
+  m_gWindowManager.Add(new CGUIDialogTVGuide);                  // window id = 603
+  m_gWindowManager.Add(new CGUIDialogTVRecordingInfo);          // window id = 603
+  m_gWindowManager.Add(new CGUIDialogTVGroupManager);           // window id = 603
   m_gWindowManager.Add(new CGUIWindowSystemInfo);               // window id = 7
   m_gWindowManager.Add(new CGUIWindowTestPattern);      // window id = 8
   m_gWindowManager.Add(new CGUIWindowSettingsScreenCalibration); // window id = 11
@@ -1351,7 +1367,7 @@
   m_gWindowManager.Add(new CGUIDialogSmartPlaylistRule);       // window id = 137
   m_gWindowManager.Add(new CGUIDialogBusy);      // window id = 138
   m_gWindowManager.Add(new CGUIDialogPictureInfo);      // window id = 139
-  m_gWindowManager.Add(new CGUIDialogPluginSettings);      // window id = 140
+  m_gWindowManager.Add(new CGUIDialogAddonSettings);      // window id = 140
 #ifdef HAS_LINUX_NETWORK
   m_gWindowManager.Add(new CGUIDialogAccessPoints);      // window id = 141
 #endif
@@ -1478,6 +1494,11 @@
       scanner->StartScanning("");
   }
 
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+  {
+    StartPVRManager();
+  }
+
   m_slowTimer.StartZero();
 
 #ifdef __APPLE__
@@ -1839,6 +1860,21 @@
 #endif
 }
 
+void CApplication::StartPVRManager()
+{
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+  {
+    CLog::Log(LOGINFO, "starting PVRManager");
+    CPVRManager::GetInstance()->Start();
+  }
+}
+
+void CApplication::StopPVRManager()
+{
+  CLog::Log(LOGINFO, "stopping PVRManager");
+  CPVRManager::GetInstance()->Stop();
+}
+
 void CApplication::DimLCDOnPlayback(bool dim)
 {
 #ifdef HAS_LCD
@@ -3785,6 +3821,7 @@
     m_gWindowManager.Delete(WINDOW_MUSIC_PLAYLIST);
     m_gWindowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
     m_gWindowManager.Delete(WINDOW_MUSIC_FILES);
+	m_gWindowManager.Delete(WINDOW_TV);
     m_gWindowManager.Delete(WINDOW_MUSIC_NAV);
     m_gWindowManager.Delete(WINDOW_MUSIC_INFO);
     m_gWindowManager.Delete(WINDOW_VIDEO_INFO);
@@ -3828,8 +3865,18 @@
     m_gWindowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_RULE);
     m_gWindowManager.Delete(WINDOW_DIALOG_BUSY);
     m_gWindowManager.Delete(WINDOW_DIALOG_PICTURE_INFO);
-    m_gWindowManager.Delete(WINDOW_DIALOG_PLUGIN_SETTINGS);
+    m_gWindowManager.Delete(WINDOW_DIALOG_ADDON_SETTINGS);
     m_gWindowManager.Delete(WINDOW_DIALOG_ACCESS_POINTS);
+    m_gWindowManager.Delete(WINDOW_DIALOG_PVRCLIENT_SETTINGS);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_GUIDE_INFO);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_RECORDING_INFO);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_TIMER_SETTING);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_GROUP_MANAGER);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_CHANNEL_MANAGER);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_OSD_CHANNELS);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_OSD_GUIDE);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_OSD_TELETEXT);
+    m_gWindowManager.Delete(WINDOW_DIALOG_TV_OSD_DIRECTOR);
 
     m_gWindowManager.Delete(WINDOW_STARTUP);
     m_gWindowManager.Delete(WINDOW_LOGIN_SCREEN);
@@ -3862,6 +3909,7 @@
     m_gWindowManager.Remove(WINDOW_SETTINGS_MYVIDEOS);
     m_gWindowManager.Remove(WINDOW_SETTINGS_NETWORK);
     m_gWindowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
+	m_gWindowManager.Remove(WINDOW_SETTINGS_MYTV);
     m_gWindowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
 
     m_gWindowManager.Remove(WINDOW_DIALOG_SEEK_BAR);
@@ -3895,6 +3943,7 @@
     g_buttonTranslator.Clear();
     CScrobbler::RemoveInstance();
     CLastFmManager::RemoveInstance();
+	//StopPVRManager();
 #ifdef HAS_EVENT_SERVER
     CEventServer::RemoveInstance();
 #endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Application.h XBMC/xbmc/Application.h
--- XBMC-unpatched/xbmc/Application.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Application.h	2009-04-18 09:16:18.000000000 +0200
@@ -103,6 +103,8 @@
   void StopUPnPClient();
   void StartUPnPServer();
   void StopUPnPServer();
+  void StartPVRManager();
+  void StopPVRManager();
   void StartEventServer();
   bool StopEventServer(bool promptuser=false);
   void RefreshEventServer();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/ButtonTranslator.cpp XBMC/xbmc/ButtonTranslator.cpp
--- XBMC-unpatched/xbmc/ButtonTranslator.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/ButtonTranslator.cpp	2009-04-11 23:38:27.000000000 +0200
@@ -844,6 +844,11 @@
   else if (strWindow.Equals("videofiles")) wWindowID = WINDOW_VIDEO_FILES;
   else if (strWindow.Equals("videolibrary")) wWindowID = WINDOW_VIDEO_NAV;
   else if (strWindow.Equals("videoplaylist")) wWindowID = WINDOW_VIDEO_PLAYLIST;
+  else if (strWindow.Equals("tv")) wWindowID = WINDOW_TV;
+  else if (strWindow.Equals("tvosdchannels")) wWindowID = WINDOW_DIALOG_TV_OSD_CHANNELS;
+  else if (strWindow.Equals("tvosdguide")) wWindowID = WINDOW_DIALOG_TV_OSD_GUIDE;
+  else if (strWindow.Equals("tvosdteletext")) wWindowID = WINDOW_DIALOG_TV_OSD_TELETEXT;
+  else if (strWindow.Equals("tvosddirector")) wWindowID = WINDOW_DIALOG_TV_OSD_DIRECTOR;
   else if (strWindow.Equals("systeminfo")) wWindowID = WINDOW_SYSTEM_INFORMATION;
   else if (strWindow.Equals("guicalibration")) wWindowID = WINDOW_SCREEN_CALIBRATION;
   else if (strWindow.Equals("screencalibration")) wWindowID = WINDOW_SCREEN_CALIBRATION;
@@ -854,6 +859,7 @@
   else if (strWindow.Equals("musicsettings")) wWindowID = WINDOW_SETTINGS_MYMUSIC;
   else if (strWindow.Equals("systemsettings")) wWindowID = WINDOW_SETTINGS_SYSTEM;
   else if (strWindow.Equals("videossettings")) wWindowID = WINDOW_SETTINGS_MYVIDEOS;
+  else if (strWindow.Equals("tvsettings")) wWindowID = WINDOW_SETTINGS_MYTV;
   else if (strWindow.Equals("networksettings")) wWindowID = WINDOW_SETTINGS_NETWORK;
   else if (strWindow.Equals("appearancesettings")) wWindowID = WINDOW_SETTINGS_APPEARANCE;
   else if (strWindow.Equals("scripts")) wWindowID = WINDOW_SCRIPTS;
@@ -905,7 +911,7 @@
   else if (strWindow.Equals("musicoverlay")) wWindowID = WINDOW_MUSIC_OVERLAY;
   else if (strWindow.Equals("videooverlay")) wWindowID = WINDOW_VIDEO_OVERLAY;
   else if (strWindow.Equals("pictureinfo")) wWindowID = WINDOW_DIALOG_PICTURE_INFO;
-  else if (strWindow.Equals("pluginsettings")) wWindowID = WINDOW_DIALOG_PLUGIN_SETTINGS;
+  else if (strWindow.Equals("pluginsettings") || strWindow.Equals("addonsettings")) wWindowID = WINDOW_DIALOG_ADDON_SETTINGS;
   else if (strWindow.Equals("fullscreeninfo")) wWindowID = WINDOW_DIALOG_FULLSCREEN_INFO;
   else
     CLog::Log(LOGERROR, "Window Translator: Can't find window %s", strWindow.c_str());
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp XBMC/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2009-04-22 19:10:26.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2009-04-11 18:43:05.000000000 +0200
@@ -286,7 +286,8 @@
       context->max_packet_size = FFMPEG_DVDNAV_BUFFER_SIZE;
       context->is_streamed = 1;
     }
-    else if (m_pInput->IsStreamType(DVDSTREAM_TYPE_TV))
+    else if ((m_pInput->IsStreamType(DVDSTREAM_TYPE_TV)) ||
+             (m_pInput->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)))
     {
       if(m_pInput->Seek(0, SEEK_POSSIBLE) == 0)
         context->is_streamed = 1;
@@ -375,7 +376,12 @@
       if(m_pInput->Seek(0, SEEK_POSSIBLE) == 0)
         m_pFormatContext->max_analyze_duration = 500000;
     }
-
+    else if (m_pInput->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+    {
+      /* too speed up livetv channel changes, only analyse very short */
+      if(m_pInput->Seek(0, SEEK_POSSIBLE) == 0)
+        m_pFormatContext->max_analyze_duration = 5000;
+    }
 
     CLog::Log(LOGDEBUG, "%s - av_find_stream_info starting", __FUNCTION__);
     int iErr = m_dllAvFormat.av_find_stream_info(m_pFormatContext);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -27,6 +27,7 @@
 #include "DVDInputStreamHttp.h"
 #include "DVDInputStreamFFmpeg.h"
 #include "../../../FileSystem/cdioSupport.h"
+#include "DVDInputStreamPVRManager.h"
 #include "DVDInputStreamTV.h"
 #include "DVDInputStreamRTMP.h"
 #ifdef ENABLE_DVDPLAYER_HTSP
@@ -49,6 +50,10 @@
   {
     return (new CDVDInputStreamNavigator(pPlayer));
   }
+  else if(file.substr(0, 5) == "tv://"
+       || file.substr(0, 8) == "radio://"
+       || file.substr(0, 9) == "record://")
+    return new CDVDInputStreamPVRManager();
   else if(file.substr(0, 6) == "rtp://"
        || file.substr(0, 7) == "rtsp://"
        || file.substr(0, 6) == "sdp://"
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStream.h	2009-04-04 20:52:44.000000000 +0200
@@ -37,6 +37,7 @@
   DVDSTREAM_TYPE_TV     = 6,
   DVDSTREAM_TYPE_RTMP   = 7,
   DVDSTREAM_TYPE_HTSP   = 8,
+  DVDSTREAM_TYPE_PVRMANAGER = 9
 };
 
 #define DVDSTREAM_BLOCK_SIZE_FILE (2048 * 16)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp	2009-04-05 23:24:56.000000000 +0200
@@ -0,0 +1,422 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * DESCRIPTION:
+ *
+ * DVDPlayer input stream interface to PVRManager to play live tv and
+ * recorded streams from pvr/tv server backend on the local machine
+ * or from the network inside XBMC.
+ *
+ * Channel zapping and switching is also supported by numeric keys
+ * and the channel up/down button on the remote.
+ *
+ * Streams are directly readed from PVRManager class over the control
+ * class of the selected type of backend.
+ *
+ * Input file string must be in the following format.
+ * For live tv:
+ * "tv://1" or "pvr://1" where the number is the channel number to open.
+ * For recordings:
+ * "record://1" where the number is recording number stored by the
+ * backend.
+ *
+ */
+
+#include "stdafx.h"
+#include "DVDInputStreamPVRManager.h"
+#include "FileItem.h"
+#include "FileSystem/File.h"
+#include "PVRManager.h"
+#include "GUIWindowManager.h"
+#include "GUIDialogFullScreenInfo.h"
+#include "Application.h"
+
+/************************************************************************
+ * Description: Class constructor, initialize member variables
+ *              public class is CDVDInputStream
+ */
+CDVDInputStreamPVRManager::CDVDInputStreamPVRManager() : CDVDInputStream(DVDSTREAM_TYPE_PVRMANAGER)
+{
+  m_eof               = true;
+  m_isPlayRecording   = false;
+  m_playingItem       = NULL;
+}
+
+/************************************************************************
+ * Description: Class destructor
+ */
+CDVDInputStreamPVRManager::~CDVDInputStreamPVRManager()
+{
+  Close();
+}
+
+/************************************************************************
+ * Description: Get the end of file flag
+ * \return bool                     = true means end of file
+ */
+bool CDVDInputStreamPVRManager::IsEOF()
+{
+  return m_eof;
+}
+
+/************************************************************************
+ * Description: Open a stream over PVRManager from the backend
+ * \param const char* strFile       = URL of the stream, see note
+ * \param const std::string& content=
+ * \return bool                     = false if open fails
+ *
+ * Note:
+ * Input file string must be in the following format.
+ * For live tv:
+ * "tv://1" where the number is the channel number to open.
+ * For recordings:
+ * "record://1" where the number is recording number stored by the
+ * backend.
+ */
+bool CDVDInputStreamPVRManager::Open(const char* strFile, const std::string& content)
+{
+  bool isRadio = false;
+
+  if (!CDVDInputStream::Open(strFile, content)) return false;
+
+  /* Find out which type of pvr data must be played
+     and get its id for recordings or channelnumber
+     for live tv or radio */
+  std::string filename = strFile;
+
+  if (filename.substr(0, 5) == "tv://")              /* Live TV */
+  {
+    filename.erase(0, 5);
+    m_playingItem = atoi(filename.c_str());
+    m_isPlayRecording = false;
+  }
+  else if (filename.substr(0, 8) == "radio://")     /* Live Radio */
+  {
+    filename.erase(0, 8);
+    m_playingItem = atoi(filename.c_str());
+    m_isPlayRecording = false;
+    isRadio = true;
+  }
+  else if (filename.substr(0, 9) == "record://")     /* Recorded TV */
+  {
+    filename.erase(0, 9);
+    m_playingItem = atoi(filename.c_str());
+    m_isPlayRecording = true;
+  }
+
+  /* Check if PVRManager is connected to a tv backend */
+  if (!CPVRManager::GetInstance()->IsConnected())
+  {
+    return false;
+  }
+
+  /* Open the stream from PVRManager to DVDPlayer */
+  if (!m_isPlayRecording)
+  {
+    if (!CPVRManager::GetInstance()->OpenLiveStream(m_playingItem, isRadio))
+    {
+      return false;
+    }
+  }
+  else
+  {
+    if (!CPVRManager::GetInstance()->OpenRecordedStream(m_playingItem))
+    {
+      return false;
+    }
+  }
+
+  m_eof = false;
+
+  return true;
+}
+
+/************************************************************************
+ * Description: Close opened stream and reset everyting
+ */
+void CDVDInputStreamPVRManager::Close()
+{
+  /* Close the stream from PVRManager to DVDPlayer */
+  if (!m_isPlayRecording)
+  {
+    CPVRManager::GetInstance()->CloseLiveStream();
+  }
+  else
+  {
+    CPVRManager::GetInstance()->CloseRecordedStream();
+  }
+
+  CDVDInputStream::Close();
+
+  m_eof = true;
+}
+
+/************************************************************************
+ * Description: Read stream from PVRManager into buffer
+ * \param BYTE* buf                 = pointer to buffer
+ * \param int buf_size              = size of buffer
+ * \return int                      = Bytes readen (-1 for fail)
+ *
+ * Note:
+ * The end of file flag is set if a failure occours and result by
+ * stopping stream
+ */
+int CDVDInputStreamPVRManager::Read(BYTE* buf, int buf_size)
+{
+  unsigned int ret;
+
+  /* Read the stream from PVRManager to DVDPlayer */
+
+  if (!m_isPlayRecording)
+  {
+    ret = CPVRManager::GetInstance()->ReadLiveStream(buf, buf_size);
+  }
+  else
+  {
+    ret = CPVRManager::GetInstance()->ReadRecordedStream(buf, buf_size);
+  }
+
+  /* we currently don't support non completing reads */
+  if (ret < 0) m_eof = true;
+
+  return (int)(ret & 0xFFFFFFFF);
+}
+
+__int64 CDVDInputStreamPVRManager::Seek(__int64 offset, int whence)
+{
+  if (m_isPlayRecording)
+  {
+    if (whence == SEEK_POSSIBLE)
+    {
+      __int64 ret = CPVRManager::GetInstance()->SeekRecordedStream(offset, whence);
+
+      if (ret >= 0)
+      {
+        return ret;
+      }
+      else
+      {
+        if (CPVRManager::GetInstance()->LengthRecordedStream() && CPVRManager::GetInstance()->SeekRecordedStream(0, SEEK_CUR) >= 0)
+          return 1;
+        else
+          return 0;
+      }
+    }
+    else
+    {
+      return CPVRManager::GetInstance()->SeekRecordedStream(offset, whence);
+    }
+  }
+  else
+  {
+    if (g_guiSettings.GetBool("pvrrecord.timeshift"))
+    {
+      return CPVRManager::GetInstance()->SeekLiveStream(offset, whence);
+    }
+
+    return 0;
+  }
+}
+
+__int64 CDVDInputStreamPVRManager::GetLength()
+{
+  if (m_isPlayRecording)
+  {
+    return CPVRManager::GetInstance()->LengthRecordedStream();
+  }
+
+  return 0;
+}
+
+/************************************************************************
+ * Description: Get the total time of the current played stream
+ * \return int                  = Total time of the stream in milliseconds
+ * Note:
+ * Total time = unix total time * 1000
+ */
+int CDVDInputStreamPVRManager::GetTotalTime()
+{
+  return CPVRManager::GetInstance()->GetTotalTime();
+}
+
+/************************************************************************
+ * Description: Get the start time of the current played stream
+ * \return int                  = Start time of the stream in milliseconds
+ *
+ * Note:
+ * Start time = (unix start time - unix current time) * 1000
+ * Must be a negative value
+ */
+int CDVDInputStreamPVRManager::GetStartTime()
+{
+  return CPVRManager::GetInstance()->GetStartTime();
+}
+
+/************************************************************************
+ * Description: Do a channel switch by enter numbers by numeric
+ *              keys on the remote or keyboard.
+ * \param int iChannel          = integer value of first channelnumber
+ *                                (next numbers are entered by
+ *                                CGUIDialogNumeric)
+ * \return bool                 = true if ok, false if error
+ *
+ * Note:
+ * Not all type of errors give "false" on return, a stream is normally
+ * always played and if the switch fails in case of a invalid channel
+ * the current tuned channel continue to play.
+ *
+ * Errors like this opens a DialogWindow to inform the user for the fault.
+ */
+bool CDVDInputStreamPVRManager::Channel(int iChannel)
+{
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    /** TODO:
+     ** Add support for cutting keys (functions becomes the numeric keys as integer)
+     **/
+    return true;
+  }
+
+  if (CPVRManager::GetInstance()->ChannelSwitch(iChannel))
+  {
+    m_playingItem = iChannel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+/************************************************************************
+ * Description: Do a channel switch to next available channel in list
+ * \return bool                 = true if ok, false if error
+ *
+ * Note:
+ * Not all type of errors give "false" on return, a stream is normally
+ * always played and if the switch fails in case of a invalid channel
+ * the current tuned channel continue to play.
+ *
+ * Errors like this opens a DialogWindow to inform the user for the fault.
+ */
+bool CDVDInputStreamPVRManager::NextChannel()
+{
+  unsigned int newchannel;
+
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    return true;
+  }
+
+  /* Do channel switch and save new channel number, it is not always
+   * increased by one in a case if next channel is encrypted or we
+   * on the beginning or end of the channel list!
+   */
+  if (CPVRManager::GetInstance()->ChannelUp(&newchannel))
+  {
+    m_playingItem = newchannel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+/************************************************************************
+ * Description: Do a channel switch to previous available channel in list
+ * \return bool                 = true if ok, false if error
+ *
+ * Note:
+ * Not all type of errors give "false" on return, a stream is normally
+ * always played and if the switch fails in case of a invalid channel
+ * the current tuned channel continue to play.
+ *
+ * Errors like this opens a DialogWindow to inform the user for the fault.
+ */
+bool CDVDInputStreamPVRManager::PrevChannel()
+{
+  unsigned int newchannel;
+
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    return true;
+  }
+
+  /* Do channel switch and save new channel number, it is not always
+   * increased by one in a case if next channel is encrypted or we
+   * on the beginning or end of the channel list!
+   */
+  if (CPVRManager::GetInstance()->ChannelDown(&newchannel))
+  {
+    m_playingItem = newchannel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CDVDInputStreamPVRManager::UpdateItem(CFileItem& item)
+{
+  return CPVRManager::GetInstance()->UpdateItem(item);
+}
+
+bool CDVDInputStreamPVRManager::SeekTime(int iTimeInMsec)
+{
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::NextStream()
+{
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::CanRecord()
+{
+  if (m_isPlayRecording)
+  {
+    return false;
+  }
+
+  return false;//CPVRManager::GetInstance()->SupportRecording();
+}
+
+bool CDVDInputStreamPVRManager::IsRecording()
+{
+  return CPVRManager::GetInstance()->IsRecording(m_playingItem);
+}
+
+bool CDVDInputStreamPVRManager::Record(bool bOnOff)
+{
+  return CPVRManager::GetInstance()->RecordChannel(m_playingItem, bOnOff);
+}
+
+void CDVDInputStreamPVRManager::Pause(bool OnOff)
+{
+  CPVRManager::GetInstance()->PauseLiveStream(OnOff);
+  return;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,66 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+* for DESCRIPTION see 'DVDInputStreamPVRManager.cpp'
+*/
+
+#include "DVDInputStream.h"
+#include "FileItem.h"
+
+class CDVDInputStreamPVRManager : public CDVDInputStream
+{
+public:
+  CDVDInputStreamPVRManager();
+  virtual ~CDVDInputStreamPVRManager();
+  virtual bool Open(const char* strFile, const std::string &content);
+  virtual void Close();
+  virtual int Read(BYTE* buf, int buf_size);
+  virtual __int64 Seek(__int64 offset, int whence);
+  virtual bool IsEOF();
+  virtual __int64 GetLength();
+
+  virtual bool    NextStream();
+
+  bool            Channel(int iChannel);
+  bool            NextChannel();
+  bool            PrevChannel();
+
+  int             GetTotalTime();
+  int             GetStartTime();
+
+  bool            SeekTime(int iTimeInMsec);
+
+  bool            CanRecord();
+  bool            IsRecording();
+  bool            Record(bool bOnOff);
+
+  void            Pause(bool OnOff);
+
+  bool            UpdateItem(CFileItem& item);
+
+protected:
+  bool            m_eof;
+  bool            m_isPlayRecording;
+  int             m_playingItem;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/Makefile XBMC/xbmc/cores/dvdplayer/DVDInputStreams/Makefile
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDInputStreams/Makefile	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDInputStreams/Makefile	2009-04-08 15:15:59.000000000 +0200
@@ -13,6 +13,7 @@
 	DVDInputStreamFFmpeg.cpp \
 	DVDInputStreamTV.cpp \
 	DVDInputStreamRTMP.cpp \
+	DVDInputStreamPVRManager.cpp \
 	DVDInputStreamStack.cpp \
 	DVDInputStreamHTSP.cpp \
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDMessage.h XBMC/xbmc/cores/dvdplayer/DVDMessage.h
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDMessage.h	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDMessage.h	2009-04-04 20:52:44.000000000 +0200
@@ -67,6 +67,7 @@
 
     PLAYER_CHANNEL_NEXT,            // switches to next playback channel
     PLAYER_CHANNEL_PREV,            // switches to previous playback channel
+	PLAYER_CHANNEL,                 // switches to given playback channel
     
     // demuxer related messages
     
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDMessageQueue.cpp XBMC/xbmc/cores/dvdplayer/DVDMessageQueue.cpp
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDMessageQueue.cpp	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDMessageQueue.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -224,8 +224,8 @@
         m_iDataSize -= pMsgDemuxerPacket->GetPacketSize();
         if(m_iDataSize == 0)
         {
-          if(!m_bEmptied)
-            CLog::Log(LOGWARNING, "CDVDMessageQueue(%s)::Get - retrieved last data packet of queue", m_owner.c_str());
+         /* if(!m_bEmptied)
+            CLog::Log(LOGWARNING, "CDVDMessageQueue(%s)::Get - retrieved last data packet of queue", m_owner.c_str());*/
           m_bEmptied = true;
         }
         else
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/dvdplayer/DVDPlayer.cpp XBMC/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- XBMC-unpatched/xbmc/cores/dvdplayer/DVDPlayer.cpp	2009-04-22 19:10:49.000000000 +0200
+++ XBMC/xbmc/cores/dvdplayer/DVDPlayer.cpp	2009-04-11 14:09:59.000000000 +0200
@@ -26,6 +26,7 @@
 #include "DVDInputStreams/DVDFactoryInputStream.h"
 #include "DVDInputStreams/DVDInputStreamNavigator.h"
 #include "DVDInputStreams/DVDInputStreamTV.h"
+#include "DVDInputStreams/DVDInputStreamPVRManager.h"
 
 #include "DVDDemuxers/DVDDemux.h"
 #include "DVDDemuxers/DVDDemuxUtils.h"
@@ -38,6 +39,8 @@
 
 #include "Util.h"
 #include "utils/GUIInfoManager.h"
+#include "GUIWindowManager.h"
+#include "GUIDialogFullScreenInfo.h"
 #include "Application.h"
 #include "DVDPerformanceCounter.h"
 #include "../../FileSystem/cdioSupport.h"
@@ -429,6 +432,7 @@
 
   // find any available external subtitles for non dvd files
   if (!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD) 
+  &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV)
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTSP))
   {
@@ -802,12 +806,13 @@
   if (m_pDlgCache)
     m_pDlgCache->SetMessage(g_localizeStrings.Get(10213));
 
-#if 0 // disable this untill our queues are time based
+ // disable this untill our queues are time based
   if(!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD) 
+  && !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)
   && !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV)
   && !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTSP))
     SetCaching(true);
-#endif
+
 
   while (!m_bAbortRequest)
   {
@@ -827,7 +832,7 @@
     // should we open a new demuxer?
     if(!m_pDemuxer)
     {
-      if (m_pInputStream->NextStream() == false)
+      if (!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && m_pInputStream->NextStream() == false)
         break;
 
       if (m_pInputStream->IsEOF())
@@ -1685,7 +1690,9 @@
       }
       else if (pMsg->IsType(CDVDMsg::PLAYER_SET_RECORD))
       {
-        if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+        if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+          static_cast<CDVDInputStreamPVRManager*>(m_pInputStream)->Record(*(CDVDMsgBool*)pMsg);
+        else if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
           static_cast<CDVDInputStreamTV*>(m_pInputStream)->Record(*(CDVDMsgBool*)pMsg);
       }
       else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
@@ -1696,6 +1703,11 @@
       {
         int speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
         
+        if (g_guiSettings.GetBool("pvrrecord.timeshift") && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) )
+        {
+          ((CDVDInputStreamPVRManager*)m_pInputStream)->Pause(speed == DVD_PLAYSPEED_PAUSE ? true : false);
+        }
+
         // correct our current clock, as it would start going wrong otherwise
         if(m_State.timestamp > 0)
         {
@@ -1725,10 +1737,51 @@
         if(m_pDemuxer)
           m_pDemuxer->SetSpeed(speed);
       } 
+      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL))
+      {
+        CPlayerSeek m_pause(this);
+
+        if( m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) )
+        {
+          int channel = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+          bool result = ((CDVDInputStreamPVRManager*)m_pInputStream)->Channel(channel);
+          if(result)
+          {
+            m_UpdateApplication = 0;
+            FlushBuffers(false);
+            CloseVideoStream(false);
+            CloseAudioStream(false);
+            CloseSubtitleStream(false);
+            SAFE_DELETE(m_pDemuxer);
+            m_dvdPlayerVideo.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, NULL));
+          }
+        }
+      }
       else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREV))
       {
         CPlayerSeek m_pause(this);
 
+        if( m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) )
+        {
+          bool result;
+          if(pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT))
+            result = ((CDVDInputStreamPVRManager*)m_pInputStream)->NextChannel();
+          else
+            result = ((CDVDInputStreamPVRManager*)m_pInputStream)->PrevChannel();
+
+          if(result)
+          {
+            m_UpdateApplication = 0;
+            FlushBuffers(false);
+            CloseVideoStream(false);
+            CloseAudioStream(false);
+            CloseSubtitleStream(false);
+            SAFE_DELETE(m_pDemuxer);
+            m_dvdPlayerVideo.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, NULL));
+          }
+        }
+        else
+        {
         CDVDInputStream::IChannel* input = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
         if(input)
         {
@@ -1745,6 +1798,7 @@
           }
         }
       }
+      }
       else if (pMsg->IsType(CDVDMsg::GENERAL_GUI_ACTION))
         OnAction(((CDVDMsgType<CAction>*)pMsg)->m_value);
     }
@@ -2704,7 +2758,85 @@
     }
   }
 
-  if (dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream))
+  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+  {
+    switch (action.wID)
+    {
+      case ACTION_MOVE_UP:
+      case ACTION_NEXT_ITEM:
+      case ACTION_PAGE_UP:
+        m_messenger.Put(new CDVDMsg(CDVDMsg::PLAYER_CHANNEL_NEXT));
+        if (g_guiSettings.GetBool("pvrmenu.infoswitch"))
+        {
+          CGUIDialogFullScreenInfo* pDialog = (CGUIDialogFullScreenInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_FULLSCREEN_INFO);
+          if (pDialog)
+          {
+            if (g_guiSettings.GetBool("pvrmenu.infotimeout"))
+            {
+              pDialog->SetAutoClose(g_guiSettings.GetInt("pvrmenu.infotime")*1000);
+            }
+            pDialog->DoModal();
+          }
+        }
+        g_infoManager.SetDisplayAfterSeek();
+        return true;
+        break;
+
+      case ACTION_MOVE_DOWN:
+      case ACTION_PREV_ITEM:
+      case ACTION_PAGE_DOWN:
+        m_messenger.Put(new CDVDMsg(CDVDMsg::PLAYER_CHANNEL_PREV));
+        if (g_guiSettings.GetBool("pvrmenu.infoswitch"))
+        {
+          CGUIDialogFullScreenInfo* pDialog = (CGUIDialogFullScreenInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_FULLSCREEN_INFO);
+          if (pDialog)
+          {
+            if (g_guiSettings.GetBool("pvrmenu.infotimeout"))
+            {
+              pDialog->SetAutoClose(g_guiSettings.GetInt("pvrmenu.infotime")*1000);
+            }
+            pDialog->DoModal();
+          }
+        }
+        g_infoManager.SetDisplayAfterSeek();
+        return true;
+      break;
+
+      case ACTION_CHANNEL_SWITCH:
+      {
+        // Offset from key codes back to button number
+        int channel = action.fAmount1;
+        m_messenger.Put(new CDVDMsgInt(CDVDMsg::PLAYER_CHANNEL, channel));
+        if (g_guiSettings.GetBool("pvrmenu.infoswitch"))
+        {
+          CGUIDialogFullScreenInfo* pDialog = (CGUIDialogFullScreenInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_FULLSCREEN_INFO);
+          if (pDialog)
+          {
+            if (g_guiSettings.GetBool("pvrmenu.infotimeout"))
+            {
+              pDialog->SetAutoClose(g_guiSettings.GetInt("pvrmenu.infotime")*1000);
+            }
+            pDialog->DoModal();
+          }
+        }
+        g_infoManager.SetDisplayAfterSeek();
+        return true;
+      }
+      break;
+
+/*
+      case ACTION_RECORD:
+        m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_RECORD, true));
+        g_infoManager.SetDisplayAfterSeek();
+        return true;
+        break;
+*/
+      default:
+        return false;
+        break;
+    }
+  }
+  else if (dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream))
   {
     switch (action.wID)
     {
@@ -2929,12 +3061,6 @@
   {
     // override from input stream if needed
 
-    if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
-    {
-      m_State.canrecord = static_cast<CDVDInputStreamTV*>(m_pInputStream)->CanRecord();
-      m_State.recording = static_cast<CDVDInputStreamTV*>(m_pInputStream)->IsRecording();
-    }
-
     if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
     {
       if(m_dvd.state == DVDSTATE_STILL) 
@@ -2948,9 +3074,22 @@
         m_State.time_total = ((CDVDInputStreamNavigator*)m_pInputStream)->GetTotalTime();
       }
     }
+    else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+    {
+      m_State.canrecord = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream)->CanRecord();
+      m_State.recording = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream)->IsRecording();
 
+      if(((CDVDInputStreamPVRManager*)m_pInputStream)->GetTotalTime() > 0)
+      {
+        m_State.time      -= ((CDVDInputStreamPVRManager*)m_pInputStream)->GetStartTime();
+        m_State.time_total = ((CDVDInputStreamPVRManager*)m_pInputStream)->GetTotalTime();
+      }
+    }
     else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
     {
+      m_State.canrecord = static_cast<CDVDInputStreamTV*>(m_pInputStream)->CanRecord();
+      m_State.recording = static_cast<CDVDInputStreamTV*>(m_pInputStream)->IsRecording();
+
       if(((CDVDInputStreamTV*)m_pInputStream)->GetTotalTime() > 0)
       {
         m_State.time      -= ((CDVDInputStreamTV*)m_pInputStream)->GetStartTime();
@@ -2992,6 +3131,21 @@
   && m_UpdateApplication + DVD_MSEC_TO_TIME(timeout) > CDVDClock::GetAbsoluteClock())
     return;
 
+  if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+  {
+    CDVDInputStreamPVRManager* pStream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+
+    CFileItem item(g_application.CurrentFileItem());
+    if(pStream->UpdateItem(item))
+    {
+      g_application.CurrentFileItem() = item;
+      g_infoManager.SetCurrentItem(item);
+      /* Correct aspect ratio for next programm */
+      m_dvdPlayerVideo.SendMessage(new CDVDMsgDouble(CDVDMsg::VIDEO_SET_ASPECT, NULL));
+    }
+  }
+  else
+  {
   CDVDInputStream::IChannel* pStream = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
   if(pStream)
   {
@@ -3002,6 +3156,7 @@
       g_infoManager.SetCurrentItem(item);
     }
   }
+  }
   m_UpdateApplication = CDVDClock::GetAbsoluteClock();
 }
 
@@ -3019,7 +3174,8 @@
 
 bool CDVDPlayer::Record(bool bOnOff)
 {
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+  if (m_pInputStream && (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV) ||
+                         m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)) )
   {
     m_messenger.Put(new CDVDMsgBool(CDVDMsg::PLAYER_SET_RECORD, bOnOff));
     return true;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/DateTime.cpp XBMC/xbmc/DateTime.cpp
--- XBMC-unpatched/xbmc/DateTime.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/DateTime.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -776,10 +776,16 @@
 
 void CDateTime::GetAsTime(time_t& time) const
 {
+#ifdef _WIN32
+  LONGLONG ll;    
+  ll = ((LONGLONG)m_time.dwHighDateTime << 32) + m_time.dwLowDateTime;    
+  time=(time_t)((ll - 116444736000000000) / 10000000);
+#else
   ULARGE_INTEGER filetime;
   ToULargeInt(filetime);
 
   time=(time_t)(filetime.QuadPart-0x19DB1DED53E8000LL)/10000000UL;
+#endif
 }
 
 void CDateTime::GetAsTm(tm& time) const
@@ -820,11 +826,27 @@
   GetAsSystemTime(st);
 
   CStdString date;
-  date.Format("%04i-%02i-%02i %02i:%02i:%02i", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMilliseconds, st.wSecond);
+  date.Format("%04i-%02i-%02i %02i:%02i:%02i", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
+
 
   return date;
 }
 
+void CDateTime::SetFromDBDateTime(const CStdString &dateTime)
+{
+  // assumes format:
+  // YYYY-MM-DD HH:MM:SS
+  int year = 0, month = 0, day = 0,
+      hour = 0, minute = 0, second = 0;
+  year = atoi(dateTime.Mid(0,4).c_str());
+  month = atoi(dateTime.Mid(5,2).c_str());
+  day = atoi(dateTime.Mid(8,2).c_str());
+  hour = atoi(dateTime.Mid(11,2).c_str());
+  minute = atoi(dateTime.Mid(14,2).c_str());
+  second = atoi(dateTime.Mid(17,2).c_str());
+  SetDateTime(year, month, day, hour, minute, second);
+}
+
 void CDateTime::SetFromDBDate(const CStdString &date)
 {
   // assumes format:
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/DateTime.h XBMC/xbmc/DateTime.h
--- XBMC-unpatched/xbmc/DateTime.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/DateTime.h	2009-04-04 20:52:44.000000000 +0200
@@ -147,6 +147,7 @@
   void SetDate(int year, int month, int day);
   void SetTime(int hour, int minute, int second);
   void SetFromDBDate(const CStdString &date);
+  void SetFromDBDateTime(const CStdString &dateTime);
 
   void GetAsSystemTime(SYSTEMTIME& time) const;
   void GetAsTime(time_t& time) const;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileItem.cpp XBMC/xbmc/FileItem.cpp
--- XBMC-unpatched/xbmc/FileItem.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/FileItem.cpp	2009-04-14 15:39:32.000000000 +0200
@@ -42,6 +42,10 @@
 #include "SortFileItem.h"
 #include "utils/TuxBoxUtil.h"
 #include "VideoInfoTag.h"
+#include "utils/TVEPGInfoTag.h"
+#include "utils/TVChannelInfoTag.h"
+#include "utils/TVRecordInfoTag.h"
+#include "utils/TVTimerInfoTag.h"
 #include "utils/SingleLock.h"
 #include "MusicInfoTag.h"
 #include "PictureInfoTag.h"
@@ -61,6 +65,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(song.strTitle);
@@ -75,6 +83,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(album.strAlbum);
@@ -102,6 +114,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(movie.m_strTitle);
@@ -122,10 +138,96 @@
   SetInvalid();
 }
 
+CFileItem::CFileItem(const CTVEPGInfoTag& programme)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+  Reset();
+  m_strPath = programme.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetTVEPGInfoTag() = programme;
+  SetLabel(programme.m_strTitle);
+  m_strLabel2 = programme.m_strExtra;
+  SetThumbnailImage(programme.m_IconPath);
+  //FillInDefaultIcon();
+  //SetVideoThumb();
+  SetInvalid();
+}
+
+CFileItem::CFileItem(const CTVChannelInfoTag& channel)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+  Reset();
+  m_strPath = channel.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetTVChannelInfoTag() = channel;
+  SetLabel(channel.m_strChannel);
+  m_strLabel2 = channel.m_strTitle;
+  SetThumbnailImage(channel.m_IconPath);
+  //FillInDefaultIcon();
+  //SetVideoThumb();
+  SetInvalid();
+}
+
+CFileItem::CFileItem(const CTVRecordingInfoTag& record)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_tvepgInfoTag   = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+  Reset();
+  m_strPath = record.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetTVRecordingInfoTag() = record;
+  SetLabel(record.m_strTitle);
+  m_strLabel2 = record.m_Summary;
+  //FillInDefaultIcon();
+  //SetVideoThumb();
+  SetInvalid();
+}
+
+CFileItem::CFileItem(const CTVTimerInfoTag& timer)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+  Reset();
+  m_strPath = timer.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetTVTimerInfoTag() = timer;
+  SetLabel(timer.m_strTitle);
+  m_strLabel2 = timer.m_Summary;
+  //FillInDefaultIcon();
+  //SetVideoThumb();
+  SetInvalid();
+}
+
 CFileItem::CFileItem(const CArtist& artist)
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(artist.strArtist);
@@ -139,6 +241,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(genre.strGenre);
@@ -152,6 +258,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   *this = item;
 }
@@ -160,6 +270,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   // not particularly pretty, but it gets around the issue of Reset() defaulting
@@ -171,6 +285,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
 }
@@ -180,6 +298,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   SetLabel(strLabel);
@@ -189,6 +311,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   m_strPath = strPath;
@@ -207,6 +333,10 @@
 {
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
   Reset();
   m_bIsFolder = true;
@@ -230,10 +360,18 @@
 {
   delete m_musicInfoTag;
   delete m_videoInfoTag;
+  delete m_tvepgInfoTag;
+  delete m_tvchannelInfoTag;
+  delete m_tvrecordingInfoTag;
+  delete m_tvtimerInfoTag;
   delete m_pictureInfoTag;
 
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
+  m_tvepgInfoTag = NULL;
+  m_tvchannelInfoTag = NULL;
+  m_tvrecordingInfoTag = NULL;
+  m_tvtimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
 }
 
@@ -273,6 +411,62 @@
     m_videoInfoTag = NULL;
   }
 
+  if (item.HasTVEPGInfoTag())
+  {
+    m_tvepgInfoTag = GetTVEPGInfoTag();
+    if (m_tvepgInfoTag)
+      *m_tvepgInfoTag = *item.m_tvepgInfoTag;
+  }
+  else
+  {
+    if (m_tvepgInfoTag)
+      delete m_tvepgInfoTag;
+
+    m_tvepgInfoTag = NULL;
+  }
+
+  if (item.HasTVChannelInfoTag())
+  {
+    m_tvchannelInfoTag = GetTVChannelInfoTag();
+    if (m_tvchannelInfoTag)
+      *m_tvchannelInfoTag = *item.m_tvchannelInfoTag;
+  }
+  else
+  {
+    if (m_tvchannelInfoTag)
+      delete m_tvchannelInfoTag;
+
+    m_tvchannelInfoTag = NULL;
+  }
+
+  if (item.HasTVRecordingInfoTag())
+  {
+    m_tvrecordingInfoTag = GetTVRecordingInfoTag();
+    if (m_tvrecordingInfoTag)
+      *m_tvrecordingInfoTag = *item.m_tvrecordingInfoTag;
+  }
+  else
+  {
+    if (m_tvrecordingInfoTag)
+      delete m_tvrecordingInfoTag;
+
+    m_tvrecordingInfoTag = NULL;
+  }
+
+  if (item.HasTVTimerInfoTag())
+  {
+    m_tvtimerInfoTag = GetTVTimerInfoTag();
+    if (m_tvtimerInfoTag)
+      *m_tvtimerInfoTag = *item.m_tvtimerInfoTag;
+  }
+  else
+  {
+    if (m_tvtimerInfoTag)
+      delete m_tvtimerInfoTag;
+
+    m_tvtimerInfoTag = NULL;
+  }
+
   if (item.HasPictureInfoTag())
   {
     m_pictureInfoTag = GetPictureInfoTag();
@@ -332,6 +526,14 @@
   m_musicInfoTag=NULL;
   delete m_videoInfoTag;
   m_videoInfoTag=NULL;
+  delete m_tvepgInfoTag;
+  m_tvepgInfoTag=NULL;
+  delete m_tvchannelInfoTag;
+  m_tvchannelInfoTag=NULL;
+  delete m_tvrecordingInfoTag;
+  m_tvrecordingInfoTag=NULL;
+  delete m_tvtimerInfoTag;
+  m_tvtimerInfoTag=NULL;
   delete m_pictureInfoTag;
   m_pictureInfoTag=NULL;
   m_extrainfo.Empty();
@@ -486,6 +688,30 @@
   return false;
 }
 
+bool CFileItem::IsTVEPG() const
+{
+  if (HasTVEPGInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsTVChannel() const
+{
+  if (HasTVChannelInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsTVRecording() const
+{
+  if (HasTVRecordingInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsTVTimer() const
+{
+  if (HasTVTimerInfoTag()) return true; /// is this enough?
+  return false;
+}
+
 bool CFileItem::IsAudio() const
 {
   if (IsCDDA()) return true;
@@ -1001,6 +1227,12 @@
   CGUIListItem::SetLabel(strLabel);
 }
 
+void CFileItem::SetLabel2(const CStdString &strLabel)
+{
+  m_strLabel2 = strLabel;
+}
+
+
 void CFileItem::SetFileSizeLabel()
 {
   if( m_bIsFolder && m_dwSize == 0 )
@@ -2149,6 +2381,8 @@
     return CMusicDatabaseDirectory::CanCache(m_strPath);
   if (IsVideoDb())
     return CVideoDatabaseDirectory::CanCache(m_strPath);
+//  if (IsTVEPG())
+//    return true; // always cache
   return false;
 }
 
@@ -2868,6 +3102,38 @@
   return m_videoInfoTag;
 }
 
+CTVEPGInfoTag* CFileItem::GetTVEPGInfoTag()
+{
+  if (!m_tvepgInfoTag)
+    m_tvepgInfoTag = new CTVEPGInfoTag;
+
+  return m_tvepgInfoTag;
+}
+
+CTVChannelInfoTag* CFileItem::GetTVChannelInfoTag()
+{
+  if (!m_tvchannelInfoTag)
+    m_tvchannelInfoTag = new CTVChannelInfoTag;
+
+  return m_tvchannelInfoTag;
+}
+
+CTVRecordingInfoTag* CFileItem::GetTVRecordingInfoTag()
+{
+  if (!m_tvrecordingInfoTag)
+    m_tvrecordingInfoTag = new CTVRecordingInfoTag;
+
+  return m_tvrecordingInfoTag;
+}
+
+CTVTimerInfoTag* CFileItem::GetTVTimerInfoTag()
+{
+  if (!m_tvtimerInfoTag)
+    m_tvtimerInfoTag = new CTVTimerInfoTag;
+
+  return m_tvtimerInfoTag;
+}
+
 CPictureInfoTag* CFileItem::GetPictureInfoTag()
 {
   if (!m_pictureInfoTag)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileItem.h XBMC/xbmc/FileItem.h
--- XBMC-unpatched/xbmc/FileItem.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/FileItem.h	2009-04-14 15:39:32.000000000 +0200
@@ -41,6 +41,10 @@
   class CMusicInfoTag;
 }
 class CVideoInfoTag;
+class CTVEPGInfoTag;
+class CTVChannelInfoTag;
+class CTVRecordingInfoTag;
+class CTVTimerInfoTag;
 class CPictureInfoTag;
 
 class CAlbum;
@@ -73,6 +77,10 @@
   CFileItem(const CArtist& artist);
   CFileItem(const CGenre& genre);
   CFileItem(const CVideoInfoTag& movie);
+  CFileItem(const CTVEPGInfoTag& programme);
+  CFileItem(const CTVChannelInfoTag& channel);
+  CFileItem(const CTVRecordingInfoTag& record);
+  CFileItem(const CTVTimerInfoTag& timer);
   CFileItem(const CMediaSource& share);
   virtual ~CFileItem(void);
 
@@ -118,6 +126,10 @@
   bool IsMultiPath() const;
   bool IsMusicDb() const;
   bool IsVideoDb() const;
+  bool IsTVEPG() const;
+  bool IsTVChannel() const;
+  bool IsTVRecording() const;
+  bool IsTVTimer() const;
   bool IsType(const char *ext) const;
   bool IsVirtualDirectoryRoot() const;
   bool IsReadOnly() const;
@@ -138,6 +150,7 @@
   void SetMusicThumb(bool alwaysCheckRemote = false);
   void SetFileSizeLabel();
   virtual void SetLabel(const CStdString &strLabel);
+  virtual void SetLabel2(const CStdString &strLabel);
   CURL GetAsUrl() const;
   bool IsLabelPreformated() const { return m_bLabelPreformated; }
   void SetLabelPreformated(bool bYesNo) { m_bLabelPreformated=bYesNo; }
@@ -166,6 +179,54 @@
     return m_videoInfoTag;
   }
 
+  bool HasTVEPGInfoTag() const
+  {
+    return m_tvepgInfoTag != NULL;
+  }
+
+  CTVEPGInfoTag* GetTVEPGInfoTag();
+
+  inline const CTVEPGInfoTag* GetTVEPGInfoTag() const
+  {
+    return m_tvepgInfoTag;
+  }
+
+  bool HasTVChannelInfoTag() const
+  {
+    return m_tvchannelInfoTag != NULL;
+  }
+
+  CTVChannelInfoTag* GetTVChannelInfoTag();
+
+  inline const CTVChannelInfoTag* GetTVChannelInfoTag() const
+  {
+    return m_tvchannelInfoTag;
+  }
+
+  bool HasTVRecordingInfoTag() const
+  {
+    return m_tvrecordingInfoTag != NULL;
+  }
+
+  CTVRecordingInfoTag* GetTVRecordingInfoTag();
+
+  inline const CTVRecordingInfoTag* GetTVRecordingInfoTag() const
+  {
+    return m_tvrecordingInfoTag;
+  }
+
+  bool HasTVTimerInfoTag() const
+  {
+    return m_tvtimerInfoTag != NULL;
+  }
+
+  CTVTimerInfoTag* GetTVTimerInfoTag();
+
+  inline const CTVTimerInfoTag* GetTVTimerInfoTag() const
+  {
+    return m_tvtimerInfoTag;
+  }
+
   bool HasPictureInfoTag() const
   {
     return m_pictureInfoTag != NULL;
@@ -263,6 +324,10 @@
   CStdString m_extrainfo;
   MUSIC_INFO::CMusicInfoTag* m_musicInfoTag;
   CVideoInfoTag* m_videoInfoTag;
+  CTVEPGInfoTag* m_tvepgInfoTag;
+  CTVChannelInfoTag* m_tvchannelInfoTag;
+  CTVRecordingInfoTag* m_tvrecordingInfoTag;
+  CTVTimerInfoTag * m_tvtimerInfoTag;
   CPictureInfoTag* m_pictureInfoTag;
 };
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/CMythDirectory.h XBMC/xbmc/FileSystem/CMythDirectory.h
--- XBMC-unpatched/xbmc/FileSystem/CMythDirectory.h	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/CMythDirectory.h	2009-04-04 20:52:44.000000000 +0200
@@ -58,6 +58,7 @@
   bool GetChannelsDb(const CStdString& base, CFileItemList &items);
 
   CStdString GetValue(char* str)           { return m_session->GetValue(str); }
+  int        GetValue(int integer)         { return m_session->GetValue(integer); }
   CDateTime  GetValue(cmyth_timestamp_t t);
 
   XFILE::CCMythSession* m_session;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/CMythSession.cpp XBMC/xbmc/FileSystem/CMythSession.cpp
--- XBMC-unpatched/xbmc/FileSystem/CMythSession.cpp	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/CMythSession.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -116,6 +116,16 @@
   return result;
 }
 
+int CCMythSession::GetValue(int integer)
+{
+  int result;
+  if(integer)
+  {
+    result = integer;
+  }
+  return result;
+}
+
 bool CCMythSession::UpdateItem(CFileItem &item, cmyth_proginfo_t info)
 {
   if(!info)
@@ -218,6 +228,7 @@
 {
   Disconnect();
   delete m_dll;
+  CLog::Log(LOGDEBUG, "CCMythSession destroyed");
 }
 
 bool CCMythSession::CanSupport(const CURL& url)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/CMythSession.h XBMC/xbmc/FileSystem/CMythSession.h
--- XBMC-unpatched/xbmc/FileSystem/CMythSession.h	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/CMythSession.h	2009-04-04 20:52:44.000000000 +0200
@@ -62,6 +62,7 @@
 
   CDateTime        GetValue(cmyth_timestamp_t t);
   CStdString       GetValue(char* str);
+  int              GetValue(int integer);
 private:
   CCMythSession(const CURL& url);
   ~CCMythSession();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/DllLibCMyth.h XBMC/xbmc/FileSystem/DllLibCMyth.h
--- XBMC-unpatched/xbmc/FileSystem/DllLibCMyth.h	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/DllLibCMyth.h	2009-04-04 20:52:44.000000000 +0200
@@ -38,11 +38,17 @@
   virtual cmyth_recorder_t conn_get_free_recorder   (cmyth_conn_t conn)=0;
   virtual cmyth_recorder_t conn_get_recorder_from_num(cmyth_conn_t conn, int num)=0;
 
+  virtual int              conn_get_freespace       (cmyth_conn_t control,long long *total, long long *used)=0;
+  virtual int              conn_hung                (cmyth_conn_t control)=0;
 
   virtual cmyth_event_t    event_get                (cmyth_conn_t conn, char * data, int len)=0;
   virtual int              event_select             (cmyth_conn_t conn, struct timeval *timeout)=0;
 
   virtual cmyth_proglist_t proglist_get_all_recorded(cmyth_conn_t control)=0;
+  virtual cmyth_proglist_t proglist_get_all_scheduled(cmyth_conn_t control)=0;
+  virtual cmyth_proglist_t proglist_get_all_pending  (cmyth_conn_t control)=0;
+  virtual cmyth_proglist_t proglist_get_conflicting  (cmyth_conn_t control)=0;
+
   virtual int              mysql_get_guide(cmyth_database_t db, cmyth_program_t **prog, time_t starttime, time_t endtime) = 0;
   virtual cmyth_proginfo_t proglist_get_item        (cmyth_proglist_t pl, int index)=0;
   virtual int              proglist_get_count       (cmyth_proglist_t pl)=0;
@@ -101,7 +107,9 @@
   virtual cmyth_timestamp_t proginfo_end            (cmyth_proginfo_t prog)=0;
   virtual cmyth_timestamp_t proginfo_rec_start      (cmyth_proginfo_t prog)=0;
   virtual cmyth_timestamp_t proginfo_rec_end        (cmyth_proginfo_t prog)=0;
+  virtual cmyth_timestamp_t proginfo_originalairdate(cmyth_proginfo_t prog)=0;
   virtual cmyth_proginfo_rec_status_t proginfo_rec_status(cmyth_proginfo_t prog)=0;
+  virtual long              proginfo_card_id        (cmyth_proginfo_t prog)=0;
   virtual cmyth_proginfo_t  proginfo_get_from_basename   (cmyth_conn_t control, const char* basename)=0;
   virtual int               proginfo_delete_recording(cmyth_conn_t control, cmyth_proginfo_t prog)=0;
   virtual int               proginfo_stop_recording(cmyth_conn_t control, cmyth_proginfo_t prog)=0;
@@ -130,11 +138,17 @@
 
   DEFINE_METHOD1(cmyth_recorder_t,    conn_get_free_recorder,   (cmyth_conn_t p1))
   DEFINE_METHOD2(cmyth_recorder_t,    conn_get_recorder_from_num,(cmyth_conn_t p1, int p2))
+  DEFINE_METHOD3(int,                 conn_get_freespace,       (cmyth_conn_t p1, long long *p2, long long *p3))
+  DEFINE_METHOD1(int,                 conn_hung,                (cmyth_conn_t p1))
 
   DEFINE_METHOD3(cmyth_event_t,       event_get,                (cmyth_conn_t p1, char * p2, int p3))
   DEFINE_METHOD2(int,                 event_select,             (cmyth_conn_t p1, struct timeval *p2))
 
   DEFINE_METHOD1(cmyth_proglist_t,    proglist_get_all_recorded, (cmyth_conn_t p1))
+  DEFINE_METHOD1(cmyth_proglist_t,    proglist_get_all_scheduled, (cmyth_conn_t p1))
+  DEFINE_METHOD1(cmyth_proglist_t,    proglist_get_all_pending, (cmyth_conn_t p1))
+  DEFINE_METHOD1(cmyth_proglist_t,    proglist_get_conflicting, (cmyth_conn_t p1))
+
   DEFINE_METHOD4(int,                 mysql_get_guide,          (cmyth_database_t p1, cmyth_program_t **p2, time_t p3, time_t p4))
   DEFINE_METHOD2(cmyth_proginfo_t,    proglist_get_item,        (cmyth_proglist_t p1, int p2))
   DEFINE_METHOD1(int,                 proglist_get_count,       (cmyth_proglist_t p1))
@@ -191,7 +205,9 @@
   DEFINE_METHOD1(cmyth_timestamp_t,   proginfo_end,             (cmyth_proginfo_t p1))
   DEFINE_METHOD1(cmyth_timestamp_t,   proginfo_rec_start,       (cmyth_proginfo_t p1))
   DEFINE_METHOD1(cmyth_timestamp_t,   proginfo_rec_end,         (cmyth_proginfo_t p1))
+  DEFINE_METHOD1(cmyth_timestamp_t,   proginfo_originalairdate, (cmyth_proginfo_t p1))
   DEFINE_METHOD1(cmyth_proginfo_rec_status_t, proginfo_rec_status, (cmyth_proginfo_t p1))
+  DEFINE_METHOD1(long,                proginfo_card_id,         (cmyth_proginfo_t p1))
   DEFINE_METHOD2(cmyth_proginfo_t,    proginfo_get_from_basename,    (cmyth_conn_t p1, const char* p2))
   DEFINE_METHOD2(int,                 proginfo_delete_recording, (cmyth_conn_t p1, cmyth_proginfo_t p2))
   DEFINE_METHOD2(int,                 proginfo_stop_recording,  (cmyth_conn_t p1, cmyth_proginfo_t p2))
@@ -215,10 +231,15 @@
     RESOLVE_METHOD_RENAME(cmyth_conn_connect_path, conn_connect_path)
     RESOLVE_METHOD_RENAME(cmyth_conn_get_free_recorder, conn_get_free_recorder)
     RESOLVE_METHOD_RENAME(cmyth_conn_get_recorder_from_num, conn_get_recorder_from_num)
+    RESOLVE_METHOD_RENAME(cmyth_conn_get_freespace, conn_get_freespace)
+    RESOLVE_METHOD_RENAME(cmyth_conn_hung, conn_hung)
 
     RESOLVE_METHOD_RENAME(cmyth_event_get, event_get)
     RESOLVE_METHOD_RENAME(cmyth_event_select, event_select)
     RESOLVE_METHOD_RENAME(cmyth_proglist_get_all_recorded, proglist_get_all_recorded)
+    RESOLVE_METHOD_RENAME(cmyth_proglist_get_all_scheduled, proglist_get_all_scheduled)
+    RESOLVE_METHOD_RENAME(cmyth_proglist_get_all_pending, proglist_get_all_pending)
+    RESOLVE_METHOD_RENAME(cmyth_proglist_get_conflicting, proglist_get_conflicting)
     RESOLVE_METHOD_RENAME(cmyth_mysql_get_guide, mysql_get_guide)
     RESOLVE_METHOD_RENAME(cmyth_proglist_get_item, proglist_get_item)
     RESOLVE_METHOD_RENAME(cmyth_proglist_get_count, proglist_get_count)
@@ -276,6 +297,8 @@
     RESOLVE_METHOD_RENAME(cmyth_proginfo_rec_start, proginfo_rec_start)
     RESOLVE_METHOD_RENAME(cmyth_proginfo_rec_end, proginfo_rec_end)
     RESOLVE_METHOD_RENAME(cmyth_proginfo_rec_status, proginfo_rec_status)
+    RESOLVE_METHOD_RENAME(cmyth_proginfo_card_id, proginfo_card_id)
+    RESOLVE_METHOD_RENAME(cmyth_proginfo_originalairdate, proginfo_originalairdate)
     RESOLVE_METHOD_RENAME(cmyth_proginfo_get_from_basename, proginfo_get_from_basename)
     RESOLVE_METHOD_RENAME(cmyth_proginfo_delete_recording, proginfo_delete_recording)
     RESOLVE_METHOD_RENAME(cmyth_proginfo_stop_recording, proginfo_stop_recording)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/PluginDirectory.cpp XBMC/xbmc/FileSystem/PluginDirectory.cpp
--- XBMC-unpatched/xbmc/FileSystem/PluginDirectory.cpp	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/PluginDirectory.cpp	2009-04-16 16:59:49.000000000 +0200
@@ -23,11 +23,12 @@
 #include "stdafx.h"
 #include "PluginDirectory.h"
 #include "Util.h"
+#include "utils/Addon.h"
 #ifdef HAS_PYTHON
 #include "lib/libPython/XBPython.h"
 #endif
 #include "../utils/SingleLock.h"
-#include "PluginSettings.h"
+#include "settings/AddonSettings.h"
 #include "GUIWindowManager.h"
 #include "GUIDialogProgress.h"
 #include "FileSystem/File.h"
@@ -36,6 +37,7 @@
 
 using namespace DIRECTORY;
 using namespace std;
+using namespace ADDON;
 
 vector<CPluginDirectory *> CPluginDirectory::globalHandles;
 CCriticalSection CPluginDirectory::m_handleLock;
@@ -93,10 +95,10 @@
 
   // Load the plugin settings
   CLog::Log(LOGDEBUG, "%s - URL for plugin settings: %s", __FUNCTION__, url.GetFileName().c_str() );
-  g_currentPluginSettings.Load(url);
+  g_currentAddonSettings.Load(url);
 
   // Load language strings
-  LoadPluginStrings(url);
+  ADDON::CAddon::LoadAddonStrings(url);
 
   // reset our wait event, and grab a new handle
   ResetEvent(m_fetchComplete);
@@ -199,7 +201,7 @@
   dir->m_listItems->SetReplaceListing(replaceListing);
 
   // Unload temporary language strings
-  ClearPluginStrings();
+  ADDON::CAddon::ClearAddonStrings();
 
   // set the event to mark that we're done
   SetEvent(dir->m_fetchComplete);
@@ -391,10 +393,10 @@
     return false;
 
   // Load the settings incase they changed while in the plugins directory
-  g_currentPluginSettings.Load(url);
+  g_currentAddonSettings.Load(url);
 
   // Load language strings
-  LoadPluginStrings(url);
+  ADDON::CAddon::LoadAddonStrings(url);
 
   // path is special://home/plugins/<path from here>
   CStdString pathToScript = "special://home/plugins/";
@@ -618,33 +620,5 @@
   dir->m_listItems->SetProperty(strProperty, strValue);
 }
 
-void CPluginDirectory::LoadPluginStrings(const CURL &url)
-{
-  // Path where the plugin resides
-  CStdString pathToPlugin = "special://home/plugins/";
-  CUtil::AddFileToFolder(pathToPlugin, url.GetHostName(), pathToPlugin);
-  CUtil::AddFileToFolder(pathToPlugin, url.GetFileName(), pathToPlugin);
-
-  // Path where the language strings reside
-  CStdString pathToLanguageFile = pathToPlugin;
-  CStdString pathToFallbackLanguageFile = pathToPlugin;
-  CUtil::AddFileToFolder(pathToLanguageFile, "resources", pathToLanguageFile);
-  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "resources", pathToFallbackLanguageFile);
-  CUtil::AddFileToFolder(pathToLanguageFile, "language", pathToLanguageFile);
-  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "language", pathToFallbackLanguageFile);
-  CUtil::AddFileToFolder(pathToLanguageFile, g_guiSettings.GetString("locale.language"), pathToLanguageFile);
-  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "english", pathToFallbackLanguageFile);
-  CUtil::AddFileToFolder(pathToLanguageFile, "strings.xml", pathToLanguageFile);
-  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "strings.xml", pathToFallbackLanguageFile);
-
-  // Load language strings temporarily
-  g_localizeStringsTemp.Load(pathToLanguageFile, pathToFallbackLanguageFile);
-}
-
-void CPluginDirectory::ClearPluginStrings()
-{
-  // Unload temporary language strings
-  g_localizeStringsTemp.Clear();
-}
 
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/FileSystem/PluginDirectory.h XBMC/xbmc/FileSystem/PluginDirectory.h
--- XBMC-unpatched/xbmc/FileSystem/PluginDirectory.h	2009-04-22 19:11:17.000000000 +0200
+++ XBMC/xbmc/FileSystem/PluginDirectory.h	2009-04-06 00:56:10.000000000 +0200
@@ -45,8 +45,6 @@
   static bool RunScriptWithParams(const CStdString& strPath);
   static bool HasPlugins(const CStdString &type);
   bool GetPluginsDirectory(const CStdString &type, CFileItemList &items);
-  static void LoadPluginStrings(const CURL &url);
-  static void ClearPluginStrings();
   bool StartScript(const CStdString& strPath);
   static bool GetPluginResult(const CStdString& strPath, CFileItem &resultItem);
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogAddonBrowser.cpp XBMC/xbmc/GUIDialogAddonBrowser.cpp
--- XBMC-unpatched/xbmc/GUIDialogAddonBrowser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogAddonBrowser.cpp	2009-04-06 02:23:29.000000000 +0200
@@ -0,0 +1,419 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "stdafx.h"
+#include "utils/Addon.h"
+#include "GUIDialogAddonBrowser.h"
+#include "GUISpinControlEx.h"
+#include "GUIDialogContextMenu.h"
+#include "GUIDialogAddonSettings.h"
+#include "GUIDialogYesNo.h"
+#include "GUIDialogNumeric.h"
+#include "GUIDialogKeyboard.h"
+#include "GUIWindowManager.h"
+#include "GUIEditControl.h"
+#include "Util.h"
+#include "URL.h"
+#include "FileItem.h"
+
+#define CONTROL_LIST            450
+#define CONTROL_HEADING_LABEL   411
+#define CONTROL_LABEL_PATH      412
+#define CONTROL_OK              413
+#define CONTROL_REMOVE_ADDONS   414
+#define CONTROL_ADDONS          415
+#define CONTROL_CONFIG_ADDONS   416
+
+using namespace ADDON;
+
+CGUIDialogAddonBrowser::CGUIDialogAddonBrowser(void)
+: CGUIDialog(WINDOW_DIALOG_ADDON_BROWSER, "DialogAddonBrowser.xml")
+{
+  m_vecItems = new CFileItemList;
+  m_confirmed = false;
+  m_changed = false;
+  m_loadOnDemand = true;
+}
+
+CGUIDialogAddonBrowser::~CGUIDialogAddonBrowser()
+{
+}
+
+bool CGUIDialogAddonBrowser::OnAction(const CAction &action)
+{
+  if (action.wID == ACTION_CONTEXT_MENU || action.wID == ACTION_MOUSE_RIGHT_CLICK)
+  {
+    int iItem = m_viewControl.GetSelectedItem();
+    return OnContextMenu(iItem);
+  }
+  return CGUIDialog::OnAction(action);
+}
+
+bool CGUIDialogAddonBrowser::OnMessage(CGUIMessage& message)
+{
+  switch ( message.GetMessage() )
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+    {
+      CGUIDialog::OnMessage(message);
+      ClearFileItems();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_WINDOW_INIT:
+    {
+      Update();
+      return CGUIDialog::OnMessage(message);
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      if (m_viewControl.HasControl(message.GetSenderId()))  // list control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        int iAction = message.GetParam1();
+        if (iItem < 0) break;
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          OnClick(iItem);
+          return true;
+        }
+        if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+        {
+          OnContextMenu(iItem);
+          return true;
+        }
+      }
+      else if (message.GetSenderId() == CONTROL_REMOVE_ADDONS)
+      {
+        if (m_vecItems->Size() > 0)
+        {
+          int iItem = m_viewControl.GetSelectedItem();
+          CFileItemPtr pItem = m_vecItems->Get(iItem);
+          CGUIDialogYesNo* pDialog = new CGUIDialogYesNo();
+          if (pDialog->ShowAndGetInput(g_localizeStrings.Get(33009), pItem->GetProperty("Addon.Name"), "", g_localizeStrings.Get(33010)))
+          {
+            g_settings.DisableAddon(pItem->GetProperty("Addon.GUID"), m_type);
+            m_changed = true;
+            Update();
+          }
+        }
+        return true;
+      }
+      else if (message.GetSenderId() == CONTROL_CONFIG_ADDONS)
+      {
+        if (m_vecItems->Size() > 0)
+        {
+          int iItem = m_viewControl.GetSelectedItem();
+          CFileItemPtr pItem = m_vecItems->Get(iItem);
+          CURL url(pItem->m_strPath);
+          CGUIDialogAddonSettings::ShowAndGetInput(url);
+        }
+        return true;
+      }
+      else if (message.GetSenderId() == CONTROL_ADDONS)
+      {
+        OnGetAddons(m_type);
+        return true;
+      }
+      else if (message.GetSenderId() == CONTROL_OK)
+      {
+        m_confirmed = true;
+        Close();
+        return true;
+      }
+    }
+    break;
+
+  case GUI_MSG_SETFOCUS:
+    {
+      if (m_viewControl.HasControl(message.GetControlId()) && (DWORD) m_viewControl.GetCurrentControl() != message.GetControlId())
+      {
+        m_viewControl.SetFocused();
+        return true;
+      }
+    }
+    break;
+  }
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogAddonBrowser::ClearFileItems()
+{
+  m_viewControl.Clear();
+  m_vecItems->Clear(); // will clean up everything
+}
+
+void CGUIDialogAddonBrowser::OnSort()
+{
+  m_vecItems->Sort(SORT_METHOD_LABEL, SORT_ORDER_ASC);
+}
+
+void CGUIDialogAddonBrowser::Update()
+{
+  m_vecItems->Clear();
+
+  VECADDONS *addons;
+  if (m_getAddons)
+  {
+    addons = &g_settings.m_allAddons;
+  }
+  else
+  {
+    addons = g_settings.GetAddonsFromType(m_type);
+    if (addons == NULL)
+      return;
+  }
+
+  for (unsigned i=0; i < addons->size(); i++)
+  {
+    CAddon addon = addons->at(i);
+
+    if (m_getAddons)
+    { // don't show addons that are enabled
+      //TODO add-on manager should do all this
+      bool skip(false);
+      VECADDONS *addons = g_settings.GetAddonsFromType(m_type);
+      for (unsigned i = 0; i < addons->size(); i++)
+      {
+        CAddon found = addons->at(i);
+        if (found.m_guid == addon.m_guid)
+          skip = true;
+      }
+      if (skip)
+        break;
+    }
+
+    CFileItemPtr pItem(new CFileItem(addon.m_strPath, false));
+    pItem->SetProperty("Addon.GUID", addon.m_guid);
+    pItem->SetProperty("Addon.Name", addon.m_strName);
+    pItem->SetProperty("Addon.Summary", addon.m_summary);
+    pItem->SetProperty("Addon.Description", addon.m_strDesc);
+    pItem->SetProperty("Addon.Creator", addon.m_strCreator);
+    pItem->SetProperty("Addon.Disclaimer", addon.m_disclaimer);
+    pItem->SetProperty("Addon.Rating", addon.m_stars);
+    pItem->SetThumbnailImage(addon.m_icon);
+    m_vecItems->Add(pItem);
+  }
+  m_vecItems->FillInDefaultIcons();
+  OnSort();
+
+  m_viewControl.SetItems(*m_vecItems);
+  m_viewControl.SetCurrentView(DEFAULT_VIEW_LIST);
+  m_viewControl.SetSelectedItem(0);
+}
+
+void CGUIDialogAddonBrowser::Render()
+{
+  CONTROL_ENABLE_ON_CONDITION(CONTROL_ADDONS, !m_getAddons);
+  CONTROL_ENABLE_ON_CONDITION(CONTROL_CONFIG_ADDONS, !m_getAddons && m_vecItems->Size() != 0);
+  CONTROL_ENABLE_ON_CONDITION(CONTROL_REMOVE_ADDONS, !m_getAddons && m_vecItems->Size() != 0);
+  //CONTROL_ENABLE_ON_CONDITION(CONTROL_OK, m_changed && !m_getAddons);
+
+  CGUIDialog::Render();
+}
+
+void CGUIDialogAddonBrowser::OnClick(int iItem)
+{
+  if ( iItem < 0 || iItem >= (int)m_vecItems->Size() ) return ;
+  CFileItemPtr pItem = (*m_vecItems)[iItem];
+  CStdString strPath = pItem->m_strPath;
+
+  if (m_getAddons)
+  {
+    /* need to determine which addon from allAddons this and add to AddonType specific vector */
+    VECADDONS *addons = g_settings.GetAddonsFromType(m_type);
+    CAddon addon;
+    if (g_settings.GetAddonFromGUID(pItem->GetProperty("Addon.GUID"), addon))
+    {
+      // add the addon to g_settings, not saving to addons.xml until parent dialog is confirmed
+      addons->push_back(addon);
+      m_confirmed = true;
+      Close(false);
+    }
+    else
+    {
+      // shouldn't happen as we just retrieved this guid from g_settings
+      CLog::Log(LOGERROR, "Addons: Can't determine Addon by GUID");
+    }
+  }
+  else
+  {
+    /* open up settings dialog */
+
+  }
+}
+
+void CGUIDialogAddonBrowser::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST));
+  // set the page spin controls to hidden
+#ifdef PRE_SKIN_VERSION_2_1_COMPATIBILITY
+  CGUIControl *spin = (CGUIControl *)GetControl(CONTROL_LIST + 5000);
+  if (spin) spin->SetVisible(false);
+#endif
+}
+
+void CGUIDialogAddonBrowser::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+void CGUIDialogAddonBrowser::SetHeading(const CStdString &heading)
+{
+  Initialize();
+  SET_CONTROL_LABEL(CONTROL_HEADING_LABEL, heading);
+}
+
+bool CGUIDialogAddonBrowser::ShowAndGetAddons(const AddonType &type, const bool viewActive)
+{
+  // Create a new addonbrowser window
+  CGUIDialogAddonBrowser *browser = new CGUIDialogAddonBrowser();
+  if (!browser) return false;
+
+  // Add it to our window manager
+  m_gWindowManager.AddUniqueInstance(browser);
+
+  // determine the correct heading
+  CStdString heading;
+  if (!viewActive)
+    heading = g_localizeStrings.Get(33002); // "Available Add-ons"
+  else
+  {
+    // set according to addon type
+    switch (type)
+    {
+    case ADDON_PVRDLL:
+      heading = g_localizeStrings.Get(18028); // "Manage PVR clients"
+      break;
+
+    default:
+      break;
+    }
+  }
+
+  // finalize the window and display
+  browser->SetHeading(heading);
+  browser->SetAddonType(type);
+  browser->SetAddNew(viewActive);
+  browser->DoModal();
+  bool confirmed = browser->IsConfirmed();
+
+  m_gWindowManager.Remove(browser->GetID());
+  delete browser;
+  return confirmed;
+}
+
+void CGUIDialogAddonBrowser::SetAddonType(const AddonType &type)
+{
+  m_type = type;
+}
+
+void CGUIDialogAddonBrowser::OnGetAddons(const AddonType &type)
+{
+  // switch context to available addons
+  // creates a new addonbrowser window
+  CGUIDialogAddonBrowser *browser = new CGUIDialogAddonBrowser();
+  if (!browser) return;
+
+  // Add it to our window manager
+  m_gWindowManager.AddUniqueInstance(browser);
+
+  // request available addons update
+  g_settings.GetAllAddons();
+
+  // present dialog with available addons
+  if (ShowAndGetAddons(type, false))
+  {
+    // need to update the list of installed addons
+    Update();
+    // we made changes
+    m_changed = true;
+  }
+}
+
+bool CGUIDialogAddonBrowser::OnContextMenu(int iItem)
+{
+  // disable context menu for available addons for now
+  if (m_getAddons)
+    return true;
+
+  CGUIDialogContextMenu* pMenu = (CGUIDialogContextMenu*)m_gWindowManager.GetWindow(WINDOW_DIALOG_CONTEXT_MENU);
+  if (!pMenu)
+    return false;
+
+  float posX = 200, posY = 100;
+  const CGUIControl *pList = GetControl(CONTROL_LIST);
+  if (pList)
+  {
+    posX = pList->GetXPosition() + pList->GetWidth() / 2;
+    posY = pList->GetYPosition() + pList->GetHeight() / 2;
+  }
+
+  pMenu->Initialize();
+
+  int iSettingsLabel = 33008;
+  int iRemoveLabel = 33009;
+
+  int btn_Settings = pMenu->AddButton(iSettingsLabel);
+  int btn_Remove = -1;
+  if (m_vecItems->Size() > 0)
+    btn_Remove = pMenu->AddButton(iRemoveLabel);
+
+  pMenu->SetPosition(posX, posY);
+  pMenu->DoModal();
+
+  int btnid = pMenu->GetButton();
+
+  CFileItemPtr pItem = m_vecItems->Get(iItem);
+
+  if (btnid == btn_Settings)
+  { // present addon settings dialog
+    CURL url(pItem->m_strPath);
+    CGUIDialogAddonSettings::ShowAndGetInput(url);
+    return true;
+  }
+  else if (btnid == btn_Remove)
+  { // request confirmation
+    CGUIDialogYesNo* pDialog = new CGUIDialogYesNo();
+    if (pDialog->ShowAndGetInput(g_localizeStrings.Get(33009), pItem->GetProperty("Addon.Name"), "", g_localizeStrings.Get(33010)))
+    {
+      g_settings.DisableAddon(pItem->GetProperty("Addon.GUID"), m_type);
+      m_changed = true;
+      Update();
+    }
+
+    return true;
+  }
+  return false;
+}
+
+CFileItemPtr CGUIDialogAddonBrowser::GetCurrentListItem(int offset)
+{
+  return CFileItemPtr();
+}
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogAddonBrowser.h XBMC/xbmc/GUIDialogAddonBrowser.h
--- XBMC-unpatched/xbmc/GUIDialogAddonBrowser.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogAddonBrowser.h	2009-04-06 01:49:47.000000000 +0200
@@ -0,0 +1,68 @@
+#pragma once
+
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "Addon.h"
+#include "GUIDialog.h"
+#include "GUIViewControl.h"
+
+class CFileItem;
+class CFileItemList;
+
+class CGUIDialogAddonBrowser : public CGUIDialog
+{
+public:
+  CGUIDialogAddonBrowser(void);
+  virtual ~CGUIDialogAddonBrowser(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual bool OnAction(const CAction &action);
+  virtual void Render();
+  virtual void OnWindowLoaded();
+  virtual void OnWindowUnload();
+  bool IsConfirmed() { return m_confirmed; };
+  void SetHeading(const CStdString &heading);
+
+  static bool ShowAndGetAddons(const ADDON::AddonType &type, const bool activeOnly);
+
+  void SetAddonType(const ADDON::AddonType &type);
+
+  virtual bool HasListItems() const { return true; };
+  virtual CFileItemPtr GetCurrentListItem(int offset = 0);
+
+protected:
+  void OnClick(int iItem);
+  void OnSort();
+  void ClearFileItems();
+  void Update();
+  bool OnContextMenu(int iItem);
+  void OnGetAddons(const ADDON::AddonType &type);
+
+  ADDON::AddonType m_type;
+  CFileItemList* m_vecItems;
+
+  bool m_confirmed;
+  bool m_changed;
+  inline void SetAddNew(bool activeOnly) { m_getAddons = !activeOnly; };
+  bool m_getAddons;
+  CGUIViewControl m_viewControl;
+};
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogAddonSettings.cpp XBMC/xbmc/GUIDialogAddonSettings.cpp
--- XBMC-unpatched/xbmc/GUIDialogAddonSettings.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogAddonSettings.cpp	2009-04-06 01:04:14.000000000 +0200
@@ -0,0 +1,678 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "GUIDialogAddonSettings.h"
+#include "utils/Addon.h"
+#include "GUIDialogNumeric.h"
+#include "GUIDialogFileBrowser.h"
+#include "GUIControlGroupList.h"
+#include "Util.h"
+#include "MediaManager.h"
+#include "GUIRadioButtonControl.h"
+#include "GUISpinControlEx.h"
+#include "GUIImage.h"
+#include "FileSystem/Directory.h"
+#include "VideoInfoScanner.h"
+#include "ScraperSettings.h"
+#include "GUIWindowManager.h"
+#include "Application.h"
+#include "GUIDialogKeyboard.h"
+#include "FileItem.h"
+
+using namespace std;
+using namespace DIRECTORY;
+
+#define CONTROL_AREA                    2
+#define CONTROL_DEFAULT_BUTTON          3
+#define CONTROL_DEFAULT_RADIOBUTTON     4
+#define CONTROL_DEFAULT_SPIN            5
+#define CONTROL_DEFAULT_SEPARATOR       6
+#define CONTROL_DEFAULT_LABEL_SEPARATOR 7
+#define ID_BUTTON_OK                    10
+#define ID_BUTTON_CANCEL                11
+#define ID_BUTTON_DEFAULT               12
+#define CONTROL_HEADING_LABEL           20
+#define CONTROL_START_CONTROL           100
+
+using namespace ADDON;
+
+CGUIDialogAddonSettings::CGUIDialogAddonSettings()
+   : CGUIDialogBoxBase(WINDOW_DIALOG_ADDON_SETTINGS, "DialogAddonSettings.xml")
+{}
+
+CGUIDialogAddonSettings::~CGUIDialogAddonSettings(void)
+{}
+
+bool CGUIDialogAddonSettings::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIDialogBoxBase::OnMessage(message);
+      FreeControls();
+      CreateControls();
+      return true;
+    }
+
+    case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+      bool bCloseDialog = false;
+
+      if (iControl == ID_BUTTON_OK)
+        SaveSettings();
+      else if (iControl == ID_BUTTON_DEFAULT)
+        SetDefaults();
+      else
+        bCloseDialog = ShowVirtualKeyboard(iControl);
+
+      if (iControl == ID_BUTTON_OK || iControl == ID_BUTTON_CANCEL || bCloseDialog)
+      {
+        m_bConfirmed = true;
+        Close();
+        return true;
+      }
+    }
+    break;
+  }
+  return CGUIDialogBoxBase::OnMessage(message);
+}
+
+// \brief Show CGUIDialogOK dialog, then wait for user to dismiss it.
+void CGUIDialogAddonSettings::ShowAndGetInput(CURL& url)
+{
+  m_url = url;
+
+  // Load language strings temporarily
+  CAddon::LoadAddonStrings(url);
+
+  // Create the dialog
+  CGUIDialogAddonSettings* pDialog = (CGUIDialogAddonSettings*) m_gWindowManager.GetWindow(WINDOW_DIALOG_ADDON_SETTINGS);
+
+  CStdString heading;
+  heading = m_url.GetFileName();
+  CUtil::RemoveSlashAtEnd(heading);
+
+  //TODO Fix all Addon paths & strings
+  if (url.GetProtocol() == "plugin")
+    heading.Format("$LOCALIZE[1045] - %s", heading.c_str());
+  else
+    heading.Format("$LOCALIZE[33000] - %s", heading.c_str());
+
+  // Set the heading
+  pDialog->m_strHeading = heading;
+
+  CAddonSettings settings;
+  settings.Load(m_url);
+  pDialog->m_settings = settings;
+
+  pDialog->DoModal();
+
+  settings = pDialog->m_settings;
+  settings.Save();
+
+  // Unload temporary language strings
+  CAddon::ClearAddonStrings();
+
+  return;
+}
+
+// \brief Show CGUIDialogOK dialog, then wait for user to dismiss it.
+void CGUIDialogAddonSettings::ShowAndGetInput(SScraperInfo& info)
+{
+  // Create the dialog
+  CGUIDialogAddonSettings* pDialog = (CGUIDialogAddonSettings*) m_gWindowManager.GetWindow(WINDOW_DIALOG_ADDON_SETTINGS);
+
+  pDialog->m_settings = info.settings;
+  pDialog->m_strHeading.Format("$LOCALIZE[20407] - %s", info.strTitle.c_str());
+
+  pDialog->DoModal();
+  info.settings.LoadUserXML(static_cast<CScraperSettings&>(pDialog->m_settings).GetSettings());
+
+  return;
+}
+
+bool CGUIDialogAddonSettings::ShowVirtualKeyboard(int iControl)
+{
+  int controlId = CONTROL_START_CONTROL;
+  bool bCloseDialog = false;
+
+  TiXmlElement *setting = m_settings.GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    if (controlId == iControl)
+    {
+      const CGUIControl* control = GetControl(controlId);
+      if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
+      {
+        const char *type = setting->Attribute("type");
+        const char *option = setting->Attribute("option");
+        const char *source = setting->Attribute("source");
+        CStdString value = ((CGUIButtonControl*) control)->GetLabel2();
+
+        if (strcmp(type, "text") == 0)
+        {
+          // get any options
+          bool bHidden = false;
+          if (option)
+            bHidden = (strcmp(option, "hidden") == 0);
+
+          if (CGUIDialogKeyboard::ShowAndGetInput(value, ((CGUIButtonControl*) control)->GetLabel(), true, bHidden))
+            ((CGUIButtonControl*) control)->SetLabel2(value);
+        }
+        else if (strcmp(type, "integer") == 0 && CGUIDialogNumeric::ShowAndGetNumber(value, ((CGUIButtonControl*) control)->GetLabel()))
+        {
+          ((CGUIButtonControl*) control)->SetLabel2(value);
+        }
+        else if (strcmp(type, "ipaddress") == 0 && CGUIDialogNumeric::ShowAndGetIPAddress(value, ((CGUIButtonControl*) control)->GetLabel()))
+        {
+          ((CGUIButtonControl*) control)->SetLabel2(value);
+        }
+        else if (strcmpi(type, "video") == 0 || strcmpi(type, "music") == 0 ||
+          strcmpi(type, "pictures") == 0 || strcmpi(type, "programs") == 0 ||
+          strcmpi(type, "folder") == 0 || strcmpi(type, "files") == 0)
+        {
+          // setup the shares
+          VECSOURCES *shares = NULL;
+          if (!source || strcmpi(source, "") == 0)
+            shares = g_settings.GetSourcesFromType(type);
+          else
+            shares = g_settings.GetSourcesFromType(source);
+
+          if (!shares)
+          {
+            VECSOURCES localShares, networkShares;
+            g_mediaManager.GetLocalDrives(localShares);
+            if (!source || strcmpi(source, "local") != 0)
+              g_mediaManager.GetNetworkLocations(networkShares);
+            localShares.insert(localShares.end(), networkShares.begin(), networkShares.end());
+            shares = &localShares;
+          }
+
+          if (strcmpi(type, "folder") == 0)
+          {
+            // get any options
+            bool bWriteOnly = false;
+            if (option)
+              bWriteOnly = (strcmpi(option, "writeable") == 0);
+
+            if (CGUIDialogFileBrowser::ShowAndGetDirectory(*shares, ((CGUIButtonControl*) control)->GetLabel(), value, bWriteOnly))
+              ((CGUIButtonControl*) control)->SetLabel2(value);
+          }
+          else if (strcmpi(type, "pictures") == 0)
+          {
+            if (CGUIDialogFileBrowser::ShowAndGetImage(*shares, ((CGUIButtonControl*) control)->GetLabel(), value))
+              ((CGUIButtonControl*) control)->SetLabel2(value);
+          }
+          else
+          {
+            // set the proper mask
+            CStdString strMask;
+            if (setting->Attribute("mask"))
+              strMask = setting->Attribute("mask");
+            else
+            {
+              if (strcmpi(type, "video") == 0)
+                strMask = g_stSettings.m_videoExtensions;
+              else if (strcmpi(type, "music") == 0)
+                strMask = g_stSettings.m_musicExtensions;
+              else if (strcmpi(type, "programs") == 0)
+#if defined(_WIN32_WINNT)
+                strMask = ".exe|.bat|.cmd|.py";
+#else
+                strMask = "";
+#endif
+            }
+
+            // get any options
+            bool bUseThumbs = false;
+            bool bUseFileDirectories = false;
+            if (option)
+            {
+              bUseThumbs = (strcmpi(option, "usethumbs") == 0 || strcmpi(option, "usethumbs|treatasfolder") == 0);
+              bUseFileDirectories = (strcmpi(option, "treatasfolder") == 0 || strcmpi(option, "usethumbs|treatasfolder") == 0);
+            }
+
+            if (CGUIDialogFileBrowser::ShowAndGetFile(*shares, strMask, ((CGUIButtonControl*) control)->GetLabel(), value))
+              ((CGUIButtonControl*) control)->SetLabel2(value);
+          }
+        }
+        else if (strcmpi(type, "action") == 0)
+        {
+          if (setting->Attribute("default"))
+          {
+            if (option)
+              bCloseDialog = (strcmpi(option, "close") == 0);
+            g_application.getApplicationMessenger().ExecBuiltIn(setting->Attribute("default"));
+          }
+        }
+        break;
+      }
+    }
+    setting = setting->NextSiblingElement("setting");
+    controlId++;
+  }
+  EnableControls();
+  return bCloseDialog;
+}
+
+// Go over all the settings and set their values according to the values of the GUI components
+bool CGUIDialogAddonSettings::SaveSettings(void)
+{
+  // Retrieve all the values from the GUI components and put them in the model
+  int controlId = CONTROL_START_CONTROL;
+  TiXmlElement *setting = m_settings.GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    CStdString id;
+    if (setting->Attribute("id"))
+      id = setting->Attribute("id");
+    const char *type = setting->Attribute("type");
+
+    // skip type "lsep", it is not a required control
+    if (strcmpi(type, "lsep") != 0)
+    {
+      const CGUIControl* control = GetControl(controlId);
+
+      CStdString value;
+      switch (control->GetControlType())
+      {
+        case CGUIControl::GUICONTROL_BUTTON:
+          value = ((CGUIButtonControl*) control)->GetLabel2();
+          break;
+        case CGUIControl::GUICONTROL_RADIO:
+          value = ((CGUIRadioButtonControl*) control)->IsSelected() ? "true" : "false";
+          break;
+        case CGUIControl::GUICONTROL_SPINEX:
+          if (strcmpi(type, "fileenum") == 0 || strcmpi(type, "labelenum") == 0)
+            value = ((CGUISpinControlEx*) control)->GetLabel();
+          else
+            value.Format("%i", ((CGUISpinControlEx*) control)->GetValue());
+          break;
+        default:
+          break;
+      }
+      m_settings.Set(id, value);
+    }
+    setting = setting->NextSiblingElement("setting");
+    controlId++;
+  }
+  return true;
+}
+
+void CGUIDialogAddonSettings::FreeControls()
+{
+  // clear the category group
+  CGUIControlGroupList *control = (CGUIControlGroupList *)GetControl(CONTROL_AREA);
+  if (control)
+  {
+    control->FreeResources();
+    control->ClearAll();
+  }
+}
+
+void CGUIDialogAddonSettings::CreateControls()
+{
+  CGUISpinControlEx *pOriginalSpin = (CGUISpinControlEx*)GetControl(CONTROL_DEFAULT_SPIN);
+  CGUIRadioButtonControl *pOriginalRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_DEFAULT_RADIOBUTTON);
+  CGUIButtonControl *pOriginalButton = (CGUIButtonControl *)GetControl(CONTROL_DEFAULT_BUTTON);
+  CGUIImage *pOriginalImage = (CGUIImage *)GetControl(CONTROL_DEFAULT_SEPARATOR);
+  CGUILabelControl *pOriginalLabel = (CGUILabelControl *)GetControl(CONTROL_DEFAULT_LABEL_SEPARATOR);
+
+  if (!pOriginalSpin || !pOriginalRadioButton || !pOriginalButton || !pOriginalImage)
+    return;
+
+  pOriginalSpin->SetVisible(false);
+  pOriginalRadioButton->SetVisible(false);
+  pOriginalButton->SetVisible(false);
+  pOriginalImage->SetVisible(false);
+  if (pOriginalLabel)
+    pOriginalLabel->SetVisible(false);
+
+  // clear the category group
+  CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(CONTROL_AREA);
+  if (!group)
+    return;
+
+  // set our dialog heading
+  SET_CONTROL_LABEL(CONTROL_HEADING_LABEL, m_strHeading);
+
+  // Create our base path, used for type "fileenum" settings
+  //TODO Fix all Addon paths
+  CStdString basepath;
+  if (m_url.GetProtocol() == "plugin")
+    basepath = "special://home/plugins/";
+  else
+    basepath = "special://xbmc/";
+
+  CUtil::AddFileToFolder(basepath, m_url.GetHostName(), basepath);
+  CUtil::AddFileToFolder(basepath, m_url.GetFileName(), basepath);
+
+  CGUIControl* pControl = NULL;
+  int controlId = CONTROL_START_CONTROL;
+  TiXmlElement *setting = m_settings.GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    const char *type = setting->Attribute("type");
+    const char *id = setting->Attribute("id");
+    CStdString values;
+    if (setting->Attribute("values"))
+      values = setting->Attribute("values");
+    CStdString lvalues;
+    if (setting->Attribute("lvalues"))
+      lvalues = setting->Attribute("lvalues");
+    CStdString entries;
+    if (setting->Attribute("entries"))
+      entries = setting->Attribute("entries");
+    CStdString label;
+    if (setting->Attribute("label") && atoi(setting->Attribute("label")) > 0)
+      label.Format("$LOCALIZE[%s]", setting->Attribute("label"));
+    else
+      label = setting->Attribute("label");
+
+    if (type)
+    {
+      if (strcmpi(type, "text") == 0 || strcmpi(type, "ipaddress") == 0 ||
+        strcmpi(type, "integer") == 0 || strcmpi(type, "video") == 0 ||
+        strcmpi(type, "music") == 0 || strcmpi(type, "pictures") == 0 ||
+        strcmpi(type, "folder") == 0 || strcmpi(type, "programs") == 0 ||
+        strcmpi(type, "files") == 0 || strcmpi(type, "action") == 0)
+      {
+        pControl = new CGUIButtonControl(*pOriginalButton);
+        if (!pControl) return;
+        ((CGUIButtonControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
+        ((CGUIButtonControl *)pControl)->SetLabel(label);
+        if (id)
+          ((CGUIButtonControl *)pControl)->SetLabel2(m_settings.Get(id));
+      }
+      else if (strcmpi(type, "bool") == 0)
+      {
+        pControl = new CGUIRadioButtonControl(*pOriginalRadioButton);
+        if (!pControl) return;
+        ((CGUIRadioButtonControl *)pControl)->SetLabel(label);
+        ((CGUIRadioButtonControl *)pControl)->SetSelected(m_settings.Get(id) == "true");
+      }
+      else if (strcmpi(type, "enum") == 0 || strcmpi(type, "labelenum") == 0)
+      {
+        vector<CStdString> valuesVec;
+        vector<CStdString> entryVec;
+
+        pControl = new CGUISpinControlEx(*pOriginalSpin);
+        if (!pControl) return;
+        ((CGUISpinControlEx *)pControl)->SetText(label);
+
+        if (!lvalues.IsEmpty())
+          CUtil::Tokenize(lvalues, valuesVec, "|");
+        else
+          CUtil::Tokenize(values, valuesVec, "|");
+        if (!entries.IsEmpty())
+          CUtil::Tokenize(entries, entryVec, "|");
+        for (unsigned int i = 0; i < valuesVec.size(); i++)
+        {
+          int iAdd = i;
+          if (entryVec.size() > i)
+            iAdd = atoi(entryVec[i]);
+          if (!lvalues.IsEmpty())
+          {
+            CStdString replace = g_localizeStringsTemp.Get(atoi(valuesVec[i]));
+            if (replace.IsEmpty())
+              replace = g_localizeStrings.Get(atoi(valuesVec[i]));
+            ((CGUISpinControlEx *)pControl)->AddLabel(replace, iAdd);
+          }
+          else
+            ((CGUISpinControlEx *)pControl)->AddLabel(valuesVec[i], iAdd);
+        }
+        if (strcmpi(type, "labelenum") == 0)
+        { // need to run through all our settings and find the one that matches
+          ((CGUISpinControlEx*) pControl)->SetValueFromLabel(m_settings.Get(id));
+        }
+        else
+          ((CGUISpinControlEx*) pControl)->SetValue(atoi(m_settings.Get(id)));
+
+      }
+      else if (strcmpi(type, "fileenum") == 0)
+      {
+        pControl = new CGUISpinControlEx(*pOriginalSpin);
+        if (!pControl) return;
+        ((CGUISpinControlEx *)pControl)->SetText(label);
+
+        //find Folders...
+        CFileItemList items;
+        CStdString enumpath;
+        CUtil::AddFileToFolder(basepath, values, enumpath);
+        CStdString mask;
+        if (setting->Attribute("mask"))
+          mask = setting->Attribute("mask");
+        if (!mask.IsEmpty())
+          CDirectory::GetDirectory(enumpath, items, mask);
+        else
+          CDirectory::GetDirectory(enumpath, items);
+
+        int iItem = 0;
+        for (int i = 0; i < items.Size(); ++i)
+        {
+          CFileItemPtr pItem = items[i];
+          if ((mask.Equals("/") && pItem->m_bIsFolder) || !pItem->m_bIsFolder)
+          {
+            ((CGUISpinControlEx *)pControl)->AddLabel(pItem->GetLabel(), iItem);
+            if (pItem->GetLabel().Equals(m_settings.Get(id)))
+              ((CGUISpinControlEx *)pControl)->SetValue(iItem);
+            iItem++;
+          }
+        }
+      }
+      else if (strcmpi(type, "lsep") == 0 && pOriginalLabel)
+      {
+        pControl = new CGUILabelControl(*pOriginalLabel);
+        if (pControl)
+          ((CGUILabelControl *)pControl)->SetLabel(label);
+      }
+      else if ((strcmpi(type, "sep") == 0 || strcmpi(type, "lsep") == 0) && pOriginalImage)
+        pControl = new CGUIImage(*pOriginalImage);
+    }
+
+    if (pControl)
+    {
+      pControl->SetWidth(group->GetWidth());
+      pControl->SetVisible(true);
+      pControl->SetID(controlId);
+      pControl->AllocResources();
+      group->AddControl(pControl);
+      pControl = NULL;
+    }
+
+    setting = setting->NextSiblingElement("setting");
+    controlId++;
+  }
+  EnableControls();
+}
+
+// Go over all the settings and set their enabled condition according to the values of the enabled attribute
+void CGUIDialogAddonSettings::EnableControls()
+{
+  int controlId = CONTROL_START_CONTROL;
+  TiXmlElement *setting = m_settings.GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    const CGUIControl* control = GetControl(controlId);
+    if (control)
+    {
+      // set enable status
+      if (setting->Attribute("enable"))
+        ((CGUIControl*) control)->SetEnabled(GetCondition(setting->Attribute("enable"), controlId));
+      else
+        ((CGUIControl*) control)->SetEnabled(true);
+      // set visible status
+      if (setting->Attribute("visible"))
+        ((CGUIControl*) control)->SetVisible(GetCondition(setting->Attribute("visible"), controlId));
+      else
+        ((CGUIControl*) control)->SetVisible(true);
+    }
+    setting = setting->NextSiblingElement("setting");
+    controlId++;
+  }
+}
+
+bool CGUIDialogAddonSettings::GetCondition(const CStdString &condition, const int controlId)
+{
+  if (condition.IsEmpty()) return true;
+
+  bool bCondition = true;
+  bool bCompare = true;
+  vector<CStdString> conditionVec;
+  if (condition.Find("+") >= 0)
+    CUtil::Tokenize(condition, conditionVec, "+");
+  else
+  {
+    bCondition = false;
+    bCompare = false;
+    CUtil::Tokenize(condition, conditionVec, "|");
+  }
+
+  for (unsigned int i = 0; i < conditionVec.size(); i++)
+  {
+    vector<CStdString> condVec;
+    if (!TranslateSingleString(conditionVec[i], condVec)) continue;
+
+    const CGUIControl* control2 = GetControl(controlId + atoi(condVec[1]));
+
+    CStdString value;
+    switch (control2->GetControlType())
+    {
+      case CGUIControl::GUICONTROL_BUTTON:
+        value = ((CGUIButtonControl*) control2)->GetLabel2();
+        break;
+      case CGUIControl::GUICONTROL_RADIO:
+        value = ((CGUIRadioButtonControl*) control2)->IsSelected() ? "true" : "false";
+        break;
+      case CGUIControl::GUICONTROL_SPINEX:
+        value.Format("%i", ((CGUISpinControlEx*) control2)->GetValue());
+        break;
+      default:
+        break;
+    }
+
+    if (condVec[0].Equals("eq"))
+    {
+      if (bCompare)
+        bCondition &= value.Equals(condVec[2]);
+      else
+        bCondition |= value.Equals(condVec[2]);
+    }
+    else if (condVec[0].Equals("!eq"))
+    {
+      if (bCompare)
+        bCondition &= !value.Equals(condVec[2]);
+      else
+        bCondition |= !value.Equals(condVec[2]);
+    }
+    else if (condVec[0].Equals("gt"))
+    {
+      if (bCompare)
+        bCondition &= (atoi(value) > atoi(condVec[2]));
+      else
+        bCondition |= (atoi(value) > atoi(condVec[2]));
+    }
+    else if (condVec[0].Equals("lt"))
+    {
+      if (bCompare)
+        bCondition &= (atoi(value) < atoi(condVec[2]));
+      else
+        bCondition |= (atoi(value) < atoi(condVec[2]));
+    }
+  }
+  return bCondition;
+}
+
+bool CGUIDialogAddonSettings::TranslateSingleString(const CStdString &strCondition, vector<CStdString> &condVec)
+{
+  CStdString strTest = strCondition;
+  strTest.ToLower();
+  strTest.TrimLeft(" ");
+  strTest.TrimRight(" ");
+
+  int pos1 = strTest.Find("(");
+  int pos2 = strTest.Find(",");
+  int pos3 = strTest.Find(")");
+  if (pos1 >= 0 && pos2 > pos1 && pos3 > pos2)
+  {
+    condVec.push_back(strTest.Left(pos1));
+    condVec.push_back(strTest.Mid(pos1 + 1, pos2 - pos1 - 1));
+    condVec.push_back(strTest.Mid(pos2 + 1, pos3 - pos2 - 1));
+    return true;
+  }
+  return false;
+}
+
+// Go over all the settings and set their default values
+void CGUIDialogAddonSettings::SetDefaults()
+{
+  int controlId = CONTROL_START_CONTROL;
+  TiXmlElement *setting = m_settings.GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    const CGUIControl* control = GetControl(controlId);
+    if (control)
+    {
+      CStdString value;
+      switch (control->GetControlType())
+      {
+        case CGUIControl::GUICONTROL_BUTTON:
+          if (setting->Attribute("default") && setting->Attribute("id"))
+            ((CGUIButtonControl*) control)->SetLabel2(setting->Attribute("default"));
+          else
+            ((CGUIButtonControl*) control)->SetLabel2("");
+          break;
+        case CGUIControl::GUICONTROL_RADIO:
+          if (setting->Attribute("default"))
+            ((CGUIRadioButtonControl*) control)->SetSelected(strcmpi(setting->Attribute("default"), "true") == 0);
+          else
+            ((CGUIRadioButtonControl*) control)->SetSelected(false);
+          break;
+        case CGUIControl::GUICONTROL_SPINEX:
+          {
+            if (setting->Attribute("default"))
+            {
+              if (strcmpi(setting->Attribute("type"), "fileenum") == 0 || strcmpi(setting->Attribute("type"), "labelenum") == 0)
+              { // need to run through all our settings and find the one that matches
+                  ((CGUISpinControlEx*) control)->SetValueFromLabel(setting->Attribute("default"));
+              }
+              else
+                ((CGUISpinControlEx*) control)->SetValue(atoi(setting->Attribute("default")));
+            }
+            else
+              ((CGUISpinControlEx*) control)->SetValue(0);
+          }
+          break;
+        default:
+          break;
+      }
+    }
+    setting = setting->NextSiblingElement("setting");
+    controlId++;
+  }
+  EnableControls();
+}
+
+CURL CGUIDialogAddonSettings::m_url;
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogAddonSettings.h XBMC/xbmc/GUIDialogAddonSettings.h
--- XBMC-unpatched/xbmc/GUIDialogAddonSettings.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogAddonSettings.h	2009-04-05 20:24:54.000000000 +0200
@@ -0,0 +1,55 @@
+#ifndef GUIDIALOG_PLUGIN_SETTINGS_
+#define GUIDIALOG_PLUGIN_SETTINGS_
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogBoxBase.h"
+#include "settings/AddonSettings.h"
+
+struct SScraperInfo;
+
+class CGUIDialogAddonSettings : public CGUIDialogBoxBase
+{
+public:
+  CGUIDialogAddonSettings(void);
+  virtual ~CGUIDialogAddonSettings(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  static void ShowAndGetInput(CURL& url);
+  static void ShowAndGetInput(SScraperInfo& info);
+
+private:
+  void CreateControls();
+  void FreeControls();
+  void EnableControls();
+  void SetDefaults();
+  bool GetCondition(const CStdString &condition, const int controlId);
+
+  bool SaveSettings(void);
+  bool ShowVirtualKeyboard(int iControl);
+  static CURL m_url;
+  bool TranslateSingleString(const CStdString &strCondition, std::vector<CStdString> &enableVec);
+  CAddonSettings m_settings;
+  CStdString m_strHeading;
+};
+
+#endif
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogContentSettings.cpp XBMC/xbmc/GUIDialogContentSettings.cpp
--- XBMC-unpatched/xbmc/GUIDialogContentSettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogContentSettings.cpp	2009-04-05 19:55:01.000000000 +0200
@@ -21,7 +21,7 @@
 
 #include "stdafx.h"
 #include "GUIDialogContentSettings.h"
-#include "GUIDialogPluginSettings.h"
+#include "GUIDialogAddonSettings.h"
 #include "Util.h"
 #include "VideoDatabase.h"
 #include "VideoInfoScanner.h"
@@ -136,7 +136,7 @@
     {
       if (m_info.settings.LoadSettingsXML("special://xbmc/system/scrapers/video/"+m_info.strPath))
       {
-        CGUIDialogPluginSettings::ShowAndGetInput(m_info);
+        CGUIDialogAddonSettings::ShowAndGetInput(m_info);
         m_bNeedSave = true;
         return true;
       }
@@ -528,7 +528,7 @@
       bRunScan = false;
     }
 
-    if (!scraper.strContent.IsEmpty() && !scraper.strContent.Equals("None") && (!scraper.settings.GetPluginRoot() || scraper.settings.GetSettings().IsEmpty()))
+    if (!scraper.strContent.IsEmpty() && !scraper.strContent.Equals("None") && (!scraper.settings.GetAddonRoot() || scraper.settings.GetSettings().IsEmpty()))
     { // load default scraper settings
       scraper.settings.LoadSettingsXML("special://xbmc/system/scrapers/video/"+scraper.strPath);
       scraper.settings.SaveFromDefault();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogContextMenu.h XBMC/xbmc/GUIDialogContextMenu.h
--- XBMC-unpatched/xbmc/GUIDialogContextMenu.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogContextMenu.h	2009-04-04 20:52:44.000000000 +0200
@@ -100,6 +100,14 @@
                       CONTEXT_BUTTON_PLUGIN_SETTINGS,
                       CONTEXT_BUTTON_LASTFM_UNLOVE_ITEM,
                       CONTEXT_BUTTON_LASTFM_UNBAN_ITEM,
+                      CONTEXT_BUTTON_HIDE,
+                      CONTEXT_BUTTON_SHOW_HIDDEN,
+                      CONTEXT_BUTTON_ADD,
+                      CONTEXT_BUTTON_ACTIVATE,
+                      CONTEXT_BUTTON_START_RECORD,
+                      CONTEXT_BUTTON_STOP_RECORD,
+                      CONTEXT_BUTTON_GROUP_MANAGER,
+					  CONTEXT_BUTTON_CHANNEL_MANAGER,
                       CONTEXT_BUTTON_USER1,
                       CONTEXT_BUTTON_USER2,
                       CONTEXT_BUTTON_USER3,
@@ -147,9 +155,9 @@
   static int ShowAndGetChoice(const std::vector<CStdString> &choices, const CPoint &point);
 
   static CMediaSource *GetShare(const CStdString &type, const CFileItem *item);
-protected:
   float GetWidth();
   float GetHeight();
+protected:
   virtual void OnInitWindow();
   static CStdString GetDefaultShareNameByType(const CStdString &strType);
   static void SetDefault(const CStdString &strType, const CStdString &strDefault);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogPluginSettings.cpp XBMC/xbmc/GUIDialogPluginSettings.cpp
--- XBMC-unpatched/xbmc/GUIDialogPluginSettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogPluginSettings.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,658 +0,0 @@
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "stdafx.h"
-#include "GUIDialogPluginSettings.h"
-#include "FileSystem/PluginDirectory.h"
-#include "GUIDialogNumeric.h"
-#include "GUIDialogFileBrowser.h"
-#include "GUIControlGroupList.h"
-#include "Util.h"
-#include "MediaManager.h"
-#include "GUIRadioButtonControl.h"
-#include "GUISpinControlEx.h"
-#include "GUIImage.h"
-#include "FileSystem/Directory.h"
-#include "VideoInfoScanner.h"
-#include "ScraperSettings.h"
-#include "GUIWindowManager.h"
-#include "Application.h"
-#include "GUIDialogKeyboard.h"
-#include "FileItem.h"
-
-using namespace std;
-using namespace DIRECTORY;
-
-#define CONTROL_AREA                    2
-#define CONTROL_DEFAULT_BUTTON          3
-#define CONTROL_DEFAULT_RADIOBUTTON     4
-#define CONTROL_DEFAULT_SPIN            5
-#define CONTROL_DEFAULT_SEPARATOR       6
-#define CONTROL_DEFAULT_LABEL_SEPARATOR 7
-#define ID_BUTTON_OK                    10
-#define ID_BUTTON_CANCEL                11
-#define ID_BUTTON_DEFAULT               12
-#define CONTROL_HEADING_LABEL           20
-#define CONTROL_START_CONTROL           100
-
-CGUIDialogPluginSettings::CGUIDialogPluginSettings()
-   : CGUIDialogBoxBase(WINDOW_DIALOG_PLUGIN_SETTINGS, "DialogPluginSettings.xml")
-{}
-
-CGUIDialogPluginSettings::~CGUIDialogPluginSettings(void)
-{}
-
-bool CGUIDialogPluginSettings::OnMessage(CGUIMessage& message)
-{
-  switch (message.GetMessage())
-  {
-    case GUI_MSG_WINDOW_INIT:
-    {
-      CGUIDialogBoxBase::OnMessage(message);
-      FreeControls();
-      CreateControls();
-      return true;
-    }
-
-    case GUI_MSG_CLICKED:
-    {
-      int iControl = message.GetSenderId();
-      bool bCloseDialog = false;
-
-      if (iControl == ID_BUTTON_OK)
-        SaveSettings();
-      else if (iControl == ID_BUTTON_DEFAULT)
-        SetDefaults();
-      else
-        bCloseDialog = ShowVirtualKeyboard(iControl);
-
-      if (iControl == ID_BUTTON_OK || iControl == ID_BUTTON_CANCEL || bCloseDialog)
-      {
-        m_bConfirmed = true;
-        Close();
-        return true;
-      }
-    }
-    break;
-  }
-  return CGUIDialogBoxBase::OnMessage(message);
-}
-
-// \brief Show CGUIDialogOK dialog, then wait for user to dismiss it.
-void CGUIDialogPluginSettings::ShowAndGetInput(CURL& url)
-{
-  m_url = url;
-
-  // Load language strings temporarily
-  DIRECTORY::CPluginDirectory::LoadPluginStrings(url);
-
-  // Create the dialog
-  CGUIDialogPluginSettings* pDialog = (CGUIDialogPluginSettings*) m_gWindowManager.GetWindow(WINDOW_DIALOG_PLUGIN_SETTINGS);
-
-  pDialog->m_strHeading = m_url.GetFileName();
-  CUtil::RemoveSlashAtEnd(pDialog->m_strHeading);
-  pDialog->m_strHeading.Format("$LOCALIZE[1045] - %s", pDialog->m_strHeading.c_str());
-
-  CPluginSettings settings;
-  settings.Load(m_url);
-  pDialog->m_settings = settings;
-
-  pDialog->DoModal();
-
-  settings = pDialog->m_settings;
-  settings.Save();
-
-  return;
-}
-
-// \brief Show CGUIDialogOK dialog, then wait for user to dismiss it.
-void CGUIDialogPluginSettings::ShowAndGetInput(SScraperInfo& info)
-{
-  // Create the dialog
-  CGUIDialogPluginSettings* pDialog = (CGUIDialogPluginSettings*) m_gWindowManager.GetWindow(WINDOW_DIALOG_PLUGIN_SETTINGS);
-
-  pDialog->m_settings = info.settings;
-  pDialog->m_strHeading.Format("$LOCALIZE[20407] - %s", info.strTitle.c_str());
-
-  pDialog->DoModal();
-  info.settings.LoadUserXML(static_cast<CScraperSettings&>(pDialog->m_settings).GetSettings());
-
-  return;
-}
-
-bool CGUIDialogPluginSettings::ShowVirtualKeyboard(int iControl)
-{
-  int controlId = CONTROL_START_CONTROL;
-  bool bCloseDialog = false;
-
-  TiXmlElement *setting = m_settings.GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-    if (controlId == iControl)
-    {
-      const CGUIControl* control = GetControl(controlId);
-      if (control->GetControlType() == CGUIControl::GUICONTROL_BUTTON)
-      {
-        const char *type = setting->Attribute("type");
-        const char *option = setting->Attribute("option");
-        const char *source = setting->Attribute("source");
-        CStdString value = ((CGUIButtonControl*) control)->GetLabel2();
-
-        if (strcmp(type, "text") == 0)
-        {
-          // get any options
-          bool bHidden = false;
-          if (option)
-            bHidden = (strcmp(option, "hidden") == 0);
-
-          if (CGUIDialogKeyboard::ShowAndGetInput(value, ((CGUIButtonControl*) control)->GetLabel(), true, bHidden))
-            ((CGUIButtonControl*) control)->SetLabel2(value);
-        }
-        else if (strcmp(type, "integer") == 0 && CGUIDialogNumeric::ShowAndGetNumber(value, ((CGUIButtonControl*) control)->GetLabel()))
-        {
-          ((CGUIButtonControl*) control)->SetLabel2(value);
-        }
-        else if (strcmp(type, "ipaddress") == 0 && CGUIDialogNumeric::ShowAndGetIPAddress(value, ((CGUIButtonControl*) control)->GetLabel()))
-        {
-          ((CGUIButtonControl*) control)->SetLabel2(value);
-        }
-        else if (strcmpi(type, "video") == 0 || strcmpi(type, "music") == 0 ||
-          strcmpi(type, "pictures") == 0 || strcmpi(type, "programs") == 0 ||
-          strcmpi(type, "folder") == 0 || strcmpi(type, "files") == 0)
-        {
-          // setup the shares
-          VECSOURCES *shares = NULL;
-          if (!source || strcmpi(source, "") == 0)
-            shares = g_settings.GetSourcesFromType(type);
-          else
-            shares = g_settings.GetSourcesFromType(source);
-
-          if (!shares)
-          {
-            VECSOURCES localShares, networkShares;
-            g_mediaManager.GetLocalDrives(localShares);
-            if (!source || strcmpi(source, "local") != 0)
-              g_mediaManager.GetNetworkLocations(networkShares);
-            localShares.insert(localShares.end(), networkShares.begin(), networkShares.end());
-            shares = &localShares;
-          }
-
-          if (strcmpi(type, "folder") == 0)
-          {
-            // get any options
-            bool bWriteOnly = false;
-            if (option)
-              bWriteOnly = (strcmpi(option, "writeable") == 0);
-
-            if (CGUIDialogFileBrowser::ShowAndGetDirectory(*shares, ((CGUIButtonControl*) control)->GetLabel(), value, bWriteOnly))
-              ((CGUIButtonControl*) control)->SetLabel2(value);
-          }
-          else if (strcmpi(type, "pictures") == 0)
-          {
-            if (CGUIDialogFileBrowser::ShowAndGetImage(*shares, ((CGUIButtonControl*) control)->GetLabel(), value))
-              ((CGUIButtonControl*) control)->SetLabel2(value);
-          }
-          else
-          {
-            // set the proper mask
-            CStdString strMask;
-            if (setting->Attribute("mask"))
-              strMask = setting->Attribute("mask");
-            else
-            {
-              if (strcmpi(type, "video") == 0)
-                strMask = g_stSettings.m_videoExtensions;
-              else if (strcmpi(type, "music") == 0)
-                strMask = g_stSettings.m_musicExtensions;
-              else if (strcmpi(type, "programs") == 0)
-#if defined(_WIN32_WINNT)
-                strMask = ".exe|.bat|.cmd|.py";
-#else
-                strMask = "";
-#endif
-            }
-
-            // get any options
-            bool bUseThumbs = false;
-            bool bUseFileDirectories = false;
-            if (option)
-            {
-              bUseThumbs = (strcmpi(option, "usethumbs") == 0 || strcmpi(option, "usethumbs|treatasfolder") == 0);
-              bUseFileDirectories = (strcmpi(option, "treatasfolder") == 0 || strcmpi(option, "usethumbs|treatasfolder") == 0);
-            }
-
-            if (CGUIDialogFileBrowser::ShowAndGetFile(*shares, strMask, ((CGUIButtonControl*) control)->GetLabel(), value))
-              ((CGUIButtonControl*) control)->SetLabel2(value);
-          }
-        }
-        else if (strcmpi(type, "action") == 0)
-        {
-          if (setting->Attribute("default"))
-          {
-            if (option)
-              bCloseDialog = (strcmpi(option, "close") == 0);
-            g_application.getApplicationMessenger().ExecBuiltIn(setting->Attribute("default"));
-          }
-        }
-        break;
-      }
-    }
-    setting = setting->NextSiblingElement("setting");
-    controlId++;
-  }
-  EnableControls();
-  return bCloseDialog;
-}
-
-// Go over all the settings and set their values according to the values of the GUI components
-bool CGUIDialogPluginSettings::SaveSettings(void)
-{
-  // Retrieve all the values from the GUI components and put them in the model
-  int controlId = CONTROL_START_CONTROL;
-  TiXmlElement *setting = m_settings.GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-    CStdString id;
-    if (setting->Attribute("id"))
-      id = setting->Attribute("id");
-    const char *type = setting->Attribute("type");
-
-    // skip type "lsep", it is not a required control
-    if (strcmpi(type, "lsep") != 0)
-    {
-      const CGUIControl* control = GetControl(controlId);
-
-      CStdString value;
-      switch (control->GetControlType())
-      {
-        case CGUIControl::GUICONTROL_BUTTON:
-          value = ((CGUIButtonControl*) control)->GetLabel2();
-          break;
-        case CGUIControl::GUICONTROL_RADIO:
-          value = ((CGUIRadioButtonControl*) control)->IsSelected() ? "true" : "false";
-          break;
-        case CGUIControl::GUICONTROL_SPINEX:
-          if (strcmpi(type, "fileenum") == 0 || strcmpi(type, "labelenum") == 0)
-            value = ((CGUISpinControlEx*) control)->GetLabel();
-          else
-            value.Format("%i", ((CGUISpinControlEx*) control)->GetValue());
-          break;
-        default:
-          break;
-      }
-      m_settings.Set(id, value);
-    }
-    setting = setting->NextSiblingElement("setting");
-    controlId++;
-  }
-  return true;
-}
-
-void CGUIDialogPluginSettings::FreeControls()
-{
-  // clear the category group
-  CGUIControlGroupList *control = (CGUIControlGroupList *)GetControl(CONTROL_AREA);
-  if (control)
-  {
-    control->FreeResources();
-    control->ClearAll();
-  }
-}
-
-void CGUIDialogPluginSettings::CreateControls()
-{
-  CGUISpinControlEx *pOriginalSpin = (CGUISpinControlEx*)GetControl(CONTROL_DEFAULT_SPIN);
-  CGUIRadioButtonControl *pOriginalRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_DEFAULT_RADIOBUTTON);
-  CGUIButtonControl *pOriginalButton = (CGUIButtonControl *)GetControl(CONTROL_DEFAULT_BUTTON);
-  CGUIImage *pOriginalImage = (CGUIImage *)GetControl(CONTROL_DEFAULT_SEPARATOR);
-  CGUILabelControl *pOriginalLabel = (CGUILabelControl *)GetControl(CONTROL_DEFAULT_LABEL_SEPARATOR);
-
-  if (!pOriginalSpin || !pOriginalRadioButton || !pOriginalButton || !pOriginalImage)
-    return;
-
-  pOriginalSpin->SetVisible(false);
-  pOriginalRadioButton->SetVisible(false);
-  pOriginalButton->SetVisible(false);
-  pOriginalImage->SetVisible(false);
-  if (pOriginalLabel)
-    pOriginalLabel->SetVisible(false);
-
-  // clear the category group
-  CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(CONTROL_AREA);
-  if (!group)
-    return;
-
-  // set our dialog heading
-  SET_CONTROL_LABEL(CONTROL_HEADING_LABEL, m_strHeading);
-
-  // Create our base path, used for type "fileenum" settings
-  CStdString basepath = "special://home/plugins/";
-  CUtil::AddFileToFolder(basepath, m_url.GetHostName(), basepath);
-  CUtil::AddFileToFolder(basepath, m_url.GetFileName(), basepath);
-
-  CGUIControl* pControl = NULL;
-  int controlId = CONTROL_START_CONTROL;
-  TiXmlElement *setting = m_settings.GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-    const char *type = setting->Attribute("type");
-    const char *id = setting->Attribute("id");
-    CStdString values;
-    if (setting->Attribute("values"))
-      values = setting->Attribute("values");
-    CStdString lvalues;
-    if (setting->Attribute("lvalues"))
-      lvalues = setting->Attribute("lvalues");
-    CStdString entries;
-    if (setting->Attribute("entries"))
-      entries = setting->Attribute("entries");
-    CStdString label;
-    if (setting->Attribute("label") && atoi(setting->Attribute("label")) > 0)
-      label.Format("$LOCALIZE[%s]", setting->Attribute("label"));
-    else
-      label = setting->Attribute("label");
-
-    if (type)
-    {
-      if (strcmpi(type, "text") == 0 || strcmpi(type, "ipaddress") == 0 ||
-        strcmpi(type, "integer") == 0 || strcmpi(type, "video") == 0 ||
-        strcmpi(type, "music") == 0 || strcmpi(type, "pictures") == 0 ||
-        strcmpi(type, "folder") == 0 || strcmpi(type, "programs") == 0 ||
-        strcmpi(type, "files") == 0 || strcmpi(type, "action") == 0)
-      {
-        pControl = new CGUIButtonControl(*pOriginalButton);
-        if (!pControl) return;
-        ((CGUIButtonControl *)pControl)->SettingsCategorySetTextAlign(XBFONT_CENTER_Y);
-        ((CGUIButtonControl *)pControl)->SetLabel(label);
-        if (id)
-          ((CGUIButtonControl *)pControl)->SetLabel2(m_settings.Get(id));
-      }
-      else if (strcmpi(type, "bool") == 0)
-      {
-        pControl = new CGUIRadioButtonControl(*pOriginalRadioButton);
-        if (!pControl) return;
-        ((CGUIRadioButtonControl *)pControl)->SetLabel(label);
-        ((CGUIRadioButtonControl *)pControl)->SetSelected(m_settings.Get(id) == "true");
-      }
-      else if (strcmpi(type, "enum") == 0 || strcmpi(type, "labelenum") == 0)
-      {
-        vector<CStdString> valuesVec;
-        vector<CStdString> entryVec;
-
-        pControl = new CGUISpinControlEx(*pOriginalSpin);
-        if (!pControl) return;
-        ((CGUISpinControlEx *)pControl)->SetText(label);
-
-        if (!lvalues.IsEmpty())
-          CUtil::Tokenize(lvalues, valuesVec, "|");
-        else
-          CUtil::Tokenize(values, valuesVec, "|");
-        if (!entries.IsEmpty())
-          CUtil::Tokenize(entries, entryVec, "|");
-        for (unsigned int i = 0; i < valuesVec.size(); i++)
-        {
-          int iAdd = i;
-          if (entryVec.size() > i)
-            iAdd = atoi(entryVec[i]);
-          if (!lvalues.IsEmpty())
-          {
-            CStdString replace = g_localizeStringsTemp.Get(atoi(valuesVec[i]));
-            if (replace.IsEmpty())
-              replace = g_localizeStrings.Get(atoi(valuesVec[i]));
-            ((CGUISpinControlEx *)pControl)->AddLabel(replace, iAdd);
-          }
-          else
-            ((CGUISpinControlEx *)pControl)->AddLabel(valuesVec[i], iAdd);
-        }
-        if (strcmpi(type, "labelenum") == 0)
-        { // need to run through all our settings and find the one that matches
-          ((CGUISpinControlEx*) pControl)->SetValueFromLabel(m_settings.Get(id));
-        }
-        else
-          ((CGUISpinControlEx*) pControl)->SetValue(atoi(m_settings.Get(id)));
-
-      }
-      else if (strcmpi(type, "fileenum") == 0)
-      {
-        pControl = new CGUISpinControlEx(*pOriginalSpin);
-        if (!pControl) return;
-        ((CGUISpinControlEx *)pControl)->SetText(label);
-
-        //find Folders...
-        CFileItemList items;
-        CStdString enumpath;
-        CUtil::AddFileToFolder(basepath, values, enumpath);
-        CStdString mask;
-        if (setting->Attribute("mask"))
-          mask = setting->Attribute("mask");
-        if (!mask.IsEmpty())
-          CDirectory::GetDirectory(enumpath, items, mask);
-        else
-          CDirectory::GetDirectory(enumpath, items);
-
-        int iItem = 0;
-        for (int i = 0; i < items.Size(); ++i)
-        {
-          CFileItemPtr pItem = items[i];
-          if ((mask.Equals("/") && pItem->m_bIsFolder) || !pItem->m_bIsFolder)
-          {
-            ((CGUISpinControlEx *)pControl)->AddLabel(pItem->GetLabel(), iItem);
-            if (pItem->GetLabel().Equals(m_settings.Get(id)))
-              ((CGUISpinControlEx *)pControl)->SetValue(iItem);
-            iItem++;
-          }
-        }
-      }
-      else if (strcmpi(type, "lsep") == 0 && pOriginalLabel)
-      {
-        pControl = new CGUILabelControl(*pOriginalLabel);
-        if (pControl)
-          ((CGUILabelControl *)pControl)->SetLabel(label);
-      }
-      else if ((strcmpi(type, "sep") == 0 || strcmpi(type, "lsep") == 0) && pOriginalImage)
-        pControl = new CGUIImage(*pOriginalImage);
-    }
-
-    if (pControl)
-    {
-      pControl->SetWidth(group->GetWidth());
-      pControl->SetVisible(true);
-      pControl->SetID(controlId);
-      pControl->AllocResources();
-      group->AddControl(pControl);
-      pControl = NULL;
-    }
-
-    setting = setting->NextSiblingElement("setting");
-    controlId++;
-  }
-  EnableControls();
-}
-
-// Go over all the settings and set their enabled condition according to the values of the enabled attribute
-void CGUIDialogPluginSettings::EnableControls()
-{
-  int controlId = CONTROL_START_CONTROL;
-  TiXmlElement *setting = m_settings.GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-    const CGUIControl* control = GetControl(controlId);
-    if (control)
-    {
-      // set enable status
-      if (setting->Attribute("enable"))
-        ((CGUIControl*) control)->SetEnabled(GetCondition(setting->Attribute("enable"), controlId));
-      else
-        ((CGUIControl*) control)->SetEnabled(true);
-      // set visible status
-      if (setting->Attribute("visible"))
-        ((CGUIControl*) control)->SetVisible(GetCondition(setting->Attribute("visible"), controlId));
-      else
-        ((CGUIControl*) control)->SetVisible(true);
-    }
-    setting = setting->NextSiblingElement("setting");
-    controlId++;
-  }
-}
-
-bool CGUIDialogPluginSettings::GetCondition(const CStdString &condition, const int controlId)
-{
-  if (condition.IsEmpty()) return true;
-
-  bool bCondition = true;
-  bool bCompare = true;
-  vector<CStdString> conditionVec;
-  if (condition.Find("+") >= 0)
-    CUtil::Tokenize(condition, conditionVec, "+");
-  else
-  {
-    bCondition = false;
-    bCompare = false;
-    CUtil::Tokenize(condition, conditionVec, "|");
-  }
-
-  for (unsigned int i = 0; i < conditionVec.size(); i++)
-  {
-    vector<CStdString> condVec;
-    if (!TranslateSingleString(conditionVec[i], condVec)) continue;
-
-    const CGUIControl* control2 = GetControl(controlId + atoi(condVec[1]));
-
-    CStdString value;
-    switch (control2->GetControlType())
-    {
-      case CGUIControl::GUICONTROL_BUTTON:
-        value = ((CGUIButtonControl*) control2)->GetLabel2();
-        break;
-      case CGUIControl::GUICONTROL_RADIO:
-        value = ((CGUIRadioButtonControl*) control2)->IsSelected() ? "true" : "false";
-        break;
-      case CGUIControl::GUICONTROL_SPINEX:
-        value.Format("%i", ((CGUISpinControlEx*) control2)->GetValue());
-        break;
-      default:
-        break;
-    }
-
-    if (condVec[0].Equals("eq"))
-    {
-      if (bCompare)
-        bCondition &= value.Equals(condVec[2]);
-      else
-        bCondition |= value.Equals(condVec[2]);
-    }
-    else if (condVec[0].Equals("!eq"))
-    {
-      if (bCompare)
-        bCondition &= !value.Equals(condVec[2]);
-      else
-        bCondition |= !value.Equals(condVec[2]);
-    }
-    else if (condVec[0].Equals("gt"))
-    {
-      if (bCompare)
-        bCondition &= (atoi(value) > atoi(condVec[2]));
-      else
-        bCondition |= (atoi(value) > atoi(condVec[2]));
-    }
-    else if (condVec[0].Equals("lt"))
-    {
-      if (bCompare)
-        bCondition &= (atoi(value) < atoi(condVec[2]));
-      else
-        bCondition |= (atoi(value) < atoi(condVec[2]));
-    }
-  }
-  return bCondition;
-}
-
-bool CGUIDialogPluginSettings::TranslateSingleString(const CStdString &strCondition, vector<CStdString> &condVec)
-{
-  CStdString strTest = strCondition;
-  strTest.ToLower();
-  strTest.TrimLeft(" ");
-  strTest.TrimRight(" ");
-
-  int pos1 = strTest.Find("(");
-  int pos2 = strTest.Find(",");
-  int pos3 = strTest.Find(")");
-  if (pos1 >= 0 && pos2 > pos1 && pos3 > pos2)
-  {
-    condVec.push_back(strTest.Left(pos1));
-    condVec.push_back(strTest.Mid(pos1 + 1, pos2 - pos1 - 1));
-    condVec.push_back(strTest.Mid(pos2 + 1, pos3 - pos2 - 1));
-    return true;
-  }
-  return false;
-}
-
-// Go over all the settings and set their default values
-void CGUIDialogPluginSettings::SetDefaults()
-{
-  int controlId = CONTROL_START_CONTROL;
-  TiXmlElement *setting = m_settings.GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-    const CGUIControl* control = GetControl(controlId);
-    if (control)
-    {
-      CStdString value;
-      switch (control->GetControlType())
-      {
-        case CGUIControl::GUICONTROL_BUTTON:
-          if (setting->Attribute("default") && setting->Attribute("id"))
-            ((CGUIButtonControl*) control)->SetLabel2(setting->Attribute("default"));
-          else
-            ((CGUIButtonControl*) control)->SetLabel2("");
-          break;
-        case CGUIControl::GUICONTROL_RADIO:
-          if (setting->Attribute("default"))
-            ((CGUIRadioButtonControl*) control)->SetSelected(strcmpi(setting->Attribute("default"), "true") == 0);
-          else
-            ((CGUIRadioButtonControl*) control)->SetSelected(false);
-          break;
-        case CGUIControl::GUICONTROL_SPINEX:
-          {
-            if (setting->Attribute("default"))
-            {
-              if (strcmpi(setting->Attribute("type"), "fileenum") == 0 || strcmpi(setting->Attribute("type"), "labelenum") == 0)
-              { // need to run through all our settings and find the one that matches
-                  ((CGUISpinControlEx*) control)->SetValueFromLabel(setting->Attribute("default"));
-              }
-              else
-                ((CGUISpinControlEx*) control)->SetValue(atoi(setting->Attribute("default")));
-            }
-            else
-              ((CGUISpinControlEx*) control)->SetValue(0);
-          }
-          break;
-        default:
-          break;
-      }
-    }
-    setting = setting->NextSiblingElement("setting");
-    controlId++;
-  }
-  EnableControls();
-}
-
-CURL CGUIDialogPluginSettings::m_url;
-
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogPluginSettings.h XBMC/xbmc/GUIDialogPluginSettings.h
--- XBMC-unpatched/xbmc/GUIDialogPluginSettings.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogPluginSettings.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-#ifndef GUIDIALOG_PLUGIN_SETTINGS_
-#define GUIDIALOG_PLUGIN_SETTINGS_
-
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "GUIDialogBoxBase.h"
-#include "PluginSettings.h"
-
-struct SScraperInfo;
-
-class CGUIDialogPluginSettings : public CGUIDialogBoxBase
-{
-public:
-  CGUIDialogPluginSettings(void);
-  virtual ~CGUIDialogPluginSettings(void);
-  virtual bool OnMessage(CGUIMessage& message);
-  static void ShowAndGetInput(CURL& url);
-  static void ShowAndGetInput(SScraperInfo& info);
-
-private:
-  void CreateControls();
-  void FreeControls();
-  void EnableControls();
-  void SetDefaults();
-  bool GetCondition(const CStdString &condition, const int controlId);
-
-  bool SaveSettings(void);
-  bool ShowVirtualKeyboard(int iControl);
-  static CURL m_url;
-  bool TranslateSingleString(const CStdString &strCondition, std::vector<CStdString> &enableVec);
-  CBasicSettings m_settings;
-  CStdString m_strHeading;
-};
-
-#endif
-
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogSeekBar.cpp XBMC/xbmc/GUIDialogSeekBar.cpp
--- XBMC-unpatched/xbmc/GUIDialogSeekBar.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogSeekBar.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -24,6 +24,7 @@
 #include "GUISliderControl.h"
 #include "Application.h"
 #include "utils/GUIInfoManager.h"
+#include "FileItem.h"
 
 #define SEEK_BAR_DISPLAY_TIME 2000L
 #define SEEK_BAR_SEEK_TIME     500L
@@ -126,6 +127,13 @@
     return;
   }
 
+  CFileItem item(g_application.CurrentFileItem());
+  if (item.HasTVChannelInfoTag() && g_guiSettings.GetBool("pvrmenu.hidevideolength"))
+  {
+    Close(true);
+    return;
+  }
+
   // check if we should seek or exit
   if (!g_infoManager.m_performingSeek && timeGetTime() - m_dwTimer > SEEK_BAR_DISPLAY_TIME)
     g_infoManager.SetSeeking(false);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogSettings.cpp XBMC/xbmc/GUIDialogSettings.cpp
--- XBMC-unpatched/xbmc/GUIDialogSettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogSettings.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -32,6 +32,8 @@
 #define CONTROL_DEFAULT_SPIN        9
 #define CONTROL_DEFAULT_SLIDER     10
 #define CONTROL_DEFAULT_SEPARATOR  11
+#define CONTROL_DEFAULT_EDIT       12
+#define CONTROL_DEFAULT_EDIT_NUM   13
 #define CONTROL_OKAY_BUTTON        28
 #define CONTROL_CANCEL_BUTTON      29
 #define CONTROL_START              30
@@ -40,6 +42,8 @@
 CGUIDialogSettings::CGUIDialogSettings(DWORD id, const char *xmlFile)
     : CGUIDialog(id, xmlFile)
 {
+  m_pOriginalEdit = NULL;
+  m_pOriginalEditNum = NULL;
   m_pOriginalSpin = NULL;
   m_pOriginalRadioButton = NULL;
   m_pOriginalSettingsButton = NULL;
@@ -79,11 +83,15 @@
 {
   // cleanup first, if necessary
   FreeControls();
+  m_pOriginalEdit = (CGUIEditControl*)GetControl(CONTROL_DEFAULT_EDIT);
+  m_pOriginalEditNum = (CGUIEditControl*)GetControl(CONTROL_DEFAULT_EDIT_NUM);
   m_pOriginalSpin = (CGUISpinControlEx*)GetControl(CONTROL_DEFAULT_SPIN);
   m_pOriginalRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_DEFAULT_RADIOBUTTON);
   m_pOriginalSettingsButton = (CGUIButtonControl *)GetControl(CONTROL_DEFAULT_BUTTON);
   m_pOriginalSlider = (CGUISettingsSliderControl *)GetControl(CONTROL_DEFAULT_SLIDER);
   m_pOriginalSeparator = (CGUIImage *)GetControl(CONTROL_DEFAULT_SEPARATOR);
+  if (m_pOriginalEdit) m_pOriginalEdit->SetVisible(false);
+  if (m_pOriginalEditNum) m_pOriginalEditNum->SetVisible(false);
   if (m_pOriginalSpin) m_pOriginalSpin->SetVisible(false);
   if (m_pOriginalRadioButton) m_pOriginalRadioButton->SetVisible(false);
   if (m_pOriginalSettingsButton) m_pOriginalSettingsButton->SetVisible(false);
@@ -91,7 +99,14 @@
   if (m_pOriginalSeparator) m_pOriginalSeparator->SetVisible(false);
 
   // update our settings label
+  if (GetID() == WINDOW_DIALOG_TV_TIMER_SETTING)
+  {
+    SET_CONTROL_LABEL(CONTROL_SETTINGS_LABEL, g_localizeStrings.Get(18068));
+  }
+  else
+  {
   SET_CONTROL_LABEL(CONTROL_SETTINGS_LABEL, g_localizeStrings.Get(13395 + GetID() - WINDOW_DIALOG_VIDEO_OSD_SETTINGS));
+  }
 
   CGUIControlGroupList *group = (CGUIControlGroupList *)GetControl(CONTROL_GROUP_LIST);
   if (!group)
@@ -176,7 +191,26 @@
     if (pControl && setting.data) pControl->SetIntValue(*(int *)setting.data);
   }
   else if (setting.type == SettingInfo::BUTTON)
+  {
       SET_CONTROL_LABEL(controlID,setting.name);
+    CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(controlID);
+	if (pControl && setting.data) ((CGUIButtonControl *)pControl)->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(controlID);
+    if (pControl && setting.data) pControl->SetLabel2(*(CStdString *)setting.data);
+
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(controlID);
+    if (pControl && setting.data) {
+        CStdString strIndex;
+        strIndex.Format("%i", *(int *)setting.data);
+        pControl->SetLabel2(strIndex);
+    }
+  }
 
   if (setting.enabled)
   {
@@ -221,6 +255,24 @@
     CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(iID);
     if (setting.data) *(int *)setting.data = pControl->GetValue();
   }
+  else if (setting.type == SettingInfo::BUTTON)
+  {
+    CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(iID);
+    if (setting.data) *(CStdString *)setting.data = pControl->GetLabel2();
+  }
+  else if (setting.type == SettingInfo::EDIT)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(iID);
+    if (setting.data) *(CStdString *)setting.data = pControl->GetLabel2();
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(iID);
+    if (setting.data) {
+        CStdString strIndex = pControl->GetLabel2();
+        *(int *)setting.data = atol(strIndex.c_str());
+    }
+  }
   else if (setting.type == SettingInfo::CHECK)
   {
     CGUIRadioButtonControl *pControl = (CGUIRadioButtonControl *)GetControl(iID);
@@ -264,6 +316,28 @@
     if (!pControl) return ;
     ((CGUIButtonControl *)pControl)->SetLabel(setting.name);
     pControl->SetWidth(width);
+	if (setting.data) ((CGUIButtonControl *)pControl)->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT && m_pOriginalEdit)
+  {
+    pControl = new CGUIEditControl(*m_pOriginalEdit);
+    if (!pControl) return ;
+    ((CGUIEditControl *)pControl)->SetLabel(setting.name);
+    pControl->SetWidth(width);
+    if (setting.data) ((CGUIEditControl *)pControl)->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM && m_pOriginalEditNum)
+  {
+    pControl = new CGUIEditControl(*m_pOriginalEditNum);
+    if (!pControl) return ;
+    ((CGUIEditControl *)pControl)->SetLabel(setting.name);
+    pControl->SetWidth(width);
+    ((CGUIEditControl *)pControl)->SetInputType(CGUIEditControl::INPUT_TYPE_NUMBER, 0);
+    if (setting.data) {
+        CStdString strIndex;
+        strIndex.Format("%i", *(int *)setting.data);
+        ((CGUIEditControl *)pControl)->SetLabel2(strIndex);
+    }
   }
   else if (setting.type == SettingInfo::SEPARATOR && m_pOriginalSeparator)
   {
@@ -328,6 +402,28 @@
     delete pControl;
 }
 
+void CGUIDialogSettings::AddEdit(unsigned int id, int label, CStdString *str, bool enabled)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::EDIT;
+  setting.enabled  = enabled;
+  setting.data = str;
+  m_settings.push_back(setting);
+}
+
+void CGUIDialogSettings::AddNumEdit(unsigned int id, int label, int *current, bool enabled)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::EDIT_NUM;
+  setting.enabled  = enabled;
+  setting.data = current;
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddButton(unsigned int id, int label,bool bOn)
 {
   SettingInfo setting;
@@ -339,6 +435,17 @@
   m_settings.push_back(setting);
 }
 
+void CGUIDialogSettings::AddButton(unsigned int id, int label, CStdString *str, bool bOn)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::BUTTON;
+  setting.enabled  = bOn;
+  setting.data = str;
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddBool(unsigned int id, int label, bool *on, bool enabled)
 {
   SettingInfo setting;
@@ -350,6 +457,18 @@
   m_settings.push_back(setting);
 }
 
+void CGUIDialogSettings::AddSpin(unsigned int id, int label, int *current, unsigned int max, const SETTINGSTRINGS &entries)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::SPIN;
+  setting.data = current;
+  for (unsigned int i = 0; i < max; i++)
+    setting.entry.push_back(entries[i].c_str());
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddSpin(unsigned int id, int label, int *current, unsigned int max, const int *entries)
 {
   SettingInfo setting;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogSettings.h XBMC/xbmc/GUIDialogSettings.h
--- XBMC-unpatched/xbmc/GUIDialogSettings.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIDialogSettings.h	2009-04-04 20:52:44.000000000 +0200
@@ -22,17 +22,20 @@
  */
 
 #include "GUIDialog.h"
+#include "GUIEditControl.h"
 #include "GUISpinControlEx.h"
 #include "GUIRadioButtonControl.h"
 #include "GUIButtonControl.h"
 #include "GUISettingsSliderControl.h"
 
+typedef std::vector<CStdString> SETTINGSTRINGS;
+
 class CGUIImage;
 
 class SettingInfo
 {
 public:
-  enum SETTING_TYPE { NONE=0, BUTTON, CHECK, CHECK_UCHAR, SPIN, SLIDER, SLIDER_INT, SLIDER_ABS, SEPARATOR };
+  enum SETTING_TYPE { NONE=0, EDIT, EDIT_NUM, BUTTON, CHECK, CHECK_UCHAR, SPIN, SLIDER, SLIDER_INT, SLIDER_ABS, SEPARATOR };
   SettingInfo()
   {
     id = 0;
@@ -74,14 +77,20 @@
 
   void AddSetting(SettingInfo &setting, float width, int iControlID);
 
+  void AddEdit(unsigned int id, int label, CStdString *str, bool enabled = true);
+  void AddNumEdit(unsigned int id, int label, int *current, bool enabled = true);
   void AddButton(unsigned int it, int label, bool bOn=true);
+  void AddButton(unsigned int it, int label, CStdString *str, bool bOn=true);
   void AddBool(unsigned int id, int label, bool *on, bool enabled = true);
+  void AddSpin(unsigned int id, int label, int *current, unsigned int max, const SETTINGSTRINGS &entries);
   void AddSpin(unsigned int id, int label, int *current, unsigned int max, const int *entries);
   void AddSpin(unsigned int id, int label, int *current, unsigned int min, unsigned int max, const char* minLabel = NULL);
   void AddSlider(unsigned int id, int label, float *current, float min, float interval, float max, const char *format = NULL, bool absvalue=false);
   void AddSlider(unsigned int id, int label, int *current, int min, int max);
   void AddSeparator(unsigned int id);
 
+  CGUIEditControl *m_pOriginalEdit;
+  CGUIEditControl *m_pOriginalEditNum;
   CGUISpinControlEx *m_pOriginalSpin;
   CGUIRadioButtonControl *m_pOriginalRadioButton;
   CGUIButtonControl *m_pOriginalSettingsButton;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVChannels.cpp XBMC/xbmc/GUIDialogTVChannels.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVChannels.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVChannels.cpp	2009-04-11 07:29:04.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "GUIDialogTVChannels.h"
+#include "PVRManager.h"
+#include "Application.h"
+#include "Util.h"
+#include "Picture.h"
+#include "GUIDialogContextMenu.h"
+#include "GUIDialogOK.h"
+#include "GUIWindowManager.h"
+#include "ViewState.h"
+#include "Settings.h"
+#include "FileItem.h"
+
+using namespace std;
+
+#define CONTROL_LIST                  11
+
+CGUIDialogTVChannels::CGUIDialogTVChannels()
+    : CGUIDialog(WINDOW_DIALOG_TV_OSD_CHANNELS, "VideoOSDTVChannels.xml")
+{
+  m_vecItems = new CFileItemList;
+}
+
+CGUIDialogTVChannels::~CGUIDialogTVChannels()
+{
+  delete m_vecItems;
+}
+
+bool CGUIDialogTVChannels::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+  case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIWindow::OnMessage(message);
+      Update();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+
+      if (m_viewControl.HasControl(iControl))   // list/thumb control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        int iAction = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          GotoChannel(iItem);
+          return true;
+        }
+      }
+    }
+    break;
+
+  case GUI_MSG_SETFOCUS:
+    {
+      if (m_viewControl.HasControl(message.GetControlId()) && (DWORD) m_viewControl.GetCurrentControl() != message.GetControlId())
+      {
+        m_viewControl.SetFocused();
+        return true;
+      }
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogTVChannels::Update()
+{
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+  m_viewControl.SetCurrentView(DEFAULT_VIEW_LIST);
+
+  // empty the list ready for population
+  Clear();
+
+  if (CPVRManager::GetInstance()->IsPlayingTV())
+  {
+    CPVRManager::GetInstance()->GetTVChannels(m_vecItems, CPVRManager::GetInstance()->GetPlayingGroup(), false);
+  }
+  else if (CPVRManager::GetInstance()->IsPlayingRadio())
+  {
+    CPVRManager::GetInstance()->GetRadioChannels(m_vecItems, CPVRManager::GetInstance()->GetPlayingGroup(), false);
+  }
+
+  m_viewControl.SetItems(*m_vecItems);
+
+  m_viewControl.SetSelectedItem(CPVRManager::GetInstance()->GetCurrentChannel(CPVRManager::GetInstance()->IsPlayingRadio())-1);
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogTVChannels::Clear()
+{
+  m_viewControl.Clear();
+  m_vecItems->Clear();
+}
+
+void CGUIDialogTVChannels::GotoChannel(int item)
+{
+  /* Check file item is in list range and get his pointer */
+  if (item < 0 || item >= (int)m_vecItems->Size()) return;
+
+  CFileItemPtr pItem = m_vecItems->Get(item);
+
+  if (!g_application.PlayFile(*pItem))
+  {
+    CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+  }
+}
+
+void CGUIDialogTVChannels::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST));
+}
+
+void CGUIDialogTVChannels::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+CGUIControl *CGUIDialogTVChannels::GetFirstFocusableControl(int id)
+{
+  if (m_viewControl.HasControl(id))
+    id = m_viewControl.GetCurrentControl();
+
+  return CGUIWindow::GetFirstFocusableControl(id);
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVChannels.h XBMC/xbmc/GUIDialogTVChannels.h
--- XBMC-unpatched/xbmc/GUIDialogTVChannels.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVChannels.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,47 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialog.h"
+#include "GUIViewControl.h"
+
+class CFileItemList;
+
+class CGUIDialogTVChannels : public CGUIDialog
+{
+public:
+  CGUIDialogTVChannels(void);
+  virtual ~CGUIDialogTVChannels(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual void OnWindowLoaded();
+  virtual void OnWindowUnload();
+
+protected:
+  void GotoChannel(int iItem);
+  void Clear();
+  void Update();
+
+  CGUIControl *GetFirstFocusableControl(int id);
+
+  CFileItemList* m_vecItems;
+  CGUIViewControl m_viewControl;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVEPGProgInfo.cpp XBMC/xbmc/GUIDialogTVEPGProgInfo.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVEPGProgInfo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVEPGProgInfo.cpp	2009-04-11 07:29:19.000000000 +0200
@@ -0,0 +1,244 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+
+/* Standart includes */
+#include "stdafx.h"
+#include "Application.h"
+#include "GUIWindowManager.h"
+#include "GUISettings.h"
+#include "GUIDialogOK.h"
+#include "Util.h"
+
+/* self include */
+#include "GUIDialogTVEPGProgInfo.h"
+
+/* TV control */
+#include "PVRManager.h"
+
+/* TV information tags */
+#include "utils/TVEPGInfoTag.h"
+#include "utils/TVChannelInfoTag.h"
+#include "utils/TVRecordInfoTag.h"
+#include "utils/TVTimerInfoTag.h"
+
+/* Dialog windows includes */
+#include "GUIDialogProgress.h"
+#include "GUIDialogYesNo.h"
+#include "GUIDialogOK.h"
+#include "GUIDialogNumeric.h"
+#include "GUIDialogKeyboard.h"
+
+using namespace std;
+
+#define CONTROL_PROG_TITLE              20 // from db
+#define CONTROL_PROG_SUBTITLE           21
+#define CONTROL_PROG_STARTTIME          23
+#define CONTROL_PROG_DATE               24
+#define CONTROL_PROG_DURATION           25
+#define CONTROL_PROG_GENRE              26
+#define CONTROL_PROG_CHANNEL            27
+#define CONTROL_PROG_CHANNELCALLSIGN    28
+#define CONTROL_PROG_CHANNELNUM         29
+
+#define CONTROL_PROG_RECSTATUS          30 // from pvrmanager
+#define CONTROL_PROG_JOBSTATUS          31
+
+#define CONTROL_TEXTAREA                22
+
+#define CONTROL_BTN_SWITCH              5
+#define CONTROL_BTN_RECORD              6
+#define CONTROL_BTN_OK                  7
+
+
+CGUIDialogTVEPGProgInfo::CGUIDialogTVEPGProgInfo(void)
+    : CGUIDialog(WINDOW_DIALOG_TV_GUIDE_INFO, "DialogEPGProgInfo.xml")
+    , m_progItem(new CFileItem)
+{
+}
+
+CGUIDialogTVEPGProgInfo::~CGUIDialogTVEPGProgInfo(void)
+{
+}
+
+bool CGUIDialogTVEPGProgInfo::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+  {
+  }
+  break;
+  case GUI_MSG_WINDOW_INIT:
+  {
+    CGUIDialog::OnMessage(message);
+    m_viewDescription = true;
+    Update();
+    return true;
+  }
+
+  break;
+  case GUI_MSG_CLICKED:
+    int iControl = message.GetSenderId();
+    {
+      if (iControl == CONTROL_BTN_OK)
+      {
+        Close();
+        return true;
+      }
+      else if (iControl == CONTROL_BTN_RECORD)
+      {
+        int iChannel = m_progItem->GetTVEPGInfoTag()->m_channelNum;
+
+        if (iChannel != -1)
+        {
+          if (m_progItem->GetTVEPGInfoTag()->m_isRecording == false)
+          {
+            // prompt user for confirmation of channel record
+            CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+            if (pDialog)
+            {
+              pDialog->SetHeading(264);
+              pDialog->SetLine(0, "");
+              pDialog->SetLine(1, m_progItem->GetTVEPGInfoTag()->m_strTitle);
+              pDialog->SetLine(2, "");
+              pDialog->DoModal();
+
+              if (pDialog->IsConfirmed())
+              {
+                CTVTimerInfoTag newtimer(*m_progItem.get());
+                CFileItem *item = new CFileItem(newtimer);
+
+                if (CPVRManager::GetInstance()->AddTimer(*item))
+                {
+                  m_progItem->GetTVEPGInfoTag()->m_isRecording = true;
+                }
+              }
+            }
+          }
+          else
+          {
+            CGUIDialogOK::ShowAndGetInput(18100,18107,0,0);
+          }
+        }
+
+        Close();
+
+        return true;
+      }
+      else if (iControl == CONTROL_BTN_SWITCH)
+      {
+        Close();
+        {
+          CFileItemList channelslist;
+          int ret_channels;
+
+          if (!m_progItem->GetTVEPGInfoTag()->m_isRadio)
+            ret_channels = CPVRManager::GetInstance()->GetTVChannels(&channelslist, -1, false);
+          else
+            ret_channels = CPVRManager::GetInstance()->GetRadioChannels(&channelslist, -1, false);
+
+          if (ret_channels > 0)
+          {
+            if (!g_application.PlayFile(*channelslist[m_progItem->GetTVEPGInfoTag()->m_channelNum-1]))
+            {
+              CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+              return false;
+            }
+            return true;
+          }
+        }
+      }
+    }
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogTVEPGProgInfo::SetProgInfo(const CFileItem *item)
+{
+  *m_progItem = *item;
+}
+
+void CGUIDialogTVEPGProgInfo::Update()
+{
+  CStdString strTemp;
+  int minutes;
+
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_strTitle; strTemp.Trim();
+  SetLabel(CONTROL_PROG_TITLE, strTemp);
+
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_startTime.GetAsLocalizedDate(true); strTemp.Trim();
+  SetLabel(CONTROL_PROG_DATE, strTemp);
+
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_startTime.GetAsLocalizedTime("", false); strTemp.Trim();
+  SetLabel(CONTROL_PROG_STARTTIME, strTemp);
+
+  minutes = m_progItem->GetTVEPGInfoTag()->m_duration.GetMinutes();
+  minutes += m_progItem->GetTVEPGInfoTag()->m_duration.GetHours()*60;
+  strTemp.Format("%i", minutes);
+  strTemp.Trim();
+  SetLabel(CONTROL_PROG_DURATION, strTemp);
+
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_strGenre; strTemp.Trim();
+  SetLabel(CONTROL_PROG_GENRE, strTemp);
+
+  strTemp = CPVRManager::GetInstance()->GetNameForChannel(m_progItem->GetTVEPGInfoTag()->m_channelNum);
+  strTemp.Trim();
+  SetLabel(CONTROL_PROG_CHANNEL, strTemp);
+
+  int i = m_progItem->GetTVEPGInfoTag()->m_channelNum;
+  strTemp.Format("%u", m_progItem->GetTVEPGInfoTag()->m_channelNum); // int value
+  SetLabel(CONTROL_PROG_CHANNELNUM, strTemp);
+
+  // programme subtitle
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_strPlotOutline; strTemp.Trim();
+
+  if (strTemp.IsEmpty())
+  {
+    SET_CONTROL_HIDDEN(CONTROL_PROG_SUBTITLE);
+  }
+  else
+  {
+    SetLabel(CONTROL_PROG_SUBTITLE, strTemp);
+    SET_CONTROL_VISIBLE(CONTROL_PROG_SUBTITLE);
+  }
+
+  // programme description
+  strTemp = m_progItem->GetTVEPGInfoTag()->m_strPlot; strTemp.Trim();
+
+  SetLabel(CONTROL_TEXTAREA, strTemp);
+
+  SET_CONTROL_VISIBLE(CONTROL_BTN_RECORD);
+}
+
+void CGUIDialogTVEPGProgInfo::SetLabel(int iControl, const CStdString &strLabel)
+{
+  if (strLabel.IsEmpty())
+  {
+    SET_CONTROL_LABEL(iControl, 416); /// disable instead? // "Not available"
+  }
+  else
+  {
+    SET_CONTROL_LABEL(iControl, strLabel);
+  }
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVEPGProgInfo.h XBMC/xbmc/GUIDialogTVEPGProgInfo.h
--- XBMC-unpatched/xbmc/GUIDialogTVEPGProgInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVEPGProgInfo.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,52 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogSettings.h"
+#include "GUIListItem.h"
+#include "DateTime.h"
+
+#include "GUIDialog.h"
+#include "GUIListItem.h"
+
+class CFileItem;
+
+class CGUIDialogTVEPGProgInfo : public CGUIDialog
+{
+public:
+  CGUIDialogTVEPGProgInfo(void);
+  virtual ~CGUIDialogTVEPGProgInfo(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  void SetProgInfo(const CFileItem *item);
+
+  virtual CFileItemPtr GetCurrentListItem(int offset = 0) { return m_progItem; }
+
+  virtual bool HasListItems() const { return true; };
+
+protected:
+  void Update();
+  void SetLabel(int iControl, const CStdString& strLabel);
+
+  CFileItemPtr        m_progItem;
+  bool                m_viewDescription;
+};
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVGroupManager.cpp XBMC/xbmc/GUIDialogTVGroupManager.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVGroupManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVGroupManager.cpp	2009-04-11 07:30:21.000000000 +0200
@@ -0,0 +1,280 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "GUIDialogTVGroupManager.h"
+#include "PVRManager.h"
+#include "Application.h"
+#include "Util.h"
+#include "Picture.h"
+#include "GUIDialogContextMenu.h"
+#include "GUIDialogKeyboard.h"
+#include "GUIDialogYesNo.h"
+#include "GUIDialogOK.h"
+#include "GUIWindowManager.h"
+#include "ViewState.h"
+#include "Settings.h"
+#include "FileItem.h"
+
+using namespace std;
+
+#define CONTROL_LIST_CHANNELS_LEFT    11
+#define CONTROL_LIST_CHANNELS_RIGHT   12
+#define CONTROL_LIST_CHANNEL_GROUPS   13
+
+#define CONTROL_CURRENT_GROUP_LABEL   20
+
+#define BUTTON_NEWGROUP               26
+#define BUTTON_RENAMEGROUP            27
+#define BUTTON_DELGROUP               28
+#define BUTTON_OK                     29
+
+CGUIDialogTVGroupManager::CGUIDialogTVGroupManager()
+    : CGUIDialog(WINDOW_DIALOG_TV_GROUP_MANAGER, "DialogTVGroupManager.xml")
+{
+  m_channelLeftItems  = new CFileItemList;
+  m_channelRightItems = new CFileItemList;
+  m_channelGroupItems = new CFileItemList;
+}
+
+CGUIDialogTVGroupManager::~CGUIDialogTVGroupManager()
+{
+  delete m_channelLeftItems;
+  delete m_channelRightItems;
+  delete m_channelGroupItems;
+}
+
+bool CGUIDialogTVGroupManager::OnMessage(CGUIMessage& message)
+{
+  unsigned int iControl = 0;
+  unsigned int iMessage = message.GetMessage();
+
+  switch (iMessage)
+  {
+
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+    case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIWindow::OnMessage(message);
+      m_iSelectedLeft = 0;
+      m_iSelectedRight = 0;
+      m_iSelectedGroup = 0;
+      Update();
+      return true;
+    }
+    break;
+
+    case GUI_MSG_CLICKED:
+    {
+      iControl = message.GetSenderId();
+
+      if (iControl == BUTTON_OK)
+      {
+        Close();
+      }
+      else if (iControl == BUTTON_NEWGROUP)
+      {
+        CStdString strDescription = "";
+        if (CGUIDialogKeyboard::ShowAndGetInput(strDescription, g_localizeStrings.Get(18130), false))
+        {
+          if (strDescription != "")
+          {
+            CPVRManager::GetInstance()->AddGroup(strDescription);
+            Update();
+          }
+        }
+      }
+      else if (iControl == BUTTON_DELGROUP && m_channelGroupItems->GetFileCount() != 0)
+      {
+        m_iSelectedGroup      = m_viewControlGroup.GetSelectedItem();
+        CFileItemPtr pItemGroup   = m_channelGroupItems->Get(m_iSelectedGroup);
+
+        // prompt user for confirmation of channel record
+        CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+        if (pDialog)
+        {
+          pDialog->SetHeading(117);
+          pDialog->SetLine(0, "");
+          pDialog->SetLine(1, CPVRManager::GetInstance()->GetGroupName(atoi(pItemGroup->m_strPath.c_str())));
+          pDialog->SetLine(2, "");
+          pDialog->DoModal();
+
+          if (pDialog->IsConfirmed())
+          {
+            CPVRManager::GetInstance()->DeleteGroup(atoi(pItemGroup->m_strPath.c_str()));
+            Update();
+          }
+        }
+        return true;
+      }
+      else if (iControl == BUTTON_RENAMEGROUP && m_channelGroupItems->GetFileCount() != 0)
+      {
+        if (CGUIDialogKeyboard::ShowAndGetInput(m_CurrentGroupName, g_localizeStrings.Get(18130), false))
+        {
+          if (m_CurrentGroupName != "")
+          {
+            CPVRManager::GetInstance()->RenameGroup(atoi(m_channelGroupItems->Get(m_iSelectedGroup)->m_strPath.c_str()), m_CurrentGroupName);
+          }
+          Update();
+        }
+      }
+      else if (m_viewControlLeft.HasControl(iControl))   // list/thumb control
+      {
+        m_iSelectedLeft = m_viewControlLeft.GetSelectedItem();
+        int iAction         = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          if (m_channelGroupItems->GetFileCount() == 0)
+          {
+            CGUIDialogOK::ShowAndGetInput(18100,18135,0,18136);
+          }
+          else if (m_channelLeftItems->GetFileCount() > 0)
+          {
+            CFileItemPtr pItemGroup   = m_channelGroupItems->Get(m_iSelectedGroup);
+            CFileItemPtr pItemChannel = m_channelLeftItems->Get(m_iSelectedLeft);
+            CPVRManager::GetInstance()->ChannelToGroup(pItemChannel->GetTVChannelInfoTag()->m_iChannelNum, atoi(pItemGroup->m_strPath.c_str()), m_bIsRadio);
+            Update();
+          }
+          return true;
+        }
+      }
+      else if (m_viewControlRight.HasControl(iControl))   // list/thumb control
+      {
+        m_iSelectedRight = m_viewControlRight.GetSelectedItem();
+        int iAction          = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          if (m_channelRightItems->GetFileCount() > 0)
+          {
+            CFileItemPtr pItemChannel = m_channelRightItems->Get(m_iSelectedRight);
+            CPVRManager::GetInstance()->ChannelToGroup(pItemChannel->GetTVChannelInfoTag()->m_iChannelNum, 0, m_bIsRadio);
+            Update();
+          }
+          return true;
+        }
+      }
+      else if (m_viewControlGroup.HasControl(iControl))   // list/thumb control
+      {
+        int iAction      = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          m_iSelectedGroup = m_viewControlGroup.GetSelectedItem();
+          Update();
+          return true;
+        }
+      }
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogTVGroupManager::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+
+  m_viewControlLeft.Reset();
+  m_viewControlLeft.SetParentWindow(GetID());
+  m_viewControlLeft.AddView(GetControl(CONTROL_LIST_CHANNELS_LEFT));
+
+  m_viewControlRight.Reset();
+  m_viewControlRight.SetParentWindow(GetID());
+  m_viewControlRight.AddView(GetControl(CONTROL_LIST_CHANNELS_RIGHT));
+
+  m_viewControlGroup.Reset();
+  m_viewControlGroup.SetParentWindow(GetID());
+  m_viewControlGroup.AddView(GetControl(CONTROL_LIST_CHANNEL_GROUPS));
+}
+
+void CGUIDialogTVGroupManager::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControlLeft.Reset();
+  m_viewControlRight.Reset();
+  m_viewControlGroup.Reset();
+}
+
+void CGUIDialogTVGroupManager::Update()
+{
+  m_CurrentGroupName = "";
+
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+  m_viewControlLeft.SetCurrentView(CONTROL_LIST_CHANNELS_LEFT);
+  m_viewControlRight.SetCurrentView(CONTROL_LIST_CHANNELS_RIGHT);
+  m_viewControlGroup.SetCurrentView(CONTROL_LIST_CHANNEL_GROUPS);
+
+  // empty the lists ready for population
+  Clear();
+
+  int groups = CPVRManager::GetInstance()->GetGroupList(m_channelGroupItems);
+  m_viewControlGroup.SetItems(*m_channelGroupItems);
+  m_viewControlGroup.SetSelectedItem(m_iSelectedGroup);
+
+  if (!m_bIsRadio)
+    CPVRManager::GetInstance()->GetTVChannels(m_channelLeftItems, 0, false);
+  else
+    CPVRManager::GetInstance()->GetRadioChannels(m_channelLeftItems, 0, false);
+  m_viewControlLeft.SetItems(*m_channelLeftItems);
+  m_viewControlLeft.SetSelectedItem(m_iSelectedLeft);
+
+  if (groups > 0)
+  {
+    CFileItemPtr pItem = m_channelGroupItems->Get(m_viewControlGroup.GetSelectedItem());
+    m_CurrentGroupName = pItem->m_strTitle;
+    SET_CONTROL_LABEL(CONTROL_CURRENT_GROUP_LABEL, m_CurrentGroupName);
+
+    if (!m_bIsRadio)
+      CPVRManager::GetInstance()->GetTVChannels(m_channelRightItems, atoi(pItem->m_strPath.c_str()), false);
+    else
+      CPVRManager::GetInstance()->GetRadioChannels(m_channelRightItems, atoi(pItem->m_strPath.c_str()), false);
+    m_viewControlRight.SetItems(*m_channelRightItems);
+    m_viewControlRight.SetSelectedItem(m_iSelectedRight);
+  }
+
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogTVGroupManager::Clear()
+{
+  m_viewControlLeft.Clear();
+  m_viewControlRight.Clear();
+  m_viewControlGroup.Clear();
+
+  m_channelLeftItems->Clear();
+  m_channelRightItems->Clear();
+  m_channelGroupItems->Clear();
+}
+
+void CGUIDialogTVGroupManager::SetRadio(bool IsRadio)
+{
+  m_bIsRadio = IsRadio;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVGroupManager.h XBMC/xbmc/GUIDialogTVGroupManager.h
--- XBMC-unpatched/xbmc/GUIDialogTVGroupManager.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVGroupManager.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,55 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialog.h"
+#include "GUIViewControl.h"
+
+class CFileItemList;
+
+class CGUIDialogTVGroupManager : public CGUIDialog
+{
+public:
+  CGUIDialogTVGroupManager(void);
+  virtual ~CGUIDialogTVGroupManager(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual void OnWindowLoaded();
+  virtual void OnWindowUnload();
+  void SetRadio(bool IsRadio);
+
+protected:
+  CStdString m_CurrentGroupName;
+  unsigned int m_iSelectedLeft;
+  unsigned int m_iSelectedRight;
+  unsigned int m_iSelectedGroup;
+  bool m_bIsRadio;
+  void Clear();
+  void Update();
+
+  CFileItemList* m_channelLeftItems;
+  CFileItemList* m_channelRightItems;
+  CFileItemList* m_channelGroupItems;
+
+  CGUIViewControl m_viewControlLeft;
+  CGUIViewControl m_viewControlRight;
+  CGUIViewControl m_viewControlGroup;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVGuide.cpp XBMC/xbmc/GUIDialogTVGuide.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVGuide.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVGuide.cpp	2009-04-14 17:23:20.000000000 +0200
@@ -0,0 +1,171 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "GUIDialogTVGuide.h"
+#include "PVRManager.h"
+#include "Application.h"
+#include "Util.h"
+#include "Picture.h"
+#include "GUIDialogContextMenu.h"
+#include "GUIDialogOK.h"
+#include "GUIDialogTVEPGProgInfo.h"
+#include "GUIWindowManager.h"
+#include "ViewState.h"
+#include "Settings.h"
+#include "FileItem.h"
+
+using namespace std;
+
+#define CONTROL_LIST                  11
+
+CGUIDialogTVGuide::CGUIDialogTVGuide()
+    : CGUIDialog(WINDOW_DIALOG_TV_OSD_GUIDE, "VideoOSDTVGuide.xml")
+{
+  m_vecItems = new CFileItemList;
+}
+
+CGUIDialogTVGuide::~CGUIDialogTVGuide()
+{
+  delete m_vecItems;
+}
+
+bool CGUIDialogTVGuide::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+  case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIWindow::OnMessage(message);
+      Update();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+
+      if (m_viewControl.HasControl(iControl))   // list/thumb control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        int iAction = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          ShowInfo(iItem);
+          return true;
+        }
+      }
+    }
+    break;
+
+  case GUI_MSG_SETFOCUS:
+    {
+      if (m_viewControl.HasControl(message.GetControlId()) && (DWORD) m_viewControl.GetCurrentControl() != message.GetControlId())
+      {
+        m_viewControl.SetFocused();
+        return true;
+      }
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogTVGuide::Update()
+{
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+  m_viewControl.SetCurrentView(DEFAULT_VIEW_LIST);
+
+  // empty the list ready for population
+  Clear();
+
+  if (CPVRManager::GetInstance()->IsPlayingTV())
+  {
+    int curChannel = CPVRManager::GetInstance()->GetCurrentChannel(false);
+    CPVRManager::GetInstance()->GetEPGChannel(curChannel, m_vecItems, false);
+  }
+  else if (CPVRManager::GetInstance()->IsPlayingRadio())
+  {
+    int curChannel = CPVRManager::GetInstance()->GetCurrentChannel(true);
+    CPVRManager::GetInstance()->GetEPGChannel(curChannel, m_vecItems, true);
+  }
+
+  m_viewControl.SetItems(*m_vecItems);
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogTVGuide::Clear()
+{
+  m_viewControl.Clear();
+  m_vecItems->Clear();
+}
+
+void CGUIDialogTVGuide::ShowInfo(int item)
+{
+  /* Check file item is in list range and get his pointer */
+  if (item < 0 || item >= (int)m_vecItems->Size()) return;
+
+  CFileItemPtr pItem = m_vecItems->Get(item);
+
+  /* Load programme info dialog */
+  CGUIDialogTVEPGProgInfo* pDlgInfo = (CGUIDialogTVEPGProgInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_GUIDE_INFO);
+
+  if (!pDlgInfo)
+    return;
+
+  /* inform dialog about the file item */
+  pDlgInfo->SetProgInfo(pItem.get());
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+}
+
+void CGUIDialogTVGuide::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST));
+}
+
+void CGUIDialogTVGuide::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+CGUIControl *CGUIDialogTVGuide::GetFirstFocusableControl(int id)
+{
+  if (m_viewControl.HasControl(id))
+    id = m_viewControl.GetCurrentControl();
+
+  return CGUIWindow::GetFirstFocusableControl(id);
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVGuide.h XBMC/xbmc/GUIDialogTVGuide.h
--- XBMC-unpatched/xbmc/GUIDialogTVGuide.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVGuide.h	2009-04-14 17:15:17.000000000 +0200
@@ -0,0 +1,47 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialog.h"
+#include "GUIViewControl.h"
+
+class CFileItemList;
+
+class CGUIDialogTVGuide : public CGUIDialog
+{
+public:
+  CGUIDialogTVGuide(void);
+  virtual ~CGUIDialogTVGuide(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual void OnWindowLoaded();
+  virtual void OnWindowUnload();
+
+protected:
+  void ShowInfo(int iItem);
+  void Clear();
+  void Update();
+
+  CGUIControl *GetFirstFocusableControl(int id);
+
+  CFileItemList* m_vecItems;
+  CGUIViewControl m_viewControl;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVRecordingInfo.cpp XBMC/xbmc/GUIDialogTVRecordingInfo.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVRecordingInfo.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVRecordingInfo.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+
+/* Standart includes */
+#include "stdafx.h"
+#include "Application.h"
+#include "GUIWindowManager.h"
+#include "GUISettings.h"
+#include "Util.h"
+
+/* self include */
+#include "GUIDialogTVRecordingInfo.h"
+
+/* TV control */
+#include "PVRManager.h"
+
+/* TV information tags */
+#include "utils/TVEPGInfoTag.h"
+#include "utils/TVChannelInfoTag.h"
+#include "utils/TVRecordInfoTag.h"
+#include "utils/TVTimerInfoTag.h"
+
+/* Dialog windows includes */
+#include "GUIDialogProgress.h"
+#include "GUIDialogYesNo.h"
+#include "GUIDialogOK.h"
+#include "GUIDialogNumeric.h"
+#include "GUIDialogKeyboard.h"
+
+using namespace std;
+
+#define CONTROL_REC_TITLE               20 // from db
+#define CONTROL_REC_SUBTITLE            21
+#define CONTROL_REC_STARTTIME           23
+#define CONTROL_REC_DATE                24
+#define CONTROL_REC_DURATION            25
+#define CONTROL_REC_GENRE               26
+#define CONTROL_REC_CHANNEL             27
+
+#define CONTROL_TEXTAREA                22
+
+#define CONTROL_BTN_OK                  10
+
+
+CGUIDialogTVRecordingInfo::CGUIDialogTVRecordingInfo(void)
+    : CGUIDialog(WINDOW_DIALOG_TV_RECORDING_INFO, "DialogRecordingInfo.xml")
+    , m_recordItem(new CFileItem)
+{
+}
+
+CGUIDialogTVRecordingInfo::~CGUIDialogTVRecordingInfo(void)
+{
+}
+
+bool CGUIDialogTVRecordingInfo::OnMessage(CGUIMessage& message)
+{
+
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+  {
+  }
+  break;
+  case GUI_MSG_WINDOW_INIT:
+  {
+    CGUIDialog::OnMessage(message);
+    Update();
+    return true;
+  }
+  break;
+  case GUI_MSG_CLICKED:
+    int iControl = message.GetSenderId();
+    {
+      if (iControl == CONTROL_BTN_OK)
+      {
+        Close();
+        return true;
+      }
+    }
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogTVRecordingInfo::SetRecording(const CFileItem *item)
+{
+  *m_recordItem = *item;
+}
+
+void CGUIDialogTVRecordingInfo::Update()
+{
+  CStdString strTemp;
+  int minutes;
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_strTitle; strTemp.Trim();
+  SetLabel(CONTROL_REC_TITLE, strTemp);
+
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_startTime.GetAsLocalizedDate(true); strTemp.Trim();
+  SetLabel(CONTROL_REC_DATE, strTemp);
+
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_startTime.GetAsLocalizedTime("", false); strTemp.Trim();
+  SetLabel(CONTROL_REC_STARTTIME, strTemp);
+
+  minutes = m_recordItem->GetTVRecordingInfoTag()->m_duration.GetMinutes();
+  minutes += m_recordItem->GetTVRecordingInfoTag()->m_duration.GetHours()*60;
+  strTemp.Format("%i", minutes);
+  strTemp.Trim();
+  SetLabel(CONTROL_REC_DURATION, strTemp);
+
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_strGenre; strTemp.Trim();
+  SetLabel(CONTROL_REC_GENRE, strTemp);
+
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_strChannel; strTemp.Trim();
+  SetLabel(CONTROL_REC_CHANNEL, strTemp);
+
+  // programme subtitle
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_strPlotOutline; strTemp.Trim();
+
+  if (strTemp.IsEmpty())
+  {
+    SET_CONTROL_HIDDEN(CONTROL_REC_SUBTITLE);
+  }
+  else
+  {
+    SetLabel(CONTROL_REC_SUBTITLE, strTemp);
+    SET_CONTROL_VISIBLE(CONTROL_REC_SUBTITLE);
+  }
+
+  // programme description
+  strTemp = m_recordItem->GetTVRecordingInfoTag()->m_strPlot; strTemp.Trim();
+
+  SetLabel(CONTROL_TEXTAREA, strTemp);
+}
+
+void CGUIDialogTVRecordingInfo::SetLabel(int iControl, const CStdString &strLabel)
+{
+  if (strLabel.IsEmpty())
+  {
+    SET_CONTROL_LABEL(iControl, 416); /// disable instead? // "Not available"
+  }
+  else
+  {
+    SET_CONTROL_LABEL(iControl, strLabel);
+  }
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVRecordingInfo.h XBMC/xbmc/GUIDialogTVRecordingInfo.h
--- XBMC-unpatched/xbmc/GUIDialogTVRecordingInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVRecordingInfo.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,49 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogSettings.h"
+#include "GUIListItem.h"
+#include "DateTime.h"
+
+#include "GUIDialog.h"
+#include "GUIListItem.h"
+
+class CFileItem;
+
+class CGUIDialogTVRecordingInfo : public CGUIDialog
+{
+public:
+  CGUIDialogTVRecordingInfo(void);
+  virtual ~CGUIDialogTVRecordingInfo(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  void SetRecording(const CFileItem *item);
+  virtual CFileItemPtr GetCurrentListItem(int offset = 0) { return m_recordItem; }
+  virtual bool HasListItems() const { return true; };
+
+protected:
+  void Update();
+  void SetLabel(int iControl, const CStdString& strLabel);
+
+  CFileItemPtr        m_recordItem;
+};
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVTimerSettings.cpp XBMC/xbmc/GUIDialogTVTimerSettings.cpp
--- XBMC-unpatched/xbmc/GUIDialogTVTimerSettings.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVTimerSettings.cpp	2009-04-11 22:15:57.000000000 +0200
@@ -0,0 +1,454 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "GUIDialogTVTimerSettings.h"
+#include "GUIDialogKeyboard.h"
+#include "GUIDialogNumeric.h"
+#include "GUISettings.h"
+#include "PVRManager.h"
+#include "utils/TVTimerInfoTag.h"
+
+using namespace std;
+
+#define CONTROL_TMR_ACTIVE              20
+#define CONTROL_TMR_CHNAME_TV           21
+#define CONTROL_TMR_DAY                 22
+#define CONTROL_TMR_BEGIN               23
+#define CONTROL_TMR_END                 24
+#define CONTROL_TMR_PRIORITY            26
+#define CONTROL_TMR_LIFETIME            27
+#define CONTROL_TMR_FIRST_DAY           28
+#define CONTROL_TMR_NAME                29
+#define CONTROL_TMR_RADIO               50
+#define CONTROL_TMR_CHNAME_RADIO        51
+
+CGUIDialogTVTimerSettings::CGUIDialogTVTimerSettings(void)
+    : CGUIDialogSettings(WINDOW_DIALOG_TV_TIMER_SETTING, "DialogTimerSettings.xml")
+{
+  m_cancelled         = true;
+  m_tmp_day           = 11;
+  m_tmp_iStartTime    = 0;
+  m_tmp_iStopTime     = 0;
+}
+
+CGUIDialogTVTimerSettings::~CGUIDialogTVTimerSettings(void)
+{
+}
+
+void CGUIDialogTVTimerSettings::CreateSettings()
+{
+  CTVTimerInfoTag* tag = m_timerItem->GetTVTimerInfoTag();
+
+  // clear out any old settings
+  m_settings.clear();
+
+  // create our settings controls
+  AddBool(CONTROL_TMR_ACTIVE, 18401, &tag->m_Active);
+  AddButton(CONTROL_TMR_NAME, 18063, &tag->m_strTitle, true);
+  AddBool(CONTROL_TMR_RADIO, 18409, &tag->m_Radio);
+
+  /// Channel names
+  {
+    // For TV
+    CFileItemList channelslist_tv;
+    SETTINGSTRINGS channelstrings_tv;
+    CPVRManager::GetInstance()->GetTVChannels(&channelslist_tv, -1, false);
+
+    channelstrings_tv.push_back("0 dummy");
+
+    for (int i = 0; i < channelslist_tv.Size(); i++)
+    {
+      CStdString string;
+      CFileItemPtr item = channelslist_tv[i];
+      string.Format("%i %s", item->GetTVChannelInfoTag()->m_iChannelNum, item->GetTVChannelInfoTag()->m_strChannel.c_str());
+      channelstrings_tv.push_back(string);
+    }
+
+    AddSpin(CONTROL_TMR_CHNAME_TV, 18402, &tag->m_channelNum, channelstrings_tv.size(), channelstrings_tv);
+    EnableSettings(CONTROL_TMR_CHNAME_TV, !tag->m_Radio);
+
+	// For Radio
+    CFileItemList channelslist_radio;
+    SETTINGSTRINGS channelstrings_radio;
+    CPVRManager::GetInstance()->GetRadioChannels(&channelslist_radio, -1, false);
+
+    channelstrings_radio.push_back("0 dummy");
+
+    for (int i = 0; i < channelslist_radio.Size(); i++)
+    {
+      CStdString string;
+      CFileItemPtr item = channelslist_radio[i];
+      string.Format("%i %s", item->GetTVChannelInfoTag()->m_iChannelNum, item->GetTVChannelInfoTag()->m_strChannel.c_str());
+      channelstrings_radio.push_back(string);
+    }
+
+    AddSpin(CONTROL_TMR_CHNAME_RADIO, 18402, &tag->m_channelNum, channelstrings_radio.size(), channelstrings_radio);
+    EnableSettings(CONTROL_TMR_CHNAME_RADIO, tag->m_Radio);
+  }
+
+  /// Day
+  {
+    SETTINGSTRINGS daystrings;
+    tm time_cur;
+    tm time_tmr;
+
+    daystrings.push_back(g_localizeStrings.Get(18300));
+    daystrings.push_back(g_localizeStrings.Get(18301));
+    daystrings.push_back(g_localizeStrings.Get(18302));
+    daystrings.push_back(g_localizeStrings.Get(18303));
+    daystrings.push_back(g_localizeStrings.Get(18304));
+    daystrings.push_back(g_localizeStrings.Get(18305));
+    daystrings.push_back(g_localizeStrings.Get(18306));
+    daystrings.push_back(g_localizeStrings.Get(18307));
+    daystrings.push_back(g_localizeStrings.Get(18308));
+    daystrings.push_back(g_localizeStrings.Get(18309));
+    daystrings.push_back(g_localizeStrings.Get(18310));
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = tag->m_StartTime;
+
+    /* get diffence of timer in days between today and timer start date */
+    time.GetAsTm(time_cur);
+    timestart.GetAsTm(time_tmr);
+
+    if (time_tmr.tm_yday - time_cur.tm_yday >= 0)
+      m_tmp_day += time_tmr.tm_yday - time_cur.tm_yday;
+    else
+      m_tmp_day += time_tmr.tm_yday - time_cur.tm_yday + 365;
+
+    for (int i = 1; i < 365; ++i)
+    {
+      CStdString string = time.GetAsLocalizedDate();
+      daystrings.push_back(string);
+      time += CDateTimeSpan(1, 0, 0, 0);
+    }
+
+    if (tag->m_Repeat)
+    {
+      if (tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+          !tag->m_Repeat_Thu && !tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+          !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 0;
+      }
+      else if (!tag->m_Repeat_Mon &&  tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu && !tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 1;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue &&  tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu && !tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 2;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               tag->m_Repeat_Thu && !tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 3;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu &&  tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 4;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu && !tag->m_Repeat_Fri && tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 5;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu && !tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 6;
+      }
+      else if (tag->m_Repeat_Mon && tag->m_Repeat_Tue && tag->m_Repeat_Wed &&
+               tag->m_Repeat_Thu && tag->m_Repeat_Fri && !tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 7;
+      }
+      else if (tag->m_Repeat_Mon && tag->m_Repeat_Tue && tag->m_Repeat_Wed &&
+               tag->m_Repeat_Thu && tag->m_Repeat_Fri && tag->m_Repeat_Sat &&
+               !tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 8;
+      }
+      else if (tag->m_Repeat_Mon && tag->m_Repeat_Tue && tag->m_Repeat_Wed &&
+               tag->m_Repeat_Thu && tag->m_Repeat_Fri && tag->m_Repeat_Sat &&
+               tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 9;
+      }
+      else if (!tag->m_Repeat_Mon && !tag->m_Repeat_Tue && !tag->m_Repeat_Wed &&
+               !tag->m_Repeat_Thu && !tag->m_Repeat_Fri &&  tag->m_Repeat_Sat &&
+               tag->m_Repeat_Sun)
+      {
+        m_tmp_day = 10;
+      }
+    }
+
+    AddSpin(CONTROL_TMR_DAY, 18403, &m_tmp_day, daystrings.size(), daystrings);
+  }
+
+  AddButton(CONTROL_TMR_BEGIN, 18404, &timerStartTimeStr, true);
+  AddButton(CONTROL_TMR_END, 18405, &timerEndTimeStr, true);
+  AddSpin(CONTROL_TMR_PRIORITY, 18406, &tag->m_Priority, 0, 99);
+  AddSpin(CONTROL_TMR_LIFETIME, 18407, &tag->m_Lifetime, 0, 365);
+
+  /// First day
+  {
+    SETTINGSTRINGS daystrings;
+    tm time_cur;
+    tm time_tmr;
+
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = tag->m_FirstDay;
+
+    /* get diffence of timer in days between today and timer start date */
+
+    if (time < timestart)
+    {
+      time.GetAsTm(time_cur);
+      timestart.GetAsTm(time_tmr);
+
+      if (time_tmr.tm_yday - time_cur.tm_yday >= 0)
+      {
+        m_tmp_iFirstDay += time_tmr.tm_yday - time_cur.tm_yday + 1;
+      }
+      else
+      {
+        m_tmp_iFirstDay += time_tmr.tm_yday - time_cur.tm_yday + 365 + 1;
+      }
+    }
+
+    daystrings.push_back(g_localizeStrings.Get(18150));
+
+    for (int i = 1; i < 365; ++i)
+    {
+      CStdString string = time.GetAsLocalizedDate();
+      daystrings.push_back(string);
+      time += CDateTimeSpan(1, 0, 0, 0);
+    }
+
+    AddSpin(CONTROL_TMR_FIRST_DAY, 18408, &m_tmp_iFirstDay, daystrings.size(), daystrings);
+
+    if (tag->m_Repeat)
+      EnableSettings(CONTROL_TMR_FIRST_DAY, true);
+    else
+      EnableSettings(CONTROL_TMR_FIRST_DAY, false);
+  }
+}
+
+void CGUIDialogTVTimerSettings::OnSettingChanged(unsigned int num)
+{
+  // setting has changed - update anything that needs it
+  if (num >= m_settings.size()) return;
+
+  SettingInfo &setting = m_settings.at(num);
+
+  CTVTimerInfoTag* tag = m_timerItem->GetTVTimerInfoTag();
+
+  if (setting.id == CONTROL_TMR_NAME)
+  {
+    if (CGUIDialogKeyboard::ShowAndGetInput(tag->m_strTitle, g_localizeStrings.Get(18207), false))
+    {
+      UpdateSetting(CONTROL_TMR_NAME);
+    }
+  }
+  else if (setting.id == CONTROL_TMR_RADIO)
+  {
+    EnableSettings(CONTROL_TMR_CHNAME_TV, !tag->m_Radio);
+    EnableSettings(CONTROL_TMR_CHNAME_RADIO, tag->m_Radio);
+    tag->m_strChannel = CPVRManager::GetInstance()->GetNameForChannel(tag->m_channelNum, tag->m_Radio);
+    tag->m_clientNum = CPVRManager::GetInstance()->GetClientChannelNumber(tag->m_channelNum, tag->m_Radio);
+  }
+  else if (setting.id == CONTROL_TMR_CHNAME_TV || setting.id == CONTROL_TMR_CHNAME_RADIO)
+  {
+    tag->m_strChannel = CPVRManager::GetInstance()->GetNameForChannel(tag->m_channelNum, tag->m_Radio);
+    tag->m_clientNum = CPVRManager::GetInstance()->GetClientChannelNumber(tag->m_channelNum, tag->m_Radio);
+  }
+  else if (setting.id == CONTROL_TMR_DAY && m_tmp_day > 10)
+  {
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = timerStartTime;
+	CDateTime timestop = timerEndTime;
+    int m_tmp_diff;
+    tm time_cur;
+    tm time_tmr;
+
+    /* get diffence of timer in days between today and timer start date */
+    time.GetAsTm(time_cur);
+    timestart.GetAsTm(time_tmr);
+
+    if (time_tmr.tm_yday - time_cur.tm_yday >= 0)
+      m_tmp_diff = time_tmr.tm_yday - time_cur.tm_yday;
+    else
+      m_tmp_diff = time_tmr.tm_yday - time_cur.tm_yday + 365;
+
+    tag->m_StartTime = timestart + CDateTimeSpan(m_tmp_day-11-m_tmp_diff, 0, 0, 0);
+    tag->m_StopTime  = timestop  + CDateTimeSpan(m_tmp_day-11-m_tmp_diff, 0, 0, 0);
+
+	EnableSettings(CONTROL_TMR_FIRST_DAY, false);
+
+	tag->m_Repeat = false;
+    tag->m_Repeat_Mon = false;
+    tag->m_Repeat_Tue = false;
+    tag->m_Repeat_Wed = false;
+    tag->m_Repeat_Thu = false;
+    tag->m_Repeat_Fri = false;
+    tag->m_Repeat_Sat = false;
+    tag->m_Repeat_Sun = false;
+  }
+  else if (setting.id == CONTROL_TMR_DAY && m_tmp_day <= 10)
+  {
+    EnableSettings(CONTROL_TMR_FIRST_DAY, true);
+    tag->m_Repeat = true;
+    tag->m_Repeat_Mon = false;
+    tag->m_Repeat_Tue = false;
+    tag->m_Repeat_Wed = false;
+    tag->m_Repeat_Thu = false;
+    tag->m_Repeat_Fri = false;
+    tag->m_Repeat_Sat = false;
+    tag->m_Repeat_Sun = false;
+
+    if (m_tmp_day == 0)
+    {
+      tag->m_Repeat_Mon = true;
+    }
+    else if (m_tmp_day == 1)
+    {
+      tag->m_Repeat_Tue = true;
+    }
+    else if (m_tmp_day == 2)
+    {
+      tag->m_Repeat_Wed = true;
+    }
+    else if (m_tmp_day == 3)
+    {
+      tag->m_Repeat_Thu = true;
+    }
+    else if (m_tmp_day == 4)
+    {
+      tag->m_Repeat_Fri = true;
+    }
+    else if (m_tmp_day == 5)
+    {
+      tag->m_Repeat_Sat = true;
+    }
+    else if (m_tmp_day == 6)
+    {
+      tag->m_Repeat_Sun = true;
+    }
+    else if (m_tmp_day == 7)
+    {
+      tag->m_Repeat_Mon = true;
+      tag->m_Repeat_Tue = true;
+      tag->m_Repeat_Wed = true;
+      tag->m_Repeat_Thu = true;
+      tag->m_Repeat_Fri = true;
+    }
+    else if (m_tmp_day == 8)
+    {
+      tag->m_Repeat_Mon = true;
+      tag->m_Repeat_Tue = true;
+      tag->m_Repeat_Wed = true;
+      tag->m_Repeat_Thu = true;
+      tag->m_Repeat_Fri = true;
+      tag->m_Repeat_Sat = true;
+    }
+    else if (m_tmp_day == 9)
+    {
+      tag->m_Repeat_Mon = true;
+      tag->m_Repeat_Tue = true;
+      tag->m_Repeat_Wed = true;
+      tag->m_Repeat_Thu = true;
+      tag->m_Repeat_Fri = true;
+      tag->m_Repeat_Sat = true;
+      tag->m_Repeat_Sun = true;
+    }
+    else if (m_tmp_day == 10)
+    {
+      tag->m_Repeat_Sat = true;
+      tag->m_Repeat_Sun = true;
+    }
+  }
+  else if (setting.id == CONTROL_TMR_BEGIN)
+  {
+    if (CGUIDialogNumeric::ShowAndGetTime(timerStartTime, g_localizeStrings.Get(14066)))
+    {
+      CDateTime timestart = timerStartTime;
+      int start_day       = tag->m_StartTime.GetDay();
+      int start_month     = tag->m_StartTime.GetMonth();
+      int start_year      = tag->m_StartTime.GetYear();
+      int start_hour      = timestart.GetHour();
+      int start_minute    = timestart.GetMinute();
+      tag->m_StartTime.SetDateTime(start_year, start_month, start_day, start_hour, start_minute, 0);
+
+	  timerStartTimeStr = tag->m_StartTime.GetAsLocalizedTime("", false);
+	  UpdateSetting(CONTROL_TMR_BEGIN);
+    }
+  }
+  else if (setting.id == CONTROL_TMR_END)
+  {
+    if (CGUIDialogNumeric::ShowAndGetTime(timerEndTime, g_localizeStrings.Get(14066)))
+    {
+	  CDateTime timestop = timerEndTime;
+      int start_day       = tag->m_StopTime.GetDay();
+      int start_month     = tag->m_StopTime.GetMonth();
+      int start_year      = tag->m_StopTime.GetYear();
+      int start_hour      = timestop.GetHour();
+      int start_minute    = timestop.GetMinute();
+      tag->m_StopTime.SetDateTime(start_year, start_month, start_day, start_hour, start_minute, 0);
+
+      timerEndTimeStr = tag->m_StopTime.GetAsLocalizedTime("", false);
+	  UpdateSetting(CONTROL_TMR_END);
+    }
+  }
+  else if (setting.id == CONTROL_TMR_FIRST_DAY && m_tmp_day <= 10)
+  {
+    if (m_tmp_iFirstDay > 0)
+      tag->m_FirstDay = CDateTime::GetCurrentDateTime() + CDateTimeSpan(m_tmp_iFirstDay-1, 0, 0, 0);
+    else
+      tag->m_FirstDay = NULL;
+  }
+}
+
+void CGUIDialogTVTimerSettings::SetTimer(CFileItem *item)
+{
+  m_timerItem         = item;
+  m_cancelled         = true;
+
+  m_timerItem->GetTVTimerInfoTag()->m_StartTime.GetAsSystemTime(timerStartTime);
+  m_timerItem->GetTVTimerInfoTag()->m_StopTime.GetAsSystemTime(timerEndTime);
+  timerStartTimeStr   = m_timerItem->GetTVTimerInfoTag()->m_StartTime.GetAsLocalizedTime("", false);
+  timerEndTimeStr     = m_timerItem->GetTVTimerInfoTag()->m_StopTime.GetAsLocalizedTime("", false);
+
+  m_tmp_iStartTime    = 0;
+  m_tmp_iStopTime     = 0;
+  m_tmp_iFirstDay     = 0;
+  m_tmp_day           = 11;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIDialogTVTimerSettings.h XBMC/xbmc/GUIDialogTVTimerSettings.h
--- XBMC-unpatched/xbmc/GUIDialogTVTimerSettings.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIDialogTVTimerSettings.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,58 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogSettings.h"
+#include "GUIListItem.h"
+#include "DateTime.h"
+
+class CFileItem;
+
+class CGUIDialogTVTimerSettings : public CGUIDialogSettings
+{
+public:
+  CGUIDialogTVTimerSettings(void);
+  virtual ~CGUIDialogTVTimerSettings(void);
+  void SetTimer(CFileItem *item);
+  bool GetOK() { return !m_cancelled; }
+
+protected:
+  virtual void CreateSettings();
+  virtual void OnSettingChanged(unsigned int setting);
+  virtual void OnOkay() { m_cancelled = false; }
+  virtual void OnCancel() { m_cancelled = true; }
+
+  SYSTEMTIME	  timerStartTime;
+  SYSTEMTIME	  timerEndTime;
+  CStdString	  timerStartTimeStr;
+  CStdString	  timerEndTimeStr;
+  int             m_tmp_iStartTime;
+  int             m_tmp_iStopTime;
+  int             m_tmp_iFirstDay;;
+
+  int             m_tmp_day;
+
+
+  CFileItem      *m_timerItem;
+  bool            m_cancelled;
+};
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIMediaWindow.cpp XBMC/xbmc/GUIMediaWindow.cpp
--- XBMC-unpatched/xbmc/GUIMediaWindow.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIMediaWindow.cpp	2009-04-22 18:25:41.000000000 +0200
@@ -40,8 +40,8 @@
 #include "GUIImage.h"
 #include "GUIMultiImage.h"
 #include "GUIDialogSmartPlaylistEditor.h"
-#include "GUIDialogPluginSettings.h"
-#include "PluginSettings.h"
+#include "GUIDialogAddonSettings.h"
+#include "settings/AddonSettings.h"
 #include "GUIWindowManager.h"
 #include "GUIDialogOK.h"
 #include "PlayList.h"
@@ -1226,7 +1226,7 @@
 
   if (item->IsPlugin() && item->IsFileFolder())
   {
-    if (CPluginSettings::SettingsExist(item->m_strPath))
+    if (CAddonSettings::SettingsExist(item->m_strPath))
       buttons.Add(CONTEXT_BUTTON_PLUGIN_SETTINGS, 1045);
   }
 
@@ -1256,7 +1256,7 @@
   case CONTEXT_BUTTON_PLUGIN_SETTINGS:
     {
       CURL url(m_vecItems->Get(itemNumber)->m_strPath);
-      CGUIDialogPluginSettings::ShowAndGetInput(url);
+      CGUIDialogAddonSettings::ShowAndGetInput(url);
       return true;
     }
   case CONTEXT_BUTTON_USER1:
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUISettings.cpp XBMC/xbmc/GUISettings.cpp
--- XBMC-unpatched/xbmc/GUISettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUISettings.cpp	2009-04-22 18:25:41.000000000 +0200
@@ -38,11 +38,14 @@
 using namespace std;
 
 // String id's of the masks
+#define MASK_DAYS   17999
+#define MASK_HOURS  17998
 #define MASK_MINS   14044
 #define MASK_SECS   14045
 #define MASK_MS    14046
 #define MASK_PERCENT 14047
 #define MASK_KBPS   14048
+#define MASK_MB    17997
 #define MASK_KB    14049
 #define MASK_DB    14050
 
@@ -425,6 +428,11 @@
   AddString(12, "videolibrary.export", 647, "", BUTTON_CONTROL_STANDARD);
   AddString(13, "videolibrary.import", 648, "", BUTTON_CONTROL_STANDARD);
 
+  AddCategory(5, "pvrmanager", 18000);
+  AddBool(1, "pvrmanager.enabled", 449  , false);
+  AddString(2, "pvrmanager.pvrsources", 18001, "", BUTTON_CONTROL_STANDARD);
+  AddSeparator(3, "pvrmanager.sep1");
+
   AddCategory(5, "videoplayer", 16003);
   AddString(1, "videoplayer.calibrate", 214, "", BUTTON_CONTROL_STANDARD);
   AddString(2, "videoplayer.jumptoaudiohardware", 16001, "", BUTTON_CONTROL_STANDARD);
@@ -660,6 +668,36 @@
   AddBool(9, "screensaver.slideshowshuffle", 13319, false);
 
   AddPath(0,"system.playlistspath",20006,"set default",BUTTON_CONTROL_PATH_INPUT,false);
+
+  // tv settings (access over TV menu from home window)
+  AddGroup(8, 18000);
+  AddCategory(8,"pvrmenu", 18004);
+  AddInt(1, "pvrmenu.daystodisplay", 18005, 2, 1, 1, 4, SPIN_CONTROL_INT_PLUS, MASK_DAYS);
+  AddInt(2, "pvrmenu.lingertime", 18006, 0, 0, 30, 960, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddBool(3, "pvrmenu.showradio", 18008, true);
+  AddBool(4, "pvrmenu.infoswitch", 18010, true);
+  AddBool(5, "pvrmenu.infotimeout", 18011, true);
+  AddInt(6, "pvrmenu.infotime", 18009, 5, 1, 1, 10, SPIN_CONTROL_INT_PLUS, MASK_SECS);
+  AddBool(7, "pvrmenu.hidevideolength", 18024, true);
+  AddString(8, "pvrmenu.iconpath", 18012, "", BUTTON_CONTROL_PATH_INPUT, false, 657);
+  AddSeparator(9, "pvrmenu.sep1");
+  AddInt(10, "pvrmenu.scantime", 18025, 5, 1, 1, 15, SPIN_CONTROL_INT_PLUS, MASK_SECS);
+
+  AddCategory(8,"pvrepg", 18013);
+  AddInt(1, "pvrepg.epgscan", 18014, 5, 1, 1, 24, SPIN_CONTROL_INT_PLUS, MASK_HOURS);
+  AddInt(2, "pvrepg.epgupdate", 18015, 60, 15, 15, 240, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddInt(3, "pvrepg.daystosave", 18016, 7, 1, 1, 180, SPIN_CONTROL_INT_PLUS, MASK_DAYS);
+
+  AddCategory(8,"pvrrecord", 18017);
+  AddInt(1, "pvrrecord.instantrecordtime", 18018, 180, 1, 1, 720, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddInt(2, "pvrrecord.defaultpriority", 18019, 50, 1, 1, 100, SPIN_CONTROL_INT_PLUS);
+  AddInt(3, "pvrrecord.defaultlifetime", 18020, 99, 1, 1, 365, SPIN_CONTROL_INT_PLUS, MASK_DAYS);
+  AddInt(4, "pvrrecord.marginstart", 18021, 2, 1, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddInt(5, "pvrrecord.marginstop", 18022, 10, 1, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddSeparator(6, "pvrrecord.sep1");
+  AddBool(7, "pvrrecord.timeshift", 18107, false);
+  AddInt(8, "pvrrecord.timeshiftcache", 18108, 512, 0, 16, 2048, SPIN_CONTROL_INT_PLUS, MASK_MB, TEXT_OFF);
+  AddString(9, "pvrrecord.timeshiftpath", 18123, "", BUTTON_CONTROL_PATH_INPUT, false, 657);
 }
 
 CGUISettings::~CGUISettings(void)
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowFullScreen.cpp XBMC/xbmc/GUIWindowFullScreen.cpp
--- XBMC-unpatched/xbmc/GUIWindowFullScreen.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIWindowFullScreen.cpp	2009-04-15 05:24:38.000000000 +0200
@@ -35,8 +35,10 @@
 #include "GUITextLayout.h"
 #include "GUIWindowManager.h"
 #include "GUIDialogFullScreenInfo.h"
+#include "GUIDialogNumeric.h"
 #include "Settings.h"
 #include "FileItem.h"
+#include "PVRManager.h"
 
 #include <stdio.h>
 
@@ -193,23 +195,83 @@
     break;
 
   case ACTION_STEP_BACK:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasTVChannelInfoTag())
+      {
+        int current_group = CPVRManager::GetInstance()->GetPlayingGroup();
+        current_group = CPVRManager::GetInstance()->GetPrevGroupID(current_group);
+        CPVRManager::GetInstance()->SetPlayingGroup(current_group);
+
+        CAction action;
+        action.wID = ACTION_CHANNEL_SWITCH;
+        action.fAmount1 = CPVRManager::GetInstance()->GetFirstChannelForGroupID(current_group);
+        OnAction(action);
+      }
+      else
+      {
     Seek(false, false);
     return true;
+      }
+    }
     break;
 
   case ACTION_STEP_FORWARD:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasTVChannelInfoTag())
+      {
+        int current_group = CPVRManager::GetInstance()->GetPlayingGroup();
+        current_group = CPVRManager::GetInstance()->GetNextGroupID(current_group);
+        CPVRManager::GetInstance()->SetPlayingGroup(current_group);
+
+        CAction action;
+        action.wID = ACTION_CHANNEL_SWITCH;
+        action.fAmount1 = CPVRManager::GetInstance()->GetFirstChannelForGroupID(current_group);
+        OnAction(action);
+      }
+      else
+      {
     Seek(true, false);
     return true;
+      }
+    }
     break;
 
   case ACTION_BIG_STEP_BACK:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasTVChannelInfoTag())
+      {
+        CAction action;
+        action.wID = ACTION_PREV_ITEM;
+        OnAction(action);
+        return true;
+      }
+      else
+      {
     Seek(false, true);
     return true;
+      }
+    }
     break;
 
   case ACTION_BIG_STEP_FORWARD:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasTVChannelInfoTag())
+      {
+        CAction action;
+        action.wID = ACTION_NEXT_ITEM;
+        OnAction(action);
+        return true;
+      }
+      else
+      {
     Seek(true, true);
     return true;
+      }
+    }
     break;
 
   case ACTION_NEXT_SCENE:
@@ -244,6 +306,7 @@
       CGUIDialogFullScreenInfo* pDialog = (CGUIDialogFullScreenInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_FULLSCREEN_INFO);
       if (pDialog)
       {
+        CFileItem item(g_application.CurrentFileItem());
         pDialog->DoModal();
         return true;
       }
@@ -316,8 +379,29 @@
   case REMOTE_7:
   case REMOTE_8:
   case REMOTE_9:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasTVChannelInfoTag())
+      {
+        CStdString strChannel;
+        strChannel.Format("%i", action.wID - REMOTE_0);
+        if (CGUIDialogNumeric::ShowAndGetNumber(strChannel, g_localizeStrings.Get(18109)))
+        {
+          int channelNr = atoi(strChannel.c_str());
+          if (channelNr > 0)
+          {
+            CAction action;
+            action.wID = ACTION_CHANNEL_SWITCH;
+            action.fAmount1 = channelNr;
+            OnAction(action);
+          }
+        }
+      }
+      else {
     ChangetheTimeCode(action.wID);
+      }
     return true;
+    }
     break;
 
   case ACTION_ASPECT_RATIO:
@@ -504,10 +588,14 @@
   }
   if (g_Mouse.bClick[MOUSE_LEFT_BUTTON])
   { // no control found to absorb this click - pause video
+    CFileItem item(g_application.CurrentFileItem());
+    if (!item.HasTVChannelInfoTag() || g_guiSettings.GetBool("pvrrecord.timeshift"))
+	{
     CAction action;
     action.wID = ACTION_PAUSE;
     return g_application.OnAction(action);
   }
+  }
   if (g_Mouse.HasMoved())
   { // movement - toggle the OSD
     CGUIWindowOSD *pOSD = (CGUIWindowOSD *)m_gWindowManager.GetWindow(WINDOW_OSD);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowOSD.cpp XBMC/xbmc/GUIWindowOSD.cpp
--- XBMC-unpatched/xbmc/GUIWindowOSD.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIWindowOSD.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -46,7 +46,11 @@
     // check for movement of mouse or a submenu open
     if (g_Mouse.HasMoved() || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_AUDIO_OSD_SETTINGS)
                            || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_VIDEO_OSD_SETTINGS)
-                           || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_VIDEO_BOOKMARKS))
+                           || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_VIDEO_BOOKMARKS)
+						   || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_TV_OSD_CHANNELS)
+						   || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_TV_OSD_GUIDE)
+						   || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_TV_OSD_TELETEXT)
+                           || m_gWindowManager.IsWindowActive(WINDOW_DIALOG_TV_OSD_DIRECTOR))
       SetAutoClose(3000);
   }
   CGUIDialog::Render();
@@ -98,6 +102,14 @@
       if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
       pDialog = (CGUIDialog *)m_gWindowManager.GetWindow(WINDOW_DIALOG_VIDEO_BOOKMARKS);
       if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_OSD_CHANNELS);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_OSD_GUIDE);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_OSD_TELETEXT);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_OSD_DIRECTOR);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
     }
     break;
   }
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowSettingsCategory.cpp XBMC/xbmc/GUIWindowSettingsCategory.cpp
--- XBMC-unpatched/xbmc/GUIWindowSettingsCategory.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIWindowSettingsCategory.cpp	2009-04-18 09:16:18.000000000 +0200
@@ -52,6 +52,7 @@
 #include "GUIDialogGamepad.h"
 #include "GUIDialogNumeric.h"
 #include "GUIDialogFileBrowser.h"
+#include "GUIDialogAddonBrowser.h"
 #include "GUIFontManager.h"
 #include "GUIDialogContextMenu.h"
 #include "GUIDialogKeyboard.h"
@@ -123,7 +124,7 @@
   m_pOriginalImage = NULL;
   m_pOriginalEdit = NULL;
   // set the correct ID range...
-  m_dwIDRange = 8;
+  m_dwIDRange = 9;
   m_iScreen = 0;
   // set the network settings so that we don't reset them unnecessarily
   m_iNetworkAssignment = -1;
@@ -1031,6 +1032,12 @@
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
       if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("upnp.server"));
     }
+	else if (!strSetting.Equals("pvrmanager.enabled")
+      && strSetting.Left(4).Equals("pvrmanager."))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrmanager.enabled"));
+    }
     else if (!strSetting.Equals("remoteevents.enabled")
              && strSetting.Left(13).Equals("remoteevents."))
     {
@@ -1371,6 +1378,21 @@
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
       if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("lookandfeel.enablerssfeeds"));
     }
+    else if (strSetting.Equals("pvrrecord.timeshiftcache") || strSetting.Equals("pvrrecord.timeshiftpath"))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrrecord.timeshift"));
+    }
+    else if (strSetting.Equals("pvrmenu.infotimeout"))
+    { // only visible if infoswitch is enabled
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrmenu.infoswitch"));
+    }
+    else if (strSetting.Equals("pvrmenu.infotime"))
+    { // only visible if infoswitch is enabled
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrmenu.infoswitch") && g_guiSettings.GetBool("pvrmenu.infotimeout"));
+    }
   }
 }
 
@@ -2082,7 +2104,7 @@
     if (CGUIDialogFileBrowser::ShowAndGetDirectory(g_settings.m_pictureSources, g_localizeStrings.Get(pSettingString->m_iHeadingString), path))
       pSettingString->SetData(path);
   }
-  else if (strSetting.Equals("pictures.screenshotpath") || strSetting.Equals("mymusic.recordingpath") || strSetting.Equals("cddaripper.path") || strSetting.Equals("subtitles.custompath"))
+  else if ((strSetting.Equals("pictures.screenshotpath") || strSetting.Equals("mymusic.recordingpath") || strSetting.Equals("cddaripper.path") || strSetting.Equals("subtitles.custompath")) || strSetting.Equals("pvrmenu.iconpath") || strSetting.Equals("pvrrecord.timeshiftpath"))
   {
     CSettingString *pSettingString = (CSettingString *)pSettingControl->GetSetting();
     CStdString path = g_guiSettings.GetString(strSetting,false);
@@ -2094,7 +2116,11 @@
     UpdateSettings();
     bool bWriteOnly = true;
 
-    if (strSetting.Equals("subtitles.custompath"))
+    if (strSetting.Equals("pvrmenu.iconpath"))
+    {
+      bWriteOnly = false;
+    }
+    else if (strSetting.Equals("subtitles.custompath"))
     {
       bWriteOnly = false;
       shares = g_settings.m_videoSources;
@@ -2273,6 +2299,26 @@
     else
       g_settings.LoadUPnPXml(filename);
   }
+  else if (strSetting.Equals("pvrmanager.enabled"))
+  {
+    if (g_guiSettings.GetBool("pvrmanager.enabled"))
+      g_application.StartPVRManager();
+    else
+      g_application.StopPVRManager();
+  }
+  else if (strSetting.Equals("pvrmanager.pvrsources"))
+  {
+    if (CGUIDialogAddonBrowser::ShowAndGetAddons(ADDON::ADDON_PVRDLL, true))
+    { // save the new list
+      g_settings.SaveAddons();
+      g_application.StopPVRManager();
+      g_application.StartPVRManager();
+    }
+    else
+    { // reload the existing list
+      g_settings.LoadAddons();
+    }
+  }
   else if (strSetting.Equals("masterlock.lockcode"))
   {
     // Now Prompt User to enter the old and then the new MasterCode!
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowTV.cpp XBMC/xbmc/GUIWindowTV.cpp
--- XBMC-unpatched/xbmc/GUIWindowTV.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIWindowTV.cpp	2009-04-15 05:20:18.000000000 +0200
@@ -0,0 +1,1934 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/* Standart includes */
+#include "stdafx.h"
+#include "Application.h"
+#include "GUIWindowManager.h"
+#include "URL.h"
+#include "MediaManager.h"
+
+/* Dialog windows includes */
+#include "GUIDialogFileBrowser.h"
+#include "GUIDialogProgress.h"
+#include "GUIDialogYesNo.h"
+#include "GUIDialogOK.h"
+#include "GUIDialogNumeric.h"
+#include "GUIDialogKeyboard.h"
+#include "GUIDialogTVEPGProgInfo.h"
+#include "GUIDialogTVRecordingInfo.h"
+#include "GUIDialogTVTimerSettings.h"
+#include "GUIDialogTVGroupManager.h"
+
+/* self include */
+#include "GUIWindowTV.h"
+
+/* TV control */
+#include "PVRManager.h"
+
+
+using namespace std;
+
+#define CONTROL_LIST_TIMELINE        10
+#define CONTROL_LIST_CHANNELS_TV     11
+#define CONTROL_LIST_CHANNELS_RADIO  12
+#define CONTROL_LIST_RECORDINGS      13
+#define CONTROL_LIST_TIMERS          14
+#define CONTROL_LIST_GUIDE_CHANNEL   15
+#define CONTROL_LIST_GUIDE_NOW_NEXT  16
+
+#define CONTROL_DISKSIZE             20
+#define CONTROL_NEXTTIMER            21
+
+#define CONTROL_LABELHEADER          29
+#define CONTROL_LABELEMPTY           30
+
+#define CONTROL_BTNGUIDE             31
+#define CONTROL_BTNCHANNELS_TV       32
+#define CONTROL_BTNCHANNELS_RADIO    33
+#define CONTROL_BTNRECORDINGS        34
+#define CONTROL_BTNTIMERS            35
+#define CONTROL_BTNSETTINGS          36
+
+#define CONTROL_INFO_BACKEND         40
+#define CONTROL_INFO_VERSION         41
+#define CONTROL_INFO_ADDRESS         42
+#define CONTROL_INFO_DISKSIZE        43
+#define CONTROL_INFO_CHANNELS        44
+#define CONTROL_INFO_RECORDINGS      45
+#define CONTROL_INFO_TIMERS          46
+
+#define CONTROL_AREA_GUIDE           9001
+#define CONTROL_AREA_CHANNELS_TV     9002
+#define CONTROL_AREA_CHANNELS_RADIO  9003
+#define CONTROL_AREA_RECORDINGS      9004
+#define CONTROL_AREA_TIMERS          9005
+#define CONTROL_AREA_INFO            9006
+
+
+#define GUIDE_VIEW_CHANNEL          0
+#define GUIDE_VIEW_NOW              1
+#define GUIDE_VIEW_NEXT             2
+#define GUIDE_VIEW_TIMELINE         3
+
+/**
+ * \brief Class constructor
+ */
+CGUIWindowTV::CGUIWindowTV(void) : CGUIMediaWindow(WINDOW_TV, "MyTV.xml")
+{
+  m_iCurrSubTVWindow              = TV_WINDOW_UNKNOWN;
+  m_iSavedSubTVWindow             = TV_WINDOW_UNKNOWN;
+  m_iSelected_GUIDE               = 0;
+  m_iSelected_CHANNELS_TV         = 0;
+  m_iSelected_CHANNELS_RADIO      = 0;
+  m_iSelected_RECORDINGS          = 0;
+  m_iSelected_TIMERS              = 0;
+  m_iCurrentTVGroup               = -1;
+  m_iCurrentRadioGroup            = -1;
+  m_bShowHiddenChannels           = false;
+  m_iGuideView                    = GUIDE_VIEW_CHANNEL;
+  m_guideGrid                     = NULL;
+}
+
+/**
+ * \brief Class destructor
+ */
+CGUIWindowTV::~CGUIWindowTV()
+{
+}
+
+/**
+ * \brief GUI action handler
+ * \param const CAction &action     = GUI action class
+ * \return bool                     = true if ok
+ * Info:
+ * Actions handled:
+ * ACTION_PREVIOUS_MENU             goes to previous window
+ */
+bool CGUIWindowTV::OnAction(const CAction &action)
+{
+  if (action.wID == ACTION_MOVE_LEFT || action.wID == ACTION_MOVE_RIGHT)
+  {
+    if (GetFocusedControlID() == CONTROL_BTNGUIDE)
+    {
+      if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+      {
+        SET_CONTROL_FOCUS(CONTROL_LIST_GUIDE_CHANNEL, 0);
+      }
+      else if (m_iGuideView == GUIDE_VIEW_NOW)
+      {
+        SET_CONTROL_FOCUS(CONTROL_LIST_GUIDE_NOW_NEXT, 0);
+      }
+      else if (m_iGuideView == GUIDE_VIEW_NEXT)
+      {
+        SET_CONTROL_FOCUS(CONTROL_LIST_GUIDE_NOW_NEXT, 0);
+      }
+      else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+      {
+        SET_CONTROL_FOCUS(CONTROL_LIST_TIMELINE, 0);
+      }
+
+      return true;
+    }
+  }
+  else if (action.wID == ACTION_PREVIOUS_MENU)
+  {
+    m_gWindowManager.PreviousWindow();
+    return true;
+  }
+
+  return CGUIMediaWindow::OnAction(action);
+}
+
+/**
+ * \brief GUI message handler
+ * \param CGUIMessage& message      = GUI message class
+ * \return bool                     = true if ok
+ */
+bool CGUIWindowTV::OnMessage(CGUIMessage& message)
+{
+  unsigned int iControl = 0;
+  unsigned int iMessage = message.GetMessage();
+
+  if (iMessage == GUI_MSG_WINDOW_INIT)
+  {
+    /* Check for connected PVR backend server, if no connection is present
+       show message window and go back */
+    if (!CPVRManager::GetInstance()->IsConnected())
+    {
+      m_gWindowManager.PreviousWindow();
+      CGUIDialogOK::ShowAndGetInput(18090,18091,0,18092);
+      return true;
+    }
+
+    if (!CPVRManager::GetInstance()->IsSynchronized())
+    {
+      m_gWindowManager.PreviousWindow();
+      CGUIDialogOK::ShowAndGetInput(18100,18133,0,330);
+      return true;
+    }
+  }
+  else if (iMessage == GUI_MSG_WINDOW_DEINIT)
+  {
+    /* Save current Subwindow selected list position */
+    if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_GUIDE_CHANNEL);
+		g_graphicsContext.SendMessage(msg);
+		m_iSelected_GUIDE = msg.GetParam1();
+      }
+      else if (m_iGuideView == GUIDE_VIEW_NOW || m_iGuideView == GUIDE_VIEW_NEXT)
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT);
+		g_graphicsContext.SendMessage(msg);
+		m_iSelected_GUIDE = msg.GetParam1();
+      }
+      else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMELINE);
+		g_graphicsContext.SendMessage(msg);
+		m_iSelected_GUIDE = msg.GetParam1();
+      }
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_TV);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected_CHANNELS_TV = msg.GetParam1();
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_RADIO);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected_CHANNELS_RADIO = msg.GetParam1();
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_RECORDINGS);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected_RECORDINGS = msg.GetParam1();
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMERS);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected_TIMERS = msg.GetParam1();
+    }
+
+    m_iSavedSubTVWindow = m_iCurrSubTVWindow;
+    m_iCurrSubTVWindow  = TV_WINDOW_UNKNOWN;
+  }
+  else if (iMessage == GUI_MSG_FOCUSED)
+  {
+    /* Get the focused control Identifier */
+    iControl = message.GetControlId();
+
+    /* Process Identifier for focused Subwindow select buttons or list item.
+     * If a new conrol becomes highlighted load his subwindow data
+     */
+
+    if (iControl == CONTROL_BTNGUIDE || m_iSavedSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_INFO);
+
+      if (m_iCurrSubTVWindow != TV_WINDOW_TV_PROGRAM)
+      {
+        m_iCurrSubTVWindow = TV_WINDOW_TV_PROGRAM;
+
+        UpdateGuide();
+        UpdateButtons();
+      }
+      else
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMELINE);
+        g_graphicsContext.SendMessage(msg);
+        m_iSelected_GUIDE = msg.GetParam1();
+      }
+
+      SET_CONTROL_VISIBLE(CONTROL_AREA_GUIDE);
+    }
+    else if (iControl == CONTROL_BTNCHANNELS_TV || m_iSavedSubTVWindow == TV_WINDOW_CHANNELS_TV)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_AREA_GUIDE);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_INFO);
+
+      if (m_iCurrSubTVWindow != TV_WINDOW_CHANNELS_TV)
+      {
+        m_iCurrSubTVWindow = TV_WINDOW_CHANNELS_TV;
+
+        UpdateChannelsTV();
+        UpdateButtons();
+      }
+      else
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_TV);
+        g_graphicsContext.SendMessage(msg);
+        m_iSelected_CHANNELS_TV = msg.GetParam1();
+      }
+
+      SET_CONTROL_VISIBLE(CONTROL_AREA_CHANNELS_TV);
+    }
+    else if (iControl == CONTROL_BTNCHANNELS_RADIO || m_iSavedSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_AREA_GUIDE);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_INFO);
+
+      if (m_iCurrSubTVWindow != TV_WINDOW_CHANNELS_RADIO)
+      {
+        m_iCurrSubTVWindow = TV_WINDOW_CHANNELS_RADIO;
+
+        UpdateChannelsRadio();
+        UpdateButtons();
+      }
+      else
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_RADIO);
+        g_graphicsContext.SendMessage(msg);
+        m_iSelected_CHANNELS_RADIO = msg.GetParam1();
+      }
+
+      SET_CONTROL_VISIBLE(CONTROL_AREA_CHANNELS_RADIO);
+    }
+    else if (iControl == CONTROL_BTNRECORDINGS || m_iSavedSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_AREA_GUIDE);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_INFO);
+
+      if (m_iCurrSubTVWindow != TV_WINDOW_RECORDINGS)
+      {
+        m_iCurrSubTVWindow = TV_WINDOW_RECORDINGS;
+
+        UpdateRecordings();
+        UpdateButtons();
+      }
+      else
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_RECORDINGS);
+        g_graphicsContext.SendMessage(msg);
+        m_iSelected_RECORDINGS = msg.GetParam1();
+      }
+
+      SET_CONTROL_VISIBLE(CONTROL_AREA_RECORDINGS);
+    }
+    else if (iControl == CONTROL_BTNTIMERS || m_iSavedSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_AREA_GUIDE);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_INFO);
+
+      if (m_iCurrSubTVWindow != TV_WINDOW_TIMERS)
+      {
+        m_iCurrSubTVWindow = TV_WINDOW_TIMERS;
+
+        UpdateTimers();
+        UpdateButtons();
+      }
+      else
+      {
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMERS);
+        g_graphicsContext.SendMessage(msg);
+        m_iSelected_TIMERS = msg.GetParam1();
+      }
+
+      SET_CONTROL_VISIBLE(CONTROL_AREA_TIMERS);
+    }
+    else if (iControl == CONTROL_BTNSETTINGS || m_iSavedSubTVWindow == TV_WINDOW_SETTINGS)
+    {
+      m_iCurrSubTVWindow = TV_WINDOW_SETTINGS;
+
+      CStdString strLabel;
+      CURL m_connString = CPVRManager::GetInstance()->GetConnString();
+
+      strLabel = CPVRManager::GetInstance()->GetBackendName();
+      SET_CONTROL_LABEL(CONTROL_INFO_BACKEND, strLabel);
+
+      strLabel = CPVRManager::GetInstance()->GetBackendVersion();
+      SET_CONTROL_LABEL(CONTROL_INFO_VERSION, strLabel);
+
+      strLabel.Format("%s:%d", (const char*)m_connString.GetHostName(), m_connString.GetPort());
+      SET_CONTROL_LABEL(CONTROL_INFO_ADDRESS, strLabel);
+
+      long long m_iDisktotal = 1024;
+      long long m_iDiskused  = 1024;
+      int       m_iPercent   = -1;
+      CPVRManager::GetInstance()->GetDriveSpace(&m_iDisktotal, &m_iDiskused, &m_iPercent);
+      m_iDisktotal /= 1024; // Convert to MBytes
+      m_iDiskused /= 1024;  // Convert to MBytes
+
+#ifdef _LINUX
+      if (m_iPercent >= 0 && m_iPercent <= 100)
+		strLabel.Format("%s %0.f GByte - %s: %0.f GByte (%i %)", g_localizeStrings.Get(18055), (float) m_iDisktotal / 1024, g_localizeStrings.Get(156), (float) m_iDiskused / 1024, m_iPercent);
+      else
+#endif
+		strLabel.Format("%s %0.f GByte - %s: %0.f GByte", g_localizeStrings.Get(18055), (float) m_iDisktotal / 1024, g_localizeStrings.Get(156), (float) m_iDiskused / 1024);
+
+      SET_CONTROL_LABEL(CONTROL_INFO_DISKSIZE, strLabel);
+
+      strLabel.Format("%i", CPVRManager::GetInstance()->GetNumChannels());
+      SET_CONTROL_LABEL(CONTROL_INFO_CHANNELS, strLabel);
+
+      strLabel.Format("%i", CPVRManager::GetInstance()->GetNumRecordings());
+      SET_CONTROL_LABEL(CONTROL_INFO_RECORDINGS, strLabel);
+
+      strLabel.Format("%i", CPVRManager::GetInstance()->GetNumTimers());
+      SET_CONTROL_LABEL(CONTROL_INFO_TIMERS, strLabel);
+
+      strLabel.Format("%s - %s", g_localizeStrings.Get(9), g_localizeStrings.Get(5));
+      SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+
+      SET_CONTROL_HIDDEN(CONTROL_AREA_GUIDE);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+      SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+      SET_CONTROL_VISIBLE(CONTROL_AREA_INFO);
+    }
+
+    if (m_iSavedSubTVWindow != TV_WINDOW_UNKNOWN)
+    {
+      m_iSavedSubTVWindow = TV_WINDOW_UNKNOWN;
+    }
+  }
+  else if (iMessage == GUI_MSG_CLICKED)
+  {
+    iControl = message.GetSenderId();
+
+    if (iControl == CONTROL_BTNGUIDE)
+    {
+      m_iGuideView++;
+
+      if (m_iGuideView > GUIDE_VIEW_TIMELINE)
+      {
+        m_iGuideView = 0;
+      }
+
+      UpdateGuide();
+    }
+    else if (iControl == CONTROL_BTNCHANNELS_TV)
+    {
+      m_iCurrentTVGroup = CPVRManager::GetInstance()->GetNextGroupID(m_iCurrentTVGroup);
+      UpdateChannelsTV();
+    }
+    else if (iControl == CONTROL_BTNCHANNELS_RADIO)
+    {
+      m_iCurrentRadioGroup = CPVRManager::GetInstance()->GetNextGroupID(m_iCurrentRadioGroup);
+      UpdateChannelsRadio();
+    }
+    else if (iControl == CONTROL_LIST_TIMELINE ||
+             iControl == CONTROL_LIST_GUIDE_CHANNEL ||
+             iControl == CONTROL_LIST_GUIDE_NOW_NEXT)
+    {
+      CFileItemPtr pItem;
+      int iItem;
+
+      /* Get currently performed action */
+      int iAction = message.GetParam1();
+
+      if (iControl == CONTROL_LIST_TIMELINE)
+      {
+        /* Get currently selected item from grid container */
+        pItem = m_guideGrid->GetSelectedItemPtr();
+
+        if (!pItem) return false;
+      }
+      else
+      {
+        /* Get currently selected item from file list */
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControl);
+        g_graphicsContext.SendMessage(msg);
+        iItem = msg.GetParam1();
+
+        /* Check file item is in list range and get his pointer */
+
+        if (iItem < 0 || iItem >= (int)m_vecItems->Size()) return true;
+
+        pItem = m_vecItems->Get(iItem);
+      }
+
+      /* Process actions */
+      if ((iAction == ACTION_SELECT_ITEM) || (iAction == ACTION_SHOW_INFO || iAction == ACTION_MOUSE_LEFT_CLICK))
+      {
+        /* Show information Dialog */
+        ShowEPGInfo(pItem.get());
+        return true;
+      }
+      else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      {
+        //contextmenu
+        OnPopupMenu(iItem);
+        return true;
+      }
+      else if (iAction == ACTION_RECORD)
+      {
+        int iChannel = pItem->GetTVEPGInfoTag()->m_channelNum;
+
+        if (iChannel != -1)
+        {
+          if (pItem->GetTVEPGInfoTag()->m_isRecording == false)
+          {
+            // prompt user for confirmation of channel record
+            CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+            if (pDialog)
+            {
+              pDialog->SetHeading(264);
+              pDialog->SetLine(0, "");
+              pDialog->SetLine(1, pItem->GetTVEPGInfoTag()->m_strTitle);
+              pDialog->SetLine(2, "");
+              pDialog->DoModal();
+
+              if (pDialog->IsConfirmed())
+              {
+                CTVTimerInfoTag newtimer(*pItem.get());
+                CFileItem *item = new CFileItem(newtimer);
+
+                if (CPVRManager::GetInstance()->AddTimer(*item))
+                {
+                  pItem->GetTVEPGInfoTag()->m_isRecording = true;
+                  pItem->SetProperty("Recording", pItem->GetTVEPGInfoTag()->m_isRecording);
+                }
+              }
+            }
+          }
+          else
+          {
+            CGUIDialogOK::ShowAndGetInput(18100,18107,0,0);
+          }
+        }
+      }
+    }
+    else if ((iControl == CONTROL_LIST_CHANNELS_TV) || (iControl == CONTROL_LIST_CHANNELS_RADIO))
+    {
+      /* Get currently performed action */
+      int iAction = message.GetParam1();
+
+      /* Get currently selected item from file list */
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControl);
+      g_graphicsContext.SendMessage(msg);
+      int iItem = msg.GetParam1();
+
+      /* Check file item is in list range and get his pointer */
+
+      if (iItem < 0 || iItem >= (int)m_vecItems->Size()) return true;
+
+      CFileItemPtr pItem = m_vecItems->Get(iItem);
+
+      /* Process actions */
+      if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+      {
+        /* Check if "Add channel..." entry is pressed by OK, if yes
+           create a new channel and open settings dialog, otherwise
+           open channel with player */
+        if (pItem->m_strPath == g_localizeStrings.Get(18061))
+        {
+          CTVChannelInfoTag newchannel();
+          CFileItem *item = new CFileItem(newchannel);
+          CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+        }
+        else
+        {
+          if (g_guiSettings.GetBool("pvrrecord.timshift") && g_guiSettings.GetString("pvrrecord.timshiftpath") == "")
+          {
+            CGUIDialogOK::ShowAndGetInput(18100,18124,0,18125);
+            return false;
+          }
+
+          if (iControl == CONTROL_LIST_CHANNELS_TV)
+            CPVRManager::GetInstance()->SetPlayingGroup(m_iCurrentTVGroup);
+          if (iControl == CONTROL_LIST_CHANNELS_RADIO)
+            CPVRManager::GetInstance()->SetPlayingGroup(m_iCurrentRadioGroup);
+
+          /* Open tv channel by Player and return */
+          if (!g_application.PlayFile(*pItem))
+          {
+            CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+            return false;
+          }
+          return true;
+        }
+      }
+      else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      {
+        //contextmenu
+        OnPopupMenu(iItem);
+        return true;
+      }
+      else if (iAction == ACTION_SHOW_INFO)
+      {
+        /* Show information Dialog */
+        ShowEPGInfo(pItem.get());
+        return true;
+      }
+      else if (iAction == ACTION_DELETE_ITEM)
+      {
+        /* Check if entry is a valid deleteable channel */
+        int iChannel = pItem->GetTVChannelInfoTag()->m_iChannelNum;
+
+        if (iChannel != -1)
+        {
+          CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+          if (pDialog)
+          {
+            pDialog->SetHeading(18196);
+            pDialog->SetLine(0, "");
+            pDialog->SetLine(1, pItem->GetTVChannelInfoTag()->m_strChannel);
+            pDialog->SetLine(2, "");
+            pDialog->DoModal();
+
+            if (!pDialog->IsConfirmed()) return false;
+
+            if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+            {
+              CPVRManager::GetInstance()->HideChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, false);
+              UpdateChannelsTV();
+            }
+            else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+            {
+              CPVRManager::GetInstance()->HideChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, true);
+              UpdateChannelsRadio();
+            }
+          }
+
+          return true;
+        }
+      }
+    }
+    else if (iControl == CONTROL_LIST_RECORDINGS)
+    {
+      /* Get currently performed action */
+      int iAction = message.GetParam1();
+
+      /* Get currently selected item from file list */
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControl);
+      g_graphicsContext.SendMessage(msg);
+      int iItem = msg.GetParam1();
+
+      /* Check file item is in list range and get his pointer */
+
+      if (iItem < 0 || iItem >= (int)m_vecItems->Size()) return true;
+
+      CFileItemPtr pItem = m_vecItems->Get(iItem);
+
+      /* Process actions */
+      if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+      {
+        /* Open recording with Player and return */
+        return g_application.PlayFile(*pItem);
+      }
+      else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      {
+        //contextmenu
+        OnPopupMenu(iItem);
+        return true;
+      }
+      else if (iAction == ACTION_SHOW_INFO)
+      {
+        /* Show information Dialog */
+        ShowRecordingInfo(pItem.get());
+        return true;
+      }
+      else if (iAction == ACTION_DELETE_ITEM)
+      {
+        /* Check if entry is a valid deleteable record */
+        int iRecordIdx = pItem->GetTVRecordingInfoTag()->m_Index;
+
+        if (iRecordIdx != -1)
+        {
+          // prompt user for confirmation of record deletion
+          CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+          if (pDialog)
+          {
+            pDialog->SetHeading(122);
+            pDialog->SetLine(0, 18192);
+            pDialog->SetLine(1, "");
+            pDialog->SetLine(2, pItem->GetTVRecordingInfoTag()->m_strTitle);
+            pDialog->DoModal();
+
+            if (pDialog->IsConfirmed())
+            {
+              CPVRManager::GetInstance()->DeleteRecording(iRecordIdx);
+              UpdateRecordings();
+            }
+          }
+
+          return true;
+        }
+      }
+    }
+    else if (iControl == CONTROL_LIST_TIMERS)
+    {
+      /* Get currently performed action */
+      int iAction = message.GetParam1();
+
+      /* Get currently selected item from file list */
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControl);
+      g_graphicsContext.SendMessage(msg);
+      int iItem = msg.GetParam1();
+
+      /* Check file item is in list range and get his pointer */
+
+      if (iItem < 0 || iItem >= (int)m_vecItems->Size()) return true;
+
+      CFileItemPtr pItem = m_vecItems->Get(iItem);
+
+      /* Process actions */
+      if (iAction == ACTION_SHOW_INFO || iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+      {
+        /* Check if "Add timer..." entry is pressed by OK, if yes
+           create a new timer and open settings dialog, otherwise
+           open settings for selected timer entry */
+        if (pItem->m_strPath == g_localizeStrings.Get(18057))
+        {
+          CTVTimerInfoTag newtimer(true);
+          CFileItem *item = new CFileItem(newtimer);
+
+          if (ShowTimerSettings(item))
+          {
+            /* Add timer to backend */
+            CPVRManager::GetInstance()->AddTimer(*item);
+            UpdateTimers();
+          }
+        }
+        else
+        {
+          CFileItem fileitem(*pItem);
+
+          if (ShowTimerSettings(&fileitem))
+          {
+            /* Update timer on pvr backend */
+            CPVRManager::GetInstance()->UpdateTimer(fileitem);
+            UpdateTimers();
+          }
+        }
+
+        return true;
+      }
+      else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      {
+        //contextmenu
+        OnPopupMenu(iItem);
+        return true;
+      }
+      else if (iAction == ACTION_DELETE_ITEM)
+      {
+        /* Check if entry is a valid deleteable timer */
+        int iTimerIdx = pItem->GetTVTimerInfoTag()->m_Index;
+
+        if (iTimerIdx != -1)
+        {
+          // prompt user for confirmation of timer deletion
+          CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+          if (pDialog)
+          {
+            pDialog->SetHeading(122);
+            pDialog->SetLine(0, 18076);
+            pDialog->SetLine(1, "");
+            pDialog->SetLine(2, pItem->GetTVTimerInfoTag()->m_strTitle);
+            pDialog->DoModal();
+
+            if (pDialog->IsConfirmed())
+            {
+              CPVRManager::GetInstance()->DeleteTimer(iTimerIdx);
+              UpdateTimers();
+            }
+          }
+
+          return true;
+        }
+      }
+    }
+    else if (iControl == CONTROL_BTNSETTINGS)
+    {
+      m_gWindowManager.ActivateWindow(WINDOW_SETTINGS_MYTV);
+    }
+  }
+
+  return CGUIMediaWindow::OnMessage(message);
+}
+
+/**
+ * \brief Perform popup menu
+ * \param int iItem                 = Index number inside global file item list
+ * \return bool                     = true if ok
+ * Note:
+ * Is a copy from CGUIMediaWindow with a little change for the window position
+ * without it the context menu is always in the left upper corner. Why ?????
+ */
+bool CGUIWindowTV::OnPopupMenu(int iItem)
+{
+  /* Check if it is inside a list */
+  unsigned int iControl = GetFocusedControlID();
+  int m_iSelected;
+
+  if (iControl < 10 || iControl > 16) return false;
+
+  /* Save current Subwindow selected list position */
+  if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+  {
+    if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_GUIDE_CHANNEL);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected = m_iSelected_GUIDE = msg.GetParam1();
+    }
+    else if (m_iGuideView == GUIDE_VIEW_NEXT || m_iGuideView == GUIDE_VIEW_NOW)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected = m_iSelected_GUIDE = msg.GetParam1();
+    }
+    else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+    {
+      CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMELINE);
+      g_graphicsContext.SendMessage(msg);
+      m_iSelected = m_iSelected_GUIDE = msg.GetParam1();
+    }
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+  {
+    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_TV);
+    g_graphicsContext.SendMessage(msg);
+    m_iSelected = m_iSelected_CHANNELS_TV = msg.GetParam1();
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+  {
+    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_CHANNELS_RADIO);
+    g_graphicsContext.SendMessage(msg);
+    m_iSelected = m_iSelected_CHANNELS_RADIO = msg.GetParam1();
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+  {
+    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_RECORDINGS);
+    g_graphicsContext.SendMessage(msg);
+    m_iSelected = m_iSelected_RECORDINGS = msg.GetParam1();
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+  {
+    CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), CONTROL_LIST_TIMERS);
+    g_graphicsContext.SendMessage(msg);
+    m_iSelected = m_iSelected_TIMERS = msg.GetParam1();
+  }
+
+  // popup the context menu
+  // grab our context menu
+  CContextButtons buttons;
+
+  GetContextButtons(m_iSelected, buttons);
+
+  if (buttons.size())
+  {
+
+    // mark the item
+    if (m_iSelected >= 0 && m_iSelected < m_vecItems->Size())
+      m_vecItems->Get(m_iSelected)->Select(true);
+
+    CGUIDialogContextMenu *pMenu = (CGUIDialogContextMenu *)m_gWindowManager.GetWindow(WINDOW_DIALOG_CONTEXT_MENU);
+
+    if (!pMenu) return false;
+
+    // load our menu
+    pMenu->Initialize();
+
+    // add the buttons and execute it
+    for (CContextButtons::iterator it = buttons.begin(); it != buttons.end(); it++)
+      pMenu->AddButton((*it).second);
+
+    // position it correctly
+    pMenu->SetPosition(GetWidth() / 2 - pMenu->GetWidth() / 2, GetHeight() / 2 - pMenu->GetHeight() / 2);
+
+    pMenu->DoModal();
+
+    // translate our button press
+    CONTEXT_BUTTON btn = CONTEXT_BUTTON_CANCELLED;
+
+    if (pMenu->GetButton() > 0 && pMenu->GetButton() <= (int)buttons.size())
+      btn = buttons[pMenu->GetButton() - 1].first;
+
+    // deselect our item
+    if (m_iSelected >= 0 && m_iSelected < m_vecItems->Size())
+      m_vecItems->Get(m_iSelected)->Select(false);
+
+    if (btn != CONTEXT_BUTTON_CANCELLED)
+      return OnContextButton(m_iSelected, btn);
+  }
+
+  return false;
+}
+
+/**
+ * \brief Get context button names for given sub window
+ * \param int itemNumber            = Index number inside global file item list
+ * \param CContextButtons &buttons  = context button class
+ */
+void CGUIWindowTV::GetContextButtons(int itemNumber, CContextButtons &buttons)
+{
+  /* Perform file item for specified sub window */
+  CFileItemPtr pItem = m_vecItems->Get(itemNumber);
+
+  if (pItem)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV || m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+    {
+      if (itemNumber < 0 || itemNumber >= m_vecItems->Size())
+        return;
+
+      /* check that file item is in list and get his pointer*/
+      if (pItem->m_strPath == g_localizeStrings.Get(18061))
+      {
+        /* If yes show only "New Channel" on context menu */
+        buttons.Add(CONTEXT_BUTTON_ADD, 18049); /* NEW CHANNEL */
+      }
+      else
+      {
+        buttons.Add(CONTEXT_BUTTON_INFO, 658);          /* Channel info button */
+        buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 18109);   /* switch to channel */
+        buttons.Add(CONTEXT_BUTTON_SET_THUMB, 18161);   /* Set icon */
+        buttons.Add(CONTEXT_BUTTON_GROUP_MANAGER, 18126);       /* Group managment */
+        buttons.Add(CONTEXT_BUTTON_HIDE, m_bShowHiddenChannels ? 18193 : 18198);        /* HIDE CHANNEL */
+
+        if (m_vecItems->Size() > 1 && !m_bShowHiddenChannels)
+          buttons.Add(CONTEXT_BUTTON_MOVE, 116);          /* MOVE CHANNEL */
+
+        if (m_bShowHiddenChannels || CPVRManager::GetInstance()->GetNumHiddenChannels() > 0)
+          buttons.Add(CONTEXT_BUTTON_SHOW_HIDDEN, m_bShowHiddenChannels ? 18194 : 18195);  /* SHOW HIDDEN CHANNELS */
+
+//        if (CPVRManager::GetInstance()->SupportChannelSettings())
+//          buttons.Add(CONTEXT_BUTTON_EDIT, 18048);        /* EDIT CHANNEL */
+
+        CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
+      }
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)           /* Add recordings context buttons */
+    {
+      buttons.Add(CONTEXT_BUTTON_INFO, 658);
+      buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 12021);
+//            buttons.Add(CONTEXT_BUTTON_RESUME_ITEM, 12022);
+      buttons.Add(CONTEXT_BUTTON_RENAME, 118);
+      buttons.Add(CONTEXT_BUTTON_DELETE, 117);
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)           /* Add timer context buttons */
+    {
+      /* Check for a empty file item list, means only a
+          file item with the name "Add timer..." is present */
+
+      if (pItem->m_strPath == g_localizeStrings.Get(18057))
+      {
+        /* If yes show only "New Timer" on context menu */
+        buttons.Add(CONTEXT_BUTTON_ADD, 18072); /* NEW TIMER */
+      }
+      else
+      {
+        /* If any timers are present show more */
+        buttons.Add(CONTEXT_BUTTON_EDIT, 18068);
+        buttons.Add(CONTEXT_BUTTON_ADD, 18072); /* NEW TIMER */
+        buttons.Add(CONTEXT_BUTTON_ACTIVATE, 18070); /* ON/OFF */
+        buttons.Add(CONTEXT_BUTTON_RENAME, 118);
+        buttons.Add(CONTEXT_BUTTON_DELETE, 117);
+      }
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      buttons.Add(CONTEXT_BUTTON_INFO, 658);              /* Epg info button */
+
+      if (pItem->GetTVEPGInfoTag()->m_endTime > CDateTime::GetCurrentDateTime())
+      {
+        if (pItem->GetTVEPGInfoTag()->m_isRecording == false)
+        {
+          if (pItem->GetTVEPGInfoTag()->m_startTime < CDateTime::GetCurrentDateTime())
+          {
+            buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);             /* RECORD programme */
+          }
+          else
+          {
+            buttons.Add(CONTEXT_BUTTON_START_RECORD, 18416);
+          }
+        }
+        else
+        {
+          if (pItem->GetTVEPGInfoTag()->m_startTime < CDateTime::GetCurrentDateTime())
+          {
+            buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 18414);
+          }
+          else
+          {
+            buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 18415);
+          }
+        }
+      }
+
+      buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 18109);           /* Switch channel */
+    }
+  }
+
+  return;
+}
+
+/**
+ * \brief Do functions for given context menu button for current subwindow
+ * \param int itemNumber            = Index number inside global file item list
+ * \param CONTEXT_BUTTON button     = button type pressed
+ * \return bool                     = true if ok
+ */
+bool CGUIWindowTV::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  CFileItemPtr pItem = (itemNumber >= 0 && itemNumber < m_vecItems->Size()) ? m_vecItems->Get(itemNumber) : CFileItemPtr();
+
+  if (button == CONTEXT_BUTTON_PLAY_ITEM)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      return g_application.PlayFile(*pItem);
+    }
+
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV ||
+        m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+    {
+      if (g_guiSettings.GetBool("pvrrecord.timshift") && g_guiSettings.GetString("pvrrecord.timshiftpath") == "")
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,18124,0,18125);
+        return false;
+      }
+
+      if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+        CPVRManager::GetInstance()->SetPlayingGroup(m_iCurrentTVGroup);
+      if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+        CPVRManager::GetInstance()->SetPlayingGroup(m_iCurrentRadioGroup);
+
+      if (!g_application.PlayFile(*pItem))
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+        return false;
+      }
+      return true;
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      CFileItemList channelslist;
+      int ret_channels;
+
+      if (!pItem->GetTVEPGInfoTag()->m_isRadio)
+      {
+        ret_channels = CPVRManager::GetInstance()->GetTVChannels(&channelslist, m_iCurrentTVGroup, false);
+      }
+      else
+      {
+        ret_channels = CPVRManager::GetInstance()->GetRadioChannels(&channelslist, m_iCurrentRadioGroup, false);
+      }
+
+      if (ret_channels > 0)
+      {
+        if (g_guiSettings.GetBool("pvrrecord.timshift") && g_guiSettings.GetString("pvrrecord.timshiftpath") == "")
+        {
+          CGUIDialogOK::ShowAndGetInput(18100,18124,0,18125);
+          return false;
+        }
+
+        CPVRManager::GetInstance()->SetPlayingGroup(-1);
+        if (!g_application.PlayFile(*channelslist[pItem->GetTVEPGInfoTag()->m_channelNum-1]))
+        {
+          CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+          return false;
+        }
+        return true;
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_MOVE)
+  {
+    CStdString strIndex;
+    strIndex.Format("%i", pItem->GetTVChannelInfoTag()->m_iChannelNum);
+    CGUIDialogNumeric::ShowAndGetNumber(strIndex, g_localizeStrings.Get(18197));
+    int newIndex = atoi(strIndex.c_str());
+
+    if (newIndex != pItem->GetTVChannelInfoTag()->m_iChannelNum)
+    {
+      if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+      {
+        CPVRManager::GetInstance()->MoveChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, newIndex, false);
+        UpdateChannelsTV();
+      }
+      else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+      {
+        CPVRManager::GetInstance()->MoveChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, newIndex, true);
+        UpdateChannelsRadio();
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_HIDE)
+  {
+    // prompt user for confirmation of channel hide
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+    if (pDialog)
+    {
+      pDialog->SetHeading(18196);
+      pDialog->SetLine(0, "");
+      pDialog->SetLine(1, pItem->GetTVChannelInfoTag()->m_strChannel);
+      pDialog->SetLine(2, "");
+      pDialog->DoModal();
+
+      if (!pDialog->IsConfirmed()) return false;
+
+      if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+      {
+        CPVRManager::GetInstance()->HideChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, false);
+        UpdateChannelsTV();
+      }
+      else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+      {
+        CPVRManager::GetInstance()->HideChannel(pItem->GetTVChannelInfoTag()->m_iChannelNum, true);
+        UpdateChannelsRadio();
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_SHOW_HIDDEN)
+  {
+    if (m_bShowHiddenChannels)
+      m_bShowHiddenChannels = false;
+    else
+      m_bShowHiddenChannels = true;
+
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+      UpdateChannelsTV();
+    else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+      UpdateChannelsRadio();
+  }
+  else if (button == CONTEXT_BUTTON_SET_THUMB)
+  {
+    if (g_guiSettings.GetString("pvrmenu.iconpath") == "")
+    {
+      CGUIDialogOK::ShowAndGetInput(18100,18812,0,18813);
+      return true;
+    }
+
+    CStdString strIcon = pItem->GetTVChannelInfoTag()->m_IconPath == "" ? g_guiSettings.GetString("pvrmenu.iconpath") : pItem->GetTVChannelInfoTag()->m_IconPath;
+
+    VECSOURCES shares;
+    g_mediaManager.GetLocalDrives(shares);
+
+    if (CGUIDialogFileBrowser::ShowAndGetImage(shares,g_localizeStrings.Get(1030),strIcon))
+    {
+      if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+      {
+        CPVRManager::GetInstance()->SetChannelIcon(pItem->GetTVChannelInfoTag()->m_iChannelNum, strIcon, false);
+        UpdateChannelsTV();
+      }
+      else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+      {
+        CPVRManager::GetInstance()->SetChannelIcon(pItem->GetTVChannelInfoTag()->m_iChannelNum, strIcon, true);
+        UpdateChannelsRadio();
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_EDIT)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO ||
+        m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+    {
+      CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      CFileItem fileitem(*pItem);
+
+      if (ShowTimerSettings(&fileitem))
+      {
+        CPVRManager::GetInstance()->UpdateTimer(fileitem);
+        UpdateTimers();
+      }
+    }
+
+    return true;
+  }
+  else if (button == CONTEXT_BUTTON_ADD)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO ||
+        m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+    {
+      CTVChannelInfoTag newchannel();
+      CFileItem *item = new CFileItem(newchannel);
+      CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      CTVTimerInfoTag newtimer(true);
+      CFileItem *item = new CFileItem(newtimer);
+
+      if (ShowTimerSettings(item))
+      {
+        CPVRManager::GetInstance()->AddTimer(*item);
+        UpdateTimers();
+      }
+
+      return true;
+    }
+  }
+  else if (button == CONTEXT_BUTTON_ACTIVATE)
+  {
+    int return_str_id;
+
+    if (pItem->GetTVTimerInfoTag()->m_Active == true)
+    {
+      pItem->GetTVTimerInfoTag()->m_Active = false;
+      return_str_id = 13106;
+    }
+    else
+    {
+      pItem->GetTVTimerInfoTag()->m_Active = true;
+      return_str_id = 305;
+    }
+
+    CGUIDialogOK::ShowAndGetInput(18100, 18076, 0, return_str_id);
+
+    CPVRManager::GetInstance()->UpdateTimer(*pItem);
+    UpdateTimers(); /** Force list update **/
+    return true;
+  }
+  else if (button == CONTEXT_BUTTON_RENAME)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      CStdString strDescription;
+      strDescription = pItem->GetTVTimerInfoTag()->m_strTitle;
+
+      if (CGUIDialogKeyboard::ShowAndGetInput(strDescription, g_localizeStrings.Get(18400), false))
+      {
+        CPVRManager::GetInstance()->RenameTimer(pItem->GetTVTimerInfoTag()->m_Index, strDescription);
+        UpdateTimers();
+      }
+
+      return true;
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      CStdString strDescription;
+      strDescription = pItem->GetTVRecordingInfoTag()->m_strTitle;
+
+      if (CGUIDialogKeyboard::ShowAndGetInput(strDescription, g_localizeStrings.Get(18399), false))
+      {
+        CPVRManager::GetInstance()->RenameRecording(pItem->GetTVRecordingInfoTag()->m_Index, strDescription);
+        UpdateRecordings();
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_DELETE)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS)
+    {
+      // prompt user for confirmation of timer deletion
+      CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+      if (pDialog)
+      {
+        pDialog->SetHeading(122);
+        pDialog->SetLine(0, 18076);
+        pDialog->SetLine(1, "");
+        pDialog->SetLine(2, pItem->GetTVTimerInfoTag()->m_strTitle);
+        pDialog->DoModal();
+
+        if (!pDialog->IsConfirmed()) return false;
+
+        CPVRManager::GetInstance()->DeleteTimer(pItem->GetTVTimerInfoTag()->m_Index);
+
+        UpdateTimers();
+      }
+
+      return true;
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+      if (pDialog)
+      {
+        pDialog->SetHeading(122);
+        pDialog->SetLine(0, 18192);
+        pDialog->SetLine(1, "");
+        pDialog->SetLine(2, pItem->GetTVRecordingInfoTag()->m_strTitle);
+        pDialog->DoModal();
+
+        if (!pDialog->IsConfirmed()) return false;
+
+        CPVRManager::GetInstance()->DeleteRecording(pItem->GetTVRecordingInfoTag()->m_Index);
+
+        UpdateRecordings();
+      }
+
+      return true;
+    }
+  }
+  else if (button == CONTEXT_BUTTON_INFO)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV ||
+        m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO ||
+        m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+
+      if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+      {
+        /* Get currently selected item from grid container */
+        pItem = m_guideGrid->GetSelectedItemPtr();
+
+        if (!pItem) return false;
+      }
+
+      ShowEPGInfo(pItem.get());
+    }
+    else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS)
+    {
+      ShowRecordingInfo(pItem.get());
+    }
+  }
+  else if (button == CONTEXT_BUTTON_START_RECORD)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      int iChannel = pItem->GetTVEPGInfoTag()->m_channelNum;
+
+      if (iChannel != -1)
+      {
+        if (pItem->GetTVEPGInfoTag()->m_isRecording == false)
+        {
+          // prompt user for confirmation of channel record
+          CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+          if (pDialog)
+          {
+            pDialog->SetHeading(264);
+            pDialog->SetLine(0, pItem->GetTVEPGInfoTag()->m_strChannel);
+            pDialog->SetLine(1, "");
+            pDialog->SetLine(2, pItem->GetTVEPGInfoTag()->m_strTitle);
+            pDialog->DoModal();
+
+            if (pDialog->IsConfirmed())
+            {
+              CTVTimerInfoTag newtimer(*pItem.get());
+              CFileItem *item = new CFileItem(newtimer);
+
+              if (CPVRManager::GetInstance()->AddTimer(*item))
+              {
+                pItem->GetTVEPGInfoTag()->m_isRecording = true;
+                pItem->SetProperty("Recording", pItem->GetTVEPGInfoTag()->m_isRecording);
+              }
+            }
+          }
+        }
+        else
+        {
+          CGUIDialogOK::ShowAndGetInput(18100,18107,0,0);
+        }
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_STOP_RECORD)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM)
+    {
+      int iChannel = pItem->GetTVEPGInfoTag()->m_channelNum;
+
+      if (iChannel != -1)
+      {
+        if (pItem->GetTVEPGInfoTag()->m_isRecording == true)
+        {
+          CFileItemList timerlist;
+
+          if (CPVRManager::GetInstance()->GetAllTimers(&timerlist) > 0)
+          {
+            for (int i = 0; i < timerlist.Size(); ++i)
+            {
+              if ((timerlist[i]->GetTVTimerInfoTag()->m_channelNum == pItem->GetTVEPGInfoTag()->m_channelNum) &&
+                  (timerlist[i]->GetTVTimerInfoTag()->m_StartTime  <= pItem->GetTVEPGInfoTag()->m_startTime) &&
+                  (timerlist[i]->GetTVTimerInfoTag()->m_StopTime   >= pItem->GetTVEPGInfoTag()->m_endTime) &&
+                  (timerlist[i]->GetTVTimerInfoTag()->m_Repeat != true))
+              {
+                CPVRManager::GetInstance()->DeleteTimer(timerlist[i]->GetTVTimerInfoTag()->m_Index);
+              }
+            }
+          }
+
+          pItem->GetTVEPGInfoTag()->m_isRecording = false;
+
+          pItem->SetProperty("Recording", pItem->GetTVEPGInfoTag()->m_isRecording);
+        }
+      }
+    }
+  }
+  else if (button == CONTEXT_BUTTON_GROUP_MANAGER)
+  {
+    if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV)
+      ShowGroupManager(false);
+    else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO)
+      ShowGroupManager(true);
+  }
+  else if (button == CONTEXT_BUTTON_RESUME_ITEM)
+  {
+
+  }
+
+  return CGUIMediaWindow::OnContextButton(itemNumber, button);
+}
+
+/**
+ * \brief Show programme summary information dialog for given epg or channel info tag
+ * \param CFileItem *item           = pointer to file item with TV epg or channel info tag
+ */
+void CGUIWindowTV::ShowEPGInfo(CFileItem *item)
+{
+  /* Check item is TV epg or channel information tag */
+  if (item->IsTVEPG())
+  {
+    /* Load programme info dialog */
+    CGUIDialogTVEPGProgInfo* pDlgInfo = (CGUIDialogTVEPGProgInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_GUIDE_INFO);
+
+    if (!pDlgInfo)
+      return;
+
+    /* inform dialog about the file item */
+    pDlgInfo->SetProgInfo(item);
+
+    /* Open dialog window */
+    pDlgInfo->DoModal();
+  }
+  else if (item->IsTVChannel())
+  {
+    CTVEPGInfoTag epgnow(NULL);
+    CFileItem *itemNow  = new CFileItem(epgnow);
+    CFileItem *itemNext = new CFileItem();
+
+    if (!CPVRManager::GetInstance()->GetEPGInfo(item->GetTVChannelInfoTag()->m_iChannelNum, *itemNow, *itemNext, item->GetTVChannelInfoTag()->m_radio))
+      return;
+
+    /* Load programme info dialog */
+    CGUIDialogTVEPGProgInfo* pDlgInfo = (CGUIDialogTVEPGProgInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_GUIDE_INFO);
+
+    if (!pDlgInfo)
+      return;
+
+    /* inform dialog about the file item */
+    pDlgInfo->SetProgInfo(itemNow);
+
+    /* Open dialog window */
+    pDlgInfo->DoModal();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "CGUIWindowTV: Can't open programme info dialog, no epg or channel info tag!");
+    return;
+  }
+
+  /* Return to caller */
+  return;
+
+}
+
+/**
+ * \brief Show recording summary information dialog for given record info tag
+ * \param CFileItem *item           = pointer to file item with TV recording info tag
+ */
+void CGUIWindowTV::ShowRecordingInfo(CFileItem *item)
+{
+  /* Check item is TV record information tag */
+  if (!item->IsTVRecording())
+  {
+    CLog::Log(LOGERROR, "CGUIWindowTV: Can't open recording info dialog, no record info tag!");
+    return;
+  }
+
+  /* Load record info dialog */
+  CGUIDialogTVRecordingInfo* pDlgInfo = (CGUIDialogTVRecordingInfo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_RECORDING_INFO);
+
+  if (!pDlgInfo)
+    return;
+
+  /* inform dialog about the file item */
+  pDlgInfo->SetRecording(item);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  /* Return to caller */
+  return;
+}
+
+/**
+ * \brief Show Timer settings dialog for given timer info tag
+ * \param CFileItem *item           = pointer to file item with TV timer info tag
+ * \return bool                     = true if tag is changed, false for no change
+ */
+bool CGUIWindowTV::ShowTimerSettings(CFileItem *item)
+{
+  /* Check item is TV timer information tag */
+  if (!item->IsTVTimer())
+  {
+    CLog::Log(LOGERROR, "CGUIWindowTV: Can't open timer settings dialog, no timer info tag!");
+    return false;
+  }
+
+  /* Load timer settings dialog */
+  CGUIDialogTVTimerSettings* pDlgInfo = (CGUIDialogTVTimerSettings*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_TIMER_SETTING);
+
+  if (!pDlgInfo)
+    return false;
+
+  /* inform dialog about the file item */
+  pDlgInfo->SetTimer(item);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  /* Get modify flag from window and return it to caller */
+  return pDlgInfo->GetOK();
+}
+
+/**
+ * \brief Show Channel group managment
+ */
+void CGUIWindowTV::ShowGroupManager(bool IsRadio)
+{
+  /* Load timer settings dialog */
+  CGUIDialogTVGroupManager* pDlgInfo = (CGUIDialogTVGroupManager*)m_gWindowManager.GetWindow(WINDOW_DIALOG_TV_GROUP_MANAGER);
+
+  if (!pDlgInfo)
+    return;
+
+  pDlgInfo->SetRadio(IsRadio);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  return;
+}
+
+/**
+ * \brief Update TV Guide list
+ */
+void CGUIWindowTV::UpdateGuide()
+{
+  CStdString strLabel;
+
+  m_vecItems->Clear();
+
+  bool TVPlaying = CPVRManager::GetInstance()->IsPlayingTV();
+  bool RadioPlaying = CPVRManager::GetInstance()->IsPlayingRadio();
+
+  if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+  {
+    m_guideGrid = NULL;
+    CStdString strChannel;
+    int current_channel;
+
+    SET_CONTROL_HIDDEN(8002);
+    SET_CONTROL_HIDDEN(8003);
+    SET_CONTROL_VISIBLE(8001);
+
+    if (TVPlaying || RadioPlaying)
+    {
+      current_channel = CPVRManager::GetInstance()->GetCurrentChannel(RadioPlaying);
+      strChannel = CPVRManager::GetInstance()->GetNameForChannel(current_channel, RadioPlaying);
+    }
+    else
+    {
+      current_channel = 1;
+      strChannel = CPVRManager::GetInstance()->GetNameForChannel(current_channel, false);
+    }
+
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), strChannel.c_str());
+
+    if (CPVRManager::GetInstance()->GetEPGChannel(current_channel, m_vecItems, RadioPlaying) > 0)
+    {
+      CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_GUIDE_CHANNEL, 0, 0, m_vecItems);
+      g_graphicsContext.SendMessage(msg);
+    }
+
+    /* Set Selected item inside list */
+    CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_GUIDE_CHANNEL, m_iSelected_GUIDE);
+    g_graphicsContext.SendMessage(msg);
+  }
+  else if (m_iGuideView == GUIDE_VIEW_NOW)
+  {
+    m_guideGrid = NULL;
+    SET_CONTROL_HIDDEN(8001);
+    SET_CONTROL_HIDDEN(8003);
+    SET_CONTROL_VISIBLE(8002);
+
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18101));
+
+    if (CPVRManager::GetInstance()->GetEPGNow(m_vecItems, RadioPlaying) > 0)
+    {
+      CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT, 0, 0, m_vecItems);
+      g_graphicsContext.SendMessage(msg);
+    }
+
+    /* Set Selected item inside list */
+    CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT, m_iSelected_GUIDE);
+    g_graphicsContext.SendMessage(msg);
+  }
+  else if (m_iGuideView == GUIDE_VIEW_NEXT)
+  {
+    m_guideGrid = NULL;
+    SET_CONTROL_HIDDEN(8001);
+    SET_CONTROL_HIDDEN(8003);
+    SET_CONTROL_VISIBLE(8002);
+
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18102));
+
+    if (CPVRManager::GetInstance()->GetEPGNext(m_vecItems, RadioPlaying) > 0)
+    {
+      CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT, 0, 0, m_vecItems);
+      g_graphicsContext.SendMessage(msg);
+    }
+
+    /* Set Selected item inside list */
+    CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_GUIDE_NOW_NEXT, m_iSelected_GUIDE);
+
+    g_graphicsContext.SendMessage(msg);
+  }
+  else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+  {
+    SET_CONTROL_HIDDEN(8001);
+    SET_CONTROL_HIDDEN(8002);
+    SET_CONTROL_VISIBLE(8003);
+
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18103));
+
+    if (CPVRManager::GetInstance()->GetEPGAll(m_vecItems, RadioPlaying) > 0)
+    {
+      time_t time_start;
+      time_t time_end;
+      CDateTime       now = CDateTime::GetCurrentDateTime();
+
+      CDateTime m_gridStart = now - CDateTimeSpan(0, 0, 0, (now.GetMinute() % 30) * 60 + now.GetSecond())
+                              - CDateTimeSpan(0, g_guiSettings.GetInt("pvrmenu.lingertime") / 60, g_guiSettings.GetInt("pvrmenu.lingertime") % 60, 0);
+      CDateTime m_gridEnd = m_gridStart + CDateTimeSpan(g_guiSettings.GetInt("pvrmenu.daystodisplay"), 0, 0, 0);
+
+      m_gridStart.GetAsTime(time_start);
+      m_gridEnd.GetAsTime(time_end);
+
+      CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_TIMELINE, time_start, time_end, m_vecItems);
+      g_graphicsContext.SendMessage(msg);
+      m_guideGrid = (CGUIEPGGridContainer*)GetControl(CONTROL_LIST_TIMELINE);
+    }
+
+    /* Set Selected item inside list */
+    CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_TIMELINE, m_iSelected_GUIDE);
+    g_graphicsContext.SendMessage(msg);
+  }
+
+  SET_CONTROL_LABEL(CONTROL_BTNGUIDE, strLabel);
+
+  strLabel.Format("%s - %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18050));
+  SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+}
+
+/**
+ * \brief Update TV Channels list
+ */
+void CGUIWindowTV::UpdateChannelsTV()
+{
+  SET_CONTROL_HIDDEN(CONTROL_LIST_CHANNELS_TV);
+
+  m_vecItems->Clear();
+
+  if (CPVRManager::GetInstance()->GetTVChannels(m_vecItems, m_iCurrentTVGroup, m_bShowHiddenChannels) > 0)
+  {
+    CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_CHANNELS_TV, 0, 0, m_vecItems);
+    g_graphicsContext.SendMessage(msg);
+  }
+  else if (m_bShowHiddenChannels)
+  {
+    m_bShowHiddenChannels = false;
+    UpdateChannelsTV();
+    return;
+  }
+  else if (m_iCurrentTVGroup != -1)
+  {
+    m_iCurrentTVGroup = CPVRManager::GetInstance()->GetNextGroupID(m_iCurrentTVGroup);
+    UpdateChannelsTV();
+    return;
+  }
+  else if (CPVRManager::GetInstance()->SupportChannelSettings())
+  {
+    /* Add blank item in list to add new channel */
+    CFileItem *item = new CFileItem();
+    item->m_strPath = g_localizeStrings.Get(18061); /* "Add channel..." */
+    CFileItemPtr addchannel(item);
+    m_vecItems->Add(addchannel);
+  }
+
+  /* Set Selected item inside list */
+  CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_CHANNELS_TV, m_iSelected_CHANNELS_TV);
+  g_graphicsContext.SendMessage(msg);
+
+  CStdString strLabel;
+  if (m_bShowHiddenChannels)
+    strLabel.Format("%s - %s: %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18051), g_localizeStrings.Get(18151));
+  else
+    strLabel.Format("%s - %s: %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18051), CPVRManager::GetInstance()->GetGroupName(m_iCurrentTVGroup));
+  SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+
+  SET_CONTROL_VISIBLE(CONTROL_LIST_CHANNELS_TV);
+}
+
+/**
+ * \brief Update Radio Channels list
+ */
+void CGUIWindowTV::UpdateChannelsRadio()
+{
+  SET_CONTROL_HIDDEN(CONTROL_LIST_CHANNELS_RADIO);
+
+  m_vecItems->Clear();
+
+  if (CPVRManager::GetInstance()->GetRadioChannels(m_vecItems, m_iCurrentRadioGroup, m_bShowHiddenChannels) > 0)
+  {
+    CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_CHANNELS_RADIO, 0, 0, m_vecItems);
+    g_graphicsContext.SendMessage(msg);
+  }
+  else if (m_bShowHiddenChannels)
+  {
+    m_bShowHiddenChannels = false;
+    UpdateChannelsRadio();
+    return;
+  }
+  else if (m_iCurrentRadioGroup != -1)
+  {
+    m_iCurrentRadioGroup = CPVRManager::GetInstance()->GetNextGroupID(m_iCurrentRadioGroup);
+    UpdateChannelsRadio();
+    return;
+  }
+  else if (CPVRManager::GetInstance()->SupportChannelSettings())
+  {
+    /* Add blank item in list to add new channel */
+    CFileItem *item = new CFileItem();
+    item->m_strPath = g_localizeStrings.Get(18061); /* "Add channel..." */
+    CFileItemPtr addchannel(item);
+    m_vecItems->Add(addchannel);
+  }
+
+  /* Set Selected item inside list */
+  CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_CHANNELS_RADIO, m_iSelected_CHANNELS_RADIO);
+  g_graphicsContext.SendMessage(msg);
+
+  CStdString strLabel;
+  if (m_bShowHiddenChannels)
+    strLabel.Format("%s - %s: %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18052), g_localizeStrings.Get(18151));
+  else
+    strLabel.Format("%s - %s: %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18052), CPVRManager::GetInstance()->GetGroupName(m_iCurrentTVGroup));
+  SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+
+  SET_CONTROL_VISIBLE(CONTROL_LIST_CHANNELS_RADIO);
+}
+
+/**
+ * \brief Update Radio Channels list
+ */
+void CGUIWindowTV::UpdateRecordings()
+{
+  SET_CONTROL_HIDDEN(CONTROL_LIST_RECORDINGS);
+
+  /* Disksize */
+  CStdString strLabel;
+  long long m_iDisktotal = 1024;
+  long long m_iDiskused  = 1024;
+  int       m_iPercent   = -1;
+  CPVRManager::GetInstance()->GetDriveSpace(&m_iDisktotal, &m_iDiskused, &m_iPercent);
+  m_iDisktotal /= 1024; // Convert to MBytes
+  m_iDiskused /= 1024;  // Convert to MBytes
+
+#ifdef _LINUX
+  if (m_iPercent >= 0 && m_iPercent <= 100)
+	strLabel.Format("%s %0.f GByte - %s: %0.f GByte (%i %)", g_localizeStrings.Get(18055), (float) m_iDisktotal / 1024, g_localizeStrings.Get(156), (float) m_iDiskused / 1024, m_iPercent);
+  else
+#endif
+	strLabel.Format("%s %0.f GByte - %s: %0.f GByte", g_localizeStrings.Get(18055), (float) m_iDisktotal / 1024, g_localizeStrings.Get(156), (float) m_iDiskused / 1024);
+
+  SET_CONTROL_LABEL(CONTROL_DISKSIZE, strLabel);
+
+  m_vecItems->Clear();
+  CPVRManager::GetInstance()->GetAllRecordings(m_vecItems);
+
+  {
+    CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_RECORDINGS, 0, 0, m_vecItems);
+    g_graphicsContext.SendMessage(msg);
+  }
+
+  /* Set Selected item inside list */
+  {
+    CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_RECORDINGS, m_iSelected_RECORDINGS);
+    g_graphicsContext.SendMessage(msg);
+  }
+
+  strLabel.Format("%s - %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18066));
+  SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+
+  SET_CONTROL_VISIBLE(CONTROL_LIST_RECORDINGS);
+}
+
+/**
+ * \brief Update Radio Channels list
+ */
+void CGUIWindowTV::UpdateTimers()
+{
+  SET_CONTROL_HIDDEN(CONTROL_LIST_TIMERS);
+
+  m_vecItems->Clear();
+
+  if (CPVRManager::GetInstance()->GetAllTimers(m_vecItems) > 0)
+  {
+    /* Update next timer window data */
+    CDateTime next = CPVRManager::GetInstance()->NextTimerDate();
+    CStdString strLabel;
+    strLabel.Format("%s %s %s %s", g_localizeStrings.Get(18190)
+                    , next.GetAsLocalizedDate(true)
+                    , g_localizeStrings.Get(18191)
+                    , next.GetAsLocalizedTime("HH:mm", false));
+
+    if (next == NULL)
+    {
+      SET_CONTROL_HIDDEN(CONTROL_NEXTTIMER);
+    }
+    else
+    {
+      SET_CONTROL_LABEL(CONTROL_NEXTTIMER, strLabel);
+      SET_CONTROL_VISIBLE(CONTROL_NEXTTIMER);
+    }
+    CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_TIMERS, 0, 0, m_vecItems);
+    g_graphicsContext.SendMessage(msg);
+  }
+  else
+  {
+    /* Add blank item in list to add new timer */
+    CFileItem *item = new CFileItem();
+    item->m_strPath = g_localizeStrings.Get(18057); /* "Add timer..." */
+    CFileItemPtr addtimer(item);
+    m_vecItems->Add(addtimer);
+
+    CGUIMessage msg(GUI_MSG_LABEL_BIND, GetID(), CONTROL_LIST_TIMERS, 0, 0, m_vecItems);
+    g_graphicsContext.SendMessage(msg);
+
+    SET_CONTROL_HIDDEN(CONTROL_NEXTTIMER);
+  }
+
+  /* Set Selected item inside list */
+  CGUIMessage msg(GUI_MSG_ITEM_SELECT, GetID(), CONTROL_LIST_TIMERS, m_iSelected_TIMERS);
+  g_graphicsContext.SendMessage(msg);
+
+  CStdString strLabel;
+  strLabel.Format("%s - %s", g_localizeStrings.Get(9), g_localizeStrings.Get(18054));
+  SET_CONTROL_LABEL(CONTROL_LABELHEADER, strLabel);
+
+  SET_CONTROL_VISIBLE(CONTROL_LIST_TIMERS);
+}
+
+/**
+ * \brief Update changed buttons
+ */
+void CGUIWindowTV::UpdateButtons()
+{
+  CStdString strLabel;
+
+  if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+  {
+    CStdString strChannel;
+    int current_channel;
+    bool TVPlaying = CPVRManager::GetInstance()->IsPlayingTV();
+    bool RadioPlaying = CPVRManager::GetInstance()->IsPlayingRadio();
+
+    if (TVPlaying || RadioPlaying)
+    {
+      current_channel = CPVRManager::GetInstance()->GetCurrentChannel(RadioPlaying);
+      strChannel = CPVRManager::GetInstance()->GetNameForChannel(current_channel, RadioPlaying);
+    }
+    else
+    {
+      current_channel = 1;
+      strChannel = CPVRManager::GetInstance()->GetNameForChannel(current_channel, false);
+    }
+
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), strChannel.c_str());
+  }
+  else if (m_iGuideView == GUIDE_VIEW_NOW)
+  {
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18101));
+  }
+  else if (m_iGuideView == GUIDE_VIEW_NEXT)
+  {
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18102));
+  }
+  else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+  {
+    strLabel.Format("%s: %s", g_localizeStrings.Get(18050), g_localizeStrings.Get(18103));
+  }
+
+  SET_CONTROL_LABEL(CONTROL_BTNGUIDE, strLabel);
+}
+
+void CGUIWindowTV::UpdateData(TVWindow update)
+{
+  if (m_iCurrSubTVWindow == TV_WINDOW_TV_PROGRAM && update == TV_WINDOW_TV_PROGRAM)
+  {
+
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_TV && update == TV_WINDOW_CHANNELS_TV)
+  {
+    SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_TV);
+    UpdateChannelsTV();
+    SET_CONTROL_VISIBLE(CONTROL_AREA_CHANNELS_TV);
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_CHANNELS_RADIO && update == TV_WINDOW_CHANNELS_RADIO)
+  {
+    SET_CONTROL_HIDDEN(CONTROL_AREA_CHANNELS_RADIO);
+    UpdateChannelsRadio();
+    SET_CONTROL_VISIBLE(CONTROL_AREA_CHANNELS_RADIO);
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_RECORDINGS && update == TV_WINDOW_RECORDINGS)
+  {
+    SET_CONTROL_HIDDEN(CONTROL_AREA_RECORDINGS);
+    UpdateRecordings();
+    SET_CONTROL_VISIBLE(CONTROL_AREA_RECORDINGS);
+  }
+  else if (m_iCurrSubTVWindow == TV_WINDOW_TIMERS && update == TV_WINDOW_TIMERS)
+  {
+    SET_CONTROL_HIDDEN(CONTROL_AREA_TIMERS);
+    UpdateTimers();
+    SET_CONTROL_VISIBLE(CONTROL_AREA_TIMERS);
+  }
+  UpdateButtons();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowTV.h XBMC/xbmc/GUIWindowTV.h
--- XBMC-unpatched/xbmc/GUIWindowTV.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/GUIWindowTV.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,82 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIMediaWindow.h"
+#include "GUIEPGGridContainer.h"
+
+enum TVWindow
+{
+  TV_WINDOW_UNKNOWN         = 0,
+  TV_WINDOW_TV_PROGRAM      = 1,
+  TV_WINDOW_CHANNELS_TV     = 2,
+  TV_WINDOW_CHANNELS_RADIO  = 3,
+  TV_WINDOW_RECORDINGS      = 4,
+  TV_WINDOW_TIMERS          = 5,
+  TV_WINDOW_SETTINGS        = 6
+};
+
+class CGUIWindowTV : public CGUIMediaWindow
+{
+public:
+  CGUIWindowTV(void);
+  virtual ~CGUIWindowTV(void);
+  virtual bool OnMessage(CGUIMessage& message);
+  virtual bool OnAction(const CAction &action);
+
+  void UpdateData(TVWindow update);
+
+protected:
+  virtual bool OnPopupMenu(int iItem);
+  virtual void GetContextButtons(int itemNumber, CContextButtons &buttons);
+  virtual bool OnContextButton(int itemNumber, CONTEXT_BUTTON button);
+  virtual void UpdateButtons();
+
+private:
+  TVWindow m_iCurrSubTVWindow;    /* Active subwindow */
+  TVWindow m_iSavedSubTVWindow;   /* Last subwindow, required if main window is shown again */
+  bool m_bShowHiddenChannels;
+
+  /* Selected item in associated list, required for subwindow change */
+  int m_iSelected_GUIDE;
+  int m_iSelected_CHANNELS_TV;
+  int m_iSelected_CHANNELS_RADIO;
+  int m_iSelected_RECORDINGS;
+  int m_iSelected_TIMERS;
+
+  int m_iGuideView;
+  int m_iCurrentTVGroup;
+  int m_iCurrentRadioGroup;
+
+  void ShowEPGInfo(CFileItem *item);
+  void ShowRecordingInfo(CFileItem *item);
+  bool ShowTimerSettings(CFileItem *item);
+  void ShowGroupManager(bool IsRadio);
+
+  void UpdateGuide();
+  void UpdateChannelsTV();
+  void UpdateChannelsRadio();
+  void UpdateRecordings();
+  void UpdateTimers();
+
+  CGUIEPGGridContainer   *m_guideGrid;
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/GUIWindowVideoBase.cpp XBMC/xbmc/GUIWindowVideoBase.cpp
--- XBMC-unpatched/xbmc/GUIWindowVideoBase.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/GUIWindowVideoBase.cpp	2009-04-14 02:51:17.000000000 +0200
@@ -467,7 +467,7 @@
   m_database.GetScraperForPath(item->m_strPath,info,settings);
   CStdString nfoFile;
 
-  if (!info.settings.GetPluginRoot() && info.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
+  if (!info.settings.GetAddonRoot() && info.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
   {
     CScraperParser parser;
     CStdString strPath;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp XBMC/xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp
--- XBMC-unpatched/xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp	2009-04-22 19:12:31.000000000 +0200
+++ XBMC/xbmc/lib/libPython/xbmcmodule/xbmcplugin.cpp	2009-04-22 18:25:41.000000000 +0200
@@ -22,15 +22,17 @@
 #include "stdafx.h"
 #include "FileSystem/PluginDirectory.h"
 #include "listitem.h"
-#include "PluginSettings.h"
+#include "settings/AddonSettings.h"
+#include "utils/Addon.h"
 #include "FileItem.h"
-#include "GUIDialogPluginSettings.h"
+#include "GUIDialogAddonSettings.h"
 
 // include for constants
 #include "pyutil.h"
 
 using namespace std;
 using namespace XFILE;
+using namespace ADDON;
 
 #ifndef __GNUC__
 #pragma code_seg("PY_TEXT")
@@ -317,7 +319,7 @@
       return NULL;
     };
 
-    return Py_BuildValue((char*)"s", g_currentPluginSettings.Get(id).c_str());
+    return Py_BuildValue((char*)"s", g_currentAddonSettings.Get(id).c_str());
   }
 
   PyDoc_STRVAR(setSetting__doc__,
@@ -356,8 +358,8 @@
       return NULL;
     }
     
-    g_currentPluginSettings.Set(id, value);
-    g_currentPluginSettings.Save();
+    g_currentAddonSettings.Set(id, value);
+    g_currentAddonSettings.Save();
 
     Py_INCREF(Py_None);
     return Py_None;
@@ -569,20 +571,20 @@
     if (!pUrl || (pUrl && !PyGetUnicodeString(url, pUrl, 1)))
       return NULL;
 
-    if (!CPluginSettings::SettingsExist(url))
+    if (!CAddonSettings::SettingsExist(url))
     {
       PyErr_SetString(PyExc_Exception, "No settings.xml file could be found!");
       return NULL;
     }
 
     CURL cUrl(url);
-    CGUIDialogPluginSettings::ShowAndGetInput(cUrl);
+    CGUIDialogAddonSettings::ShowAndGetInput(cUrl);
 
     // reload plugin settings & strings
     if (bReload)
     {
-      g_currentPluginSettings.Load(cUrl);
-      DIRECTORY::CPluginDirectory::LoadPluginStrings(cUrl);
+      g_currentAddonSettings.Load(cUrl);
+      CAddon::LoadAddonStrings(cUrl);
     }
 
     Py_INCREF(Py_None);
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Makefile XBMC/xbmc/Makefile
--- XBMC-unpatched/xbmc/Makefile	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Makefile	2009-04-14 17:09:54.000000000 +0200
@@ -114,6 +114,7 @@
      VideoDatabase.cpp \
      ViewDatabase.cpp \
      GUIDialogAudioSubtitleSettings.cpp \
+     GUIDialogAddonBrowser.cpp \
      GUIDialogBoxBase.cpp \
      GUIDialogButtonMenu.cpp \
      GUIDialogContentSettings.cpp \
@@ -136,6 +137,7 @@
      GUIDialogSelect.cpp \
      GUIDialogSettings.cpp \
      GUIDialogSubMenu.cpp \
+     GUIDialogTVGuide.cpp \
      GUIDialogVideoBookmarks.cpp \
      GUIDialogVideoSettings.cpp \
      GUIDialogVisualisationPresetList.cpp \
@@ -155,6 +157,7 @@
      GUIWindowScripts.cpp \
      GUIWindowScriptsInfo.cpp \
      GUIWindowSystemInfo.cpp \
+     GUIWindowTV.cpp \
      GUIWindowVisualisation.cpp \
      GUIWindowWeather.cpp \
      BackgroundInfoLoader.cpp \
@@ -184,8 +187,7 @@
      GUIDialogKaiToast.cpp \
      KeyboardLayoutConfiguration.cpp \
      Edl.cpp \
-     GUIDialogPluginSettings.cpp \
-     PluginSettings.cpp \
+     GUIDialogAddonSettings.cpp \
      GUIDialogAccessPoints.cpp \
      ScraperSettings.cpp \
      Artist.cpp \
@@ -199,6 +201,13 @@
      GUIDialogFullScreenInfo.cpp \
      PowerManager.cpp \
      Zeroconf.cpp \
+     GUIDialogTVEPGProgInfo.cpp \
+     GUIDialogTVRecordingInfo.cpp \
+     GUIDialogTVTimerSettings.cpp \
+     GUIDialogTVChannels.cpp \
+     GUIDialogTVGroupManager.cpp \
+     PVRManager.cpp \
+     TVDatabase.cpp \
 
 LIB=xbmc.a
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/PluginSettings.cpp XBMC/xbmc/PluginSettings.cpp
--- XBMC-unpatched/xbmc/PluginSettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/PluginSettings.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,246 +0,0 @@
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-#include "stdafx.h"
-#include "PluginSettings.h"
-#include "Util.h"
-#include "FileSystem/File.h"
-#include "FileSystem/Directory.h"
-
-
-CBasicSettings::CBasicSettings()
-{
-}
-
-CBasicSettings::~CBasicSettings()
-{
-}
-
-bool CBasicSettings::SaveFromDefault(void)
-{
-  if (!GetPluginRoot()) //if scraper has no settings return false
-    return false;
-
-  TiXmlElement *setting = GetPluginRoot()->FirstChildElement("setting");
-  while (setting)
-  {
-      CStdString id;
-      if (setting->Attribute("id"))
-          id = setting->Attribute("id");
-      CStdString value;
-      if (setting->Attribute("default"))
-          value = setting->Attribute("default");
-      Set(id,value);
-      setting = setting->NextSiblingElement("setting");
-  }
-  return true;
-}
-
-void CBasicSettings::Clear()
-{
-  m_pluginXmlDoc.Clear();
-  m_userXmlDoc.Clear();
-}
-
-void CBasicSettings::Set(const CStdString& key, const CStdString& value)
-{
-  if (key == "") return;
-
-  // Try to find the setting and change its value
-  if (!m_userXmlDoc.RootElement())
-  {
-    TiXmlElement node("settings");
-    m_userXmlDoc.InsertEndChild(node);
-  }
-  TiXmlElement *setting = m_userXmlDoc.RootElement()->FirstChildElement("setting");
-  while (setting)
-  {
-    const char *id = setting->Attribute("id");
-    if (id && strcmpi(id, key) == 0)
-    {
-      setting->SetAttribute("value", value.c_str());
-      return;
-    }
-
-    setting = setting->NextSiblingElement("setting");
-  }
-
-  // Setting not found, add it
-  TiXmlElement nodeSetting("setting");
-  nodeSetting.SetAttribute("id", key.c_str());
-  nodeSetting.SetAttribute("value", value.c_str());
-  m_userXmlDoc.RootElement()->InsertEndChild(nodeSetting);
-}
-
-CStdString CBasicSettings::Get(const CStdString& key)
-{
-  if (m_userXmlDoc.RootElement())
-  {
-    // Try to find the setting and return its value
-    TiXmlElement *setting = m_userXmlDoc.RootElement()->FirstChildElement("setting");
-    while (setting)
-    {
-      const char *id = setting->Attribute("id");
-      if (id && strcmpi(id, key) == 0)
-        return setting->Attribute("value");
-
-      setting = setting->NextSiblingElement("setting");
-    }
-  }
-
-  if (m_pluginXmlDoc.RootElement())
-  {
-    // Try to find the setting in the plugin and return its default value
-    TiXmlElement* setting = m_pluginXmlDoc.RootElement()->FirstChildElement("setting");
-    while (setting)
-    {
-      const char *id = setting->Attribute("id");
-      if (id && strcmpi(id, key) == 0 && setting->Attribute("default"))
-        return setting->Attribute("default");
-
-      setting = setting->NextSiblingElement("setting");
-    }
-  }
-
-  // Otherwise return empty string
-  return "";
-}
-
-CPluginSettings::CPluginSettings()
-{
-}
-
-CPluginSettings::~CPluginSettings()
-{
-}
-
-bool CPluginSettings::Load(const CURL& url)
-{
-  m_url = url;
-
-  // create the users filepath
-  m_userFileName.Format("special://profile/plugin_data/%s/%s", url.GetHostName().c_str(), url.GetFileName().c_str());
-  CUtil::RemoveSlashAtEnd(m_userFileName);
-  CUtil::AddFileToFolder(m_userFileName, "settings.xml", m_userFileName);
-
-  // Create our final path
-  CStdString pluginFileName = "special://home/plugins/";
-
-  CUtil::AddFileToFolder(pluginFileName, url.GetHostName(), pluginFileName);
-  CUtil::AddFileToFolder(pluginFileName, url.GetFileName(), pluginFileName);
-
-  CUtil::AddFileToFolder(pluginFileName, "resources", pluginFileName);
-  CUtil::AddFileToFolder(pluginFileName, "settings.xml", pluginFileName);
-
-  pluginFileName = pluginFileName;
-
-  if (!m_pluginXmlDoc.LoadFile(pluginFileName))
-  {
-    CLog::Log(LOGERROR, "Unable to load: %s, Line %d\n%s", pluginFileName.c_str(), m_pluginXmlDoc.ErrorRow(), m_pluginXmlDoc.ErrorDesc());
-    return false;
-  }
-
-  // Make sure that the plugin XML has the settings element
-  TiXmlElement *setting = m_pluginXmlDoc.RootElement();
-  if (!setting || strcmpi(setting->Value(), "settings") != 0)
-  {
-    CLog::Log(LOGERROR, "Error loading Settings %s: cannot find root element 'settings'", pluginFileName.c_str());
-    return false;
-  }
-
-  // Load the user saved settings. If it does not exist, create it
-  if (!m_userXmlDoc.LoadFile(m_userFileName))
-  {
-    TiXmlDocument doc;
-    TiXmlDeclaration decl("1.0", "UTF-8", "yes");
-    doc.InsertEndChild(decl);
-
-    TiXmlElement xmlRootElement("settings");
-    doc.InsertEndChild(xmlRootElement);
-
-    m_userXmlDoc = doc;
-
-    // Don't worry about the actual settings, they will be set when the user clicks "Ok"
-    // in the settings dialog
-  }
-
-  return true;
-}
-
-bool CPluginSettings::Save(void)
-{
-  // break down the path into directories
-  CStdString strRoot, strType, strPlugin;
-  CUtil::GetDirectory(m_userFileName, strPlugin);
-  CUtil::RemoveSlashAtEnd(strPlugin);
-  CUtil::GetDirectory(strPlugin, strType);
-  CUtil::RemoveSlashAtEnd(strType);
-  CUtil::GetDirectory(strType, strRoot);
-  CUtil::RemoveSlashAtEnd(strRoot);
-
-  // create the individual folders
-  if (!DIRECTORY::CDirectory::Exists(strRoot))
-    DIRECTORY::CDirectory::Create(strRoot);
-  if (!DIRECTORY::CDirectory::Exists(strType))
-    DIRECTORY::CDirectory::Create(strType);
-  if (!DIRECTORY::CDirectory::Exists(strPlugin))
-    DIRECTORY::CDirectory::Create(strPlugin);
-
-  return m_userXmlDoc.SaveFile(m_userFileName);
-}
-
-TiXmlElement* CBasicSettings::GetPluginRoot()
-{
-  return m_pluginXmlDoc.RootElement();
-}
-
-bool CPluginSettings::SettingsExist(const CStdString& strPath)
-{
-  CURL url(strPath);
-  CStdString pluginFileName = "special://home/plugins/";
-
-  // Create our final path
-  CUtil::AddFileToFolder(pluginFileName, url.GetHostName(), pluginFileName);
-  CUtil::AddFileToFolder(pluginFileName, url.GetFileName(), pluginFileName);
-
-  CUtil::AddFileToFolder(pluginFileName, "resources", pluginFileName);
-  CUtil::AddFileToFolder(pluginFileName, "settings.xml", pluginFileName);
-
-  // Load the settings file to verify it's valid
-  TiXmlDocument xmlDoc;
-  if (!xmlDoc.LoadFile(pluginFileName))
-    return false;
-
-  // Make sure that the plugin XML has the settings element
-  TiXmlElement *setting = xmlDoc.RootElement();
-  if (!setting || strcmpi(setting->Value(), "settings") != 0)
-    return false;
-
-  return true;
-}
-
-CPluginSettings& CPluginSettings::operator=(const CBasicSettings& settings)
-{
-  *((CBasicSettings*)this) = settings;
-
-  return *this;
-}
-
-CPluginSettings g_currentPluginSettings;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/PluginSettings.h XBMC/xbmc/PluginSettings.h
--- XBMC-unpatched/xbmc/PluginSettings.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/PluginSettings.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-#ifndef PLUGINSETTINGS_H_
-#define PLUGINSETTINGS_H_
-/*
- *      Copyright (C) 2005-2008 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "tinyXML/tinyxml.h"
-#include "URL.h"
-#include "Settings.h"
-
-class CBasicSettings
-{
-public:
-  CBasicSettings();
-  virtual ~CBasicSettings();
-
-  bool SaveFromDefault(void);
-  virtual bool Load(const CURL& url)  { return false; }
-  virtual bool Save(void) { return false; }
-  void Clear();
-
-  void Set(const CStdString& key, const CStdString& value);
-  CStdString Get(const CStdString& key);
-
-  TiXmlElement* GetPluginRoot();
-protected:
-  TiXmlDocument   m_userXmlDoc;
-  TiXmlDocument   m_pluginXmlDoc;
-};
-
-class CPluginSettings : public CBasicSettings
-{
-public:
-  CPluginSettings();
-  virtual ~CPluginSettings();
-  bool Load(const CURL& url);
-  bool Save(void);
-  static bool SettingsExist(const CStdString &strPath);
-
-  CPluginSettings& operator =(const CBasicSettings&);
-private:
-  CStdString      m_id;
-  CURL            m_url;
-  CStdString      m_userFileName;
-};
-
-extern CPluginSettings g_currentPluginSettings;
-
-#endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Profile.cpp XBMC/xbmc/Profile.cpp
--- XBMC-unpatched/xbmc/Profile.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Profile.cpp	2009-04-05 20:04:28.000000000 +0200
@@ -30,6 +30,7 @@
   _bCanWrite = true;
   _bSources = true;
   _bCanWriteSources = true;
+  _bAddons = true;
   _bLockPrograms = false;
   _bLockPictures = false;
   _bLockFiles = false;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Profile.h XBMC/xbmc/Profile.h
--- XBMC-unpatched/xbmc/Profile.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Profile.h	2009-04-05 20:04:32.000000000 +0200
@@ -42,6 +42,7 @@
   bool canWriteDatabases() const { return _bCanWrite; }
   bool hasSources() const { return _bSources; }
   bool canWriteSources() const { return _bCanWriteSources; }
+  bool hasAddons() const { return _bAddons; }
   bool settingsLocked() const { return _bLockSettings; }
   bool musicLocked() const { return _bLockMusic; }
   bool videoLocked() const { return _bLockVideo; }
@@ -76,6 +77,7 @@
   bool _bCanWrite;
   bool _bSources;
   bool _bCanWriteSources;
+  bool _bAddons;
 
   // lock stuff
   LockType _iLockMode;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/DllPVRClient.h XBMC/xbmc/pvrclients/DllPVRClient.h
--- XBMC-unpatched/xbmc/pvrclients/DllPVRClient.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/DllPVRClient.h	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,38 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+#include "DynamicDll.h"
+#include "pvrclients/PVRClientTypes.h"
+
+class DllPVRClientInterface
+{
+public:
+  void GetModule(struct PVRClient *pClient);
+};
+
+class DllPVRClient : public DllDynamic, DllPVRClientInterface
+{
+  DECLARE_DLL_WRAPPER_TEMPLATE(DllPVRClient)
+  DEFINE_METHOD1(void, GetModule, (struct PVRClient* p1))
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD_RENAME(get_module,GetModule)
+  END_METHOD_RESOLVE()
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/IPVRClient.h XBMC/xbmc/pvrclients/IPVRClient.h
--- XBMC-unpatched/xbmc/pvrclients/IPVRClient.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/IPVRClient.h	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,91 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "pvrclients/PVRClientTypes.h"
+
+/**
+* IPVRClientCallback Class
+*/
+class IPVRClientCallback
+{
+public:
+  virtual void OnClientMessage(const long clientID, const PVR_EVENT clientEvent, const char* msg)=0;
+};
+
+
+/**
+* IPVRClient PVR Client control class
+*/
+class IPVRClient
+{
+public:
+  IPVRClient(long clientID, IPVRClientCallback *callback){};
+  virtual ~IPVRClient(){};
+
+  virtual PVR_ERROR GetProperties(PVR_SERVERPROPS *props)=0;
+  virtual PVR_ERROR SetUserSetting(const char *settingName, const void *settingValue)=0;
+  virtual PVR_ERROR Connect()=0;
+  virtual void Disconnect()=0;
+  virtual bool IsUp()=0;
+
+  virtual const std::string GetBackendName()=0;
+  virtual const std::string GetBackendVersion()=0;
+  virtual PVR_ERROR GetDriveSpace(long long *total, long long *used)=0;
+
+  virtual PVR_ERROR GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start = NULL, time_t end = NULL)=0;
+  virtual PVR_ERROR GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result)=0;
+  virtual PVR_ERROR GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result)=0;
+
+  virtual int GetNumChannels()=0;
+  virtual PVR_ERROR GetChannelList(VECCHANNELS &channels, bool radio)=0;
+  virtual PVR_ERROR GetChannelSettings(CTVChannelInfoTag *result)=0;
+  virtual PVR_ERROR UpdateChannelSettings(const CTVChannelInfoTag &chaninfo)=0;
+  virtual PVR_ERROR AddChannel(const CTVChannelInfoTag &info)=0;
+  virtual PVR_ERROR DeleteChannel(unsigned int number)=0;
+  virtual PVR_ERROR RenameChannel(unsigned int number, CStdString &newname)=0;
+  virtual PVR_ERROR MoveChannel(unsigned int number, unsigned int newnumber)=0;
+
+  virtual int GetNumRecordings(void)=0;
+  virtual PVR_ERROR GetAllRecordings(VECRECORDINGS *results)=0;
+  virtual PVR_ERROR DeleteRecording(const CTVRecordingInfoTag &recinfo)=0;
+  virtual PVR_ERROR RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname)=0;
+
+  virtual int GetNumTimers(void)=0;
+  virtual PVR_ERROR GetAllTimers(VECTVTIMERS *results)=0;
+  virtual PVR_ERROR AddTimer(const CTVTimerInfoTag &timerinfo)=0;
+  virtual PVR_ERROR DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force = false)=0;
+  virtual PVR_ERROR RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname)=0;
+  virtual PVR_ERROR UpdateTimer(const CTVTimerInfoTag &timerinfo)=0;
+
+  virtual bool OpenLiveStream(unsigned int channel)=0;
+  virtual void CloseLiveStream()=0;
+  virtual int ReadLiveStream(BYTE* buf, int buf_size)=0;
+  virtual int GetCurrentClientChannel()=0;
+  virtual bool SwitchChannel(unsigned int channel)=0;
+
+  virtual bool OpenRecordedStream(const CTVRecordingInfoTag &recinfo)=0;
+  virtual void CloseRecordedStream(void)=0;
+  virtual int ReadRecordedStream(BYTE* buf, int buf_size)=0;
+  virtual __int64 SeekRecordedStream(__int64 pos, int whence=SEEK_SET)=0;
+  virtual __int64 LengthRecordedStream(void)=0;
+};
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/Makefile XBMC/xbmc/pvrclients/Makefile
--- XBMC-unpatched/xbmc/pvrclients/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/Makefile	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,10 @@
+INCLUDES=-I. -I../ -I../linux -I../../guilib -I../utils
+
+SRCS=PVRClient.cpp \
+     PVRClientFactory.cpp \
+
+LIB=pvrclient.a
+
+include ../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/PVRClient.cpp XBMC/xbmc/pvrclients/PVRClient.cpp
--- XBMC-unpatched/xbmc/pvrclients/PVRClient.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/PVRClient.cpp	2009-04-22 18:54:42.000000000 +0200
@@ -0,0 +1,316 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include <vector>
+
+#include "PVRClient.h"
+#include "pvrclients/PVRClientTypes.h"
+#include "../utils/CharsetConverter.h"
+#include "../utils/log.h"
+#include "LocalizeStrings.h"
+
+CPVRClient::CPVRClient(long clientID, struct PVRClient* pClient, DllPVRClient* pDll,
+                       const CStdString& strPVRClientName, IPVRClientCallback* cb)
+                              : IPVRClient(clientID, cb)
+                              , m_clientID(clientID)
+                              , m_pClient(pClient)
+                              , m_pDll(pDll)
+                              , m_clientName(strPVRClientName)
+                              , m_manager(cb)
+{
+
+}
+
+CPVRClient::~CPVRClient()
+{
+  // tell the plugin to disconnect and prepare for destruction
+  Disconnect();
+}
+
+bool CPVRClient::Init()
+{
+  PVRCallbacks *callbacks = new PVRCallbacks;
+  callbacks->userData     = this;
+  callbacks->Event        = PVREventCallback;
+  callbacks->Log          = PVRLogCallback;
+  callbacks->CharConv     = PVRUnknownToUTF8;
+  callbacks->LocStrings   = PVRLocStrings;
+
+  m_pClient->Create(callbacks);
+  return true;
+}
+
+long CPVRClient::GetID()
+{
+  return m_clientID;
+}
+
+PVR_ERROR CPVRClient::GetProperties(PVR_SERVERPROPS *props)
+{
+  // get info from client
+  return m_pClient->GetProperties(props);
+}
+
+PVR_ERROR CPVRClient::SetUserSetting(const char *settingName, const void *settingValue)
+{
+  return m_pClient->SetUserSetting(settingName, settingValue);
+}
+
+PVR_ERROR CPVRClient::Connect()
+{
+  return m_pClient->Connect();
+}
+
+void CPVRClient::Disconnect()
+{
+  m_pClient->Disconnect();
+}
+
+bool CPVRClient::IsUp()
+{
+  return m_pClient->IsUp();
+}
+
+const std::string CPVRClient::GetBackendName()
+{
+  return m_pClient->GetBackendName();
+}
+
+const std::string CPVRClient::GetBackendVersion()
+{
+  return m_pClient->GetBackendVersion();
+}
+
+PVR_ERROR CPVRClient::GetDriveSpace(long long *total, long long *used)
+{
+  return m_pClient->GetDriveSpace(total, used);
+}
+
+PVR_ERROR CPVRClient::GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start, time_t end)
+{
+  return m_pClient->GetEPGForChannel(number, epg, start, end);
+}
+
+PVR_ERROR CPVRClient::GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+  return m_pClient->GetEPGNowInfo(number, result);
+}
+
+PVR_ERROR CPVRClient::GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+  return m_pClient->GetEPGNextInfo(number, result);
+}
+
+int CPVRClient::GetNumChannels()
+{
+  return m_pClient->GetNumChannels();
+}
+
+PVR_ERROR CPVRClient::GetChannelList(VECCHANNELS &channels, bool radio)
+{
+  return m_pClient->GetChannelList(&channels, radio);
+}
+
+PVR_ERROR CPVRClient::GetChannelSettings(CTVChannelInfoTag *result)
+{
+  return m_pClient->GetChannelSettings(result);
+}
+
+PVR_ERROR CPVRClient::UpdateChannelSettings(const CTVChannelInfoTag &chaninfo)
+{
+  return m_pClient->UpdateChannelSettings(chaninfo);
+}
+
+PVR_ERROR CPVRClient::AddChannel(const CTVChannelInfoTag &info)
+{
+  return m_pClient->AddChannel(info);
+}
+
+PVR_ERROR CPVRClient::DeleteChannel(unsigned int number)
+{
+  return m_pClient->DeleteChannel(number);
+}
+
+PVR_ERROR CPVRClient::RenameChannel(unsigned int number, CStdString &newname)
+{
+  return m_pClient->RenameChannel(number, newname);
+}
+
+PVR_ERROR CPVRClient::MoveChannel(unsigned int number, unsigned int newnumber)
+{
+  return m_pClient->MoveChannel(number, newnumber);
+}
+
+int CPVRClient::GetNumRecordings(void)
+{
+  return m_pClient->GetNumRecordings();
+}
+
+PVR_ERROR CPVRClient::GetAllRecordings(VECRECORDINGS *results)
+{
+  return m_pClient->GetAllRecordings(results);
+}
+
+PVR_ERROR CPVRClient::DeleteRecording(const CTVRecordingInfoTag &recinfo)
+{
+  return m_pClient->DeleteRecording(recinfo);
+}
+
+PVR_ERROR CPVRClient::RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname)
+{
+  return m_pClient->RenameRecording(recinfo, newname);
+}
+
+int CPVRClient::GetNumTimers(void)
+{
+  return m_pClient->GetNumTimers();
+}
+
+PVR_ERROR CPVRClient::GetAllTimers(VECTVTIMERS *results)
+{
+  return m_pClient->GetAllTimers(results);
+}
+
+PVR_ERROR CPVRClient::AddTimer(const CTVTimerInfoTag &timerinfo)
+{
+  return m_pClient->AddTimer(timerinfo);
+}
+
+PVR_ERROR CPVRClient::DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force)
+{
+  return m_pClient->DeleteTimer(timerinfo, force);
+}
+
+PVR_ERROR CPVRClient::RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname)
+{
+  return m_pClient->RenameTimer(timerinfo, newname);
+}
+
+PVR_ERROR CPVRClient::UpdateTimer(const CTVTimerInfoTag &timerinfo)
+{
+  return m_pClient->UpdateTimer(timerinfo);
+}
+
+bool CPVRClient::OpenLiveStream(unsigned int channel)
+{
+  return m_pClient->OpenLiveStream(channel);
+}
+
+void CPVRClient::CloseLiveStream()
+{
+  return m_pClient->CloseLiveStream();
+}
+
+int CPVRClient::ReadLiveStream(BYTE* buf, int buf_size)
+{
+  return m_pClient->ReadLiveStream(buf, buf_size);
+}
+
+int CPVRClient::GetCurrentClientChannel()
+{
+  return m_pClient->GetCurrentClientChannel();
+}
+
+bool CPVRClient::SwitchChannel(unsigned int channel)
+{
+  return m_pClient->SwitchChannel(channel);
+}
+
+bool CPVRClient::OpenRecordedStream(const CTVRecordingInfoTag &recinfo)
+{
+  return m_pClient->OpenRecordedStream(recinfo);
+}
+
+void CPVRClient::CloseRecordedStream(void)
+{
+  return m_pClient->CloseRecordedStream();
+}
+
+int CPVRClient::ReadRecordedStream(BYTE* buf, int buf_size)
+{
+  return m_pClient->ReadRecordedStream(buf, buf_size);
+}
+
+__int64 CPVRClient::SeekRecordedStream(__int64 pos, int whence)
+{
+  return m_pClient->SeekRecordedStream(pos, whence);
+}
+
+__int64 CPVRClient::LengthRecordedStream(void)
+{
+  return m_pClient->LengthRecordedStream();
+}
+
+/**
+* XBMC callbacks
+*/
+void CPVRClient::PVREventCallback(void *userData, const PVR_EVENT pvrevent, const char *msg)
+{
+  CPVRClient* client=(CPVRClient*) userData;
+  if (!client)
+    return;
+
+  client->m_manager->OnClientMessage(client->m_clientID, pvrevent, msg);
+}
+
+void CPVRClient::PVRLogCallback(void *userData, const PVR_LOG loglevel, const char *format, ... )
+{
+  CPVRClient* client=(CPVRClient*) userData;
+  if (!client)
+    return;
+
+  CStdString message;
+  message.reserve(16384);
+  message.Format("PVR: %s/%s:", client->m_clientName, client->m_hostName);
+
+  va_list va;
+  va_start(va, format);
+  message.FormatV(format, va);
+  va_end(va);
+
+  int xbmclog;
+  switch (loglevel)
+  {
+    case LOG_ERROR:
+      xbmclog = LOGERROR;
+      break;
+    case LOG_INFO:
+      xbmclog = LOGINFO;
+      break;
+    case LOG_DEBUG:
+    default:
+      xbmclog = LOGDEBUG;
+      break;
+  }
+
+  CLog::Log(xbmclog, message);
+}
+
+void CPVRClient::PVRUnknownToUTF8(CStdStringA &sourceDest)
+{
+  g_charsetConverter.unknownToUTF8(sourceDest);
+}
+
+const char* CPVRClient::PVRLocStrings(DWORD dwCode)
+{
+  return g_localizeStrings.Get(dwCode).c_str();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/PVRClientFactory.cpp XBMC/xbmc/pvrclients/PVRClientFactory.cpp
--- XBMC-unpatched/xbmc/pvrclients/PVRClientFactory.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/PVRClientFactory.cpp	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+#include "stdafx.h"
+#include "PVRClientFactory.h"
+#include "Util.h"
+#include "FileSystem/File.h"
+
+using namespace XFILE;
+
+CPVRClientFactory::CPVRClientFactory()
+{
+
+}
+
+CPVRClientFactory::~CPVRClientFactory()
+{
+
+}
+
+CPVRClient* CPVRClientFactory::LoadPVRClient(const CStdString& strClient, DWORD clientID, IPVRClientCallback *cb)
+{
+  // strip of the path & extension to get the name of the client
+  // like vdr or mythtv
+  CStdString strFileName = strClient;
+  CStdString strDirFileName = strClient;
+  int found = strDirFileName.find("addon://pvrclients/", 0);
+  if (found != -1)
+    strDirFileName.erase(0, strlen("addon://pvrclients/"));
+  else
+    strDirFileName = "";
+  CStdString strName = CUtil::GetFileName(strClient);
+
+  // if it's a relative path or just a name, convert to absolute path
+  if ( strFileName[1] != ':' && strFileName[0] != '/' )
+  {
+    // first check home
+    strFileName.Format("special://home/pvrclients/%s", strDirFileName.c_str());
+
+    // if not found, use system
+    if ( ! CFile::Exists( strFileName ) )
+      strFileName.Format("special://xbmc/pvrclients/%s", strDirFileName.c_str());
+  }
+  strName = strName.Left(strName.ReverseFind('.'));
+
+  // load client
+  DllPVRClient* pDll = new DllPVRClient;
+  pDll->SetFile(strFileName);
+
+  pDll->EnableDelayedUnload(false);
+  if (!pDll->Load())
+  {
+    delete pDll;
+    return NULL;
+  }
+
+  struct PVRClient* pClient = (struct PVRClient*)malloc(sizeof(struct PVRClient));
+  ZeroMemory(pClient, sizeof(struct PVRClient));
+  pDll->GetModule(pClient);
+
+  // and pass it to a new instance of CPVRClient() which will handle the client
+  CPVRClient *client(new CPVRClient(clientID, pClient, pDll, strName, cb));
+  client->Init();
+
+  return client;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/PVRClientFactory.h XBMC/xbmc/pvrclients/PVRClientFactory.h
--- XBMC-unpatched/xbmc/pvrclients/PVRClientFactory.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/PVRClientFactory.h	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,32 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRClient.h"
+
+class CPVRClientFactory
+{
+public:
+  CPVRClientFactory();
+  virtual ~CPVRClientFactory();
+
+  static CPVRClient* LoadPVRClient(const CStdString& strClient, DWORD clientID, IPVRClientCallback *callback);
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/PVRClient.h XBMC/xbmc/pvrclients/PVRClient.h
--- XBMC-unpatched/xbmc/pvrclients/PVRClient.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/PVRClient.h	2009-04-22 18:14:57.000000000 +0200
@@ -0,0 +1,106 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "IPVRClient.h"
+#include "DllPVRClient.h"
+
+class CPVRClient : public IPVRClient
+{
+public:
+  CPVRClient(const long clientID, struct PVRClient* pClient, DllPVRClient* pDll,
+             const CStdString& strPVRClientName, IPVRClientCallback *cb);
+  ~CPVRClient();
+
+  /* DLL related */
+  bool Init();
+  void OnClientMessage(PVR_EVENT event);
+
+  /* Server */
+  virtual long GetID();
+  virtual PVR_ERROR GetProperties(PVR_SERVERPROPS *props);
+  virtual PVR_ERROR SetUserSetting(const char *settingName, const void *settingValue);
+  virtual PVR_ERROR Connect();
+  virtual void Disconnect();
+  virtual bool IsUp();
+
+  /* General */
+  virtual const std::string GetBackendName();
+  virtual const std::string GetBackendVersion();
+  virtual PVR_ERROR GetDriveSpace(long long *total, long long *used);
+
+  /* TV Guide */
+  virtual PVR_ERROR GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start, time_t end);
+  virtual PVR_ERROR GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result);
+  virtual PVR_ERROR GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result);
+
+  /* Channels */
+  virtual int GetNumChannels();
+  virtual PVR_ERROR GetChannelList(VECCHANNELS &channels, bool radio);
+  virtual PVR_ERROR GetChannelSettings(CTVChannelInfoTag *result);
+  virtual PVR_ERROR UpdateChannelSettings(const CTVChannelInfoTag &chaninfo);
+  virtual PVR_ERROR AddChannel(const CTVChannelInfoTag &info);
+  virtual PVR_ERROR DeleteChannel(unsigned int number);
+  virtual PVR_ERROR RenameChannel(unsigned int number, CStdString &newname);
+  virtual PVR_ERROR MoveChannel(unsigned int number, unsigned int newnumber);
+
+  /* Recordings */
+  virtual int GetNumRecordings(void);
+  virtual PVR_ERROR GetAllRecordings(VECRECORDINGS *results);
+  virtual PVR_ERROR DeleteRecording(const CTVRecordingInfoTag &recinfo);
+  virtual PVR_ERROR RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname);
+
+  /* Timers */
+  virtual int GetNumTimers(void);
+  virtual PVR_ERROR GetAllTimers(VECTVTIMERS *results);
+  virtual PVR_ERROR AddTimer(const CTVTimerInfoTag &timerinfo);
+  virtual PVR_ERROR DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force = false);
+  virtual PVR_ERROR RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname);
+  virtual PVR_ERROR UpdateTimer(const CTVTimerInfoTag &timerinfo);
+
+  virtual bool OpenLiveStream(unsigned int channel);
+  virtual void CloseLiveStream();
+  virtual int ReadLiveStream(BYTE* buf, int buf_size);
+  virtual int GetCurrentClientChannel();
+  virtual bool SwitchChannel(unsigned int channel);
+
+  virtual bool OpenRecordedStream(const CTVRecordingInfoTag &recinfo);
+  virtual void CloseRecordedStream(void);
+  virtual int ReadRecordedStream(BYTE* buf, int buf_size);
+  virtual __int64 SeekRecordedStream(__int64 pos, int whence=SEEK_SET);
+  virtual __int64 LengthRecordedStream(void);
+
+protected:
+  const long m_clientID;
+  std::auto_ptr<struct PVRClient> m_pClient;
+  std::auto_ptr<DllPVRClient> m_pDll;
+  CStdString m_clientName;
+  CStdString m_hostName;
+  IPVRClientCallback* m_manager;
+
+private:
+  static void PVREventCallback(void *userData, const PVR_EVENT pvrevent, const char *msg);
+  static void PVRLogCallback(void *userData, const PVR_LOG loglevel, const char *format, ... );
+  static void PVRUnknownToUTF8(CStdStringA &sourceDest);
+  static const char* PVRLocStrings(DWORD dwCode);
+};
+
+typedef std::vector<CPVRClient*> VECCLIENTS;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/PVRClientTypes.h XBMC/xbmc/pvrclients/PVRClientTypes.h
--- XBMC-unpatched/xbmc/pvrclients/PVRClientTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/PVRClientTypes.h	2009-04-22 18:15:14.000000000 +0200
@@ -0,0 +1,166 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+  Common data structures shared between XBMC and XBMC's PVR Clients
+ */
+
+#ifndef __PVRCLIENT_TYPES_H__
+#define __PVRCLIENT_TYPES_H__
+
+#include <vector>
+#include "utils/TVEPGInfoTag.h"
+#include "utils/TVChannelInfoTag.h"
+#include "utils/TVRecordInfoTag.h"
+#include "utils/TVTimerInfoTag.h"
+
+extern "C"
+{
+
+  /**
+  * XBMC logging levels
+  */
+  enum PVR_LOG {
+    LOG_DEBUG,
+    LOG_INFO,
+    LOG_ERROR
+  };
+
+  /**
+  * PVR Client Error Codes
+  */
+  typedef enum {
+    PVR_ERROR_NO_ERROR             = 0,
+    PVR_ERROR_UNKOWN               = -1,
+    PVR_ERROR_NOT_IMPLEMENTED      = -2,
+    PVR_ERROR_SERVER_WRONG_VERSION = -3,
+    PVR_ERROR_SERVER_ERROR         = -4,
+    PVR_ERROR_SERVER_TIMEOUT       = -5,
+    PVR_ERROR_NOT_SYNC             = -7,
+    PVR_ERROR_NOT_DELETED          = -8,
+    PVR_ERROR_NOT_SAVED            = -9,
+    PVR_ERROR_RECORDING_RUNNING    = -10,
+    PVR_ERROR_ALREADY_PRESENT      = -11,
+  } PVR_ERROR;
+
+  /**
+  * PVR Client Event Codes
+  * Sent via PVRManager callback
+  */
+  typedef enum {
+    PVR_EVENT_UNKNOWN              = 0,
+    PVR_EVENT_CLOSE                = 1,
+    PVR_EVENT_RECORDINGS_CHANGE    = 2,
+    PVR_EVENT_CHANNELS_CHANGE      = 3,
+    PVR_EVENT_TIMERS_CHANGE        = 4
+  } PVR_EVENT;
+
+  /**
+  * PVR Client Properties
+  * Returned on client initialization
+  */
+  typedef struct PVR_SERVERPROPS {
+    const char* Name;
+    const char* Hostname;
+    int   Port;
+    const char* DefaultUser;
+    const char* DefaultPassword;
+    bool SupportChannelLogo;
+    bool SupportChannelSettings;
+    bool SupportTimeShift;
+    bool SupportEPG;
+    bool SupportRadio;
+    bool SupportRecordings;
+    bool SupportTimers;
+    bool SupportTeletext;
+    bool SupportDirector;
+    bool SupportBouquets;
+  } PVR_SERVERPROPS;
+
+  /**
+  * XBMC callbacks
+  */
+  typedef void (*PVREventCallback)(void *userData, const PVR_EVENT, const char*);
+  typedef void (*PVRLogCallback)(void *userData, const PVR_LOG loglevel, const char *format, ... );
+  typedef void (*PVRCharConv)(CStdStringA &sourceDest);
+  typedef const char* (*PVRLocStrings)(DWORD dwCode);
+
+  typedef struct PVRCallbacks
+  {
+    PVREventCallback Event;
+    PVRLogCallback   Log;
+    PVRCharConv      CharConv;
+    PVRLocStrings    LocStrings;
+    void            *userData;
+  } PVRCallbacks;
+
+  // Structure to transfer the above functions to XBMC
+  struct PVRClient
+  {
+    PVR_ERROR (__cdecl* Create)(PVRCallbacks *callbacks);
+    PVR_ERROR (__cdecl* GetProperties)(PVR_SERVERPROPS *props);
+    PVR_ERROR (__cdecl* SetProperties)(PVR_SERVERPROPS *props);
+    PVR_ERROR (__cdecl* SetUserSetting)(const char *settingName, const void *settingValue);
+    PVR_ERROR (__cdecl* Connect)();
+    void (__cdecl* Disconnect)();
+    bool (__cdecl* IsUp)();
+    const char* (__cdecl* GetBackendName)();
+    const char* (__cdecl* GetBackendVersion)();
+    PVR_ERROR (__cdecl* GetDriveSpace)(long long *total, long long *used);
+    PVR_ERROR (__cdecl* GetEPGForChannel)(unsigned int number, EPG_DATA &epg, time_t start, time_t end);
+    PVR_ERROR (__cdecl* GetEPGNowInfo)(unsigned int number, CTVEPGInfoTag *result);
+    PVR_ERROR (__cdecl* GetEPGNextInfo)(unsigned int number, CTVEPGInfoTag *result);
+    int (__cdecl* GetNumChannels)();
+    PVR_ERROR (__cdecl* GetChannelList)(VECCHANNELS *channels, bool radio);
+    PVR_ERROR (__cdecl* GetChannelSettings)(CTVChannelInfoTag *result);
+    PVR_ERROR (__cdecl* UpdateChannelSettings)(const CTVChannelInfoTag &chaninfo);
+    PVR_ERROR (__cdecl* AddChannel)(const CTVChannelInfoTag &info);
+    PVR_ERROR (__cdecl* DeleteChannel)(unsigned int number);
+    PVR_ERROR (__cdecl* RenameChannel)(unsigned int number, CStdString &newname);
+    PVR_ERROR (__cdecl* MoveChannel)(unsigned int number, unsigned int newnumber);
+    int (__cdecl* GetNumRecordings)(void);
+    PVR_ERROR (__cdecl* GetAllRecordings)(VECRECORDINGS *results);
+    PVR_ERROR (__cdecl* DeleteRecording)(const CTVRecordingInfoTag &recinfo);
+    PVR_ERROR (__cdecl* RenameRecording)(const CTVRecordingInfoTag &recinfo, CStdString &newname);
+    int (__cdecl* GetNumTimers)(void);
+    PVR_ERROR (__cdecl* GetAllTimers)(VECTVTIMERS *results);
+    PVR_ERROR (__cdecl* AddTimer)(const CTVTimerInfoTag &timerinfo);
+    PVR_ERROR (__cdecl* DeleteTimer)(const CTVTimerInfoTag &timerinfo, bool force);
+    PVR_ERROR (__cdecl* RenameTimer)(const CTVTimerInfoTag &timerinfo, CStdString &newname);
+    PVR_ERROR (__cdecl* UpdateTimer)(const CTVTimerInfoTag &timerinfo);
+    bool (__cdecl* OpenLiveStream)(unsigned int channel);
+    void (__cdecl* CloseLiveStream)();
+    int (__cdecl* ReadLiveStream)(BYTE* buf, int buf_size);
+    int (__cdecl* GetCurrentClientChannel)();
+    bool (__cdecl* SwitchChannel)(unsigned int channel);
+    bool (__cdecl* OpenRecordedStream)(const CTVRecordingInfoTag &recinfo);
+    void (__cdecl* CloseRecordedStream)(void);
+    int (__cdecl* ReadRecordedStream)(BYTE* buf, int buf_size);
+    __int64 (__cdecl* SeekRecordedStream)(__int64 pos, int whence);
+    __int64 (__cdecl* LengthRecordedStream)(void);
+  };
+
+
+
+}
+
+#endif //__PVRCLIENT_TYPES_H__
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/client.cpp XBMC/xbmc/pvrclients/vdr/client.cpp
--- XBMC-unpatched/xbmc/pvrclients/vdr/client.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/client.cpp	2009-04-22 18:40:51.000000000 +0200
@@ -0,0 +1,243 @@
+/*
+*      Copyright (C) 2005-2009 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#ifdef HAS_XBOX_HARDWARE
+#include <xtl.h>
+#endif
+
+#include "pvrclient-vdr_os.h"
+#include "../../../pvrclients/xbmc_pvr.h"
+#include "pvrclient-vdr.h"
+
+// global callback for logging via XBMC
+PVRClientVDR *g_client;
+static PVREventCallback OnEvent;
+static PVRLogCallback OnLog;
+static void *Wrapper;
+static bool created = false;
+
+//////////////////////////////////////////////////////////////////////////////
+extern "C" PVR_ERROR Create(PVRCallbacks *callbacks)
+{
+  OnEvent   = callbacks->Event;
+  OnLog     = callbacks->Log;
+  Wrapper   = callbacks->userData;
+
+  g_client  = new PVRClientVDR(callbacks);
+  created   = true;
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+extern "C" PVR_ERROR GetProperties(PVR_SERVERPROPS* pProps)
+{
+  return g_client->GetProperties(pProps);
+}
+
+extern "C" PVR_ERROR SetUserSetting(const char *settingName, const void *settingValue)
+{
+  return g_client->SetUserSetting(settingName, settingValue);
+}
+
+extern "C" PVR_ERROR Connect()
+{
+  return g_client->Connect();
+}
+
+extern "C" void Disconnect()
+{
+  return g_client->Disconnect();
+}
+
+extern "C" bool IsUp()
+{
+  return g_client->IsUp();
+}
+
+extern "C" const char* GetBackendName()
+{
+  return g_client->GetBackendName();
+}
+
+extern "C" const char* GetBackendVersion()
+{
+  return g_client->GetBackendVersion();
+}
+
+extern "C" PVR_ERROR GetDriveSpace(long long *total, long long *used)
+{
+  return g_client->GetDriveSpace(total, used);
+}
+
+extern "C" PVR_ERROR GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start, time_t end)
+{
+  return g_client->GetEPGForChannel(number, epg, start, end);
+}
+
+extern "C" PVR_ERROR GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+  return g_client->GetEPGNowInfo(number, result);
+}
+
+extern "C" PVR_ERROR GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+  return g_client->GetEPGNextInfo(number, result);
+}
+
+extern "C" int GetNumChannels()
+{
+  return g_client->GetNumChannels();
+}
+
+extern "C" PVR_ERROR GetChannelList(VECCHANNELS *channels, bool radio)
+{
+  return g_client->GetChannelList(channels, radio);
+}
+
+extern "C" PVR_ERROR GetChannelSettings(CTVChannelInfoTag *result)
+{
+  return g_client->GetChannelSettings(result);
+}
+
+extern "C" PVR_ERROR UpdateChannelSettings(const CTVChannelInfoTag &chaninfo)
+{
+  return g_client->UpdateChannelSettings(chaninfo);
+}
+
+extern "C" PVR_ERROR AddChannel(const CTVChannelInfoTag &info)
+{
+  return g_client->AddChannel(info);
+}
+
+extern "C" PVR_ERROR DeleteChannel(unsigned int number)
+{
+  return g_client->DeleteChannel(number);
+}
+
+extern "C" PVR_ERROR RenameChannel(unsigned int number, CStdString &newname)
+{
+  return g_client->RenameChannel(number, newname);
+}
+
+extern "C" PVR_ERROR MoveChannel(unsigned int number, unsigned int newnumber)
+{
+  return g_client->MoveChannel(number, newnumber);
+}
+
+extern "C" int GetNumRecordings(void)
+{
+  return g_client->GetNumRecordings();
+}
+
+extern "C" PVR_ERROR GetAllRecordings(VECRECORDINGS *results)
+{
+  return g_client->GetAllRecordings(results);
+}
+
+extern "C" PVR_ERROR DeleteRecording(const CTVRecordingInfoTag &recinfo)
+{
+  return g_client->DeleteRecording(recinfo);
+}
+
+extern "C" PVR_ERROR RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname)
+{
+  return g_client->RenameRecording(recinfo, newname);
+}
+
+extern "C" int GetNumTimers(void)
+{
+  return g_client->GetNumTimers();
+}
+
+extern "C" PVR_ERROR GetAllTimers(VECTVTIMERS *results)
+{
+  return g_client->GetAllTimers(results);
+}
+
+extern "C" PVR_ERROR AddTimer(const CTVTimerInfoTag &timerinfo)
+{
+  return g_client->AddTimer(timerinfo);
+}
+
+extern "C" PVR_ERROR DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force)
+{
+  return g_client->DeleteTimer(timerinfo, force);
+}
+
+extern "C" PVR_ERROR RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname)
+{
+  return g_client->RenameTimer(timerinfo, newname);
+}
+
+extern "C" PVR_ERROR UpdateTimer(const CTVTimerInfoTag &timerinfo)
+{
+  return g_client->UpdateTimer(timerinfo);
+}
+
+extern "C" bool OpenLiveStream(unsigned int channel)
+{
+  return g_client->OpenLiveStream(channel);
+}
+
+extern "C" void CloseLiveStream()
+{
+  return g_client->CloseLiveStream();
+}
+
+extern "C" int ReadLiveStream(BYTE* buf, int buf_size)
+{
+  return g_client->ReadLiveStream(buf, buf_size);
+}
+
+extern "C" int GetCurrentClientChannel()
+{
+  return g_client->GetCurrentClientChannel();
+}
+
+extern "C" bool SwitchChannel(unsigned int channel)
+{
+  return g_client->SwitchChannel(channel);
+}
+
+extern "C" bool OpenRecordedStream(const CTVRecordingInfoTag &recinfo)
+{
+  return g_client->OpenRecordedStream(recinfo);
+}
+
+extern "C" void CloseRecordedStream(void)
+{
+  return g_client->CloseRecordedStream();
+}
+
+extern "C" int ReadRecordedStream(BYTE* buf, int buf_size)
+{
+  return g_client->ReadRecordedStream(buf, buf_size);
+}
+
+extern "C" __int64 SeekRecordedStream(__int64 pos, int whence)
+{
+  return g_client->SeekRecordedStream(pos, whence);
+}
+
+extern "C" __int64 LengthRecordedStream(void)
+{
+  return g_client->LengthRecordedStream();
+}
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/Makefile XBMC/xbmc/pvrclients/vdr/Makefile
--- XBMC-unpatched/xbmc/pvrclients/vdr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/Makefile	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,18 @@
+ARCH=x86_64-linux
+INCLUDES=-I. -I../../linux -I../../ -I ../../../guilib
+DEFINES+=
+CXXFLAGS=-fPIC
+OBJS=client.o pvrclient-vdr.o vtptransceiver.o
+
+SLIB=../../../pvrclients/VDR/vdr.pvr
+
+$(SLIB): $(OBJS)
+ifeq ($(findstring osx,$(ARCH)), osx)
+	@export MACOSX_DEPLOYMENT_TARGET=10.4
+	$(CXX) -bundle -shared -flat_namespace -undefined suppress -o $(SLIB) $(OBJS)
+	../../../tools/Mach5/wrapper.rb $@;mv output.so $@
+else
+	$(CXX) $(CFLAGS) -shared -g -o $(SLIB) $(OBJS)
+endif
+
+include ../../../Makefile.include
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/Makefile.in XBMC/xbmc/pvrclients/vdr/Makefile.in
--- XBMC-unpatched/xbmc/pvrclients/vdr/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/Makefile.in	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,18 @@
+ARCH=@ARCH@
+INCLUDES=-I. -I../../linux -I../../ -I ../../../guilib
+DEFINES+=
+CXXFLAGS=-fPIC
+OBJS=client.o pvrclient-vdr.o vtptransceiver.o
+
+SLIB=../../../pvrclients/VDR/vdr.pvr
+
+$(SLIB): $(OBJS)
+ifeq ($(findstring osx,$(ARCH)), osx)
+	@export MACOSX_DEPLOYMENT_TARGET=10.4
+	$(CXX) -bundle -shared -flat_namespace -undefined suppress -o $(SLIB) $(OBJS)
+	../../../tools/Mach5/wrapper.rb $@;mv output.so $@
+else
+	$(CXX) $(CFLAGS) -shared -g -o $(SLIB) $(OBJS)
+endif
+
+include ../../../Makefile.include
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr.cpp XBMC/xbmc/pvrclients/vdr/pvrclient-vdr.cpp
--- XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/pvrclient-vdr.cpp	2009-04-22 18:53:12.000000000 +0200
@@ -0,0 +1,4003 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifdef HAS_XBOX_HARDWARE
+#include <xtl.h>
+#endif
+#include "pvrclient-vdr.h"
+#include "pvrclient-vdr_os.h"
+
+#ifdef _LINUX
+#define SD_BOTH SHUT_RDWR
+#endif
+
+#define SEEK_POSSIBLE 0x10 // flag used to check if protocol allows seeks
+
+using namespace std;
+
+#ifndef _LINUX
+extern "C" long long atoll(const char *ca)
+{
+  long long ig=0;
+  int       sign=1;
+  /* test for prefixing white space */
+  while (*ca == ' ' || *ca == '\t' )
+    ca++;
+  /* Check sign entered or no */
+  if ( *ca == '-' )
+    sign = -1;
+  /* convert string to int */
+  while (*ca != '\0')
+    if (*ca >= '0' && *ca <= '9')
+      ig = ig * 10LL + *ca++ - '0';
+    else
+      ca++;
+  return (ig*(long long)sign);
+}
+#endif
+
+bool PVRClientVDR::m_bStop						= true;
+SOCKET PVRClientVDR::m_socket_data				= INVALID_SOCKET;
+SOCKET PVRClientVDR::m_socket_video				= INVALID_SOCKET;
+CVTPTransceiver *PVRClientVDR::m_transceiver    = NULL;
+PVRCallbacks *PVRClientVDR::m_xbmc				= NULL;
+bool PVRClientVDR::m_bConnected					= false;
+
+/************************************************************/
+/** Class interface */
+
+PVRClientVDR::PVRClientVDR(PVRCallbacks *callback)
+{
+  m_xbmc              = callback;
+  m_iCurrentChannel   = 1;
+  m_transceiver       = new CVTPTransceiver();
+  m_bConnected        = false;
+  m_bCharsetConv      = false;
+  m_sHostname         = "127.0.0.1";
+  m_iPort             = 2004;
+  m_bRadioEnabled     = true;
+  m_bOnlyFTA          = true;
+  m_socket_video      = INVALID_SOCKET;
+  m_socket_data       = INVALID_SOCKET;
+  m_bStop             = true;
+
+  pthread_mutex_init(&m_critSection, NULL);
+}
+
+PVRClientVDR::~PVRClientVDR()
+{
+  Disconnect();
+}
+
+
+/************************************************************/
+/** Server handling */
+
+PVR_ERROR PVRClientVDR::GetProperties(PVR_SERVERPROPS* pProps)
+{
+  pProps->Name                      = "VDR";
+  pProps->Hostname                  = m_sHostname.c_str();
+  pProps->Port                      = m_iPort;
+  pProps->DefaultUser               = "";
+  pProps->DefaultPassword           = "";
+  pProps->SupportChannelLogo        = false;
+  pProps->SupportTimeShift          = false;
+  pProps->SupportEPG                = true;
+  pProps->SupportRecordings         = true;
+  pProps->SupportTimers             = true;
+  pProps->SupportRadio              = m_bRadioEnabled;
+  pProps->SupportChannelSettings    = true;
+  pProps->SupportTeletext           = false;
+  pProps->SupportDirector           = false;
+  pProps->SupportBouquets           = false;
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::SetUserSetting(const char *settingName, const void *settingValue)
+{
+  string str = settingName;
+  if (str == "host")
+    m_sHostname = (const char*) settingValue;
+  else if (str == "port")
+    m_iPort = *(int*) settingValue;
+  else if (str == "ftaonly")
+    m_bOnlyFTA = *(bool*) settingValue;
+  else if (str == "useradio")
+    m_bRadioEnabled = *(bool*) settingValue;
+  else if (str == "convertchar")
+    m_bCharsetConv = *(bool*) settingValue;
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::Connect()
+{
+  /* Open Streamdev-Server VTP-Connection to VDR Backend Server */
+  if (!m_transceiver->Open(m_sHostname, m_iPort))
+    return PVR_ERROR_SERVER_ERROR;
+
+  /* Check VDR streamdev is patched by calling a newly added command */
+  if (GetNumChannels() == -1)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Detected unsupported Streamdev-Version");
+    return PVR_ERROR_SERVER_WRONG_VERSION;
+  }
+
+  /* Get Data socket from VDR Backend */
+  m_socket_data = m_transceiver->GetStreamData();
+
+  /* If received socket is invalid, return */
+  if (m_socket_data == INVALID_SOCKET)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get socket for data response");
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  /* Start VTP Listening Thread */
+//  m_bStop = false;
+//  if (pthread_create(&m_thread, NULL, &Process, (void *)"PVRClientVDR VTP-Listener") != 0) {
+//    return PVR_ERROR_SERVER_ERROR;
+//  }
+
+  m_bConnected = true;
+  return PVR_ERROR_NO_ERROR;
+}
+
+void PVRClientVDR::Disconnect()
+{
+  m_bStop = true;
+  pthread_join(m_thread, NULL);
+
+  m_bConnected = false;
+
+  /* Check if  stream sockets are open, if yes close them */
+  if (m_socket_data != INVALID_SOCKET)
+  {
+    m_transceiver->AbortStreamData();
+    closesocket(m_socket_data);
+    m_socket_data = INVALID_SOCKET;
+  }
+
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    m_transceiver->AbortStreamLive();
+    closesocket(m_socket_video);
+    m_socket_video = INVALID_SOCKET;
+  }
+
+  /* Close Streamdev-Server VTP Backend Connection */
+  m_transceiver->Close();
+}
+
+bool PVRClientVDR::IsUp()
+{
+  if (m_bConnected || m_transceiver->IsOpen())
+  {
+    return true;
+  }
+  return false;
+}
+
+void* PVRClientVDR::Process(void*)
+{
+  char   		 data[1024];
+  fd_set         set_r, set_e;
+  struct timeval tv;
+  int            res;
+
+  while (!m_bStop)
+  {
+	if ((!m_transceiver->IsOpen()) || (m_socket_data == INVALID_SOCKET))
+	{
+	  m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Process - Loosed connectio to VDR");
+	  m_bConnected = false;
+	  return NULL;
+	}
+
+	tv.tv_sec = 5;
+	tv.tv_usec = 0;
+
+	FD_ZERO(&set_r);
+	FD_ZERO(&set_e);
+	FD_SET(m_socket_data, &set_r);
+	FD_SET(m_socket_data, &set_e);
+	res = select(FD_SETSIZE, &set_r, NULL, &set_e, &tv);
+	if (res < 0)
+	{
+	  m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Process - select failed");
+	  continue;
+	}
+
+    if (res == 0)
+      continue;
+
+	res = recv(m_socket_data, (char*)data, sizeof(data), 0);
+	if (res < 0)
+	{
+	  m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Process - failed");
+	  continue;
+	}
+
+	if (res == 0)
+	   continue;
+
+	CStdString respStr = data;
+	if (respStr.find("MODT", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_TIMERS_CHANGE, "");
+	}
+	else if (respStr.find("DELT", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_TIMERS_CHANGE, "");
+	}
+	else if (respStr.find("ADDT", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_TIMERS_CHANGE, "");
+	}
+	else if (respStr.find("MODC", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_CHANNELS_CHANGE, "");
+	}
+	else if (respStr.find("DELC", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_CHANNELS_CHANGE, "");
+	}
+	else if (respStr.find("ADDC", 0) == 0)
+	{
+	  m_xbmc->Event(m_xbmc->userData, PVR_EVENT_CHANNELS_CHANGE, "");
+	}
+	else
+	{
+	  m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Process - Unkown respond command %s", respStr.c_str());
+	}
+  }
+  return NULL;
+}
+
+
+/************************************************************/
+/** General handling */
+
+const char* PVRClientVDR::GetBackendName()
+{
+  if (!m_transceiver->IsOpen())
+    return "";
+
+  pthread_mutex_lock(&m_critSection);
+
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->SendCommand("STAT name", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return "";
+  }
+
+  vector<string>::iterator it = lines.begin();
+  string& data(*it);
+
+  pthread_mutex_unlock(&m_critSection);
+  return data.c_str();
+}
+
+const char* PVRClientVDR::GetBackendVersion()
+{
+  if (!m_transceiver->IsOpen())
+    return "";
+
+  pthread_mutex_lock(&m_critSection);
+
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->SendCommand("STAT version", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return "";
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+
+  pthread_mutex_unlock(&m_critSection);
+  return data.c_str();
+}
+
+PVR_ERROR PVRClientVDR::GetDriveSpace(long long *total, long long *used)
+{
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->SendCommand("STAT disk", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  vector<string>::iterator it = lines.begin();
+  string& data(*it);
+  size_t found = data.find("MB");
+
+  if (found != CStdString::npos)
+  {
+    *total = atol(data.c_str()) * 1024;
+    data.erase(0, found + 3);
+    *used = atol(data.c_str()) * 1024;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+/************************************************************/
+/** EPG handling */
+
+PVR_ERROR PVRClientVDR::GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start, time_t end)
+{
+
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  int            found;
+  TVEPGData      broadcast;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (start != 0)
+    sprintf(buffer, "LSTE %d from %lu to %lu", number, (long)start, (long)end);
+  else
+    sprintf(buffer, "LSTE %d", number);
+  while (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    if (code != 451)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+    Sleep(750);
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it != lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    /** Get Channelname **/
+    found = str_result.find("C", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+//    = str_result.c_str();
+      continue;
+    }
+
+    /** Get Title **/
+    found = str_result.find("T", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      broadcast.m_strTitle = str_result.c_str();
+      continue;
+    }
+
+    /** Get short description **/
+    found = str_result.find("S", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      broadcast.m_strPlotOutline = str_result.c_str();
+      continue;
+    }
+
+    /** Get description **/
+    found = str_result.find("D", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+
+      int pos = 0;
+
+      while (1)
+      {
+        pos = str_result.find("|", pos);
+
+        if (pos < 0)
+          break;
+
+        str_result.replace(pos, 1, 1, '\n');
+      }
+      broadcast.m_strPlot = str_result.c_str();
+      continue;
+    }
+
+    /** Get Genre **/
+    found = str_result.find("G", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      broadcast.m_GenreType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      broadcast.m_GenreSubType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      broadcast.m_strGenre = str_result.c_str();
+      continue;
+    }
+
+    /** Get ID, date and length**/
+    found = str_result.find("E ", 0);
+    if (found == 0)
+    {
+      time_t rec_time;
+      int duration;
+      str_result.erase(0, 2);
+//    = atol(str_result.c_str());
+
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+
+      rec_time = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      duration = atol(str_result.c_str());
+
+      broadcast.m_startTime = CDateTime((time_t)rec_time);
+      broadcast.m_endTime = CDateTime((time_t)rec_time + duration);
+      broadcast.m_duration = CDateTimeSpan(0, 0, duration / 60, duration % 60);
+      continue;
+    }
+
+    /** end tag **/
+    found = str_result.find("e", 0);
+    if (found == 0)
+    {
+      epg.push_back(broadcast);
+
+      broadcast.m_strTitle = "";
+      broadcast.m_strPlotOutline = "";
+      broadcast.m_strPlot = "";
+      broadcast.m_startTime = NULL;
+      broadcast.m_endTime = NULL;
+      broadcast.m_strGenre = "";
+      broadcast.m_GenreType = NULL;
+      broadcast.m_GenreSubType = NULL;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  int            found;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTE %d NOW", number);
+  while (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    if (code != 451)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+    Sleep(750);
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it != lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    /** Get Channelname **/
+    found = str_result.find("C", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_strChannel = str_result.c_str();
+      continue;
+    }
+
+    /** Get Title **/
+    found = str_result.find("T", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_strTitle = str_result.c_str();
+      continue;
+    }
+
+    /** Get short description **/
+    found = str_result.find("S", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_strPlotOutline = str_result.c_str();
+      continue;
+    }
+
+    /** Get description **/
+    found = str_result.find("D", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      int pos = 0;
+
+      while (1)
+      {
+        pos = str_result.find("|", pos);
+
+        if (pos < 0)
+          break;
+
+        str_result.replace(pos, 1, 1, '\n');
+      }
+
+      result->m_strPlot = str_result.c_str();
+      continue;
+    }
+
+    /** Get Genre **/
+    found = str_result.find("G", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_GenreType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_GenreSubType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_strGenre = str_result.c_str();
+      continue;
+    }
+
+    /** Get ID, date and length**/
+    found = str_result.find("E ", 0);
+    if (found == 0)
+    {
+      time_t rec_time;
+      int duration;
+      str_result.erase(0, 2);
+//                broadcast.m_bouquetNum = atol(str_result.c_str());
+
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+
+      rec_time = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      duration = atol(str_result.c_str());
+
+      result->m_startTime = CDateTime((time_t)rec_time);
+      result->m_endTime = CDateTime((time_t)rec_time + duration);
+      result->m_duration = CDateTimeSpan(0, 0, duration / 60, duration % 60);
+      continue;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  int            found;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTE %d NEXT", number);
+  while (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    if (code != 451)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+    Sleep(750);
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it != lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    /** Get Channelname **/
+    found = str_result.find("C", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_strChannel = str_result.c_str();
+      continue;
+    }
+
+    /** Get Title **/
+    found = str_result.find("T", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_strTitle = str_result.c_str();
+      continue;
+    }
+
+    /** Get short description **/
+    found = str_result.find("S", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_strPlotOutline = str_result.c_str();
+      continue;
+    }
+
+    /** Get description **/
+    found = str_result.find("D", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+
+      int pos = 0;
+
+      while (1)
+      {
+        pos = str_result.find("|", pos);
+
+        if (pos < 0)
+          break;
+
+        str_result.replace(pos, 1, 1, '\n');
+      }
+
+      result->m_strPlot = str_result.c_str();
+      continue;
+    }
+
+    /** Get Genre **/
+    found = str_result.find("G", 0);
+    if (found == 0)
+    {
+      str_result.erase(0, 2);
+      result->m_GenreType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_GenreSubType = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      result->m_strGenre = str_result.c_str();
+      continue;
+    }
+
+    /** Get ID, date and length**/
+    found = str_result.find("E ", 0);
+    if (found == 0)
+    {
+      time_t rec_time;
+      int duration;
+      str_result.erase(0, 2);
+//                broadcast.m_bouquetNum = atol(str_result.c_str());
+
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+
+      rec_time = atol(str_result.c_str());
+      found = str_result.find(" ", 0);
+      str_result.erase(0, found + 1);
+      duration = atol(str_result.c_str());
+
+      result->m_startTime = CDateTime((time_t)rec_time);
+      result->m_endTime = CDateTime((time_t)rec_time + duration);
+      result->m_duration = CDateTimeSpan(0, 0, duration / 60, duration % 60);
+      continue;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+/************************************************************/
+/** Channel handling */
+
+int PVRClientVDR::GetNumChannels()
+{
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->IsOpen())
+    return -1;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->SendCommand("STAT channels", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return -1;
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+  pthread_mutex_unlock(&m_critSection);
+  return atol(data.c_str());
+}
+
+PVR_ERROR PVRClientVDR::GetChannelList(VECCHANNELS *channels, bool radio)
+{
+  vector<string> lines;
+  int            code;
+  unsigned int   number = 1;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  channels->erase(channels->begin(), channels->end());
+
+  while (!m_transceiver->SendCommand("LSTC", code, lines))
+  {
+    if (code != 451)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+    Sleep(750);
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it < lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+    int found;
+
+    CTVChannelInfoTag broadcast;
+    int m_VPID = 0;
+    int m_APID1 = 0;
+    int m_APID2 = 0;
+    int m_DPID1 = 0;
+    int m_DPID2 = 0;
+    int m_CAID = 0;
+    CStdString name;
+    int id;
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    // Channel number
+    broadcast.m_iClientNum = atol(str_result.c_str());
+    str_result.erase(0, str_result.find(" ", 0) + 1);
+
+    // Channel and provider name
+    found = str_result.find(":", 0);
+    name.assign(str_result, found);
+    str_result.erase(0, found + 1);
+    found = name.find(";", 0);
+
+    if (found == -1)
+    {
+      broadcast.m_strChannel = name;
+    }
+    else
+    {
+      broadcast.m_strChannel.assign(name, found);
+      name.erase(0, found + 1);
+    }
+
+    // Channel frequency
+    str_result.erase(0, str_result.find(":", 0) + 1);
+
+    // Source descriptor
+    str_result.erase(0, str_result.find(":", 0));
+
+    // Source Type
+    if (str_result.compare(0, 2, ":C") == 0)
+    {
+      str_result.erase(0, 3);
+    }
+    else if (str_result.compare(0, 2, ":T") == 0)
+    {
+      str_result.erase(0, 3);
+    }
+    else if (str_result.compare(0, 2, ":S") == 0)
+    {
+      str_result.erase(0, 2);
+      found = str_result.find(":", 0);
+      str_result.erase(0, found + 1);
+    }
+    else if (str_result.compare(0, 2, ":P") == 0)
+    {
+      str_result.erase(0, 3);
+    }
+
+
+    // Channel symbolrate
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Channel program id
+    m_VPID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Channel audio id's
+    found = str_result.find(":", 0);
+    name.assign(str_result, found);
+    str_result.erase(0, found + 1);
+    found = name.find(";", 0);
+
+    if (found == -1)
+    {
+      id = atol(name.c_str());
+
+      if (id == 0)
+      {
+        m_APID1 = 0;
+        m_APID2 = 0;
+        m_DPID1 = 0;
+        m_DPID2 = 0;
+      }
+      else
+      {
+        m_APID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          m_APID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          m_APID2 = atol(name.c_str());
+        }
+
+        m_DPID1 = 0;
+        m_DPID2 = 0;
+      }
+    }
+    else
+    {
+      int id;
+      id = atol(name.c_str());
+
+      if (id == 0)
+      {
+        m_APID1 = 0;
+        m_APID2 = 0;
+      }
+      else
+      {
+        m_APID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          m_APID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          m_APID2 = atol(name.c_str());
+        }
+      }
+
+      name.erase(0, name.find(";", 0) + 1);
+      id = atoi(name.c_str());
+      if (id == 0)
+      {
+        m_DPID1 = 0;
+        m_DPID2 = 0;
+      }
+      else
+      {
+        m_DPID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          m_DPID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          m_DPID2 = atol(name.c_str());
+        }
+      }
+    }
+
+    // Teletext id
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // CAID id
+    m_CAID = atoi(str_result.c_str());
+    str_result.erase(0, str_result.find(":", 0) + 1);
+
+    if (m_CAID && m_bOnlyFTA)
+      continue;
+
+    broadcast.m_encrypted = m_CAID ? true : false;
+
+    if ((m_VPID == 0) && (m_APID1 != 0))
+    {
+      broadcast.m_radio = true;
+      broadcast.m_strFileNameAndPath.Format("radio://%i", number);
+    }
+    else
+    {
+      broadcast.m_radio = false;
+      broadcast.m_strFileNameAndPath.Format("tv://%i", number);
+    }
+
+    if (radio == broadcast.m_radio)
+    {
+      broadcast.m_iChannelNum = number;
+      channels->push_back(broadcast);
+      number++;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::GetChannelSettings(CTVChannelInfoTag *result)
+{
+
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (result->m_iClientNum < 1)
+    return PVR_ERROR_SERVER_ERROR;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTC %d", result->m_iClientNum);
+  while (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    if (code != 451)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+    Sleep(750);
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it != lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+    int found;
+    int i_tmp;
+
+    result->m_Settings.m_VPID = 0;
+    result->m_Settings.m_APID1 = 0;
+    result->m_Settings.m_APID2 = 0;
+    result->m_Settings.m_DPID1 = 0;
+    result->m_Settings.m_DPID2 = 0;
+    result->m_Settings.m_CAID = 0;
+    CStdString name;
+    int id;
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    // Skip Channel number
+    str_result.erase(0, str_result.find(" ", 0) + 1);
+
+    // Channel and provider name
+    found = str_result.find(":", 0);
+    name.assign(str_result, found);
+    str_result.erase(0, found + 1);
+    found = name.find(";", 0);
+
+    if (found != -1)
+    {
+      name.erase(0, found + 1);
+      result->m_Settings.m_strProvider = name;
+    }
+
+    // Channel frequency
+    result->m_Settings.m_Freq = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+    found = str_result.find(":", 0);
+    result->m_Settings.m_parameter.assign(str_result, found);
+    str_result.erase(0, found);
+
+    // Source Type
+    if (str_result.compare(0, 2, ":C") == 0)
+    {
+      result->m_Settings.m_SourceType = src_DVBC;
+      result->m_Settings.m_satellite = "Cable";
+      str_result.erase(0, 3);
+    }
+    else
+      if (str_result.compare(0, 2, ":T") == 0)
+      {
+        result->m_Settings.m_SourceType = src_DVBT;
+        result->m_Settings.m_satellite = "Terrestrial";
+        str_result.erase(0, 3);
+      }
+      else
+        if (str_result.compare(0, 2, ":S") == 0)
+        {
+          result->m_Settings.m_SourceType = src_DVBS;
+          str_result.erase(0, 2);
+          found = str_result.find(":", 0);
+          result->m_Settings.m_satellite.assign(str_result, found);
+          str_result.erase(0, found + 1);
+        }
+        else
+          if (str_result.compare(0, 2, ":P") == 0)
+          {
+            result->m_Settings.m_SourceType = srcAnalog;
+            result->m_Settings.m_satellite = "Analog";
+            str_result.erase(0, 3);
+          }
+
+    // Channel symbolrate
+    result->m_Settings.m_Symbolrate = atol(str_result.c_str());
+    str_result.erase(0, str_result.find(":", 0) + 1);
+
+    // Channel program id
+    result->m_Settings.m_VPID = atol(str_result.c_str());
+    str_result.erase(0, str_result.find(":", 0) + 1);
+
+    // Channel audio id's
+    found = str_result.find(":", 0);
+    name.assign(str_result, found);
+    str_result.erase(0, found + 1);
+    found = name.find(";", 0);
+
+    if (found == -1)
+    {
+      id = atol(name.c_str());
+
+      if (id == 0)
+      {
+        result->m_Settings.m_APID1 = 0;
+        result->m_Settings.m_APID2 = 0;
+        result->m_Settings.m_DPID1 = 0;
+        result->m_Settings.m_DPID2 = 0;
+      }
+      else
+      {
+        result->m_Settings.m_APID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          result->m_Settings.m_APID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          result->m_Settings.m_APID2 = atol(name.c_str());
+        }
+        result->m_Settings.m_DPID1 = 0;
+        result->m_Settings.m_DPID2 = 0;
+      }
+    }
+    else
+    {
+      int id;
+
+      id = atol(name.c_str());
+
+      if (id == 0)
+      {
+        result->m_Settings.m_APID1 = 0;
+        result->m_Settings.m_APID2 = 0;
+      }
+      else
+      {
+        result->m_Settings.m_APID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          result->m_Settings.m_APID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          result->m_Settings.m_APID2 = atol(name.c_str());
+        }
+      }
+
+      found = name.find(";", 0);
+
+      name.erase(0, found + 1);
+      id = atol(name.c_str());
+
+      if (id == 0)
+      {
+        result->m_Settings.m_DPID1 = 0;
+        result->m_Settings.m_DPID2 = 0;
+      }
+      else
+      {
+        result->m_Settings.m_DPID1 = id;
+        found = name.find(",", 0);
+
+        if (found == -1)
+        {
+          result->m_Settings.m_DPID2 = 0;
+        }
+        else
+        {
+          name.erase(0, found + 1);
+          result->m_Settings.m_DPID2 = atol(name.c_str());
+        }
+      }
+    }
+
+    // Teletext id
+    result->m_Settings.m_TPID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // CAID id
+    result->m_Settings.m_CAID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Service id
+    result->m_Settings.m_SID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Network id
+    result->m_Settings.m_NID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Transport id
+    result->m_Settings.m_TID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // Radio id
+    result->m_Settings.m_RID = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    // DVB-S2 ?
+    if (result->m_Settings.m_SourceType == src_DVBS)
+    {
+      str_result = result->m_Settings.m_parameter;
+      found = str_result.find("S", 0);
+
+      if (found != -1)
+      {
+        str_result.erase(0, found + 1);
+        i_tmp = atol(str_result.c_str());
+
+        if (i_tmp == 1)
+        {
+          result->m_Settings.m_SourceType = src_DVBS2;
+        }
+      }
+    }
+
+    // Inversion
+    str_result = result->m_Settings.m_parameter;
+    found = str_result.find("I", 0);
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Inversion = InvOff;
+      }
+      else if (i_tmp == 1)
+      {
+        result->m_Settings.m_Inversion = InvOn;
+      }
+      else if (i_tmp == 999)
+      {
+        result->m_Settings.m_Inversion = InvAuto;
+      }
+    }
+    else
+    {
+      result->m_Settings.m_Inversion = InvAuto;
+    }
+
+    // CoderateL
+    if (result->m_Settings.m_SourceType == src_DVBT)
+    {
+      str_result = result->m_Settings.m_parameter;
+      found = str_result.find("D", 0);
+
+      if (found != -1)
+      {
+        str_result.erase(0, found + 1);
+        i_tmp = atol(str_result.c_str());
+
+        if (i_tmp == 0)
+        {
+          result->m_Settings.m_CoderateL = Coderate_None;
+        }
+        else
+          if (i_tmp == 12)
+          {
+            result->m_Settings.m_CoderateL = Coderate_1_2;
+          }
+          else
+            if (i_tmp == 23)
+            {
+              result->m_Settings.m_CoderateL = Coderate_2_3;
+            }
+            else
+              if (i_tmp == 34)
+              {
+                result->m_Settings.m_CoderateL = Coderate_3_4;
+              }
+              else
+                if (i_tmp == 45)
+                {
+                  result->m_Settings.m_CoderateL = Coderate_4_5;
+                }
+                else
+                  if (i_tmp == 56)
+                  {
+                    result->m_Settings.m_CoderateL = Coderate_5_6;
+                  }
+                  else
+                    if (i_tmp == 67)
+                    {
+                      result->m_Settings.m_CoderateL = Coderate_6_7;
+                    }
+                    else
+                      if (i_tmp == 78)
+                      {
+                        result->m_Settings.m_CoderateL = Coderate_7_8;
+                      }
+                      else
+                        if (i_tmp == 89)
+                        {
+                          result->m_Settings.m_CoderateL = Coderate_8_9;
+                        }
+                        else
+                          if (i_tmp == 910)
+                          {
+                            result->m_Settings.m_CoderateL = Coderate_9_10;
+                          }
+                          else
+                            if (i_tmp == 999 || i_tmp == 910)
+                            {
+                              result->m_Settings.m_CoderateL = Coderate_Auto;
+                            }
+      }
+      else
+      {
+        result->m_Settings.m_CoderateL = Coderate_None;
+      }
+    }
+    else
+    {
+      result->m_Settings.m_CoderateL = Coderate_None;
+    }
+
+    // CoderateH
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("C", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_CoderateH = Coderate_None;
+      }
+      else
+        if (i_tmp == 12)
+        {
+          result->m_Settings.m_CoderateH = Coderate_1_2;
+        }
+        else
+          if (i_tmp == 23)
+          {
+            result->m_Settings.m_CoderateH = Coderate_2_3;
+          }
+          else
+            if (i_tmp == 34)
+            {
+              result->m_Settings.m_CoderateH = Coderate_3_4;
+            }
+            else
+              if (i_tmp == 45)
+              {
+                result->m_Settings.m_CoderateH = Coderate_4_5;
+              }
+              else
+                if (i_tmp == 56)
+                {
+                  result->m_Settings.m_CoderateH = Coderate_5_6;
+                }
+                else
+                  if (i_tmp == 67)
+                  {
+                    result->m_Settings.m_CoderateH = Coderate_6_7;
+                  }
+                  else
+                    if (i_tmp == 78)
+                    {
+                      result->m_Settings.m_CoderateH = Coderate_7_8;
+                    }
+                    else
+                      if (i_tmp == 89)
+                      {
+                        result->m_Settings.m_CoderateH = Coderate_8_9;
+                      }
+                      else
+                        if (i_tmp == 910)
+                        {
+                          result->m_Settings.m_CoderateL = Coderate_9_10;
+                        }
+                        else
+                          if (i_tmp == 999 || i_tmp == 910)
+                          {
+                            result->m_Settings.m_CoderateH = Coderate_Auto;
+                          }
+    }
+    else
+    {
+      result->m_Settings.m_CoderateH = Coderate_None;
+    }
+
+    // Modulation
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("M", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Modulation = modNone;
+      }
+      else
+        if (i_tmp == 4)
+        {
+          result->m_Settings.m_Modulation = modQAM4;
+        }
+        else
+          if (i_tmp == 16)
+          {
+            result->m_Settings.m_Modulation = modQAM16;
+          }
+          else
+            if (i_tmp == 32)
+            {
+              result->m_Settings.m_Modulation = modQAM32;
+            }
+            else
+              if (i_tmp == 64)
+              {
+                result->m_Settings.m_Modulation = modQAM64;
+              }
+              else
+                if (i_tmp == 128)
+                {
+                  result->m_Settings.m_Modulation = modQAM128;
+                }
+                else
+                  if (i_tmp == 256)
+                  {
+                    result->m_Settings.m_Modulation = modQAM256;
+                  }
+                  else
+                    if (i_tmp == 512)
+                    {
+                      result->m_Settings.m_Modulation = modQAM512;
+                    }
+                    else
+                      if (i_tmp == 1024)
+                      {
+                        result->m_Settings.m_Modulation = modQAM1024;
+                      }
+                      else
+                        if (i_tmp == 998)
+                        {
+                          result->m_Settings.m_Modulation = modQAMAuto;
+                        }
+                        else
+                          if (i_tmp == 1)
+                          {
+                            result->m_Settings.m_Modulation = modBPSK;
+                          }
+                          else
+                            if (i_tmp == 2)
+                            {
+                              result->m_Settings.m_Modulation = modQPSK;
+                            }
+                            else
+                              if (i_tmp == 3)
+                              {
+                                result->m_Settings.m_Modulation = modOQPSK;
+                              }
+                              else
+                                if (i_tmp == 5)
+                                {
+                                  result->m_Settings.m_Modulation = mod8PSK;
+                                }
+                                else
+                                  if (i_tmp == 6)
+                                  {
+                                    result->m_Settings.m_Modulation = mod16APSK;
+                                  }
+                                  else
+                                    if (i_tmp == 7)
+                                    {
+                                      result->m_Settings.m_Modulation = mod32APSK;
+                                    }
+                                    else
+                                      if (i_tmp == 8)
+                                      {
+                                        result->m_Settings.m_Modulation = modOFDM;
+                                      }
+                                      else
+                                        if (i_tmp == 9)
+                                        {
+                                          result->m_Settings.m_Modulation = modCOFDM;
+                                        }
+                                        else
+                                          if (i_tmp == 10)
+                                          {
+                                            result->m_Settings.m_Modulation = modVSB8;
+                                          }
+                                          else
+                                            if (i_tmp == 11)
+                                            {
+                                              result->m_Settings.m_Modulation = modVSB16;
+                                            }
+    }
+    else
+    {
+      result->m_Settings.m_Modulation = modNone;
+    }
+
+    // Bandwith
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("B", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 5)
+      {
+        result->m_Settings.m_Bandwidth = bw_5MHz;
+      }
+      else
+        if (i_tmp == 6)
+        {
+          result->m_Settings.m_Bandwidth = bw_6MHz;
+        }
+        else
+          if (i_tmp == 7)
+          {
+            result->m_Settings.m_Bandwidth = bw_7MHz;
+          }
+          else
+            if (i_tmp == 8)
+            {
+              result->m_Settings.m_Bandwidth = bw_8MHz;
+            }
+            else
+              if (i_tmp == 999)
+              {
+                result->m_Settings.m_Bandwidth = bw_Auto;
+              }
+    }
+    else
+    {
+      result->m_Settings.m_Bandwidth = bw_Auto;
+    }
+
+    // Hierarchie
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("Y", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Hierarchie = false;
+      }
+      else
+        if (i_tmp == 1)
+        {
+          result->m_Settings.m_Hierarchie = true;
+        }
+    }
+    else
+    {
+      result->m_Settings.m_Hierarchie = false;
+    }
+
+    // Alpha
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("A", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Alpha = alpha_0;
+      }
+      else
+        if (i_tmp == 1)
+        {
+          result->m_Settings.m_Alpha = alpha_1;
+        }
+        else
+          if (i_tmp == 2)
+          {
+            result->m_Settings.m_Alpha = alpha_2;
+          }
+          else
+            if (i_tmp == 4)
+            {
+              result->m_Settings.m_Alpha = alpha_4;
+            }
+    }
+    else
+    {
+      result->m_Settings.m_Alpha = alpha_0;
+    }
+
+    // Guard
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("G", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 4)
+      {
+        result->m_Settings.m_Guard = guard_1_4;
+      }
+      else
+        if (i_tmp == 8)
+        {
+          result->m_Settings.m_Guard = guard_1_8;
+        }
+        else
+          if (i_tmp == 16)
+          {
+            result->m_Settings.m_Guard = guard_1_16;
+          }
+          else
+            if (i_tmp == 32)
+            {
+              result->m_Settings.m_Guard = guard_1_32;
+            }
+            else
+              if (i_tmp == 999)
+              {
+                result->m_Settings.m_Guard = guard_Auto;
+              }
+    }
+    else
+    {
+      result->m_Settings.m_Guard = guard_Auto;
+    }
+
+    // Transmission
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("T", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 2)
+      {
+        result->m_Settings.m_Transmission = transmission_2K;
+      }
+      else
+        if (i_tmp == 4)
+        {
+          result->m_Settings.m_Transmission = transmission_4K;
+        }
+        else
+          if (i_tmp == 8)
+          {
+            result->m_Settings.m_Transmission = transmission_8K;
+          }
+          else
+            if (i_tmp == 999)
+            {
+              result->m_Settings.m_Transmission = transmission_Auto;
+            }
+    }
+    else
+    {
+      result->m_Settings.m_Transmission = transmission_Auto;
+    }
+
+    // Priority
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("P", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Priority = false;
+      }
+      else
+        if (i_tmp == 1)
+        {
+          result->m_Settings.m_Priority = true;
+        }
+    }
+    else
+    {
+      result->m_Settings.m_Priority = false;
+    }
+
+    // Rolloff
+    str_result = result->m_Settings.m_parameter;
+
+    found = str_result.find("O", 0);
+
+    if (found != -1)
+    {
+      str_result.erase(0, found + 1);
+      i_tmp = atol(str_result.c_str());
+
+      if (i_tmp == 0)
+      {
+        result->m_Settings.m_Rolloff = rolloff_Unknown;
+      }
+      else
+        if (i_tmp == 20)
+        {
+          result->m_Settings.m_Rolloff = rolloff_20;
+        }
+        else
+          if (i_tmp == 25)
+          {
+            result->m_Settings.m_Rolloff = rolloff_25;
+          }
+          else
+            if (i_tmp == 35)
+            {
+              result->m_Settings.m_Rolloff = rolloff_35;
+            }
+    }
+    else
+    {
+      result->m_Settings.m_Rolloff = rolloff_Unknown;
+    }
+
+    // Polarization
+    str_result = result->m_Settings.m_parameter;
+
+    if ((int) str_result.find("H", 0) != -1)
+      result->m_Settings.m_Polarization = pol_H;
+
+    if ((int) str_result.find("h", 0) != -1)
+      result->m_Settings.m_Polarization = pol_H;
+
+    if ((int) str_result.find("V", 0) != -1)
+      result->m_Settings.m_Polarization = pol_V;
+
+    if ((int) str_result.find("v", 0) != -1)
+      result->m_Settings.m_Polarization = pol_V;
+
+    if ((int) str_result.find("L", 0) != -1)
+      result->m_Settings.m_Polarization = pol_L;
+
+    if ((int) str_result.find("l", 0) != -1)
+      result->m_Settings.m_Polarization = pol_L;
+
+    if ((int) str_result.find("R", 0) != -1)
+      result->m_Settings.m_Polarization = pol_R;
+
+    if ((int) str_result.find("r", 0) != -1)
+      result->m_Settings.m_Polarization = pol_R;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::UpdateChannelSettings(const CTVChannelInfoTag &chaninfo)
+{
+
+
+  CStdString     m_Summary;
+  CStdString     m_Summary_2;
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (chaninfo.m_iClientNum == -1)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SAVED;
+  }
+
+  m_Summary.Format("%d %s;%s:%i:" , chaninfo.m_iClientNum
+
+                   , chaninfo.m_strChannel.c_str()
+                   , chaninfo.m_Settings.m_strProvider.c_str()
+                   , chaninfo.m_Settings.m_Freq);
+
+  if ((chaninfo.m_Settings.m_SourceType == src_DVBS) ||
+      (chaninfo.m_Settings.m_SourceType == src_DVBS2))
+  {
+    if      (chaninfo.m_Settings.m_Polarization == pol_H)
+      m_Summary += "h";
+    else
+      if (chaninfo.m_Settings.m_Polarization == pol_V)
+        m_Summary += "v";
+      else
+        if (chaninfo.m_Settings.m_Polarization == pol_L)
+          m_Summary += "l";
+        else
+          if (chaninfo.m_Settings.m_Polarization == pol_R)
+            m_Summary += "r";
+  }
+
+  if (chaninfo.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (chaninfo.m_Settings.m_Inversion == InvOff)
+      m_Summary += "I0";
+    else
+      if (chaninfo.m_Settings.m_Inversion == InvOn)
+        m_Summary += "I1";
+      else
+        if (chaninfo.m_Settings.m_Inversion == InvAuto)
+          m_Summary += "I999";
+  }
+
+  if (chaninfo.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (chaninfo.m_Settings.m_Bandwidth == bw_5MHz)
+      m_Summary += "B5";
+    else
+      if (chaninfo.m_Settings.m_Bandwidth == bw_6MHz)
+        m_Summary += "B6";
+      else
+        if (chaninfo.m_Settings.m_Bandwidth == bw_7MHz)
+          m_Summary += "B7";
+        else
+          if (chaninfo.m_Settings.m_Bandwidth == bw_8MHz)
+            m_Summary += "B8";
+          else
+            if (chaninfo.m_Settings.m_Bandwidth == bw_Auto)
+              m_Summary += "B999";
+  }
+
+  if      (chaninfo.m_Settings.m_CoderateH == Coderate_None)
+    m_Summary += "C0";
+  else
+    if (chaninfo.m_Settings.m_CoderateH == Coderate_1_2)
+      m_Summary += "C12";
+    else
+      if (chaninfo.m_Settings.m_CoderateH == Coderate_2_3)
+        m_Summary += "C23";
+      else
+        if (chaninfo.m_Settings.m_CoderateH == Coderate_3_4)
+          m_Summary += "C34";
+        else
+          if (chaninfo.m_Settings.m_CoderateH == Coderate_4_5)
+            m_Summary += "C45";
+          else
+            if (chaninfo.m_Settings.m_CoderateH == Coderate_5_6)
+              m_Summary += "C56";
+            else
+              if (chaninfo.m_Settings.m_CoderateH == Coderate_6_7)
+                m_Summary += "C67";
+              else
+                if (chaninfo.m_Settings.m_CoderateH == Coderate_7_8)
+                  m_Summary += "C78";
+                else
+                  if (chaninfo.m_Settings.m_CoderateH == Coderate_8_9)
+                    m_Summary += "C89";
+                  else
+                    if (chaninfo.m_Settings.m_CoderateH == Coderate_9_10)
+                      m_Summary += "C910";
+                    else
+                      if (chaninfo.m_Settings.m_CoderateH == Coderate_Auto)
+                        m_Summary += "C999";
+
+  if (chaninfo.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (chaninfo.m_Settings.m_CoderateL == Coderate_None)
+      m_Summary += "D0";
+    else
+      if (chaninfo.m_Settings.m_CoderateL == Coderate_1_2)
+        m_Summary += "D12";
+      else
+        if (chaninfo.m_Settings.m_CoderateL == Coderate_2_3)
+          m_Summary += "D23";
+        else
+          if (chaninfo.m_Settings.m_CoderateL == Coderate_3_4)
+            m_Summary += "D34";
+          else
+            if (chaninfo.m_Settings.m_CoderateL == Coderate_4_5)
+              m_Summary += "D45";
+            else
+              if (chaninfo.m_Settings.m_CoderateL == Coderate_5_6)
+                m_Summary += "D56";
+              else
+                if (chaninfo.m_Settings.m_CoderateL == Coderate_6_7)
+                  m_Summary += "D67";
+                else
+                  if (chaninfo.m_Settings.m_CoderateL == Coderate_7_8)
+                    m_Summary += "D78";
+                  else
+                    if (chaninfo.m_Settings.m_CoderateL == Coderate_8_9)
+                      m_Summary += "D89";
+                    else
+                      if (chaninfo.m_Settings.m_CoderateL == Coderate_9_10)
+                        m_Summary += "D910";
+                      else
+                        if (chaninfo.m_Settings.m_CoderateL == Coderate_Auto)
+                          m_Summary += "D999";
+  }
+
+  if      (chaninfo.m_Settings.m_Modulation == modNone)
+    m_Summary += "M0";
+  else
+    if (chaninfo.m_Settings.m_Modulation == modQAM4)
+      m_Summary += "M4";
+    else
+      if (chaninfo.m_Settings.m_Modulation == modQAM16)
+        m_Summary += "M16";
+      else
+        if (chaninfo.m_Settings.m_Modulation == modQAM32)
+          m_Summary += "M32";
+        else
+          if (chaninfo.m_Settings.m_Modulation == modQAM64)
+            m_Summary += "M64";
+          else
+            if (chaninfo.m_Settings.m_Modulation == modQAM128)
+              m_Summary += "M128";
+            else
+              if (chaninfo.m_Settings.m_Modulation == modQAM256)
+                m_Summary += "M256";
+              else
+                if (chaninfo.m_Settings.m_Modulation == modQAM512)
+                  m_Summary += "M512";
+                else
+                  if (chaninfo.m_Settings.m_Modulation == modQAM1024)
+                    m_Summary += "M1024";
+                  else
+                    if (chaninfo.m_Settings.m_Modulation == modQAMAuto)
+                      m_Summary += "M998";
+                    else
+                      if (chaninfo.m_Settings.m_Modulation == modBPSK)
+                        m_Summary += "M1";
+                      else
+                        if (chaninfo.m_Settings.m_Modulation == modQPSK)
+                          m_Summary += "M2";
+                        else
+                          if (chaninfo.m_Settings.m_Modulation == modOQPSK)
+                            m_Summary += "M3";
+                          else
+                            if (chaninfo.m_Settings.m_Modulation == mod8PSK)
+                              m_Summary += "M5";
+                            else
+                              if (chaninfo.m_Settings.m_Modulation == mod16APSK)
+                                m_Summary += "M6";
+                              else
+                                if (chaninfo.m_Settings.m_Modulation == mod32APSK)
+                                  m_Summary += "M7";
+                                else
+                                  if (chaninfo.m_Settings.m_Modulation == modOFDM)
+                                    m_Summary += "M8";
+                                  else
+                                    if (chaninfo.m_Settings.m_Modulation == modCOFDM)
+                                      m_Summary += "M9";
+                                    else
+                                      if (chaninfo.m_Settings.m_Modulation == modVSB8)
+                                        m_Summary += "M10";
+                                      else
+                                        if (chaninfo.m_Settings.m_Modulation == modVSB16)
+                                          m_Summary += "M11";
+
+  if (chaninfo.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (chaninfo.m_Settings.m_Transmission == transmission_2K)
+      m_Summary += "T2";
+    else
+      if (chaninfo.m_Settings.m_Transmission == transmission_4K)
+        m_Summary += "T4";
+      else
+        if (chaninfo.m_Settings.m_Transmission == transmission_8K)
+          m_Summary += "T8";
+        else
+          if (chaninfo.m_Settings.m_Transmission == transmission_Auto)
+            m_Summary += "T999";
+
+    if      (chaninfo.m_Settings.m_Guard == guard_1_4)
+      m_Summary += "G4";
+    else
+      if (chaninfo.m_Settings.m_Guard == guard_1_8)
+        m_Summary += "G8";
+      else
+        if (chaninfo.m_Settings.m_Guard == guard_1_16)
+          m_Summary += "G16";
+        else
+          if (chaninfo.m_Settings.m_Guard == guard_1_32)
+            m_Summary += "G32";
+          else
+            if (chaninfo.m_Settings.m_Guard == guard_Auto)
+              m_Summary += "G999";
+
+    if      (chaninfo.m_Settings.m_Hierarchie)
+      m_Summary += "Y1";
+    else
+      m_Summary += "Y0";
+
+    if      (chaninfo.m_Settings.m_Alpha == alpha_0)
+      m_Summary += "A0";
+    else
+      if (chaninfo.m_Settings.m_Alpha == alpha_1)
+        m_Summary += "A1";
+      else
+        if (chaninfo.m_Settings.m_Alpha == alpha_2)
+          m_Summary += "A2";
+        else
+          if (chaninfo.m_Settings.m_Alpha == alpha_4)
+            m_Summary += "A4";
+
+    if      (chaninfo.m_Settings.m_Priority)
+      m_Summary += "P1";
+    else
+      m_Summary += "P0";
+  }
+
+  if (chaninfo.m_Settings.m_SourceType == src_DVBS2)
+  {
+    if      (chaninfo.m_Settings.m_Rolloff == rolloff_Unknown)
+      m_Summary += "O0";
+    else
+      if (chaninfo.m_Settings.m_Rolloff == rolloff_20)
+        m_Summary += "O20";
+      else
+        if (chaninfo.m_Settings.m_Rolloff == rolloff_25)
+          m_Summary += "O25";
+        else
+          if (chaninfo.m_Settings.m_Rolloff == rolloff_25)
+            m_Summary += "O35";
+  }
+
+  if      (chaninfo.m_Settings.m_SourceType == src_DVBS)
+    m_Summary += "O35S0:S";
+  else
+    if (chaninfo.m_Settings.m_SourceType == src_DVBS2)
+      m_Summary += "S1:S";
+    else
+      if (chaninfo.m_Settings.m_SourceType == src_DVBC)
+        m_Summary += ":C";
+      else
+        if (chaninfo.m_Settings.m_SourceType == src_DVBT)
+          m_Summary += ":T";
+
+  m_Summary_2.Format(":%i:%i:%i,%i;%i,%i:%i:%i:%i:%i:%i:%i" , chaninfo.m_Settings.m_Symbolrate
+                     , chaninfo.m_Settings.m_VPID
+                     , chaninfo.m_Settings.m_APID1
+                     , chaninfo.m_Settings.m_APID2
+                     , chaninfo.m_Settings.m_DPID1
+                     , chaninfo.m_Settings.m_DPID2
+                     , chaninfo.m_Settings.m_TPID
+                     , chaninfo.m_Settings.m_CAID
+                     , chaninfo.m_Settings.m_SID
+                     , chaninfo.m_Settings.m_NID
+                     , chaninfo.m_Settings.m_TID
+                     , chaninfo.m_Settings.m_RID);
+
+  m_Summary += m_Summary_2;
+
+  sprintf(buffer, "LSTC %d", chaninfo.m_iClientNum);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "MODC %s", m_Summary.c_str());
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SAVED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::AddChannel(const CTVChannelInfoTag &info)
+{
+
+  CStdString m_Summary;
+  CStdString m_Summary_2;
+  bool update_channel;
+  int iChannelNum;
+
+  if (!m_transceiver->IsOpen())
+  {
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (info.m_iClientNum == -1)
+  {
+    int new_number = GetNumChannels();
+
+    if (new_number == -1)
+    {
+      new_number = 1;
+    }
+
+    iChannelNum = new_number + 1;
+
+    update_channel = false;
+  }
+  else
+  {
+    iChannelNum = info.m_iClientNum;
+    update_channel = true;
+  }
+
+  m_Summary.Format("%d %s;%s:%i:" , iChannelNum
+
+                   , info.m_strChannel.c_str()
+                   , info.m_Settings.m_strProvider.c_str()
+                   , info.m_Settings.m_Freq);
+
+  if ((info.m_Settings.m_SourceType == src_DVBS) ||
+      (info.m_Settings.m_SourceType == src_DVBS2))
+  {
+    if      (info.m_Settings.m_Polarization == pol_H)
+      m_Summary += "h";
+    else
+      if (info.m_Settings.m_Polarization == pol_V)
+        m_Summary += "v";
+      else
+        if (info.m_Settings.m_Polarization == pol_L)
+          m_Summary += "l";
+        else
+          if (info.m_Settings.m_Polarization == pol_R)
+            m_Summary += "r";
+  }
+
+  if (info.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (info.m_Settings.m_Inversion == InvOff)
+      m_Summary += "I0";
+    else
+      if (info.m_Settings.m_Inversion == InvOn)
+        m_Summary += "I1";
+      else
+        if (info.m_Settings.m_Inversion == InvAuto)
+          m_Summary += "I999";
+  }
+
+  if (info.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (info.m_Settings.m_Bandwidth == bw_5MHz)
+      m_Summary += "B5";
+    else
+      if (info.m_Settings.m_Bandwidth == bw_6MHz)
+        m_Summary += "B6";
+      else
+        if (info.m_Settings.m_Bandwidth == bw_7MHz)
+          m_Summary += "B7";
+        else
+          if (info.m_Settings.m_Bandwidth == bw_8MHz)
+            m_Summary += "B8";
+          else
+            if (info.m_Settings.m_Bandwidth == bw_Auto)
+              m_Summary += "B999";
+  }
+
+  if      (info.m_Settings.m_CoderateH == Coderate_None)
+    m_Summary += "C0";
+  else
+    if (info.m_Settings.m_CoderateH == Coderate_1_2)
+      m_Summary += "C12";
+    else
+      if (info.m_Settings.m_CoderateH == Coderate_2_3)
+        m_Summary += "C23";
+      else
+        if (info.m_Settings.m_CoderateH == Coderate_3_4)
+          m_Summary += "C34";
+        else
+          if (info.m_Settings.m_CoderateH == Coderate_4_5)
+            m_Summary += "C45";
+          else
+            if (info.m_Settings.m_CoderateH == Coderate_5_6)
+              m_Summary += "C56";
+            else
+              if (info.m_Settings.m_CoderateH == Coderate_6_7)
+                m_Summary += "C67";
+              else
+                if (info.m_Settings.m_CoderateH == Coderate_7_8)
+                  m_Summary += "C78";
+                else
+                  if (info.m_Settings.m_CoderateH == Coderate_8_9)
+                    m_Summary += "C89";
+                  else
+                    if (info.m_Settings.m_CoderateH == Coderate_9_10)
+                      m_Summary += "C910";
+                    else
+                      if (info.m_Settings.m_CoderateH == Coderate_Auto)
+                        m_Summary += "C999";
+
+  if (info.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (info.m_Settings.m_CoderateL == Coderate_None)
+      m_Summary += "D0";
+    else
+      if (info.m_Settings.m_CoderateL == Coderate_1_2)
+        m_Summary += "D12";
+      else
+        if (info.m_Settings.m_CoderateL == Coderate_2_3)
+          m_Summary += "D23";
+        else
+          if (info.m_Settings.m_CoderateL == Coderate_3_4)
+            m_Summary += "D34";
+          else
+            if (info.m_Settings.m_CoderateL == Coderate_4_5)
+              m_Summary += "D45";
+            else
+              if (info.m_Settings.m_CoderateL == Coderate_5_6)
+                m_Summary += "D56";
+              else
+                if (info.m_Settings.m_CoderateL == Coderate_6_7)
+                  m_Summary += "D67";
+                else
+                  if (info.m_Settings.m_CoderateL == Coderate_7_8)
+                    m_Summary += "D78";
+                  else
+                    if (info.m_Settings.m_CoderateL == Coderate_8_9)
+                      m_Summary += "D89";
+                    else
+                      if (info.m_Settings.m_CoderateL == Coderate_9_10)
+                        m_Summary += "D910";
+                      else
+                        if (info.m_Settings.m_CoderateL == Coderate_Auto)
+                          m_Summary += "D999";
+  }
+
+  if      (info.m_Settings.m_Modulation == modNone)
+    m_Summary += "M0";
+  else
+    if (info.m_Settings.m_Modulation == modQAM4)
+      m_Summary += "M4";
+    else
+      if (info.m_Settings.m_Modulation == modQAM16)
+        m_Summary += "M16";
+      else
+        if (info.m_Settings.m_Modulation == modQAM32)
+          m_Summary += "M32";
+        else
+          if (info.m_Settings.m_Modulation == modQAM64)
+            m_Summary += "M64";
+          else
+            if (info.m_Settings.m_Modulation == modQAM128)
+              m_Summary += "M128";
+            else
+              if (info.m_Settings.m_Modulation == modQAM256)
+                m_Summary += "M256";
+              else
+                if (info.m_Settings.m_Modulation == modQAM512)
+                  m_Summary += "M512";
+                else
+                  if (info.m_Settings.m_Modulation == modQAM1024)
+                    m_Summary += "M1024";
+                  else
+                    if (info.m_Settings.m_Modulation == modQAMAuto)
+                      m_Summary += "M998";
+                    else
+                      if (info.m_Settings.m_Modulation == modBPSK)
+                        m_Summary += "M1";
+                      else
+                        if (info.m_Settings.m_Modulation == modQPSK)
+                          m_Summary += "M2";
+                        else
+                          if (info.m_Settings.m_Modulation == modOQPSK)
+                            m_Summary += "M3";
+                          else
+                            if (info.m_Settings.m_Modulation == mod8PSK)
+                              m_Summary += "M5";
+                            else
+                              if (info.m_Settings.m_Modulation == mod16APSK)
+                                m_Summary += "M6";
+                              else
+                                if (info.m_Settings.m_Modulation == mod32APSK)
+                                  m_Summary += "M7";
+                                else
+                                  if (info.m_Settings.m_Modulation == modOFDM)
+                                    m_Summary += "M8";
+                                  else
+                                    if (info.m_Settings.m_Modulation == modCOFDM)
+                                      m_Summary += "M9";
+                                    else
+                                      if (info.m_Settings.m_Modulation == modVSB8)
+                                        m_Summary += "M10";
+                                      else
+                                        if (info.m_Settings.m_Modulation == modVSB16)
+                                          m_Summary += "M11";
+
+  if (info.m_Settings.m_SourceType == src_DVBT)
+  {
+    if      (info.m_Settings.m_Transmission == transmission_2K)
+      m_Summary += "T2";
+    else
+      if (info.m_Settings.m_Transmission == transmission_4K)
+        m_Summary += "T4";
+      else
+        if (info.m_Settings.m_Transmission == transmission_8K)
+          m_Summary += "T8";
+        else
+          if (info.m_Settings.m_Transmission == transmission_Auto)
+            m_Summary += "T999";
+
+    if      (info.m_Settings.m_Guard == guard_1_4)
+      m_Summary += "G4";
+    else
+      if (info.m_Settings.m_Guard == guard_1_8)
+        m_Summary += "G8";
+      else
+        if (info.m_Settings.m_Guard == guard_1_16)
+          m_Summary += "G16";
+        else
+          if (info.m_Settings.m_Guard == guard_1_32)
+            m_Summary += "G32";
+          else
+            if (info.m_Settings.m_Guard == guard_Auto)
+              m_Summary += "G999";
+
+    if      (info.m_Settings.m_Hierarchie)
+      m_Summary += "Y1";
+    else
+      m_Summary += "Y0";
+
+    if      (info.m_Settings.m_Alpha == alpha_0)
+      m_Summary += "A0";
+    else
+      if (info.m_Settings.m_Alpha == alpha_1)
+        m_Summary += "A1";
+      else
+        if (info.m_Settings.m_Alpha == alpha_2)
+          m_Summary += "A2";
+        else
+          if (info.m_Settings.m_Alpha == alpha_4)
+            m_Summary += "A4";
+
+    if      (info.m_Settings.m_Priority)
+      m_Summary += "P1";
+    else
+      m_Summary += "P0";
+  }
+
+  if (info.m_Settings.m_SourceType == src_DVBS2)
+  {
+    if      (info.m_Settings.m_Rolloff == rolloff_Unknown)
+      m_Summary += "O0";
+    else
+      if (info.m_Settings.m_Rolloff == rolloff_20)
+        m_Summary += "O20";
+      else
+        if (info.m_Settings.m_Rolloff == rolloff_25)
+          m_Summary += "O25";
+        else
+          if (info.m_Settings.m_Rolloff == rolloff_25)
+            m_Summary += "O35";
+  }
+
+  if      (info.m_Settings.m_SourceType == src_DVBS)
+    m_Summary += "O35S0:S";
+  else
+    if (info.m_Settings.m_SourceType == src_DVBS2)
+      m_Summary += "S1:S";
+    else
+      if (info.m_Settings.m_SourceType == src_DVBC)
+        m_Summary += ":C";
+      else
+        if (info.m_Settings.m_SourceType == src_DVBT)
+          m_Summary += ":T";
+
+  m_Summary_2.Format(":%i:%i:%i,%i;%i,%i:%i:%i:%i:%i:%i:%i" , info.m_Settings.m_Symbolrate
+                     , info.m_Settings.m_VPID
+                     , info.m_Settings.m_APID1
+                     , info.m_Settings.m_APID2
+                     , info.m_Settings.m_DPID1
+                     , info.m_Settings.m_DPID2
+                     , info.m_Settings.m_TPID
+                     , info.m_Settings.m_CAID
+                     , info.m_Settings.m_SID
+                     , info.m_Settings.m_NID
+                     , info.m_Settings.m_TID
+                     , info.m_Settings.m_RID);
+
+  m_Summary += m_Summary_2;
+
+  fprintf(stderr, "<<<<<<<<<<< '%s' \n", m_Summary.c_str());
+
+  vector<string> lines;
+
+  int            code;
+
+  char           buffer[1024];
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!update_channel)
+  {
+    sprintf(buffer, "NEWC %s", m_Summary.c_str());
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SAVED;
+    }
+  }
+  else
+  {
+    // Modified channel
+    sprintf(buffer, "LSTC %d", iChannelNum);
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SYNC;
+    }
+
+    sprintf(buffer, "MODC %s", m_Summary.c_str());
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SAVED;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::DeleteChannel(unsigned int number)
+{
+
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+  {
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTC %d", number);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "DELC %d", number);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    return PVR_ERROR_NOT_DELETED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::RenameChannel(unsigned int number, CStdString &newname)
+{
+
+  CStdString     str_part1;
+  CStdString     str_part2;
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  int            found;
+
+  if (!m_transceiver->IsOpen())
+  {
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTC %d", number);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+  CStdString str_result = data;
+
+  found = str_result.find(" ", 0);
+  str_part1.assign(str_result, found + 1);
+  str_result.erase(0, found + 1);
+
+  /// Channel and provider name
+  found = str_result.find(":", 0);
+  str_part2.assign(str_result, found);
+  str_result.erase(0, found);
+  found = str_part2.find(";", 0);
+
+  if (found == -1)
+  {
+    str_part2 = newname;
+  }
+  else
+  {
+    str_part2.erase(0, found);
+    str_part2.insert(0, newname);
+  }
+
+  sprintf(buffer, "MODC %s %s %s", str_part1.c_str(), str_part2.c_str(), str_result.c_str());
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SAVED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::MoveChannel(unsigned int number, unsigned int newnumber)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+      return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTC %d", number);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "MOVC %d %d", number, newnumber);
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SAVED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+/************************************************************/
+/** Record handling **/
+
+int PVRClientVDR::GetNumRecordings(void)
+{
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->IsOpen())
+    return -1;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->SendCommand("STAT records", code, lines))
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get recordings count");
+    pthread_mutex_unlock(&m_critSection);
+    return -1;
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+  pthread_mutex_unlock(&m_critSection);
+  return atol(data.c_str());
+}
+
+PVR_ERROR PVRClientVDR::GetAllRecordings(VECRECORDINGS *results)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  unsigned int   cnt = 0;
+  CStdString     strbuffer;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->SendCommand("LSTR", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  for (vector<string>::iterator it2 = lines.begin(); it2 != lines.end(); it2++)
+  {
+    string& data(*it2);
+    CStdString str_result = data;
+    CTVRecordingInfoTag broadcast;
+
+    /* Convert to UTF8 string format */
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    /* Get recording ID */
+    broadcast.m_Index = atol(str_result.c_str());
+    str_result.erase(0, 18);
+
+    /* Get recording name */
+    broadcast.m_strTitle = str_result.c_str();
+
+    /* Set file string for replay devices */
+    broadcast.m_strFileNameAndPath.Format("record://%i", broadcast.m_Index);
+
+    /* Save it inside list */
+    results->push_back(broadcast);
+    cnt++;
+  }
+
+  std::vector<CTVRecordingInfoTag>::iterator it;
+
+  for (unsigned int i = 0; i < cnt; i++)
+  {
+    lines.erase(lines.begin(), lines.end());
+    it = results->begin() + i;
+
+    sprintf(buffer, "LSTR %d", (*it).m_Index);
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+//      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+
+    for (vector<string>::iterator it2 = lines.begin(); it2 != lines.end(); it2++)
+    {
+      string& data(*it2);
+      CStdString str_result = data;
+
+      /* Convert to UTF8 string format */
+	  if (m_bCharsetConv)
+        m_xbmc->CharConv(str_result);
+
+      /* Get Channelname */
+      if (str_result.find("C", 0) == 0)
+      {
+        str_result.erase(0, 2);
+        str_result.erase(0, str_result.find(" ", 0) + 1);
+        (*it).m_strChannel = str_result.c_str();
+        continue;
+      }
+
+      /* Get Title */
+      if (str_result.find("T", 0) == 0)
+      {
+        str_result.erase(0, 2);
+        //   (*it).m_strTitle = str_result.c_str();
+        continue;
+      }
+
+      /* Get short description */
+      if (str_result.find("S", 0) == 0)
+      {
+        str_result.erase(0, 2);
+        (*it).m_strPlotOutline   = str_result.c_str();
+        continue;
+      }
+
+      /* Get description */
+      if (str_result.find("D", 0) == 0)
+      {
+        str_result.erase(0, 2);
+        int pos = 0;
+
+        while (1)
+        {
+          pos = str_result.find("|", pos);
+          if (pos < 0)
+            break;
+
+          str_result.replace(pos, 1, 1, '\n');
+        }
+
+        (*it).m_strPlot = str_result.c_str();
+        continue;
+      }
+
+      /* Get ID, date and length */
+      if (str_result.find("E ", 0) == 0)
+      {
+        str_result.erase(0, 2);
+        // (*it).m_uniqueID = atol(str_result.c_str());
+        str_result.erase(0, str_result.find(" ", 0) + 1);
+        time_t rec_time = atol(str_result.c_str());
+        str_result.erase(0, str_result.find(" ", 0) + 1);
+        unsigned int duration = atol(str_result.c_str());
+
+        (*it).m_startTime = CDateTime((time_t)rec_time);
+        (*it).m_endTime   = CDateTime((time_t)rec_time + duration);
+        (*it).m_duration  = CDateTimeSpan(0, 0, duration / 60, duration % 60);
+        (*it).m_Summary.Format("%s", (*it).m_startTime.GetAsLocalizedDateTime(false, false));
+        continue;
+      }
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::DeleteRecording(const CTVRecordingInfoTag &recinfo)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTR %d", recinfo.m_Index);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 215)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "DELR %d", recinfo.m_Index);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_DELETED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTR %d", recinfo.m_Index);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 215)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "RENR %d %s", recinfo.m_Index, newname.c_str());
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_DELETED;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+/************************************************************/
+/** Timer handling */
+
+int PVRClientVDR::GetNumTimers(void)
+{
+  vector<string>  lines;
+  int             code;
+
+  if (!m_transceiver->IsOpen())
+    return -1;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->SendCommand("STAT timers", code, lines))
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get timers count");
+    pthread_mutex_unlock(&m_critSection);
+    return -1;
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+  pthread_mutex_unlock(&m_critSection);
+  return atol(data.c_str());
+}
+
+PVR_ERROR PVRClientVDR::GetAllTimers(VECTVTIMERS *results)
+{
+  vector<string> lines;
+  int            code;
+  int            found;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->SendCommand("LSTT", code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  for (vector<string>::iterator it = lines.begin(); it != lines.end(); it++)
+  {
+    string& data(*it);
+    CStdString str_result = data;
+    CStdString name;
+    CTVTimerInfoTag timerinfo;
+
+    /**
+     * VDR Format given by LSTT:
+     * 250-1 1:6:2008-10-27:0013:0055:50:99:Zeiglers wunderbare Welt des Fuballs:
+     * 250 2 0:15:2008-10-26:2000:2138:50:99:ZDFtheaterkanal:
+     * 250 3 1:6:MTWTFS-:2000:2129:50:99:WDR Kln:
+     */
+
+    if (m_bCharsetConv)
+      m_xbmc->CharConv(str_result);
+
+    /* Id */
+    timerinfo.m_Index = atol(str_result.c_str());
+    found = str_result.find(" ", 0);
+    str_result.erase(0, found + 1);
+
+    /* Active */
+    timerinfo.m_Active = (bool) atoi(str_result.c_str());
+	found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    /* Channel number */
+    timerinfo.m_clientNum = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    /* Start/end time */
+    int year  = atol(str_result.c_str());
+    int month = 0;
+    int day   = 0;
+    timerinfo.m_FirstDay = NULL;
+
+    if (year != 0)
+    {
+      timerinfo.m_Repeat = false;
+      found = str_result.find("-", 0);
+      str_result.erase(0, found + 1);
+      month = atol(str_result.c_str());
+      found = str_result.find("-", 0);
+      str_result.erase(0, found + 1);
+      day   = atol(str_result.c_str());
+      found = str_result.find(":", 0);
+      str_result.erase(0, found + 1);
+
+      timerinfo.m_Repeat_Mon = false;
+      timerinfo.m_Repeat_Tue = false;
+      timerinfo.m_Repeat_Wed = false;
+      timerinfo.m_Repeat_Thu = false;
+      timerinfo.m_Repeat_Fri = false;
+      timerinfo.m_Repeat_Sat = false;
+      timerinfo.m_Repeat_Sun = false;
+    }
+    else
+    {
+      timerinfo.m_Repeat = true;
+
+      timerinfo.m_Repeat_Mon = str_result.compare(0, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Tue = str_result.compare(1, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Wed = str_result.compare(2, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Thu = str_result.compare(3, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Fri = str_result.compare(4, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Sat = str_result.compare(5, 1, "-") ? true : false;
+      timerinfo.m_Repeat_Sun = str_result.compare(6, 1, "-") ? true : false;
+
+      str_result.erase(0, 7);
+      found = str_result.find("@", 0);
+
+      if (found != -1)
+      {
+        str_result.erase(0, 1);
+        year  = atol(str_result.c_str());
+        found = str_result.find("-", 0);
+        str_result.erase(0, found + 1);
+
+        month = atol(str_result.c_str());
+        found = str_result.find("-", 0);
+        str_result.erase(0, found + 1);
+
+        day   = atol(str_result.c_str());
+      }
+
+      found = str_result.find(":", 0);
+      str_result.erase(0, found + 1);
+    }
+
+    name.assign(str_result, 2);
+
+    str_result.erase(0, 2);
+    int start_hour = atol(name.c_str());
+
+    name.assign(str_result, 2);
+    str_result.erase(0, 3);
+    int start_minute = atol(name.c_str());
+
+    name.assign(str_result, 2);
+    str_result.erase(0, 2);
+    int end_hour = atol(name.c_str());
+
+    name.assign(str_result, 2);
+    str_result.erase(0, 3);
+    int end_minute = atol(name.c_str());
+
+    if (!timerinfo.m_Repeat)
+    {
+      int end_day = (start_hour > end_hour ? day + 1 : day);
+      timerinfo.m_StartTime = CDateTime(year, month, day, start_hour, start_minute, 0);
+      timerinfo.m_StopTime = CDateTime(year, month, end_day, end_hour, end_minute, 0);
+    }
+    else
+      if (year != 0)
+      {
+        timerinfo.m_FirstDay = CDateTime(year, month, day, start_hour, start_minute, 0);
+        timerinfo.m_StartTime = CDateTime(year, month, day, start_hour, start_minute, 0);
+        timerinfo.m_StopTime = CDateTime(year, month, day, end_hour, end_minute, 0);
+      }
+      else
+      {
+        timerinfo.m_StartTime = CDateTime(CDateTime::GetCurrentDateTime().GetYear(),
+                                          CDateTime::GetCurrentDateTime().GetMonth(),
+                                          CDateTime::GetCurrentDateTime().GetDay(),
+                                          start_hour, start_minute, 0);
+        timerinfo.m_StopTime = CDateTime(CDateTime::GetCurrentDateTime().GetYear(),
+                                         CDateTime::GetCurrentDateTime().GetMonth(),
+                                         CDateTime::GetCurrentDateTime().GetDay(),
+                                         end_hour, end_minute, 0);
+      }
+
+    /* Priority */
+    timerinfo.m_Priority = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    /* Lifetime */
+    timerinfo.m_Lifetime = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    /* Title */
+    found = str_result.find(":", 0);
+    str_result.erase(found, found + 1);
+    timerinfo.m_strTitle = str_result.c_str();
+
+    if (!timerinfo.m_Repeat)
+    {
+      timerinfo.m_Summary.Format("%s %s %s %s %s", timerinfo.m_StartTime.GetAsLocalizedDate()
+                                 , m_xbmc->LocStrings(18078)
+                                 , timerinfo.m_StartTime.GetAsLocalizedTime("", false)
+                                 , m_xbmc->LocStrings(18079)
+                                 , timerinfo.m_StopTime.GetAsLocalizedTime("", false));
+    }
+    else
+      if (timerinfo.m_FirstDay != NULL)
+      {
+        timerinfo.m_Summary.Format("%s-%s-%s-%s-%s-%s-%s %s %s %s %s %s %s"
+                                   , timerinfo.m_Repeat_Mon ? m_xbmc->LocStrings(18080) : "__"
+                                   , timerinfo.m_Repeat_Tue ? m_xbmc->LocStrings(18081) : "__"
+                                   , timerinfo.m_Repeat_Wed ? m_xbmc->LocStrings(18082) : "__"
+                                   , timerinfo.m_Repeat_Thu ? m_xbmc->LocStrings(18083) : "__"
+                                   , timerinfo.m_Repeat_Fri ? m_xbmc->LocStrings(18084) : "__"
+                                   , timerinfo.m_Repeat_Sat ? m_xbmc->LocStrings(18085) : "__"
+                                   , timerinfo.m_Repeat_Sun ? m_xbmc->LocStrings(18086) : "__"
+                                   , m_xbmc->LocStrings(18087)
+                                   , timerinfo.m_FirstDay.GetAsLocalizedDate(false)
+                                   , m_xbmc->LocStrings(18078)
+                                   , timerinfo.m_StartTime.GetAsLocalizedTime("", false)
+                                   , m_xbmc->LocStrings(18079)
+                                   , timerinfo.m_StopTime.GetAsLocalizedTime("", false));
+      }
+      else
+      {
+        timerinfo.m_Summary.Format("%s-%s-%s-%s-%s-%s-%s %s %s %s %s"
+                                   , timerinfo.m_Repeat_Mon ? m_xbmc->LocStrings(18080) : "__"
+                                   , timerinfo.m_Repeat_Tue ? m_xbmc->LocStrings(18081) : "__"
+                                   , timerinfo.m_Repeat_Wed ? m_xbmc->LocStrings(18082) : "__"
+                                   , timerinfo.m_Repeat_Thu ? m_xbmc->LocStrings(18083) : "__"
+                                   , timerinfo.m_Repeat_Fri ? m_xbmc->LocStrings(18084) : "__"
+                                   , timerinfo.m_Repeat_Sat ? m_xbmc->LocStrings(18085) : "__"
+                                   , timerinfo.m_Repeat_Sun ? m_xbmc->LocStrings(18086) : "__"
+                                   , m_xbmc->LocStrings(18078)
+                                   , timerinfo.m_StartTime.GetAsLocalizedTime("", false)
+                                   , m_xbmc->LocStrings(18079)
+                                   , timerinfo.m_StopTime.GetAsLocalizedTime("", false));
+      }
+
+    if ((timerinfo.m_StartTime <= CDateTime::GetCurrentDateTime()) &&
+        (timerinfo.m_Active == true))
+    {
+      timerinfo.m_recStatus = true;
+      timerinfo.m_strFileNameAndPath.Format("timer://%i #", timerinfo.m_Index);
+    }
+    else
+    {
+      timerinfo.m_strFileNameAndPath.Format("timer://%i %s", timerinfo.m_Index, timerinfo.m_Active ? "*" : " ");
+      timerinfo.m_recStatus = false;
+    }
+
+    results->push_back(timerinfo);
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::GetTimerInfo(unsigned int timernumber, CTVTimerInfoTag &timerinfo)
+{
+  vector<string>  lines;
+  int             code;
+  char            buffer[1024];
+  CStdString      name;
+  int             found;
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTT %d", timernumber);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  vector<string>::iterator it = lines.begin();
+
+  string& data(*it);
+  CStdString str_result = data;
+
+  if (m_bCharsetConv)
+    m_xbmc->CharConv(str_result);
+
+  /* Id */
+  timerinfo.m_Index = atol(str_result.c_str());
+  found = str_result.find(" ", 0);
+  str_result.erase(0, found + 1);
+
+  /* Active */
+  timerinfo.m_Active = (bool) atoi(str_result.c_str());
+  str_result.erase(0, 2);
+
+  /* Channel number */
+  timerinfo.m_clientNum = atol(str_result.c_str());
+  found = str_result.find(":", 0);
+  str_result.erase(0, found + 1);
+
+  /* Start/end time */
+  int year  = atol(str_result.c_str());
+  int month = 0;
+  int day   = 0;
+
+  timerinfo.m_FirstDay = NULL;
+
+  if (year != 0)
+  {
+    timerinfo.m_Repeat = false;
+    found = str_result.find("-", 0);
+    str_result.erase(0, found + 1);
+    month = atol(str_result.c_str());
+    found = str_result.find("-", 0);
+    str_result.erase(0, found + 1);
+    day   = atol(str_result.c_str());
+    found = str_result.find(":", 0);
+    str_result.erase(0, found + 1);
+
+    timerinfo.m_Repeat_Mon = false;
+    timerinfo.m_Repeat_Tue = false;
+    timerinfo.m_Repeat_Wed = false;
+    timerinfo.m_Repeat_Thu = false;
+    timerinfo.m_Repeat_Fri = false;
+    timerinfo.m_Repeat_Sat = false;
+    timerinfo.m_Repeat_Sun = false;
+  }
+  else
+  {
+    timerinfo.m_Repeat = true;
+    timerinfo.m_Repeat_Mon = str_result.compare(0, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Tue = str_result.compare(1, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Wed = str_result.compare(2, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Thu = str_result.compare(3, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Fri = str_result.compare(4, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Sat = str_result.compare(5, 1, "-") ? true : false;
+    timerinfo.m_Repeat_Sun = str_result.compare(6, 1, "-") ? true : false;
+
+    str_result.erase(0, 7);
+    found = str_result.find("@", 0);
+
+    if (found != -1)
+    {
+      year  = atol(str_result.c_str());
+      found = str_result.find("-", 0);
+      str_result.erase(0, found + 1);
+
+      month = atol(str_result.c_str());
+      found = str_result.find("-", 0);
+      str_result.erase(0, found + 1);
+
+      day   = atol(str_result.c_str());
+    }
+
+    found = str_result.find(":", 0);
+
+    str_result.erase(0, found + 1);
+  }
+
+  name.assign(str_result, 2);
+
+  str_result.erase(0, 2);
+  int start_hour = atol(name.c_str());
+
+  name.assign(str_result, 2);
+  str_result.erase(0, 3);
+  int start_minute = atol(name.c_str());
+
+  name.assign(str_result, 2);
+  str_result.erase(0, 2);
+  int end_hour = atol(name.c_str());
+
+  name.assign(str_result, 2);
+  str_result.erase(0, 3);
+  int end_minute = atol(name.c_str());
+
+  if (!timerinfo.m_Repeat)
+  {
+    int end_day = (start_hour > end_hour ? day + 1 : day);
+    timerinfo.m_StartTime = CDateTime(year, month, day, start_hour, start_minute, 0);
+    timerinfo.m_StopTime = CDateTime(year, month, end_day, end_hour, end_minute, 0);
+  }
+  else
+    if (year != 0)
+    {
+      timerinfo.m_FirstDay = CDateTime(year, month, day, start_hour, start_minute, 0);
+      timerinfo.m_StartTime = CDateTime(year, month, day, start_hour, start_minute, 0);
+      timerinfo.m_StopTime = CDateTime(year, month, day, end_hour, end_minute, 0);
+    }
+    else
+    {
+      timerinfo.m_StartTime = CDateTime(CDateTime::GetCurrentDateTime().GetYear(),
+                                        CDateTime::GetCurrentDateTime().GetMonth(),
+                                        CDateTime::GetCurrentDateTime().GetDay(),
+                                        start_hour, start_minute, 0);
+      timerinfo.m_StopTime = CDateTime(CDateTime::GetCurrentDateTime().GetYear(),
+                                       CDateTime::GetCurrentDateTime().GetMonth(),
+                                       CDateTime::GetCurrentDateTime().GetDay(),
+                                       end_hour, end_minute, 0);
+    }
+
+  /* Priority */
+  timerinfo.m_Priority = atol(str_result.c_str());
+  found = str_result.find(":", 0);
+  str_result.erase(0, found + 1);
+
+  /* Lifetime */
+  timerinfo.m_Lifetime = atol(str_result.c_str());
+  found = str_result.find(":", 0);
+  str_result.erase(0, found + 1);
+
+  /* Title */
+  found = str_result.find(":", 0);
+  str_result.erase(found, found + 1);
+  timerinfo.m_strTitle = str_result.c_str();
+  timerinfo.m_strPath.Format("timer://%i%s", timerinfo.m_Index, timerinfo.m_Active ? " *" : "");
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::AddTimer(const CTVTimerInfoTag &timerinfo)
+{
+  CStdString     m_Summary;
+  CStdString     m_Summary_2;
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  if (!timerinfo.m_Repeat)
+  {
+    m_Summary.Format("%d:%d:%04d-%02d-%02d:%02d%02d:%02d%02d:%d:%d:%s"
+                     , timerinfo.m_Active
+                     , timerinfo.m_clientNum
+                     , timerinfo.m_StartTime.GetYear()
+                     , timerinfo.m_StartTime.GetMonth()
+                     , timerinfo.m_StartTime.GetDay()
+                     , timerinfo.m_StartTime.GetHour()
+                     , timerinfo.m_StartTime.GetMinute()
+                     , timerinfo.m_StopTime.GetHour()
+                     , timerinfo.m_StopTime.GetMinute()
+                     , timerinfo.m_Priority
+                     , timerinfo.m_Lifetime
+                     , timerinfo.m_strTitle.c_str());
+  }
+  else
+    if (timerinfo.m_FirstDay != NULL)
+    {
+      m_Summary.Format("%d:%d:%c%c%c%c%c%c%c@"
+                       , timerinfo.m_Active
+                       , timerinfo.m_clientNum
+                       , timerinfo.m_Repeat_Mon ? 'M' : '-'
+                       , timerinfo.m_Repeat_Tue ? 'T' : '-'
+                       , timerinfo.m_Repeat_Wed ? 'W' : '-'
+                       , timerinfo.m_Repeat_Thu ? 'T' : '-'
+                       , timerinfo.m_Repeat_Fri ? 'F' : '-'
+                       , timerinfo.m_Repeat_Sat ? 'S' : '-'
+                       , timerinfo.m_Repeat_Sun ? 'S' : '-');
+      m_Summary_2.Format("%04d-%02d-%02d:%02d%02d:%02d%02d:%d:%d:%s"
+                         , timerinfo.m_FirstDay.GetYear()
+                         , timerinfo.m_FirstDay.GetMonth()
+                         , timerinfo.m_FirstDay.GetDay()
+                         , timerinfo.m_StartTime.GetHour()
+                         , timerinfo.m_StartTime.GetMinute()
+                         , timerinfo.m_StopTime.GetHour()
+                         , timerinfo.m_StopTime.GetMinute()
+                         , timerinfo.m_Priority
+                         , timerinfo.m_Lifetime
+                         , timerinfo.m_strTitle.c_str());
+      m_Summary = m_Summary + m_Summary_2;
+    }
+    else
+    {
+      m_Summary.Format("%d:%d:%c%c%c%c%c%c%c:%02d%02d:%02d%02d:%d:%d:%s"
+                       , timerinfo.m_Active
+                       , timerinfo.m_clientNum
+                       , timerinfo.m_Repeat_Mon ? 'M' : '-'
+                       , timerinfo.m_Repeat_Tue ? 'T' : '-'
+                       , timerinfo.m_Repeat_Wed ? 'W' : '-'
+                       , timerinfo.m_Repeat_Thu ? 'T' : '-'
+                       , timerinfo.m_Repeat_Fri ? 'F' : '-'
+                       , timerinfo.m_Repeat_Sat ? 'S' : '-'
+                       , timerinfo.m_Repeat_Sun ? 'S' : '-'
+                       , timerinfo.m_StartTime.GetHour()
+                       , timerinfo.m_StartTime.GetMinute()
+                       , timerinfo.m_StopTime.GetHour()
+                       , timerinfo.m_StopTime.GetMinute()
+                       , timerinfo.m_Priority
+                       , timerinfo.m_Lifetime
+                       , timerinfo.m_strTitle.c_str());
+    }
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (timerinfo.m_Index == -1)
+  {
+    sprintf(buffer, "NEWT %s", m_Summary.c_str());
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SAVED;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SYNC;
+    }
+  }
+  else
+  {
+    // Modified timer
+    sprintf(buffer, "LSTT %d", timerinfo.m_Index);
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_SERVER_ERROR;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SYNC;
+    }
+
+    sprintf(buffer, "MODT %d %s", timerinfo.m_Index, m_Summary.c_str());
+
+    if (!m_transceiver->SendCommand(buffer, code, lines))
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SAVED;
+    }
+
+    if (code != 250)
+    {
+      pthread_mutex_unlock(&m_critSection);
+      return PVR_ERROR_NOT_SYNC;
+    }
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force)
+{
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTT %d", timerinfo.m_Index);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  lines.erase(lines.begin(), lines.end());
+
+  if (force)
+  {
+    sprintf(buffer, "DELT %d FORCE", timerinfo.m_Index);
+  }
+  else
+  {
+    sprintf(buffer, "DELT %d", timerinfo.m_Index);
+  }
+
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    vector<string>::iterator it = lines.begin();
+    string& data(*it);
+    CStdString str_result = data;
+    pthread_mutex_unlock(&m_critSection);
+
+    int found = str_result.find("is recording", 0);
+
+    if (found != -1)
+    {
+      return PVR_ERROR_RECORDING_RUNNING;
+    }
+    else
+    {
+      return PVR_ERROR_NOT_DELETED;
+    }
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR PVRClientVDR::RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname)
+{
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  pthread_mutex_lock(&m_critSection);
+
+  CTVTimerInfoTag timerinfo1;
+  PVR_ERROR ret = GetTimerInfo(timerinfo.m_Index, timerinfo1);
+
+  if (ret != PVR_ERROR_NO_ERROR)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return ret;
+  }
+
+  timerinfo1.m_strTitle = newname;
+
+  pthread_mutex_unlock(&m_critSection);
+  return UpdateTimer(timerinfo1);
+}
+
+PVR_ERROR PVRClientVDR::UpdateTimer(const CTVTimerInfoTag &timerinfo)
+{
+  CStdString     m_Summary;
+  CStdString     m_Summary_2;
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+
+  if (!m_transceiver->IsOpen())
+    return PVR_ERROR_SERVER_ERROR;
+
+  if (timerinfo.m_Index == -1)
+    return PVR_ERROR_NOT_SAVED;
+
+  if (!timerinfo.m_Repeat)
+  {
+    m_Summary.Format("%d:%d:%04d-%02d-%02d:%02d%02d:%02d%02d:%d:%d:%s"
+                     , timerinfo.m_Active
+                     , timerinfo.m_clientNum
+                     , timerinfo.m_StartTime.GetYear()
+                     , timerinfo.m_StartTime.GetMonth()
+                     , timerinfo.m_StartTime.GetDay()
+                     , timerinfo.m_StartTime.GetHour()
+                     , timerinfo.m_StartTime.GetMinute()
+                     , timerinfo.m_StopTime.GetHour()
+                     , timerinfo.m_StopTime.GetMinute()
+                     , timerinfo.m_Priority
+                     , timerinfo.m_Lifetime
+                     , timerinfo.m_strTitle.c_str());
+  }
+  else
+    if (timerinfo.m_FirstDay != NULL)
+    {
+      m_Summary.Format("%d:%d:%c%c%c%c%c%c%c@"
+                       , timerinfo.m_Active
+                       , timerinfo.m_clientNum
+                       , timerinfo.m_Repeat_Mon ? 'M' : '-'
+                       , timerinfo.m_Repeat_Tue ? 'T' : '-'
+                       , timerinfo.m_Repeat_Wed ? 'W' : '-'
+                       , timerinfo.m_Repeat_Thu ? 'T' : '-'
+                       , timerinfo.m_Repeat_Fri ? 'F' : '-'
+                       , timerinfo.m_Repeat_Sat ? 'S' : '-'
+                       , timerinfo.m_Repeat_Sun ? 'S' : '-');
+      m_Summary_2.Format("%04d-%02d-%02d:%02d%02d:%02d%02d:%d:%d:%s"
+                         , timerinfo.m_FirstDay.GetYear()
+                         , timerinfo.m_FirstDay.GetMonth()
+                         , timerinfo.m_FirstDay.GetDay()
+                         , timerinfo.m_StartTime.GetHour()
+                         , timerinfo.m_StartTime.GetMinute()
+                         , timerinfo.m_StopTime.GetHour()
+                         , timerinfo.m_StopTime.GetMinute()
+                         , timerinfo.m_Priority
+                         , timerinfo.m_Lifetime
+                         , timerinfo.m_strTitle.c_str());
+      m_Summary = m_Summary + m_Summary_2;
+    }
+    else
+    {
+      m_Summary.Format("%d:%d:%c%c%c%c%c%c%c:%02d%02d:%02d%02d:%d:%d:%s"
+                       , timerinfo.m_Active
+                       , timerinfo.m_clientNum
+                       , timerinfo.m_Repeat_Mon ? 'M' : '-'
+                       , timerinfo.m_Repeat_Tue ? 'T' : '-'
+                       , timerinfo.m_Repeat_Wed ? 'W' : '-'
+                       , timerinfo.m_Repeat_Thu ? 'T' : '-'
+                       , timerinfo.m_Repeat_Fri ? 'F' : '-'
+                       , timerinfo.m_Repeat_Sat ? 'S' : '-'
+                       , timerinfo.m_Repeat_Sun ? 'S' : '-'
+                       , timerinfo.m_StartTime.GetHour()
+                       , timerinfo.m_StartTime.GetMinute()
+                       , timerinfo.m_StopTime.GetHour()
+                       , timerinfo.m_StopTime.GetMinute()
+                       , timerinfo.m_Priority
+                       , timerinfo.m_Lifetime
+                       , timerinfo.m_strTitle.c_str());
+    }
+
+  pthread_mutex_lock(&m_critSection);
+
+  sprintf(buffer, "LSTT %d", timerinfo.m_Index);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  sprintf(buffer, "MODT %d %s", timerinfo.m_Index, m_Summary.c_str());
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SAVED;
+  }
+
+  if (code != 250)
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return PVR_ERROR_NOT_SYNC;
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+/************************************************************/
+/** Live stream handling */
+
+bool PVRClientVDR::OpenLiveStream(unsigned int channel)
+{
+  if (!m_transceiver->IsOpen())
+    return false;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->CanStreamLive(channel))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return false;
+  }
+
+  /* Check if a another stream is opened, if yes first close them */
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    shutdown(m_socket_video, SD_BOTH);
+
+    if (m_iCurrentChannel < 0)
+      m_transceiver->AbortStreamRecording();
+    else
+      m_transceiver->AbortStreamLive();
+
+    closesocket(m_socket_video);
+  }
+
+  /* Get Stream socked from VDR Backend */
+  m_socket_video = m_transceiver->GetStreamLive(channel);
+
+  /* If received socket is invalid, return */
+  if (m_socket_video == INVALID_SOCKET)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get socket for live tv");
+    pthread_mutex_unlock(&m_critSection);
+    return false;
+  }
+
+  m_iCurrentChannel = channel;
+
+  pthread_mutex_unlock(&m_critSection);
+  return true;
+}
+
+void PVRClientVDR::CloseLiveStream()
+{
+  if (!m_transceiver->IsOpen())
+    return;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    m_transceiver->AbortStreamLive();
+    closesocket(m_socket_video);
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return;
+}
+
+int PVRClientVDR::ReadLiveStream(BYTE* buf, int buf_size)
+{
+  if (!m_transceiver->IsOpen())
+    return 0;
+
+  if (m_socket_video == INVALID_SOCKET)
+    return 0;
+
+  fd_set         set_r, set_e;
+
+  struct timeval tv;
+
+  int            res;
+
+  tv.tv_sec = 10;
+  tv.tv_usec = 0;
+  FD_ZERO(&set_r);
+  FD_ZERO(&set_e);
+  FD_SET(m_socket_video, &set_r);
+  FD_SET(m_socket_video, &set_e);
+  res = select(FD_SETSIZE, &set_r, NULL, &set_e, &tv);
+
+  if (res < 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Read - select failed");
+    return 0;
+  }
+
+  if (res == 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Read - timeout waiting for data");
+    return 0;
+  }
+
+  res = recv(m_socket_video, (char*)buf, (size_t)buf_size, 0);
+
+  if (res < 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Read - failed");
+    return 0;
+  }
+
+  if (res == 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::Read - eof");
+    return 0;
+  }
+
+  return res;
+}
+
+int PVRClientVDR::GetCurrentClientChannel()
+{
+  return m_iCurrentChannel;
+}
+
+bool PVRClientVDR::SwitchChannel(unsigned int channel)
+{
+  if (!m_transceiver->IsOpen())
+    return false;
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (!m_transceiver->CanStreamLive(channel))
+  {
+    pthread_mutex_unlock(&m_critSection);
+    return false;
+  }
+
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    shutdown(m_socket_video, SD_BOTH);
+    m_transceiver->AbortStreamLive();
+    closesocket(m_socket_video);
+  }
+
+  m_socket_video = m_transceiver->GetStreamLive(channel);
+
+  if (m_socket_video == INVALID_SOCKET)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get socket for live tv");
+    pthread_mutex_unlock(&m_critSection);
+    return false;
+  }
+
+  m_iCurrentChannel = channel;
+
+  pthread_mutex_unlock(&m_critSection);
+  return true;
+}
+
+
+/************************************************************/
+/** Record stream handling */
+
+bool PVRClientVDR::OpenRecordedStream(const CTVRecordingInfoTag &recinfo)
+{
+  if (!m_transceiver->IsOpen())
+  {
+    return false;
+  }
+
+  pthread_mutex_lock(&m_critSection);
+
+  /* Check if a another stream is opened, if yes first close them */
+
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    shutdown(m_socket_video, SD_BOTH);
+
+    if (m_iCurrentChannel < 0)
+      m_transceiver->AbortStreamRecording();
+    else
+      m_transceiver->AbortStreamLive();
+
+    closesocket(m_socket_video);
+  }
+
+  /* Get Stream socked from VDR Backend */
+  m_socket_video = m_transceiver->GetStreamRecording(recinfo.m_Index, &currentPlayingRecordBytes, &currentPlayingRecordFrames);
+
+  pthread_mutex_unlock(&m_critSection);
+
+  if (!currentPlayingRecordBytes)
+  {
+    return false;
+  }
+
+  /* If received socket is invalid, return */
+  if (m_socket_video == INVALID_SOCKET)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PCRClient-vdr: Couldn't get socket for recording");
+    return false;
+  }
+
+  m_iCurrentChannel               = -1;
+  currentPlayingRecordPosition    = 0;
+  return true;
+}
+
+void PVRClientVDR::CloseRecordedStream(void)
+{
+
+  if (!m_transceiver->IsOpen())
+  {
+    return;
+  }
+
+  pthread_mutex_lock(&m_critSection);
+
+  if (m_socket_video != INVALID_SOCKET)
+  {
+    m_transceiver->AbortStreamRecording();
+    closesocket(m_socket_video);
+  }
+
+  pthread_mutex_unlock(&m_critSection);
+
+  return;
+}
+
+int PVRClientVDR::ReadRecordedStream(BYTE* buf, int buf_size)
+{
+
+  vector<string> lines;
+  int            code;
+  char           buffer[1024];
+  unsigned int   amountReceived;
+
+  if (!m_transceiver->IsOpen() || m_socket_video == INVALID_SOCKET)
+    return 0;
+
+  if (currentPlayingRecordPosition + buf_size > currentPlayingRecordBytes)
+    return 0;
+
+  sprintf(buffer, "READ %llu %u", currentPlayingRecordPosition, buf_size);
+  if (!m_transceiver->SendCommand(buffer, code, lines))
+  {
+    return 0;
+  }
+
+  vector<string>::iterator it = lines.begin();
+  string& data(*it);
+
+  amountReceived = atol(data.c_str());
+
+  fd_set         set_r, set_e;
+
+  struct timeval tv;
+  int            res;
+
+  tv.tv_sec = 3;
+  tv.tv_usec = 0;
+
+  FD_ZERO(&set_r);
+  FD_ZERO(&set_e);
+  FD_SET(m_socket_video, &set_r);
+  FD_SET(m_socket_video, &set_e);
+  res = select(FD_SETSIZE, &set_r, NULL, &set_e, &tv);
+
+  if (res < 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::ReadRecordedStream - select failed");
+    return 0;
+  }
+
+  if (res == 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::ReadRecordedStream - timeout waiting for data");
+    return 0;
+  }
+
+  res = recv(m_socket_video, (char*)buf, (size_t)buf_size, 0);
+
+  if (res < 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::ReadRecordedStream - failed");
+    return 0;
+  }
+
+  if (res == 0)
+  {
+    m_xbmc->Log(m_xbmc->userData, LOG_ERROR, "PVRClientVDR::ReadRecordedStream - eof");
+    return 0;
+  }
+
+  currentPlayingRecordPosition += res;
+
+  return res;
+}
+
+__int64 PVRClientVDR::SeekRecordedStream(__int64 pos, int whence)
+{
+
+  if (!m_transceiver->IsOpen())
+  {
+    return 0;
+  }
+
+  __int64 nextPos = currentPlayingRecordPosition;
+
+  switch (whence)
+  {
+
+    case SEEK_SET:
+      nextPos = pos;
+      break;
+
+    case SEEK_CUR:
+      nextPos += pos;
+      break;
+
+    case SEEK_END:
+
+      if (currentPlayingRecordBytes)
+        nextPos = currentPlayingRecordBytes - pos;
+      else
+        return -1;
+
+      break;
+
+    case SEEK_POSSIBLE:
+      return 1;
+
+    default:
+      return -1;
+  }
+
+  if (nextPos > currentPlayingRecordBytes)
+  {
+    return 0;
+  }
+
+  currentPlayingRecordPosition = nextPos;
+
+  return currentPlayingRecordPosition;
+}
+
+__int64 PVRClientVDR::LengthRecordedStream(void)
+{
+  return currentPlayingRecordBytes;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr.h XBMC/xbmc/pvrclients/vdr/pvrclient-vdr.h
--- XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/pvrclient-vdr.h	2009-04-22 18:20:16.000000000 +0200
@@ -0,0 +1,134 @@
+#pragma once
+
+#ifndef __PVRCLIENT_VDR_H__
+#define __PVRCLIENT_VDR_H__
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+* for DESCRIPTION see 'PVRClient-vdr.cpp'
+*/
+
+#include "vtptransceiver.h"
+#include <string>
+#include <vector>
+
+/* Master defines for client control */
+#include "../xbmc/pvrclients/PVRClientTypes.h"
+
+
+class PVRClientVDR
+{
+public:
+  /* Class interface */
+  PVRClientVDR(PVRCallbacks *callback);
+  ~PVRClientVDR();
+
+  /* VTP Listening Thread */
+  static void* Process(void*);
+
+  /* Server handling */
+  PVR_ERROR GetProperties(PVR_SERVERPROPS *props);
+  PVR_ERROR SetUserSetting(const char *settingName, const void *settingValue);
+
+  PVR_ERROR Connect();
+  void Disconnect();
+  bool IsUp();
+
+  /* General handling */
+  const char* GetBackendName();
+  const char* GetBackendVersion();
+  PVR_ERROR GetDriveSpace(long long *total, long long *used);
+  PVR_ERROR GetClientTime(time_t *time, int *diff_from_gmt);
+
+  /* EPG handling */
+  PVR_ERROR GetEPGForChannel(unsigned int number, EPG_DATA &epg, time_t start = NULL, time_t end = NULL);
+  PVR_ERROR GetEPGNowInfo(unsigned int number, CTVEPGInfoTag *result);
+  PVR_ERROR GetEPGNextInfo(unsigned int number, CTVEPGInfoTag *result);
+
+  /* Channel handling */
+  int GetNumChannels(void);
+  PVR_ERROR GetChannelList(VECCHANNELS* results, bool radio = false);
+  PVR_ERROR GetChannelSettings(CTVChannelInfoTag *result);
+  PVR_ERROR UpdateChannelSettings(const CTVChannelInfoTag &chaninfo);
+  PVR_ERROR AddChannel(const CTVChannelInfoTag &info);
+  PVR_ERROR DeleteChannel(unsigned int number);
+  PVR_ERROR RenameChannel(unsigned int number, CStdString &newname);
+  PVR_ERROR MoveChannel(unsigned int number, unsigned int newnumber);
+
+  /* Record handling **/
+  int GetNumRecordings(void);
+  PVR_ERROR GetAllRecordings(VECRECORDINGS *results);
+  PVR_ERROR DeleteRecording(const CTVRecordingInfoTag &recinfo);
+  PVR_ERROR RenameRecording(const CTVRecordingInfoTag &recinfo, CStdString &newname);
+
+  /* Timer handling */
+  int GetNumTimers(void);
+  PVR_ERROR GetAllTimers(VECTVTIMERS *results);
+  PVR_ERROR GetTimerInfo(unsigned int timernumber, CTVTimerInfoTag &timerinfo);
+  PVR_ERROR AddTimer(const CTVTimerInfoTag &timerinfo);
+  PVR_ERROR DeleteTimer(const CTVTimerInfoTag &timerinfo, bool force = false);
+  PVR_ERROR RenameTimer(const CTVTimerInfoTag &timerinfo, CStdString &newname);
+  PVR_ERROR UpdateTimer(const CTVTimerInfoTag &timerinfo);
+
+  /* Live stream handling */
+  bool OpenLiveStream(unsigned int channel);
+  void CloseLiveStream();
+  int ReadLiveStream(BYTE* buf, int buf_size);
+  int GetCurrentClientChannel();
+  bool SwitchChannel(unsigned int channel);
+
+  /* Record stream handling */
+  bool OpenRecordedStream(const CTVRecordingInfoTag &recinfo);
+  void CloseRecordedStream(void);
+  int ReadRecordedStream(BYTE* buf, int buf_size);
+  __int64 SeekRecordedStream(__int64 pos, int whence=SEEK_SET);
+  __int64 LengthRecordedStream(void);
+
+protected:
+  static CVTPTransceiver *m_transceiver;
+  static SOCKET           m_socket_video;
+  static SOCKET           m_socket_data;
+
+private:
+  int                     m_iCurrentChannel;
+  static bool             m_bConnected;
+  bool                    m_bCharsetConv;
+  pthread_mutex_t         m_critSection;
+  pthread_t               m_thread;
+  CStdString              m_sHostname;
+  int                     m_iPort;
+  bool                    m_bRadioEnabled;
+  bool                    m_bOnlyFTA;
+  static bool             m_bStop;
+
+  static PVRCallbacks    *m_xbmc;
+
+  /* Following is for recordings streams */
+  uint64_t                currentPlayingRecordBytes;
+  uint32_t                currentPlayingRecordFrames;
+  uint64_t                currentPlayingRecordPosition;
+
+  void Close();
+};
+
+#endif // __PVRCLIENT_VDR_H__
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os.h XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os.h
--- XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os.h	2009-04-21 05:21:12.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#if defined(_WIN32) || defined(_WIN64)
+#define __WINDOWS__
+#endif
+
+#if defined(__WINDOWS__)
+#include "pvrclient-vdr_os_windows.h"
+#else
+#include "pvrclient-vdr_os_posix.h"
+#endif
+
+#if !defined(TRUE)
+#define TRUE 1
+#endif
+
+#if !defined(FALSE)
+#define FALSE 0
+#endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os_posix.h XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os_posix.h
--- XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os_posix.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os_posix.h	2009-04-21 05:21:19.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#define _FILE_OFFSET_BITS 64
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/timeb.h>
+#include <sys/wait.h>
+#include <sys/signal.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <pthread.h>
+
+typedef int bool_t;
+
+#define LIBTYPE
+#define sock_getlasterror errno
+#define sock_getlasterror_socktimeout (errno == EAGAIN)
+#define console_vprintf vprintf
+#define console_printf printf
+#define THREAD_FUNC_PREFIX void *
+
+static inline uint64_t getcurrenttime(void)
+{
+	struct timeval t;
+	gettimeofday(&t, NULL);
+	return ((uint64_t)t.tv_sec * 1000) + (t.tv_usec / 1000);
+}
+
+static inline int setsocktimeout(int s, int level, int optname, uint64_t timeout)
+{
+	struct timeval t;
+	t.tv_sec = timeout / 1000;
+	t.tv_usec = (timeout % 1000) * 1000;
+	return setsockopt(s, level, optname, (char *)&t, sizeof(t));
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os_windows.h XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os_windows.h
--- XBMC-unpatched/xbmc/pvrclients/vdr/pvrclient-vdr_os_windows.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/pvrclient-vdr_os_windows.h	2009-04-21 05:21:25.000000000 +0200
@@ -0,0 +1,153 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#define _WINSOCKAPI_
+#include <windows.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <wspiapi.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/timeb.h>
+
+#if defined(DLL_IMPORT)
+#define LIBTYPE __declspec( dllexport )
+#elif  defined(DLL_EXPORT)
+#define LIBTYPE __declspec( dllimport )
+#else
+#define LIBTYPE
+#endif
+
+typedef int bool_t;
+typedef signed __int8 int8_t;
+typedef signed __int16 int16_t;
+typedef signed __int32 int32_t;
+typedef signed __int64 int64_t;
+typedef unsigned __int8 uint8_t;
+typedef unsigned __int16 uint16_t;
+typedef unsigned __int32 uint32_t;
+typedef unsigned __int64 uint64_t;
+typedef HANDLE pthread_t;
+typedef HANDLE pthread_mutex_t;
+
+#define socklen_t int
+#define close closesocket
+#define sock_getlasterror WSAGetLastError()
+#define sock_getlasterror_socktimeout (WSAGetLastError() == WSAETIMEDOUT)
+#ifndef va_copy
+#define va_copy(x, y) x = y
+#endif
+#define atoll _atoi64
+#define strdup _strdup
+#define strcasecmp _stricmp
+#define snprintf _snprintf
+#define fseeko _fseeki64
+#define ftello _ftelli64
+#define THREAD_FUNC_PREFIX DWORD WINAPI
+#define SIGPIPE SIGABRT
+
+static inline int usleep(unsigned int us)
+{
+	Sleep((us)/1000);
+	return 0;
+}
+
+static inline int sleep(unsigned int sec)
+{
+	Sleep((sec)*1000);
+	return 0;
+}
+
+static inline uint64_t getcurrenttime(void)
+{
+	struct timeb tb;
+	ftime(&tb);
+	return ((uint64_t)tb.time * 1000) + tb.millitm;
+}
+
+static inline int setsocktimeout(int s, int level, int optname, uint64_t timeout)
+{
+	int t = (int)timeout;
+	return setsockopt(s, level, optname, (char *)&t, sizeof(t));
+}
+
+static inline int pthread_create(pthread_t *tid, void *attr, LPTHREAD_START_ROUTINE start, void *arg)
+{
+	*tid = CreateThread(NULL, 0, start, arg, 0, NULL);
+	if (!*tid) {
+		return (int)GetLastError();
+	}
+	return 0;
+}
+
+static inline int pthread_join(pthread_t tid, void **value_ptr)
+{
+	while (1) {
+		DWORD ExitCode = 0;
+		if (!GetExitCodeThread(tid, &ExitCode)) {
+			return (int)GetLastError();
+		}
+		if (ExitCode != STILL_ACTIVE) {
+			return 0;
+		}
+	}
+}
+
+static inline void pthread_mutex_init(pthread_mutex_t *mutex, void *attr)
+{
+	*mutex = CreateMutex(NULL, FALSE, NULL);
+}
+
+static inline void pthread_mutex_lock(pthread_mutex_t *mutex)
+{
+	WaitForSingleObject(*mutex, INFINITE);
+}
+
+static inline void pthread_mutex_unlock(pthread_mutex_t *mutex)
+{
+	ReleaseMutex(*mutex);
+}
+
+/*
+ * The console output format should be set to UTF-8, however in XP and Vista this breaks batch file processing.
+ * Attempting to restore on exit fails to restore if the program is terminated by the user.
+ * Solution - set the output format each printf.
+ */
+static inline void console_vprintf(const char *fmt, va_list ap)
+{
+	UINT cp = GetConsoleOutputCP();
+	SetConsoleOutputCP(CP_UTF8);
+	vprintf(fmt, ap);
+	SetConsoleOutputCP(cp);
+}
+
+static inline void console_printf(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	console_vprintf(fmt, ap);
+	va_end(ap);
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/vtptransceiver.cpp XBMC/xbmc/pvrclients/vdr/vtptransceiver.cpp
--- XBMC-unpatched/xbmc/pvrclients/vdr/vtptransceiver.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/vtptransceiver.cpp	2009-04-22 18:40:42.000000000 +0200
@@ -0,0 +1,561 @@
+#include "pvrclient-vdr_os.h"
+#include "vtptransceiver.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include <string>
+#include <vector>
+#ifdef HAS_XBOX_HARDWARE
+#include <xtl.h>
+#else
+#ifdef _LINUX
+#include "../xbmc/linux/PlatformInclude.h"
+#ifndef __APPLE__
+#include <sys/sysinfo.h>
+#endif
+#else
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#include <windows.h>
+#endif
+#include "../xbmc/utils/log.h"
+#include "../xbmc/pvrclients/PVRClientTypes.h"
+#include <sys/stat.h>
+#include <errno.h>
+#endif
+
+using namespace std;
+
+//#define DEBUG
+
+CVTPTransceiver::CVTPTransceiver()
+  : m_socket(INVALID_SOCKET)
+{}
+
+CVTPTransceiver::~CVTPTransceiver()
+{
+  Close();
+  Quit();
+}
+
+bool CVTPTransceiver::OpenStreamSocket(SOCKET& sock, struct sockaddr_in& address2)
+{
+  struct sockaddr_in address(address2);
+
+  sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+
+  if(sock == INVALID_SOCKET)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::OpenStreamSocket - invalid socket");*/
+    return false;
+  }
+
+  address.sin_addr.s_addr = INADDR_ANY;
+  address.sin_port        = 0;
+
+  if(bind(sock, (struct sockaddr*) &address, sizeof(address)) == SOCKET_ERROR)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::OpenStreamSocket - bind failed");*/
+    return false;
+  }
+
+  socklen_t len = sizeof(address);
+  if(getsockname(sock, (struct sockaddr*) &address, &len) == SOCKET_ERROR)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::OpenStreamSocket - bind failed");*/
+    return false;
+  }
+
+  if(listen(sock, 1) == SOCKET_ERROR)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::OpenStreamSocket - listen failed");*/
+    return false;
+  }
+
+  address2.sin_port = address.sin_port;
+
+  /*Log::Log(LOG_DEBUG, "CVTPTransceiver::OpenStreamSocket - listening on %s:%d", inet_ntoa(address.sin_addr), address.sin_port);*/
+  return true;
+}
+
+bool CVTPTransceiver::AcceptStreamSocket(SOCKET& sock2)
+{
+  SOCKET sock;
+  sock = accept(sock2, NULL, NULL);
+  if(sock == INVALID_SOCKET)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPStream::Accept - failed to accept incomming connection");*/
+    return false;
+  }
+
+  closesocket(sock2);
+  sock2 = sock;
+  return true;
+}
+
+void CVTPTransceiver::Close()
+{
+  if(m_socket != INVALID_SOCKET)
+    closesocket(m_socket);
+}
+
+bool CVTPTransceiver::Open(const string &host, int port)
+{
+  m_socket = socket(AF_INET, SOCK_STREAM, 0);
+
+  if(m_socket == INVALID_SOCKET)
+    return false;
+
+  struct sockaddr_in sa;
+  struct hostent    *hp;
+
+  hp = gethostbyname(host.c_str());
+  if (hp == NULL)
+  {
+    //log Failed to resolve hostname
+    Close();
+    return false;
+  }
+
+  memset(&sa, 0, sizeof(sa));
+  memcpy(&sa.sin_addr, hp->h_addr_list[0], hp->h_length);
+
+  sa.sin_family = hp->h_addrtype;
+  sa.sin_port = htons((u_short)port);
+  /*sa.sin_port = port;*/
+
+  if (connect(m_socket, (struct sockaddr *)&sa, sizeof(sa)) < 0)
+  {
+    //log failed to connect to server
+    Close();
+    return false;
+  }
+
+
+  // VTP Server will send a greeting
+  string line;
+  int    code;
+  ReadResponse(code, line);
+
+  /*CLog::Log(LOGERROR, "CVTPTransceiver::Open - server greeting: %s", line.c_str());*/
+
+  return true;
+}
+
+bool CVTPTransceiver::IsOpen()
+{
+  return !(m_socket == INVALID_SOCKET);
+}
+
+bool CVTPTransceiver::ReadResponse(int &code, string &line)
+{
+  vector<string> lines;
+  if(ReadResponse(code, lines))
+  {
+    line = lines[lines.size()-1];
+    return true;
+  }
+  return false;
+}
+
+bool CVTPTransceiver::ReadResponse(int &code, vector<string> &lines)
+{
+  fd_set         set_r, set_e;
+  timeval        timeout;
+  int            result;
+  int            retries = 5;
+  char           buffer[2048];
+  char           cont = 0;
+  string         line;
+  size_t         pos1 = 0, pos2 = 0, pos3 = 0;
+
+  while(true)
+  {
+    while( (pos1 = line.find("\r\n", pos3)) != std::string::npos)
+    {
+      if(sscanf(line.c_str(), "%d%c", &code, &cont) != 2)
+      {
+        /*Log::Log(LOG_DEBUG, "CVTPTransceiver::ReadResponse - unknown line format: %s", line.c_str());*/
+        line.erase(0, pos1 + 2);
+        continue;
+      }
+
+      pos2 = line.find(cont);
+
+      lines.push_back(line.substr(pos2+1, pos1-pos2-1));
+
+      line.erase(0, pos1 + 2);
+      pos3 = 0;
+    }
+
+    // we only need to recheck 1 byte
+    if(line.size() > 0)
+      pos3 = line.size() - 1;
+    else
+      pos3 = 0;
+
+    if(cont == ' ')
+      break;
+
+    //TODO set 10 seconds timeout value??
+    timeout.tv_sec  = 10;
+    timeout.tv_usec = 0;
+
+    // fill with new data
+    FD_ZERO(&set_r);
+    FD_ZERO(&set_e);
+    FD_SET(m_socket, &set_r);
+    FD_SET(m_socket, &set_e);
+    result = select(FD_SETSIZE, &set_r, NULL, &set_e, &timeout);
+    if(result < 0)
+    {
+      /*Log::Log(LOG_DEBUG, "CVTPTransceiver::ReadResponse - select failed");*/
+      m_socket = INVALID_SOCKET;
+      return false;
+    }
+
+    if(result == 0)
+    {
+      /*Log::Log(LOG_DEBUG, "CVTPTransceiver::ReadResponse - timeout waiting for response, retrying...");*/
+      if (retries != 0) {
+          retries--;
+      continue;
+    }
+      else {
+          m_socket = INVALID_SOCKET;
+          return false;
+      }
+    }
+
+    result = recv(m_socket, buffer, sizeof(buffer) - 1, 0);
+    if(result < 0)
+    {
+      /*Log::Log(LOG_DEBUG, "CVTPTransceiver::ReadResponse - recv failed");*/
+      m_socket = INVALID_SOCKET;
+      return false;
+    }
+    buffer[result] = 0;
+
+    line.append(buffer);
+  }
+
+  return true;
+}
+
+bool CVTPTransceiver::SendCommand(const string &command)
+{
+  fd_set set_w, set_e;
+  struct timeval tv;
+  int  result;
+  char buffer[1024];
+  int  len;
+
+  len = sprintf(buffer, "%s\r\n", command.c_str());
+
+  // fill with new data
+  tv.tv_sec  = 0;
+  tv.tv_usec = 0;
+
+  FD_ZERO(&set_w);
+  FD_ZERO(&set_e);
+  FD_SET(m_socket, &set_w);
+  FD_SET(m_socket, &set_e);
+  result = select(FD_SETSIZE, &set_w, NULL, &set_e, &tv);
+  if(result < 0)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::SendCommand - select failed");*/
+    m_socket = INVALID_SOCKET;
+    return false;
+  }
+  if (FD_ISSET(m_socket, &set_w))
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::SendCommand - failed to send data");*/
+    m_socket = INVALID_SOCKET;
+    return false;
+  }
+  if(send(m_socket, buffer, len, 0) != len)
+  {
+    /*Log::Log(LOG_ERROR, "CVTPTransceiver::SendCommand - failed to send data");*/
+    m_socket = INVALID_SOCKET;
+    return false;
+  }
+  return true;
+}
+
+bool CVTPTransceiver::SendCommand(const string &command, int &code, string line)
+{
+  vector<string> lines;
+  if(SendCommand(command, code, lines))
+  {
+    line = lines[lines.size()-1];
+    return true;
+  }
+  return false;
+}
+
+bool CVTPTransceiver::SendCommand(const string &command, int &code, vector<string> &lines)
+{
+  if(!SendCommand(command))
+    return false;
+
+  if(!ReadResponse(code, lines))
+    return false;
+
+  if(code < 200 || code > 299)
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::SendCommand - Failed with code: %d (%s)", code, lines[lines.size()-1].c_str());
+    return false;
+  }
+
+  return true;
+}
+
+SOCKET CVTPTransceiver::GetStreamLive(int channel)
+{
+
+  sockaddr_in address;
+  SOCKET      sock;
+  socklen_t   len = sizeof(address);
+  char        buffer[1024];
+  string      result;
+  int         code;
+
+  if(!SendCommand("CAPS TS", code, result))
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::GetStreamLive - server is unable to provide mpeg-ts");
+    return INVALID_SOCKET;
+  }
+
+  sprintf(buffer, "PROV %d %d", 100, channel);
+  if(!SendCommand(buffer, code, result))
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::GetStreamLive - server is unable to provide channel");
+    return INVALID_SOCKET;
+  }
+
+  sprintf(buffer, "TUNE %d", channel);
+  if(!SendCommand(buffer, code, result))
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::GetStreamLive - server is unable to tune to said channel");
+    return INVALID_SOCKET;
+  }
+
+  if(getsockname(m_socket, (struct sockaddr*) &address, &len) == SOCKET_ERROR)
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::GetStreamLive - getsockname failed");
+    return INVALID_SOCKET;
+  }
+
+  //Log::Log(LOG_DEBUG, "CVTPTransceiver::GetStreamLive - local address %s:%d", inet_ntoa(address.sin_addr), ntohs(address.sin_port) );
+
+  if(!OpenStreamSocket(sock, address))
+    return INVALID_SOCKET;
+
+  int port = ntohs(address.sin_port);
+  int addr = ntohl(address.sin_addr.s_addr);
+
+  sprintf(buffer, "PORT 0 %d,%d,%d,%d,%d,%d"
+                , (addr & 0xFF000000)>>24
+                , (addr & 0x00FF0000)>>16
+                , (addr & 0x0000FF00)>>8
+                , (addr & 0x000000FF)>>0
+                , (port & 0xFF00)>>8
+                , (port & 0x00FF)>>0);
+
+  if(!SendCommand(buffer, code, result))
+    return NULL;
+
+  if(!AcceptStreamSocket(sock))
+  {
+    closesocket(sock);
+    return INVALID_SOCKET;
+  }
+  return sock;
+}
+
+SOCKET CVTPTransceiver::GetStreamRecording(int recording, uint64_t *size, uint32_t *frames)
+{
+    sockaddr_in address;
+    SOCKET      sock;
+    socklen_t   len = sizeof(address);
+    char        buffer[1024];
+    string      result;
+    int         code;
+    vector<string> lines;
+
+    sprintf(buffer, "PLAY %d", recording);
+    if (!SendCommand(buffer, code, lines))
+    {
+      return INVALID_SOCKET;
+    }
+
+    vector<string>::iterator it = lines.begin();
+    string& data(*it);
+
+    sscanf(data.c_str(), "%I64u", size);
+    data.erase(0,data.find(" ", 0)+1);
+    *frames = atol(data.c_str());
+
+    if(getsockname(m_socket, (struct sockaddr*) &address, &len) == SOCKET_ERROR)
+    {
+      //Log::Log(LOG_ERROR, "CVTPTransceiver::GetStreamRecording - getsockname failed");
+      return INVALID_SOCKET;
+    }
+
+    //Log::Log(LOG_DEBUG, "CVTPTransceiver::GetStreamRecording - local address %s:%d", inet_ntoa(address.sin_addr), ntohs(address.sin_port) );
+
+    if(!OpenStreamSocket(sock, address))
+      return INVALID_SOCKET;
+
+    int port = ntohs(address.sin_port);
+    int addr = ntohl(address.sin_addr.s_addr);
+
+    sprintf(buffer, "PORT 1 %d,%d,%d,%d,%d,%d"
+                  , (addr & 0xFF000000)>>24
+                  , (addr & 0x00FF0000)>>16
+                  , (addr & 0x0000FF00)>>8
+                  , (addr & 0x000000FF)>>0
+                  , (port & 0xFF00)>>8
+                  , (port & 0x00FF)>>0);
+
+    if(!SendCommand(buffer, code, result))
+      return INVALID_SOCKET;
+
+
+    if(!AcceptStreamSocket(sock))
+    {
+      closesocket(sock);
+      return INVALID_SOCKET;
+    }
+    return sock;
+}
+
+SOCKET CVTPTransceiver::GetStreamData()
+{
+  sockaddr_in address;
+  SOCKET      sock;
+  socklen_t   len = sizeof(address);
+  char        buffer[1024];
+  string      result;
+  int         code;
+
+  if(getsockname(m_socket, (struct sockaddr*) &address, &len) == SOCKET_ERROR)
+  {
+ //   CLog::Log(LOGERROR, "VTPTransceiver::GetStreamData - getsockname failed");
+    return INVALID_SOCKET;
+  }
+
+//  CLog::Log(LOGDEBUG, "VTPTransceiver::GetStreamData - local address %s:%d", inet_ntoa(address.sin_addr), ntohs(address.sin_port) );
+
+  if(!OpenStreamSocket(sock, address))
+    return INVALID_SOCKET;
+
+  int port = ntohs(address.sin_port);
+  int addr = ntohl(address.sin_addr.s_addr);
+
+  sprintf(buffer, "PORT 3 %d,%d,%d,%d,%d,%d"
+                , (addr & 0xFF000000)>>24
+                , (addr & 0x00FF0000)>>16
+                , (addr & 0x0000FF00)>>8
+                , (addr & 0x000000FF)>>0
+                , (port & 0xFF00)>>8
+                , (port & 0x00FF)>>0);
+
+  if(!SendCommand(buffer, code, result))
+    return INVALID_SOCKET;
+
+  if(!AcceptStreamSocket(sock))
+  {
+    closesocket(sock);
+    return INVALID_SOCKET;
+  }
+  return sock;
+}
+
+void CVTPTransceiver::AbortStreamLive()
+{
+  if(m_socket == INVALID_SOCKET)
+    return;
+
+  string line;
+  int    code;
+  if(!SendCommand("ABRT 0", code, line))
+    return;
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::AbortStreamLive - failed");
+}
+
+void CVTPTransceiver::AbortStreamRecording()
+{
+  if(m_socket == INVALID_SOCKET)
+    return;
+
+  string line;
+  int    code;
+  if(!SendCommand("ABRT 1", code, line))
+    return;
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::AbortStreamRecording - failed");
+}
+
+void CVTPTransceiver::AbortStreamData()
+{
+  if(m_socket == INVALID_SOCKET)
+    return;
+
+  string line;
+  int    code;
+  if(!SendCommand("ABRT 3", code, line))
+    return;
+    //CLog::Log(LOGERROR, "VTPTransceiver::AbortStreamData - failed");
+}
+
+bool CVTPTransceiver::CanStreamLive(int channel)
+{
+  if(m_socket == INVALID_SOCKET)
+    return false;
+
+  char   buffer[1024];
+  string line;
+  int    code;
+
+  sprintf(buffer, "PROV %d %d", -1, channel);
+  if(!SendCommand(buffer, code, line))
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::CanStreamLive - server is unable to provide channel %d", channel);
+    return false;
+  }
+  return true;
+}
+
+bool CVTPTransceiver::SuspendServer()
+{
+  vector<string> lines;
+  int            code;
+  bool           ret;
+
+  ret = SendCommand("SUSP", code, lines);
+
+  if (!ret || code != 220)
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::SuspendServer: Couldn't suspend server");
+    return false;
+  }
+  return true;
+}
+
+bool CVTPTransceiver::Quit()
+{
+  vector<string> lines;
+  int            code;
+  bool           ret;
+
+  ret = SendCommand("QUIT", code, lines);
+
+  if (!ret || code != 221)
+  {
+    //Log::Log(LOG_ERROR, "CVTPTransceiver::Quit: Couldn't quit command connection");
+    return false;
+  }
+  return true;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/vtptransceiver.h XBMC/xbmc/pvrclients/vdr/vtptransceiver.h
--- XBMC-unpatched/xbmc/pvrclients/vdr/vtptransceiver.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/vtptransceiver.h	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,55 @@
+#pragma once
+
+#ifndef VTPSESSION_H
+#define VTPSESSION_H
+
+#include <string>
+#include <vector>
+
+#ifdef HAVE_WINSOCK2
+#include <winsock2.h>
+typedef unsigned long long uint64_t;
+typedef unsigned int uint32_t;
+#else
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <netdb.h>
+typedef int SOCKET;
+#define SOCKET_ERROR   (-1)
+#endif
+
+class CVTPTransceiver
+{
+public:
+  CVTPTransceiver();
+  ~CVTPTransceiver();
+  bool Open(const std::string &host, int port);
+  void Close();
+
+  bool ReadResponse(int &code, std::string &line);
+  bool ReadResponse(int &code, std::vector<std::string> &lines);
+
+  bool SendCommand(const std::string &command);
+  bool SendCommand(const std::string &command, int &code, std::string line);
+  bool SendCommand(const std::string &command, int &code, std::vector<std::string> &lines);
+
+  SOCKET GetStreamLive(int channel);
+  SOCKET GetStreamRecording(int recording, uint64_t *size, uint32_t *frames);
+  SOCKET GetStreamData();
+  void   AbortStreamLive();
+  void   AbortStreamRecording();
+  void	 AbortStreamData();
+  bool   CanStreamLive(int channel);
+  bool   IsOpen();
+  bool   SuspendServer();
+  bool   Quit();
+
+private:
+  bool   OpenStreamSocket(SOCKET& socket, struct sockaddr_in& address);
+  bool   AcceptStreamSocket(SOCKET& socket);
+
+  SOCKET m_socket;
+};
+
+#endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/XBMC_VDR.sln XBMC/xbmc/pvrclients/vdr/XBMC_VDR.sln
--- XBMC-unpatched/xbmc/pvrclients/vdr/XBMC_VDR.sln	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/XBMC_VDR.sln	2009-04-18 12:31:20.000000000 +0200
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XBMC_VDR", "XBMC_VDR.vcproj", "{D450FE9A-CE56-4496-B4AB-379094E642F2}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug.ActiveCfg = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Debug.Build.0 = Debug|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release.ActiveCfg = Release|Win32
+		{D450FE9A-CE56-4496-B4AB-379094E642F2}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/pvrclients/vdr/XBMC_VDR.vcproj XBMC/xbmc/pvrclients/vdr/XBMC_VDR.vcproj
--- XBMC-unpatched/xbmc/pvrclients/vdr/XBMC_VDR.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/pvrclients/vdr/XBMC_VDR.vcproj	2009-04-22 18:36:28.000000000 +0200
@@ -0,0 +1,236 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9,00"
+	Name="XBMC_VDR"
+	ProjectGUID="{D450FE9A-CE56-4496-B4AB-379094E642F2}"
+	RootNamespace="XBMC_VDR"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="&quot;..\..\..\xbmc\lib\libSDL-WIN32\include&quot;;..\..\..\xbmc\Win32;..\..\..\xbmc\;..\..\..\guilib\freetype2\include;..\..\..\xbmc\lib\boost;..\..\..\guilib;..\..\..\xbmc\utils"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;VTP_STANDALONE;HAVE_WINSOCK2;VDR_EXPORTS;_WIN32PC"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib"
+				OutputFile="$(OutDir)/default.pvr"
+				LinkIncremental="2"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="$(OutDir)/XBMC_VDR.pdb"
+				SubSystem="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				ImportLibrary="$(OutDir)/XBMC_VDR.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				Description="Copying Library to XBMC"
+				CommandLine="copy $(TargetPath) d:\dev\svn.xbmc\unified-pvr\XBMC\pvrclients\XBMC_VDR_win32.pvr"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories=""
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;HAS_SDL_OPENGL;HAS_SDL;_USRDLL;XBMC_VDR_EXPORTS;_WIN32PC"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib"
+				OutputFile="$(OutDir)/XBMC_VDR_win32.pvr"
+				LinkIncremental="1"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				ImportLibrary="$(OutDir)/XBMC_VDR.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\..\pvrclients\vdr\client.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\pvrclient-vdr.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\vtptransceiver.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\pvrclient-vdr.h"
+				>
+			</File>
+			<File
+				RelativePath=".\pvrclient-vdr_os.h"
+				>
+			</File>
+			<File
+				RelativePath=".\pvrclient-vdr_os_posix.h"
+				>
+			</File>
+			<File
+				RelativePath=".\pvrclient-vdr_os_windows.h"
+				>
+			</File>
+			<File
+				RelativePath=".\vtptransceiver.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/PVRManager.cpp XBMC/xbmc/PVRManager.cpp
--- XBMC-unpatched/xbmc/PVRManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/PVRManager.cpp	2009-04-16 19:38:53.000000000 +0200
@@ -0,0 +1,3177 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "Application.h"
+#include "GUISettings.h"
+#include "Util.h"
+#include "GUIWindowTV.h"
+#include "GUIWindowManager.h"
+#include "utils/GUIInfoManager.h"
+#include "settings/AddonSettings.h"
+#include "PVRManager.h"
+#include "pvrclients/PVRClientFactory.h"
+#include "MusicInfoTag.h"
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+
+/* GUI Messages includes */
+#include "GUIDialogOK.h"
+#include "GUIDialogYesNo.h"
+
+
+using namespace std;
+using namespace MUSIC_INFO;
+using namespace XFILE;
+using namespace ADDON;
+
+
+CPVRManager* CPVRManager::m_instance    = NULL;
+bool CPVRManager::m_isPlayingTV         = false;
+bool CPVRManager::m_isPlayingRadio      = false;
+bool CPVRManager::m_isPlayingRecording  = false;
+bool CPVRManager::m_hasRecordings       = false;
+bool CPVRManager::m_isRecording         = false;
+bool CPVRManager::m_hasTimers           = false;
+
+
+/************************************************************/
+/** Class handling */
+
+CPVRManager::CPVRManager()
+{
+  /* Initialize Member variables */
+  m_bConnectionLost       = false;
+  m_CurrentTVChannel      = 1;
+  m_CurrentRadioChannel   = 1;
+  m_CurrentChannelID      = -1;
+  m_HiddenChannels        = 0;
+  m_CurrentGroupID        = -1;
+  m_synchronized     	  = false;
+  m_client                = NULL;
+
+  InitializeCriticalSection(&m_critSection);
+  CLog::Log(LOGDEBUG,"PVR: created");
+}
+
+CPVRManager::~CPVRManager()
+{
+  DeleteCriticalSection(&m_critSection);
+  CLog::Log(LOGDEBUG,"PVR: destroyed");
+}
+
+void CPVRManager::Start()
+{
+  /* If a client is already started, close it first */
+  if (m_client)
+    delete m_client;
+
+  /* Check if TV is enabled under Settings->Video->TV->Enable */
+  if (!g_guiSettings.GetBool("pvrmanager.enabled"))
+    return;
+
+  CLog::Log(LOGNOTICE, "PVR: PVRManager starting");
+
+  /* Discover and load chosen client */
+  m_client = LoadClient();
+  if (!m_client)
+  {
+    CLog::Log(LOGERROR, "PVR: couldn't load client");
+    return;
+  }
+
+  /* now that client have been initialized, we check connectivity */
+  if (!ConnectClient())
+  {
+    CLog::Log(LOGERROR, "PVR: couldn't connect client");
+    return;
+  }
+
+  /* Add client to TV-Database to identify different backend servers,
+   * if client is already added his id is given.
+   * Backend name have the following format: "NAME-IP:PORT", as example "VDR-192.168.0.120:2004"
+   */
+  m_database.Open();
+  CStdString ClientName;
+  ClientName.Format("%s-%s:%u", m_clientProps.Name, m_clientProps.Hostname, m_clientProps.Port);
+  m_currentClientID = m_database.AddClient(ClientName);
+
+  /* Get channels if present from Database, otherwise load it from client
+   * and add it to database
+   */
+  if (m_database.GetNumChannels(m_currentClientID) > 0)
+  {
+    m_database.GetChannelList(m_currentClientID, &m_channels_tv, false);
+    m_database.GetChannelList(m_currentClientID, &m_channels_radio, true);
+    m_HiddenChannels = m_database.GetNumHiddenChannels(m_currentClientID);
+  }
+  else
+  {
+    CLog::Log(LOGNOTICE, "PVR: TV Database holds no channels, reading channels from client");
+
+    m_client->GetChannelList(m_channels_tv, false);
+    m_client->GetChannelList(m_channels_radio, true);
+
+    /* Fill Channels to Database */
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+      m_channels_tv[i].m_strStatus = "livetv";
+      m_channels_tv[i].m_iIdChannel = m_database.AddChannel(m_currentClientID, m_channels_tv[i]);
+    }
+
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+      m_channels_radio[i].m_strStatus = "livetv";
+      m_channels_radio[i].m_iIdChannel = m_database.AddChannel(m_currentClientID, m_channels_radio[i]);
+    }
+
+    m_database.Compress(true);
+  }
+
+  /* Get Channelgroups */
+  m_database.GetGroupList(m_currentClientID, &m_channel_group);
+
+  /* Get Recordings from Backend */
+  if (m_clientProps.SupportRecordings)
+    GetRecordings();
+
+  /* Get Timers from Backend */
+  if (m_clientProps.SupportTimers)
+    GetTimers();
+
+  SyncInfo();
+  m_database.Close();
+
+  Create();
+  SetName("PVRManager Updater");
+  SetPriority(-15);
+
+  CLog::Log(LOGNOTICE, "PVR: PVRManager started. Client '%s' loaded with Id: %i", ClientName.c_str(), m_currentClientID);
+  return;
+}
+
+void CPVRManager::Stop()
+{
+  CLog::Log(LOGNOTICE, "PVR: PVRManager stoping");
+  StopThread();
+
+  if (m_client)
+  {
+    DisconnectClient();
+    delete m_client;
+    m_client = NULL;
+  }
+
+  m_bConnectionLost       = false;
+  m_CurrentTVChannel      = 1;
+  m_CurrentRadioChannel   = 1;
+  m_CurrentChannelID      = -1;
+  m_HiddenChannels        = 0;
+  m_CurrentGroupID        = -1;
+  m_synchronized     	  = false;
+
+  return;
+}
+
+IPVRClient* CPVRManager::LoadClient()
+{
+  VECADDONS *addons;
+
+  /* call update */
+  addons = g_settings.GetAddonsFromType(ADDON_PVRDLL);
+
+  if (addons == NULL || addons->empty())
+    return false;
+
+  CPVRClientFactory factory;
+  for (unsigned i=0; i<addons->size(); i++)
+  {
+    CAddon &clientAddon = addons->at(i);
+
+    if (clientAddon.m_disabled) // ignore disabled addons
+      continue;
+
+    IPVRClient *client = NULL;
+    client = factory.LoadPVRClient((clientAddon.m_strPath + clientAddon.m_strLibName), i, this);
+    if (client)
+    {
+      /* Transmit current unified user settings to the PVR Addon */
+      CAddonSettings settings;
+      settings.Load(clientAddon.m_strPath);
+
+      TiXmlElement *setting = settings.GetAddonRoot()->FirstChildElement("setting");
+      while (setting)
+      {
+        const char *type = setting->Attribute("type");
+        const char *id = setting->Attribute("id");
+        const char *value = settings.Get(id).c_str();
+
+        if (type)
+        {
+          if (strcmpi(type, "text") == 0 || strcmpi(type, "ipaddress") == 0)
+          {
+            client->SetUserSetting(id, value);
+          }
+          else if (strcmpi(type, "integer") == 0)
+          {
+            int tmp = atoi(settings.Get(id));
+            client->SetUserSetting(id, (int*) &tmp);
+          }
+          if (strcmpi(type, "bool") == 0)
+          {
+            bool tmp = settings.Get(id) == "true" ? true : false;
+            client->SetUserSetting(id, (bool*) &tmp);
+          }
+        }
+        setting = setting->NextSiblingElement("setting");
+      }
+
+      /* Get Standart client settings and features */
+      if (client->GetProperties(&m_clientProps) != PVR_ERROR_NO_ERROR)
+      {
+        delete client;
+        client = NULL;
+        continue;
+      }
+
+      /* Currently only one backend is supported, break here*/
+      return client;
+    }
+  }
+
+  return NULL;
+}
+
+void CPVRManager::Process()
+{
+  GetChannels();
+  m_synchronized = true;
+
+  /* create EPG data structures */
+  if (m_clientProps.SupportEPG)
+  {
+    time_t start;
+    time_t end;
+    CDateTime::GetCurrentDateTime().GetAsTime(start);
+    CDateTime::GetCurrentDateTime().GetAsTime(end);
+	start -= g_guiSettings.GetInt("pvrmenu.lingertime")*60;
+    end   += g_guiSettings.GetInt("pvrmenu.daystodisplay")*24*60*60;
+
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+	  EnterCriticalSection(&m_critSection);
+      m_client->GetEPGForChannel(m_channels_tv[i].m_iClientNum, m_channels_tv[i].m_EPG, start, end);
+	  LeaveCriticalSection(&m_critSection);
+    }
+
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+	  EnterCriticalSection(&m_critSection);
+      m_client->GetEPGForChannel(m_channels_radio[i].m_iClientNum, m_channels_radio[i].m_EPG, start, end);
+	  LeaveCriticalSection(&m_critSection);
+    }
+  }
+
+  CDateTime lastTVUpdate    = NULL;//CDateTime::GetCurrentDateTime();
+  CDateTime lastRadioUpdate = CDateTime::GetCurrentDateTime();
+  CDateTime lastScan        = CDateTime::GetCurrentDateTime();
+
+  while (!m_bStop)
+  {
+    if (m_clientProps.SupportEPG)
+    {
+      if (lastTVUpdate+CDateTimeSpan(0, g_guiSettings.GetInt("pvrepg.epgupdate") / 60, g_guiSettings.GetInt("pvrepg.epgupdate") % 60, 0) < CDateTime::GetCurrentDateTime())
+      {
+        lastTVUpdate = CDateTime::GetCurrentDateTime();
+
+        if (m_channels_tv.size() > 0)
+        {
+          time_t end;
+          CDateTime::GetCurrentDateTime().GetAsTime(end);
+		  end += (time_t)g_guiSettings.GetInt("pvrmenu.daystodisplay")*24*60*60;
+
+          for (unsigned int i = 0; i < m_channels_tv.size(); ++i)
+          {
+		    CTVEPGInfoTag epgentry;
+			time_t lastEntry = NULL;
+
+			m_channels_tv[i].GetEPGLastEntry(&epgentry);
+			if (epgentry.m_endTime.IsValid())
+			{
+			  epgentry.m_endTime.GetAsTime(lastEntry);
+              m_channels_tv[i].CleanupEPG();
+			}
+		    EnterCriticalSection(&m_critSection);
+		    m_client->GetEPGForChannel(m_channels_tv[i].m_iClientNum, m_channels_tv[i].m_EPG, lastEntry, end);
+		    LeaveCriticalSection(&m_critSection);
+          }
+        }
+      }
+      if (m_clientProps.SupportRadio)
+      {
+        if (lastRadioUpdate+CDateTimeSpan(0, g_guiSettings.GetInt("pvrepg.epgupdate") / 60, g_guiSettings.GetInt("pvrepg.epgupdate") % 60+5, 0) < CDateTime::GetCurrentDateTime())
+        {
+          lastRadioUpdate = CDateTime::GetCurrentDateTime();
+
+          if (m_channels_radio.size() > 0)
+          {
+            time_t end;
+            CDateTime::GetCurrentDateTime().GetAsTime(end);
+		    end += (time_t)g_guiSettings.GetInt("pvrmenu.daystodisplay")*24*60*60;
+
+            for (unsigned int i = 0; i < m_channels_radio.size(); ++i)
+            {
+		      CTVEPGInfoTag epgentry;
+			  time_t lastEntry = NULL;
+
+			  m_channels_radio[i].GetEPGLastEntry(&epgentry);
+			  if (epgentry.m_endTime.IsValid())
+			  {
+			    epgentry.m_endTime.GetAsTime(lastEntry);
+                m_channels_radio[i].CleanupEPG();
+			  }
+		      EnterCriticalSection(&m_critSection);
+		      m_client->GetEPGForChannel(m_channels_radio[i].m_iClientNum, m_channels_radio[i].m_EPG, lastEntry, end);
+		      LeaveCriticalSection(&m_critSection);
+            }
+		  }
+		}
+	  }
+	}
+    /* Wait 30 seconds until start next change check */
+    Sleep(30000);
+  }
+}
+
+
+/************************************************************/
+/** Manager access */
+
+CPVRManager* CPVRManager::GetInstance()
+{
+  if (!m_instance)
+    m_instance = new CPVRManager();
+
+  return m_instance;
+}
+
+void CPVRManager::ReleaseInstance()
+{
+  m_instance = NULL; /// check is this enough?
+}
+
+void CPVRManager::RemoveInstance()
+{
+  if (m_instance)
+  {
+    delete m_instance;
+    m_instance = NULL;
+  }
+}
+
+
+/************************************************************/
+/** Server access */
+
+bool CPVRManager::ConnectClient()
+{
+  /* signal client to connect to backend */
+  PVR_ERROR err = m_client->Connect();
+  if (err == PVR_ERROR_NO_ERROR)
+    return true;
+  else if (err == PVR_ERROR_SERVER_WRONG_VERSION)
+    CGUIDialogOK::ShowAndGetInput(18100, 18091, 18106, 18092);
+  else
+    CGUIDialogOK::ShowAndGetInput(18100, 18091, 0, 18092);
+
+  CLog::Log(LOGERROR, "PVR: Could't connect client to backend server");
+  Stop();
+  return false;
+}
+
+void CPVRManager::DisconnectClient()
+{
+  /* signal client to disconnect from backend */
+  m_client->Disconnect();
+
+  return;
+}
+
+bool CPVRManager::IsConnected()
+{
+  if (m_client)
+  {
+    if (m_client->IsUp())
+    {
+      return true;
+    }
+  }
+
+//
+//  if (m_bConnectionLost)
+//  {
+//    /* If connection was lost, ask user to reconnect to backend */
+//    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+//
+//    if (pDialog)
+//    {
+//      pDialog->SetHeading(18090);
+//      pDialog->SetLine(0, 18093);
+//      pDialog->SetLine(1, "");
+//      pDialog->SetLine(2, 18094);
+//      pDialog->DoModal();
+//
+//      if (!pDialog->IsConfirmed())
+//      {
+//        return false;
+//      }
+//    }
+//  }
+//
+//  /* Try to reconnect */
+//  Stop();
+//
+//  Start();
+//
+//  /* If connection is ok, clear lost flag */
+//  if (m_client && m_client->IsUp())
+//  {
+//    m_bConnectionLost = false;
+//    return true;
+//  }
+
+  return false;
+}
+
+CURL CPVRManager::GetConnString()
+{
+  CURL connString;
+
+  /* set client connection string, for password and username
+   * only default values are given
+   */
+  connString.SetHostName(m_clientProps.Hostname);
+  connString.SetUserName(m_clientProps.DefaultUser);
+  connString.SetPassword(m_clientProps.DefaultPassword);
+  connString.SetPort(m_clientProps.Port);
+
+  return connString;
+}
+
+
+/************************************************************/
+/** Event handling */
+
+const char* CPVRManager::TranslateInfo(DWORD dwInfo)
+{
+  if (dwInfo == PVR_NOW_RECORDING_TITLE)     return m_nowRecordingTitle;
+  else if (dwInfo == PVR_NOW_RECORDING_CHANNEL)   return m_nowRecordingChannel;
+  else if (dwInfo == PVR_NOW_RECORDING_DATETIME)  return m_nowRecordingDateTime;
+  else if (dwInfo == PVR_NEXT_RECORDING_TITLE)    return m_nextRecordingTitle;
+  else if (dwInfo == PVR_NEXT_RECORDING_CHANNEL)  return m_nextRecordingChannel;
+  else if (dwInfo == PVR_NEXT_RECORDING_DATETIME) return m_nextRecordingDateTime;
+
+  return "";
+}
+
+void CPVRManager::OnClientMessage(const long clientID, const PVR_EVENT clientEvent, const char* msg)
+{
+  /* here the manager reacts to messages sent from any of the clients via the IPVRClientCallback */
+  switch (clientEvent) {
+    case PVR_EVENT_UNKNOWN:
+      CLog::Log(LOGDEBUG, "%s - PVR: client_%ld unknown event : %s", __FUNCTION__, clientID, msg);
+      break;
+
+    case PVR_EVENT_TIMERS_CHANGE:
+	  {
+        CLog::Log(LOGDEBUG, "%s - PVR: client_%ld timers changed", __FUNCTION__, clientID);
+	    GetTimers();
+        SyncInfo();
+
+        CGUIWindowTV *pTVWin = (CGUIWindowTV *)m_gWindowManager.GetWindow(WINDOW_TV);
+	    if (pTVWin)
+    	  pTVWin->UpdateData(TV_WINDOW_TIMERS);
+	  }
+      break;
+
+    case PVR_EVENT_RECORDINGS_CHANGE:
+	  {
+        CLog::Log(LOGDEBUG, "%s - PVR: client_%ld recording list changed", __FUNCTION__, clientID);
+	    GetRecordings();
+        SyncInfo();
+
+        CGUIWindowTV *pTVWin = (CGUIWindowTV *)m_gWindowManager.GetWindow(WINDOW_TV);
+	    if (pTVWin)
+    	  pTVWin->UpdateData(TV_WINDOW_RECORDINGS);
+	  }
+      break;
+
+    case PVR_EVENT_CHANNELS_CHANGE:
+	  {
+        CLog::Log(LOGDEBUG, "%s - PVR: client_%ld channel list changed", __FUNCTION__, clientID);
+	    GetChannels();
+        SyncInfo();
+
+        CGUIWindowTV *pTVWin = (CGUIWindowTV *)m_gWindowManager.GetWindow(WINDOW_TV);
+	    if (pTVWin)
+		{
+    	  pTVWin->UpdateData(TV_WINDOW_CHANNELS_TV);
+		  pTVWin->UpdateData(TV_WINDOW_CHANNELS_RADIO);
+		}
+	  }
+      break;
+    default:
+      break;
+  }
+}
+
+
+/************************************************************/
+/** Feature flags */
+bool CPVRManager::SupportEPG()
+{
+  return m_clientProps.SupportEPG;
+}
+
+bool CPVRManager::SupportRecording()
+{
+  return m_clientProps.SupportRecordings;
+}
+
+bool CPVRManager::SupportRadio()
+{
+  return m_clientProps.SupportRadio;
+}
+
+bool CPVRManager::SupportTimers()
+{
+  return m_clientProps.SupportTimers;
+}
+
+bool CPVRManager::SupportChannelSettings()
+{
+  return m_clientProps.SupportChannelSettings;
+}
+
+bool CPVRManager::SupportTeletext()
+{
+  if (m_clientProps.SupportTeletext)
+  {
+    if (CPVRManager::GetInstance()->IsPlayingTV())
+    {
+      return m_channels_tv[m_CurrentTVChannel-1].m_bTeletext;
+    }
+    else if (CPVRManager::GetInstance()->IsPlayingRadio())
+    {
+      return m_channels_tv[m_CurrentRadioChannel-1].m_bTeletext;
+    }
+  }
+  return false;
+}
+
+bool CPVRManager::SupportDirector()
+{
+  return m_clientProps.SupportDirector;
+}
+
+
+/************************************************************/
+/** General handling */
+
+CStdString CPVRManager::GetBackendName()
+{
+  if (m_client)
+    return m_client->GetBackendName();
+
+  return "";
+}
+
+CStdString CPVRManager::GetBackendVersion()
+{
+  if (m_client)
+    return m_client->GetBackendVersion();
+
+  return "";
+}
+
+bool CPVRManager::GetDriveSpace(long long *total, long long *used, int *percent)
+{
+  if (m_client && m_clientProps.SupportRecordings)
+  {
+    if (m_client->GetDriveSpace(total, used) == PVR_ERROR_NO_ERROR)
+    {
+      *percent = (int)(((float) * used / (float) * total) * 100);
+      return true;
+    }
+  }
+
+  *total = 1024;
+  *used = 1024;
+  *percent = 100;
+  return false;
+}
+
+
+/************************************************************/
+/** EPG handling */
+
+bool CPVRManager::GetEPGInfo(unsigned int number, CFileItem& now, CFileItem& next, bool radio)
+{
+  if (m_client)
+  {
+    EnterCriticalSection(&m_critSection);
+    bool ok = false;
+
+    if (!radio)
+    {
+      if (now.IsTVEPG())
+        ok = m_channels_tv[number-1].GetEPGNowInfo(now.GetTVEPGInfoTag());
+
+      if (next.IsTVEPG() && ok)
+        ok = m_channels_tv[number-1].GetEPGNowInfo(next.GetTVEPGInfoTag());
+    }
+    else
+    {
+      if (now.IsTVEPG())
+        ok = m_channels_radio[number-1].GetEPGNowInfo(now.GetTVEPGInfoTag());
+
+      if (next.IsTVEPG() && ok)
+        ok = m_channels_radio[number-1].GetEPGNowInfo(next.GetTVEPGInfoTag());
+    }
+
+    LeaveCriticalSection(&m_critSection);
+
+    if (ok)
+      return true;
+  }
+  /* print info dialog "Server error!" */
+  CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+  return false;
+}
+
+int CPVRManager::GetEPGAll(CFileItemList* results, bool radio)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  if (!radio)
+  {
+    for (unsigned int channel = 0; channel < m_channels_tv.size(); channel++)
+    {
+      if (m_channels_tv[channel].m_hide)
+        continue;
+
+      for (unsigned int i = 0; i < m_channels_tv[channel].m_EPG.size(); i++)
+      {
+        CTVEPGInfoTag epgentry(NULL);
+
+        epgentry.m_strChannel        = m_channels_tv[channel].m_strChannel;
+        epgentry.m_strTitle          = m_channels_tv[channel].m_EPG[i].m_strTitle;
+        epgentry.m_strPlotOutline    = m_channels_tv[channel].m_EPG[i].m_strPlotOutline;
+        epgentry.m_strPlot           = m_channels_tv[channel].m_EPG[i].m_strPlot;
+        epgentry.m_GenreType         = m_channels_tv[channel].m_EPG[i].m_GenreType;
+        epgentry.m_GenreSubType      = m_channels_tv[channel].m_EPG[i].m_GenreSubType;
+        epgentry.m_strGenre          = m_channels_tv[channel].m_EPG[i].m_strGenre;
+        epgentry.m_startTime         = m_channels_tv[channel].m_EPG[i].m_startTime;
+        epgentry.m_endTime           = m_channels_tv[channel].m_EPG[i].m_endTime;
+        epgentry.m_duration          = m_channels_tv[channel].m_EPG[i].m_duration;
+        epgentry.m_channelNum        = m_channels_tv[channel].m_iChannelNum;
+        epgentry.m_idChannel         = m_channels_tv[channel].m_iIdChannel;
+        epgentry.m_isRadio           = m_channels_tv[channel].m_radio;
+        epgentry.m_IconPath          = m_channels_tv[channel].m_IconPath;
+
+        CFileItemPtr channel(new CFileItem(epgentry));
+        results->Add(channel);
+        cnt++;
+      }
+    }
+  }
+  else
+  {
+    for (unsigned int channel = 0; channel < m_channels_radio.size(); channel++)
+    {
+      if (m_channels_radio[channel].m_hide)
+        continue;
+
+      for (unsigned int i = 0; i < m_channels_radio[channel].m_EPG.size(); i++)
+      {
+        CTVEPGInfoTag epgentry(NULL);
+
+        epgentry.m_strChannel        = m_channels_radio[channel].m_strChannel;
+        epgentry.m_strTitle          = m_channels_radio[channel].m_EPG[i].m_strTitle;
+        epgentry.m_strPlotOutline    = m_channels_radio[channel].m_EPG[i].m_strPlotOutline;
+        epgentry.m_strPlot           = m_channels_radio[channel].m_EPG[i].m_strPlot;
+        epgentry.m_GenreType         = m_channels_radio[channel].m_EPG[i].m_GenreType;
+        epgentry.m_GenreSubType      = m_channels_radio[channel].m_EPG[i].m_GenreSubType;
+        epgentry.m_strGenre          = m_channels_radio[channel].m_EPG[i].m_strGenre;
+        epgentry.m_startTime         = m_channels_radio[channel].m_EPG[i].m_startTime;
+        epgentry.m_endTime           = m_channels_radio[channel].m_EPG[i].m_endTime;
+        epgentry.m_duration          = m_channels_radio[channel].m_EPG[i].m_duration;
+        epgentry.m_channelNum        = m_channels_radio[channel].m_iChannelNum;
+        epgentry.m_idChannel         = m_channels_radio[channel].m_iIdChannel;
+
+        CFileItemPtr channel(new CFileItem(epgentry));
+        results->Add(channel);
+        cnt++;
+      }
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+int CPVRManager::GetEPGNow(CFileItemList* results, bool radio)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  if (!radio)
+  {
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+      CTVEPGInfoTag epgnow(NULL);
+
+      if (m_channels_tv[i].m_hide)
+        continue;
+
+      m_channels_tv[i].GetEPGNowInfo(&epgnow);
+
+      CFileItemPtr channel(new CFileItem(epgnow));
+      channel->SetLabel2(epgnow.m_startTime.GetAsLocalizedTime("", false));
+      channel->m_strPath = m_channels_tv[i].m_strChannel;
+      channel->SetThumbnailImage(m_channels_tv[i].m_IconPath);
+      results->Add(channel);
+      cnt++;
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+      CTVEPGInfoTag epgnow(NULL);
+
+      if (m_channels_radio[i].m_hide)
+        continue;
+
+      m_channels_radio[i].GetEPGNowInfo(&epgnow);
+
+      CFileItemPtr channel(new CFileItem(epgnow));
+      channel->SetLabel2(epgnow.m_startTime.GetAsLocalizedTime("", false));
+      channel->m_strPath = m_channels_radio[i].m_strChannel;
+      channel->SetThumbnailImage(m_channels_radio[i].m_IconPath);
+      results->Add(channel);
+      cnt++;
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+int CPVRManager::GetEPGNext(CFileItemList* results, bool radio)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  if (!radio)
+  {
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+      CTVEPGInfoTag epgnext(NULL);
+
+      if (m_channels_tv[i].m_hide)
+        continue;
+
+      m_channels_tv[i].GetEPGNextInfo(&epgnext);
+
+      CFileItemPtr channel(new CFileItem(epgnext));
+      channel->SetLabel2(epgnext.m_startTime.GetAsLocalizedTime("", false));
+      channel->m_strPath = m_channels_tv[i].m_strChannel;
+      channel->SetThumbnailImage(m_channels_tv[i].m_IconPath);
+      results->Add(channel);
+      cnt++;
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+      CTVEPGInfoTag epgnext(NULL);
+
+      if (m_channels_radio[i].m_hide)
+        continue;
+
+      m_channels_radio[i].GetEPGNextInfo(&epgnext);
+
+      CFileItemPtr channel(new CFileItem(epgnext));
+      channel->SetLabel2(epgnext.m_startTime.GetAsLocalizedTime("", false));
+      channel->m_strPath = m_channels_radio[i].m_strChannel;
+      channel->SetThumbnailImage(m_channels_radio[i].m_IconPath);
+      results->Add(channel);
+      cnt++;
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+int CPVRManager::GetEPGChannel(unsigned int number, CFileItemList* results, bool radio)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  if (!radio)
+  {
+    for (unsigned int i = 0; i < m_channels_tv[number-1].m_EPG.size(); i++)
+    {
+      CTVEPGInfoTag epgentry(NULL);
+
+      epgentry.m_strChannel        = m_channels_tv[number-1].m_strChannel;
+      epgentry.m_strTitle          = m_channels_tv[number-1].m_EPG[i].m_strTitle;
+      epgentry.m_strPlotOutline    = m_channels_tv[number-1].m_EPG[i].m_strPlotOutline;
+      epgentry.m_strPlot           = m_channels_tv[number-1].m_EPG[i].m_strPlot;
+      epgentry.m_GenreType         = m_channels_tv[number-1].m_EPG[i].m_GenreType;
+      epgentry.m_GenreSubType      = m_channels_tv[number-1].m_EPG[i].m_GenreSubType;
+      epgentry.m_strGenre          = m_channels_tv[number-1].m_EPG[i].m_strGenre;
+      epgentry.m_startTime         = m_channels_tv[number-1].m_EPG[i].m_startTime;
+      epgentry.m_endTime           = m_channels_tv[number-1].m_EPG[i].m_endTime;
+      epgentry.m_duration          = m_channels_tv[number-1].m_EPG[i].m_duration;
+      epgentry.m_channelNum        = m_channels_tv[number-1].m_iChannelNum;
+      epgentry.m_idChannel         = m_channels_tv[number-1].m_iIdChannel;
+      epgentry.m_isRadio           = m_channels_tv[number-1].m_radio;
+
+      CFileItemPtr channel(new CFileItem(epgentry));
+      channel->SetLabel2(epgentry.m_startTime.GetAsLocalizedDateTime(false, false));
+      results->Add(channel);
+      cnt++;
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_channels_radio[number-1].m_EPG.size(); i++)
+    {
+      CTVEPGInfoTag epgentry(NULL);
+
+      epgentry.m_strChannel        = m_channels_radio[number-1].m_strChannel;
+      epgentry.m_strTitle          = m_channels_radio[number-1].m_EPG[i].m_strTitle;
+      epgentry.m_strPlotOutline    = m_channels_radio[number-1].m_EPG[i].m_strPlotOutline;
+      epgentry.m_strPlot           = m_channels_radio[number-1].m_EPG[i].m_strPlot;
+      epgentry.m_GenreType         = m_channels_radio[number-1].m_EPG[i].m_GenreType;
+      epgentry.m_GenreSubType      = m_channels_radio[number-1].m_EPG[i].m_GenreSubType;
+      epgentry.m_strGenre          = m_channels_radio[number-1].m_EPG[i].m_strGenre;
+      epgentry.m_startTime         = m_channels_radio[number-1].m_EPG[i].m_startTime;
+      epgentry.m_endTime           = m_channels_radio[number-1].m_EPG[i].m_endTime;
+      epgentry.m_duration          = m_channels_radio[number-1].m_EPG[i].m_duration;
+      epgentry.m_channelNum        = m_channels_radio[number-1].m_iChannelNum;
+      epgentry.m_idChannel         = m_channels_radio[number-1].m_iIdChannel;
+
+      CFileItemPtr channel(new CFileItem(epgentry));
+      channel->SetLabel2(epgentry.m_startTime.GetAsLocalizedDateTime(false, false));
+      results->Add(channel);
+      cnt++;
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+
+/************************************************************/
+/** Channel handling */
+
+int CPVRManager::GetNumChannels()
+{
+  return m_channels_tv.size() + m_channels_radio.size();
+}
+
+int CPVRManager::GetNumHiddenChannels()
+{
+  return m_HiddenChannels;
+}
+
+int CPVRManager::GetTVChannels(CFileItemList* results, int group_id, bool hidden)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+  {
+    if (m_channels_tv[i].m_hide != hidden)
+      continue;
+
+    if ((group_id != -1) && (m_channels_tv[i].m_iGroupID != group_id))
+      continue;
+
+    CTVEPGInfoTag epgnow(NULL);
+    if (m_channels_tv[i].GetEPGNowInfo(&epgnow))
+    {
+      m_channels_tv[i].m_strTitle          = epgnow.m_strTitle;
+      m_channels_tv[i].m_strOriginalTitle  = epgnow.m_strTitle;
+      m_channels_tv[i].m_strPlotOutline    = epgnow.m_strPlotOutline;
+      m_channels_tv[i].m_strPlot           = epgnow.m_strPlot;
+      m_channels_tv[i].m_strGenre          = epgnow.m_strGenre;
+      m_channels_tv[i].m_startTime         = epgnow.m_startTime;
+      m_channels_tv[i].m_endTime           = epgnow.m_endTime;
+      m_channels_tv[i].m_duration          = epgnow.m_duration;
+
+      if (m_channels_tv[i].m_strPlot.Left(m_channels_tv[i].m_strPlotOutline.length()) != m_channels_tv[i].m_strPlotOutline && !m_channels_tv[i].m_strPlotOutline.IsEmpty())
+        m_channels_tv[i].m_strPlot = m_channels_tv[i].m_strPlotOutline + '\n' + m_channels_tv[i].m_strPlot;
+
+      CDateTimeSpan span = m_channels_tv[i].m_startTime - m_channels_tv[i].m_endTime;
+
+      StringUtils::SecondsToTimeString(span.GetSeconds()
+                                       + span.GetMinutes() * 60.
+                                       + span.GetHours() * 3600, m_channels_tv[i].m_strRuntime, TIME_FORMAT_GUESS);
+    }
+    else
+    {
+      m_channels_tv[i].m_strTitle          = g_localizeStrings.Get(18074);
+      m_channels_tv[i].m_strOriginalTitle  = g_localizeStrings.Get(18074);
+      m_channels_tv[i].m_strPlotOutline    = "";
+      m_channels_tv[i].m_strPlot           = "";
+      m_channels_tv[i].m_strGenre          = "";
+      m_channels_tv[i].m_startTime         = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 0, 0, 0)-CDateTimeSpan(0, 1, 0, 0);
+      m_channels_tv[i].m_endTime           = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 23, 0, 0);
+      m_channels_tv[i].m_duration          = CDateTimeSpan(0, 1, 0, 0);
+    }
+
+    m_channels_tv[i].m_strAlbum = m_channels_tv[i].m_strChannel;
+
+    m_channels_tv[i].m_iSeason  = 0; /* set this so xbmc knows it's a tv show */
+    m_channels_tv[i].m_iEpisode = 0;
+    m_channels_tv[i].m_strShowTitle.Format("%i", m_channels_tv[i].m_iChannelNum);
+
+    CFileItemPtr channel(new CFileItem(m_channels_tv[i]));
+
+    results->Add(channel);
+    cnt++;
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+int CPVRManager::GetRadioChannels(CFileItemList* results, int group_id, bool hidden)
+{
+  EnterCriticalSection(&m_critSection);
+
+  int cnt = 0;
+
+  for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+  {
+    if (m_channels_radio[i].m_hide != hidden)
+      continue;
+
+    if ((group_id != -1) && (m_channels_radio[i].m_iGroupID != group_id))
+      continue;
+
+    CTVEPGInfoTag epgnow(NULL);
+    if (m_channels_radio[i].GetEPGNowInfo(&epgnow))
+    {
+      m_channels_radio[i].m_strTitle          = epgnow.m_strTitle;
+      m_channels_radio[i].m_strOriginalTitle  = epgnow.m_strTitle;
+      m_channels_radio[i].m_strPlotOutline    = epgnow.m_strPlotOutline;
+      m_channels_radio[i].m_strPlot           = epgnow.m_strPlot;
+      m_channels_radio[i].m_strGenre          = epgnow.m_strGenre;
+      m_channels_radio[i].m_startTime         = epgnow.m_startTime;
+      m_channels_radio[i].m_endTime           = epgnow.m_endTime;
+      m_channels_radio[i].m_duration          = epgnow.m_duration;
+
+      if (m_channels_radio[i].m_strPlot.Left(m_channels_radio[i].m_strPlotOutline.length()) != m_channels_radio[i].m_strPlotOutline && !m_channels_radio[i].m_strPlotOutline.IsEmpty())
+        m_channels_radio[i].m_strPlot = m_channels_radio[i].m_strPlotOutline + '\n' + m_channels_radio[i].m_strPlot;
+
+      CDateTimeSpan span = m_channels_radio[i].m_startTime - m_channels_radio[i].m_endTime;
+
+      StringUtils::SecondsToTimeString(span.GetSeconds()
+                                       + span.GetMinutes() * 60.
+                                       + span.GetHours() * 3600, m_channels_radio[i].m_strRuntime, TIME_FORMAT_GUESS);
+    }
+    else
+    {
+      m_channels_radio[i].m_strTitle          = g_localizeStrings.Get(18074);
+      m_channels_radio[i].m_strOriginalTitle  = g_localizeStrings.Get(18074);
+      m_channels_radio[i].m_strPlotOutline    = "";
+      m_channels_radio[i].m_strPlot           = "";
+      m_channels_radio[i].m_strGenre          = "";
+      m_channels_radio[i].m_startTime         = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 0, 0, 0)-CDateTimeSpan(0, 1, 0, 0);
+      m_channels_radio[i].m_endTime           = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 23, 0, 0);
+      m_channels_radio[i].m_duration          = CDateTimeSpan(0, 1, 0, 0);
+    }
+
+    m_channels_radio[i].m_strAlbum = m_channels_radio[i].m_strChannel;
+
+    m_channels_radio[i].m_iSeason  = 0; /* set this so xbmc knows it's a tv show */
+    m_channels_radio[i].m_iEpisode = 0;
+    m_channels_radio[i].m_strShowTitle.Format("%i", m_channels_radio[i].m_iChannelNum);
+
+    CFileItemPtr channel(new CFileItem(m_channels_radio[i]));
+
+    SetMusicInfoTag(*channel, i+1);
+    results->Add(channel);
+    cnt++;
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return cnt;
+}
+
+void CPVRManager::MoveChannel(unsigned int oldindex, unsigned int newindex, bool radio)
+{
+  VECCHANNELS m_channels_temp;
+
+  if ((newindex == oldindex) || (newindex == 0))
+    return;
+
+  EnterCriticalSection(&m_critSection);
+
+  m_database.Open();
+
+  if (!radio)
+  {
+    int CurrentChannelID = m_channels_tv[m_CurrentTVChannel].m_iIdChannel;
+    int CurrentClientChannel = GetClientChannelNumber(CurrentChannelID, false);
+
+    m_channels_temp.push_back(m_channels_tv[oldindex-1]);
+    m_channels_tv.erase(m_channels_tv.begin()+oldindex-1);
+    if (newindex < m_channels_tv.size())
+      m_channels_tv.insert(m_channels_tv.begin()+newindex-1, m_channels_temp[0]);
+    else
+      m_channels_tv.push_back(m_channels_temp[0]);
+
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+      if (m_channels_tv[i].m_iChannelNum != i+1)
+      {
+        m_channels_tv[i].m_iChannelNum = i+1;
+        m_channels_tv[i].m_strFileNameAndPath.Format("tv://%i", m_channels_tv[i].m_iChannelNum);
+        m_database.UpdateChannel(m_currentClientID, m_channels_tv[i]);
+      }
+    }
+
+    CLog::Log(LOGNOTICE, "PVR: TV Channel %d moved to %d", oldindex, newindex);
+
+    if (m_isPlayingTV && m_channels_tv[m_CurrentTVChannel].m_iIdChannel != CurrentChannelID)
+    {
+      /* Perform Channel switch with new number, if played channelnumber is modified */
+      GetFrontendChannelNumber(CurrentClientChannel, &m_CurrentTVChannel, NULL);
+      CFileItemPtr channel(new CFileItem(m_channels_tv[m_CurrentTVChannel]));
+      g_application.PlayFile(*channel);
+    }
+  }
+  else
+  {
+    int CurrentChannelID = m_channels_radio[m_CurrentRadioChannel].m_iIdChannel;
+    int CurrentClientChannel = GetClientChannelNumber(CurrentChannelID, false);
+
+    m_channels_temp.push_back(m_channels_radio[oldindex-1]);
+    m_channels_radio.erase(m_channels_radio.begin()+oldindex-1);
+    if (newindex < m_channels_radio.size())
+      m_channels_radio.insert(m_channels_radio.begin()+newindex-1, m_channels_temp[0]);
+    else
+      m_channels_radio.push_back(m_channels_temp[0]);
+
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+      if (m_channels_radio[i].m_iChannelNum != i+1)
+      {
+        m_channels_radio[i].m_iChannelNum = i+1;
+        m_channels_radio[i].m_strFileNameAndPath.Format("radio://%i", m_channels_radio[i].m_iChannelNum);
+        m_database.UpdateChannel(m_currentClientID, m_channels_radio[i]);
+      }
+    }
+
+    CLog::Log(LOGNOTICE, "PVR: TV Channel %d moved to %d", oldindex, newindex);
+
+    if (m_isPlayingTV && m_channels_radio[m_CurrentRadioChannel].m_iIdChannel != CurrentChannelID)
+    {
+      /* Perform Channel switch with new number, if played channelnumber is modified */
+      GetFrontendChannelNumber(CurrentClientChannel, &m_CurrentRadioChannel, NULL);
+      CFileItemPtr channel(new CFileItem(m_channels_radio[m_CurrentRadioChannel]));
+      g_application.PlayFile(*channel);
+    }
+  }
+  m_database.Close();
+
+  /* Synchronize channel numbers inside timers */
+  for (unsigned int i = 0; i < m_timers.size(); i++)
+  {
+    GetFrontendChannelNumber(m_timers[i].m_clientNum, &m_timers[i].m_channelNum, &m_timers[i].m_Radio);
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return;
+}
+
+void CPVRManager::HideChannel(unsigned int number, bool radio)
+{
+  for (unsigned int i = 0; i < m_timers.size(); i++)
+  {
+    if ((m_timers[i].m_channelNum == number) && (m_timers[i].m_Radio == radio))
+    {
+      CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+      if (!pDialog)
+        return;
+
+      pDialog->SetHeading(18090);
+      pDialog->SetLine(0, 18095);
+      pDialog->SetLine(1, "");
+      pDialog->SetLine(2, 18096);
+      pDialog->DoModal();
+
+      if (!pDialog->IsConfirmed())
+        return;
+
+      DeleteTimer(m_timers[i].m_Index, true);
+    }
+  }
+
+  if (!radio)
+  {
+    if (m_isPlayingTV && m_CurrentTVChannel == number)
+    {
+      CGUIDialogOK::ShowAndGetInput(18090,18097,0,18098);
+      return;
+    }
+
+    if (m_channels_tv[number-1].m_hide)
+    {
+      EnterCriticalSection(&m_critSection);
+      m_channels_tv[number-1].m_hide = false;
+      m_database.Open();
+      m_database.UpdateChannel(m_currentClientID, m_channels_tv[number-1]);
+      m_HiddenChannels = m_database.GetNumHiddenChannels(m_currentClientID);
+      m_database.Close();
+      LeaveCriticalSection(&m_critSection);
+    }
+    else
+    {
+      EnterCriticalSection(&m_critSection);
+      m_channels_tv[number-1].m_hide = true;
+      m_channels_tv[number-1].m_EPG.erase(m_channels_tv[number-1].m_EPG.begin(), m_channels_tv[number-1].m_EPG.end());
+      m_database.Open();
+      m_database.RemoveEPGEntries(m_currentClientID, m_channels_tv[number-1].m_iIdChannel, NULL, NULL);
+      m_database.UpdateChannel(m_currentClientID, m_channels_tv[number-1]);
+      m_HiddenChannels = m_database.GetNumHiddenChannels(m_currentClientID);
+      m_database.Close();
+      LeaveCriticalSection(&m_critSection);
+      MoveChannel(number, m_channels_tv.size(), false);
+    }
+  }
+  else
+  {
+    if (m_isPlayingRadio && m_CurrentRadioChannel == number)
+    {
+      CGUIDialogOK::ShowAndGetInput(18090,18097,0,18098);
+      return;
+    }
+
+    if (m_channels_radio[number-1].m_hide)
+    {
+      EnterCriticalSection(&m_critSection);
+      m_channels_radio[number-1].m_hide = false;
+      m_channels_radio[number-1].m_EPG.erase(m_channels_radio[number-1].m_EPG.begin(), m_channels_radio[number-1].m_EPG.end());
+      m_database.Open();
+      m_database.UpdateChannel(m_currentClientID, m_channels_radio[number-1]);
+      m_HiddenChannels = m_database.GetNumHiddenChannels(m_currentClientID);
+      m_database.Close();
+      LeaveCriticalSection(&m_critSection);
+    }
+    else
+    {
+      EnterCriticalSection(&m_critSection);
+      m_channels_radio[number-1].m_hide = true;
+      m_channels_radio[number-1].m_EPG.erase(m_channels_radio[number-1].m_EPG.begin(), m_channels_tv[number-1].m_EPG.end());
+      m_database.Open();
+      m_database.RemoveEPGEntries(m_currentClientID, m_channels_radio[number-1].m_iIdChannel, NULL, NULL);
+      m_database.UpdateChannel(m_currentClientID, m_channels_radio[number-1]);
+      m_HiddenChannels = m_database.GetNumHiddenChannels(m_currentClientID);
+      m_database.Close();
+      LeaveCriticalSection(&m_critSection);
+      MoveChannel(number, m_channels_radio.size(), true);
+    }
+  }
+}
+
+void CPVRManager::SetChannelIcon(unsigned int number, CStdString icon, bool radio)
+{
+  EnterCriticalSection(&m_critSection);
+
+  if (!radio)
+  {
+    if (m_channels_tv[number-1].m_IconPath != icon)
+    {
+      m_database.Open();
+      m_channels_tv[number-1].m_IconPath = icon;
+      m_database.UpdateChannel(m_currentClientID, m_channels_tv[number-1]);
+      m_database.Close();
+    }
+  }
+  else
+  {
+    if (m_channels_radio[number-1].m_IconPath != icon)
+    {
+      m_database.Open();
+      m_channels_radio[number-1].m_IconPath = icon;
+      m_database.UpdateChannel(m_currentClientID, m_channels_radio[number-1]);
+      m_database.Close();
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+}
+
+CStdString CPVRManager::GetChannelIcon(unsigned int number, bool radio)
+{
+  if (!radio)
+    return m_channels_tv[number-1].m_IconPath;
+  else
+    return m_channels_radio[number-1].m_IconPath;
+}
+
+CStdString CPVRManager::GetNameForChannel(unsigned int number, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      if (((int) number <= m_channels_tv.size()+1) && (number != 0))
+      {
+        if (m_channels_tv[number-1].m_strChannel != NULL)
+          return m_channels_tv[number-1].m_strChannel;
+        else
+          return g_localizeStrings.Get(13205);
+      }
+    }
+    else
+    {
+      if (((int) number <= m_channels_radio.size()+1) && (number != 0))
+      {
+        if (m_channels_radio[number-1].m_strChannel != NULL)
+          return m_channels_radio[number-1].m_strChannel;
+        else
+          return g_localizeStrings.Get(13205);
+      }
+    }
+  }
+
+  return "";
+}
+
+bool CPVRManager::GetFrontendChannelNumber(unsigned int client_no, int *frontend_no, bool *isRadio)
+{
+  for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+  {
+    if (m_channels_tv[i].m_iClientNum == client_no)
+    {
+      if (frontend_no != NULL)
+        *frontend_no = m_channels_tv[i].m_iChannelNum;
+
+      if (isRadio != NULL)
+        *isRadio = false;
+
+      return true;
+    }
+  }
+
+  for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+  {
+    if (m_channels_radio[i].m_iClientNum == client_no)
+    {
+      if (frontend_no != NULL)
+        *frontend_no = m_channels_radio[i].m_iChannelNum;
+
+      if (isRadio != NULL)
+        *isRadio = true;
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+int CPVRManager::GetClientChannelNumber(unsigned int frontend_no, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      if (((int) frontend_no <= m_channels_tv.size()+1) && (frontend_no != 0))
+        return m_channels_tv[frontend_no-1].m_iClientNum;
+    }
+    else
+    {
+      if (((int) frontend_no <= m_channels_radio.size()+1) && (frontend_no != 0))
+        return m_channels_radio[frontend_no-1].m_iClientNum;
+    }
+  }
+
+  return -1;
+}
+
+int CPVRManager::GetChannelID(unsigned int frontend_no, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      if (((int) frontend_no <= m_channels_tv.size()+1) && (frontend_no != 0))
+        return m_channels_tv[frontend_no-1].m_iIdChannel;
+    }
+    else
+    {
+      if (((int) frontend_no <= m_channels_radio.size()+1) && (frontend_no != 0))
+        return m_channels_radio[frontend_no-1].m_iIdChannel;
+    }
+  }
+
+  return -1;
+}
+
+int CPVRManager::GetGroupList(CFileItemList* results)
+{
+  for (unsigned int i = 0; i < m_channel_group.size(); i++)
+  {
+    CFileItemPtr group(new CFileItem(m_channel_group[i].m_Title));
+    group->m_strTitle = m_channel_group[i].m_Title;
+    group->m_strPath.Format("%i", m_channel_group[i].m_ID);
+    results->Add(group);
+  }
+  return m_channel_group.size();
+}
+
+void CPVRManager::AddGroup(const CStdString &newname)
+{
+  EnterCriticalSection(&m_critSection);
+  m_database.Open();
+
+  m_database.AddGroup(m_currentClientID, newname);
+  m_database.GetGroupList(m_currentClientID, &m_channel_group);
+
+  m_database.Close();
+  LeaveCriticalSection(&m_critSection);
+}
+
+bool CPVRManager::RenameGroup(unsigned int GroupId, const CStdString &newname)
+{
+  EnterCriticalSection(&m_critSection);
+  m_database.Open();
+
+  m_database.RenameGroup(m_currentClientID, GroupId, newname);
+  m_database.GetGroupList(m_currentClientID, &m_channel_group);
+
+  m_database.Close();
+  LeaveCriticalSection(&m_critSection);
+  return true;
+}
+
+bool CPVRManager::DeleteGroup(unsigned int GroupId)
+{
+  EnterCriticalSection(&m_critSection);
+  m_database.Open();
+
+  m_database.DeleteGroup(m_currentClientID, GroupId);
+
+  for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+  {
+    if (m_channels_tv[i].m_iGroupID == GroupId)
+    {
+      m_channels_tv[i].m_iGroupID = 0;
+      m_database.UpdateChannel(m_currentClientID, m_channels_tv[i]);
+    }
+  }
+  for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+  {
+    if (m_channels_radio[i].m_iGroupID == GroupId)
+    {
+      m_channels_radio[i].m_iGroupID = 0;
+      m_database.UpdateChannel(m_currentClientID, m_channels_radio[i]);
+    }
+  }
+  m_database.GetGroupList(m_currentClientID, &m_channel_group);
+  m_database.Close();
+  LeaveCriticalSection(&m_critSection);
+  return true;
+}
+
+bool CPVRManager::ChannelToGroup(unsigned int number, unsigned int GroupId, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      if (((int) number <= m_channels_tv.size()+1) && (number != 0))
+      {
+        EnterCriticalSection(&m_critSection);
+        m_database.Open();
+        m_channels_tv[number-1].m_iGroupID = GroupId;
+        m_database.UpdateChannel(m_currentClientID, m_channels_tv[number-1]);
+        m_database.Close();
+        LeaveCriticalSection(&m_critSection);
+        return true;
+      }
+    }
+    else
+    {
+      if (((int) number <= m_channels_radio.size()+1) && (number != 0))
+      {
+        EnterCriticalSection(&m_critSection);
+        m_database.Open();
+        m_channels_radio[number-1].m_iGroupID = GroupId;
+        m_database.UpdateChannel(m_currentClientID, m_channels_radio[number-1]);
+        m_database.Close();
+        LeaveCriticalSection(&m_critSection);
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+int CPVRManager::GetPrevGroupID(int current_group_id)
+{
+  if (m_channel_group.size() == 0)
+    return -1;
+
+  if ((current_group_id == -1) || (current_group_id == 0))
+    return m_channel_group[m_channel_group.size()-1].m_ID;
+
+  for (unsigned int i = 0; i < m_channel_group.size(); i++)
+  {
+    if (current_group_id == m_channel_group[i].m_ID)
+    {
+      if (i != 0)
+        return m_channel_group[i-1].m_ID;
+      else
+        return -1;
+    }
+  }
+  return -1;
+}
+
+int CPVRManager::GetNextGroupID(int current_group_id)
+{
+  unsigned int i = 0;
+
+  if (m_channel_group.size() == 0)
+    return -1;
+
+  if ((current_group_id == 0) || (current_group_id == -1))
+    return m_channel_group[0].m_ID;
+
+  if (m_channel_group.size() == 0)
+    return -1;
+
+  for (; i < m_channel_group.size(); i++)
+  {
+    if (current_group_id == m_channel_group[i].m_ID)
+      break;
+  }
+
+  if (i >= m_channel_group.size()-1)
+    return -1;
+  else
+    return m_channel_group[i+1].m_ID;
+}
+
+CStdString CPVRManager::GetGroupName(int GroupId)
+{
+  if (GroupId == -1)
+    return g_localizeStrings.Get(593);
+
+  for (unsigned int i = 0; i < m_channel_group.size(); i++)
+  {
+    if (GroupId == m_channel_group[i].m_ID)
+      return m_channel_group[i].m_Title;
+  }
+
+  return g_localizeStrings.Get(593);
+}
+
+int CPVRManager::GetFirstChannelForGroupID(int GroupId, bool radio)
+{
+  if (GroupId == -1)
+    return 1;
+
+  if (!radio)
+  {
+    for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+    {
+      if (m_channels_tv[i].m_iGroupID == GroupId)
+        return i+1;
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+    {
+      if (m_channels_radio[i].m_iGroupID == GroupId)
+        return i+1;
+    }
+  }
+  return 1;
+}
+
+
+/************************************************************/
+/**  Backend Channel handling **/
+
+bool CPVRManager::AddBackendChannel(const CFileItem &item)
+{
+  CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+  return false;
+}
+
+bool CPVRManager::DeleteBackendChannel(unsigned int index)
+{
+  CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+  return false;
+}
+
+bool CPVRManager::RenameBackendChannel(unsigned int index, CStdString &newname)
+{
+  CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+  return false;
+}
+
+bool CPVRManager::MoveBackendChannel(unsigned int index, unsigned int newindex)
+{
+  CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+  return false;
+}
+
+bool CPVRManager::UpdateBackendChannel(const CFileItem &item)
+{
+  CGUIDialogOK::ShowAndGetInput(18100,0,18059,0);
+  return false;
+}
+
+
+/************************************************************/
+/** Record handling **/
+
+int CPVRManager::GetNumRecordings()
+{
+  return m_recordings.size();
+}
+
+int CPVRManager::GetAllRecordings(CFileItemList* results)
+{
+  EnterCriticalSection(&m_critSection);
+  GetRecordings();
+
+  for (unsigned int i = 0; i < m_recordings.size(); ++i)
+  {
+    if ((m_recordings[i].m_startTime < CDateTime::GetCurrentDateTime()) &&
+        (m_recordings[i].m_endTime > CDateTime::GetCurrentDateTime()))
+    {
+      for (unsigned int j = 0; j < m_timers.size(); ++j)
+      {
+        if ((m_timers[j].m_strChannel == m_recordings[i].m_strChannel)  &&
+            (m_timers[j].m_StartTime  <= CDateTime::GetCurrentDateTime()) &&
+            (m_timers[j].m_StopTime   >= CDateTime::GetCurrentDateTime()) &&
+            (m_timers[j].m_Repeat != true) && (m_timers[j].m_Active == true))
+        {
+          m_recordings[i].m_Summary.Format("%s", g_localizeStrings.Get(18069));
+        }
+      }
+    }
+
+    CFileItemPtr record(new CFileItem(m_recordings[i]));
+    results->Add(record);
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return m_recordings.size();
+}
+
+bool CPVRManager::DeleteRecording(unsigned int index)
+{
+  if (m_client && m_clientProps.SupportRecordings)
+  {
+    PVR_ERROR err = m_client->DeleteRecording(m_recordings[index-1]);
+
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      /* print info dialog "Server error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      /* print info dialog "Recordings not in sync!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18810,18803,0);
+    }
+    else if (err == PVR_ERROR_NOT_DELETED)
+    {
+      /* print info dialog "Couldn't delete recording!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18811,18803,0);
+    }
+    else
+    {
+      /* print info dialog "Unknown error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+    }
+  }
+
+  return false;
+}
+
+bool CPVRManager::RenameRecording(unsigned int index, CStdString &newname)
+{
+  if (m_client && m_clientProps.SupportRecordings)
+  {
+    PVR_ERROR err = m_client->RenameRecording(m_recordings[index-1], newname);
+
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      /* print info dialog "Server error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      /* print info dialog "Recordings not in sync!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18810,18803,0);
+    }
+    else if (err == PVR_ERROR_NOT_SAVED)
+    {
+      /* print info dialog "Couldn't delete recording!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18811,18803,0);
+    }
+    else
+    {
+      /* print info dialog "Unknown error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+    }
+  }
+
+  return false;
+}
+
+
+/************************************************************/
+/** Timer handling **/
+
+int CPVRManager::GetNumTimers()
+{
+  return m_timers.size();
+}
+
+int CPVRManager::GetAllTimers(CFileItemList* results)
+{
+  EnterCriticalSection(&m_critSection);
+
+  GetTimers();
+
+  for (unsigned int i = 0; i < m_timers.size(); ++i)
+  {
+    CFileItemPtr timer(new CFileItem(m_timers[i]));
+    results->Add(timer);
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return m_timers.size();
+}
+
+bool CPVRManager::AddTimer(const CFileItem &item)
+{
+  if (m_client && m_clientProps.SupportTimers)
+  {
+    /* Check if a CTVTimerInfoTag is inside file item */
+    if (!item.IsTVTimer())
+    {
+      CLog::Log(LOGERROR, "CPVRManager: UpdateTimer no TVInfoTag given!");
+      return false;
+    }
+
+    PVR_ERROR err = m_client->AddTimer(*item.GetTVTimerInfoTag());
+
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      /* print info dialog "Server error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      /* print info dialog "Timers not in sync!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18800,18803,0);
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SAVED)
+    {
+      /* print info dialog "Couldn't delete timer!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18806,18803,0);
+      return false;
+    }
+    else if (err == PVR_ERROR_ALREADY_PRESENT)
+    {
+      /* print info dialog */
+      CGUIDialogOK::ShowAndGetInput(18100,18806,0,18814);
+      return false;
+    }
+    else
+    {
+      /* print info dialog "Unknown error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+      return false;
+    }
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CPVRManager::DeleteTimer(unsigned int index, bool force)
+{
+  if (m_client && m_clientProps.SupportTimers)
+  {
+    PVR_ERROR err = PVR_ERROR_NO_ERROR;
+
+    if (force)
+      err = m_client->DeleteTimer(m_timers[index-1], true);
+    else
+      err = m_client->DeleteTimer(m_timers[index-1]);
+
+    if (err == PVR_ERROR_RECORDING_RUNNING)
+    {
+      CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)m_gWindowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+      if (pDialog)
+      {
+        pDialog->SetHeading(122);
+        pDialog->SetLine(0, "");
+        pDialog->SetLine(1, 18162);
+        pDialog->SetLine(2, "");
+        pDialog->DoModal();
+
+        if (!pDialog->IsConfirmed()) return false;
+
+        err = m_client->DeleteTimer(m_timers[index-1], true);
+      }
+    }
+
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      // print info dialog "Server error!"
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      // print info dialog "Timers not in sync!"
+      CGUIDialogOK::ShowAndGetInput(18100,18800,18803,0);
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_DELETED)
+    {
+      // print info dialog "Couldn't delete timer!"
+      CGUIDialogOK::ShowAndGetInput(18100,18802,18803,0);
+      return false;
+    }
+    else
+    {
+      // print info dialog "Unknown error!"
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+      return false;
+    }
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CPVRManager::RenameTimer(unsigned int index, CStdString &newname)
+{
+  if (m_client && m_clientProps.SupportTimers)
+  {
+    PVR_ERROR err = m_client->RenameTimer(m_timers[index-1], newname);
+
+    if (err == PVR_ERROR_NOT_IMPLEMENTED)
+    {
+      m_timers[index-1].m_strTitle = newname;
+      err = m_client->UpdateTimer(m_timers[index-1]);
+    }
+
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      /* print info dialog "Server error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      /* print info dialog "Timers not in sync!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18800,18803,0);
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SAVED)
+    {
+      /* print info dialog "Couldn't delete timer!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18806,18803,0);
+      return false;
+    }
+    else
+    {
+      /* print info dialog "Unknown error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+      return false;
+    }
+  }
+
+  return false;
+}
+
+bool CPVRManager::UpdateTimer(const CFileItem &item)
+{
+  if (m_client && m_clientProps.SupportTimers)
+  {
+    /* Check if a CTVTimerInfoTag is inside file item */
+    if (!item.IsTVTimer())
+    {
+      CLog::Log(LOGERROR, "CPVRManager: UpdateTimer no TVInfoTag given!");
+      return false;
+    }
+
+    /* and write it to the backend */
+    PVR_ERROR err = m_client->UpdateTimer(*item.GetTVTimerInfoTag());
+
+    /* Check for errors and inform the user */
+    if (err == PVR_ERROR_NO_ERROR)
+    {
+      return true;
+    }
+    else if (err == PVR_ERROR_SERVER_ERROR)
+    {
+      /* print info dialog "Server error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18801,18803,0);
+      LostConnection();
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SYNC)
+    {
+      /* print info dialog "Timers not in sync!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18800,18803,0);
+      return false;
+    }
+    else if (err == PVR_ERROR_NOT_SAVED)
+    {
+      /* print info dialog "Couldn't save timer!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18806,18803,0);
+      return false;
+    }
+    else
+    {
+      /* print info dialog "Unknown error!" */
+      CGUIDialogOK::ShowAndGetInput(18100,18106,18803,0);
+      return false;
+    }
+  }
+  else
+  {
+    return false;
+  }
+}
+
+CDateTime CPVRManager::NextTimerDate(void)
+{
+  if (m_client)
+  {
+    CDateTime nextRec = NULL;
+
+    if (m_timers.size() == 0)
+      return NULL;
+
+    for (unsigned int i = 0; i < m_timers.size(); i++)
+    {
+      if (nextRec < m_timers[i].m_StartTime && m_timers[i].m_Active)
+      {
+        nextRec = m_timers[i].m_StartTime;
+      }
+    }
+    return nextRec;
+  }
+
+  return NULL;
+}
+
+
+/************************************************************/
+/** Live stream handling **/
+
+bool CPVRManager::OpenLiveStream(unsigned int channel, bool radio)
+{
+  bool ret = false;
+  m_scanStart = timeGetTime();
+
+  EnterCriticalSection(&m_critSection);
+
+  if (m_client)
+  {
+    if (!radio)
+    {
+      LoadVideoSettings(m_channels_tv[channel-1].m_iIdChannel, false);
+
+      if (m_client->OpenLiveStream(GetClientChannelNumber(channel, radio)))
+      {
+        m_CurrentTVChannel      = channel;
+        m_CurrentChannelID      = m_channels_tv[channel-1].m_iIdChannel;
+        m_isPlayingTV           = true;
+        m_isPlayingRadio        = false;
+        m_isPlayingRecording    = false;
+        SetCurrentPlayingProgram();
+        ret = true;
+      }
+    }
+    else
+    {
+      LoadVideoSettings(m_channels_radio[channel-1].m_iIdChannel, false);
+
+      if (m_client->OpenLiveStream(GetClientChannelNumber(channel, radio)))
+      {
+        m_CurrentRadioChannel   = channel;
+        m_CurrentChannelID      = m_channels_radio[channel-1].m_iIdChannel;
+        m_isPlayingTV           = false;
+        m_isPlayingRadio        = true;
+        m_isPlayingRecording    = false;
+        SetCurrentPlayingProgram();
+        ret = true;
+      }
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+
+  return ret;
+}
+
+void CPVRManager::CloseLiveStream()
+{
+
+  if (m_client)
+  {
+    EnterCriticalSection(&m_critSection);
+
+    SaveVideoSettings(m_CurrentChannelID);
+    m_client->CloseLiveStream();
+    m_CurrentTVChannel      = 1;
+    m_CurrentRadioChannel   = 1;
+    m_CurrentChannelID      = -1;
+    m_isPlayingTV           = false;
+    m_isPlayingRadio        = false;
+    m_isPlayingRecording    = false;
+
+    LeaveCriticalSection(&m_critSection);
+  }
+  return;
+}
+
+void CPVRManager::PauseLiveStream(bool OnOff)
+{
+
+}
+
+int CPVRManager::ReadLiveStream(BYTE* buf, int buf_size)
+{
+  if (m_client)
+  {
+    if (m_scanStart)
+    {
+      if (timeGetTime() - m_scanStart > g_guiSettings.GetInt("pvrmenu.scantime")*1000)
+        return 0;
+      else if (g_application.IsPlayingVideo() || g_application.IsPlayingAudio())
+        m_scanStart = NULL;
+    }
+
+    return m_client->ReadLiveStream(buf, buf_size);
+  }
+
+  return 0;
+}
+
+__int64 CPVRManager::SeekLiveStream(__int64 pos, int whence)
+{
+
+  return 0;
+}
+
+int CPVRManager::GetCurrentChannel(bool radio)
+{
+  if (!radio)
+    return m_CurrentTVChannel;
+  else
+    return m_CurrentRadioChannel;
+}
+
+bool CPVRManager::ChannelSwitch(unsigned int iChannel)
+{
+  if (m_client)
+  {
+    if (m_isPlayingTV)
+    {
+      if (iChannel > m_channels_tv.size()+1)
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,18105,0,0);
+        return false;
+      }
+
+      EnterCriticalSection(&m_critSection);
+
+      SaveVideoSettings(m_CurrentChannelID);
+      LoadVideoSettings(m_channels_tv[iChannel-1].m_iIdChannel);
+      if (!m_client->SwitchChannel(GetClientChannelNumber(iChannel, false)))
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+        LeaveCriticalSection(&m_critSection);
+        return false;
+      }
+      m_CurrentTVChannel  = iChannel;
+      m_CurrentChannelID  = m_channels_tv[iChannel-1].m_iIdChannel;
+      m_CurrentGroupID    = m_channels_tv[iChannel-1].m_iGroupID;
+      SetCurrentPlayingProgram();
+
+      LeaveCriticalSection(&m_critSection);
+    }
+    else if (m_isPlayingRadio)
+    {
+      if (iChannel > m_channels_radio.size()+1)
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,18105,0,0);
+        return false;
+      }
+
+      EnterCriticalSection(&m_critSection);
+
+      SaveVideoSettings(m_CurrentChannelID);
+      LoadVideoSettings(m_channels_radio[iChannel-1].m_iIdChannel);
+      if (!m_client->SwitchChannel(GetClientChannelNumber(iChannel, true)))
+      {
+        CGUIDialogOK::ShowAndGetInput(18100,0,18134,0);
+        LeaveCriticalSection(&m_critSection);
+        return false;
+      }
+      m_CurrentRadioChannel = iChannel;
+      m_CurrentChannelID    = m_channels_radio[iChannel-1].m_iIdChannel;
+      m_CurrentGroupID      = m_channels_radio[iChannel-1].m_iGroupID;
+      SetCurrentPlayingProgram();
+
+      LeaveCriticalSection(&m_critSection);
+    }
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRManager::ChannelUp(unsigned int *newchannel)
+{
+  if (m_client)
+  {
+    if (m_isPlayingTV)
+    {
+      EnterCriticalSection(&m_critSection);
+      SaveVideoSettings(m_CurrentChannelID);
+
+      for (unsigned int i = 1; i < m_channels_tv.size(); i++)
+      {
+        m_CurrentTVChannel += 1;
+
+        if (m_CurrentTVChannel > m_channels_tv.size())
+          m_CurrentTVChannel = 1;
+
+        if ((m_CurrentGroupID != -1) && (m_CurrentGroupID != m_channels_tv[m_CurrentTVChannel-1].m_iGroupID))
+          continue;
+
+        m_CurrentChannelID = m_channels_tv[m_CurrentTVChannel-1].m_iIdChannel;
+        LoadVideoSettings(m_CurrentChannelID);
+
+        if (m_client->SwitchChannel(GetClientChannelNumber(m_CurrentTVChannel, false)))
+        {
+          SetCurrentPlayingProgram();
+          *newchannel = m_CurrentTVChannel;
+          LeaveCriticalSection(&m_critSection);
+          return true;
+        }
+      }
+
+      LeaveCriticalSection(&m_critSection);
+    }
+    else if (m_isPlayingRadio)
+    {
+      EnterCriticalSection(&m_critSection);
+      SaveVideoSettings(m_CurrentChannelID);
+
+      for (unsigned int i = 1; i < m_channels_radio.size(); i++)
+      {
+        m_CurrentRadioChannel += 1;
+
+        if (m_CurrentRadioChannel > m_channels_radio.size())
+          m_CurrentRadioChannel = 1;
+
+        if ((m_CurrentGroupID != -1) && (m_CurrentGroupID != m_channels_radio[m_CurrentRadioChannel-1].m_iGroupID))
+          continue;
+
+        m_CurrentChannelID = m_channels_radio[m_CurrentRadioChannel-1].m_iIdChannel;
+        LoadVideoSettings(m_CurrentChannelID);
+
+        if (m_client->SwitchChannel(GetClientChannelNumber(m_CurrentRadioChannel, true)))
+        {
+          SetCurrentPlayingProgram();
+          *newchannel = m_CurrentRadioChannel;
+          LeaveCriticalSection(&m_critSection);
+          return true;
+        }
+      }
+
+      LeaveCriticalSection(&m_critSection);
+    }
+
+    CGUIDialogOK::ShowAndGetInput(18100,18103,0,0);
+  }
+
+  return false;
+}
+
+bool CPVRManager::ChannelDown(unsigned int *newchannel)
+{
+  if (m_client)
+  {
+    if (m_isPlayingTV)
+    {
+      EnterCriticalSection(&m_critSection);
+      SaveVideoSettings(m_CurrentChannelID);
+
+      for (unsigned int i = 1; i < m_channels_tv.size(); i++)
+      {
+        m_CurrentTVChannel -= 1;
+
+        if (m_CurrentTVChannel <= 0)
+          m_CurrentTVChannel = m_channels_tv.size();
+
+        if ((m_CurrentGroupID != -1) && (m_CurrentGroupID != m_channels_tv[m_CurrentTVChannel-1].m_iGroupID))
+          continue;
+
+        m_CurrentChannelID = m_channels_tv[m_CurrentTVChannel-1].m_iIdChannel;
+        LoadVideoSettings(m_CurrentChannelID);
+
+        if (m_client->SwitchChannel(GetClientChannelNumber(m_CurrentTVChannel, false)))
+        {
+          SetCurrentPlayingProgram();
+          *newchannel = m_CurrentTVChannel;
+          LeaveCriticalSection(&m_critSection);
+          return true;
+        }
+      }
+
+      LeaveCriticalSection(&m_critSection);
+    }
+    else if (m_isPlayingRadio)
+    {
+      EnterCriticalSection(&m_critSection);
+      SaveVideoSettings(m_CurrentChannelID);
+
+      for (unsigned int i = 1; i < m_channels_radio.size(); i++)
+      {
+        m_CurrentRadioChannel -= 1;
+
+        if (m_CurrentRadioChannel <= 0)
+          m_CurrentRadioChannel = m_channels_radio.size();
+
+        if ((m_CurrentGroupID != -1) && (m_CurrentGroupID != m_channels_radio[m_CurrentRadioChannel-1].m_iGroupID))
+          continue;
+
+        m_CurrentChannelID = m_channels_radio[m_CurrentRadioChannel-1].m_iIdChannel;
+        LoadVideoSettings(m_CurrentChannelID);
+
+        if (m_client->SwitchChannel(GetClientChannelNumber(m_CurrentRadioChannel, true)))
+        {
+          SetCurrentPlayingProgram();
+          *newchannel = m_CurrentRadioChannel;
+          LeaveCriticalSection(&m_critSection);
+          return true;
+        }
+      }
+
+      LeaveCriticalSection(&m_critSection);
+    }
+
+    CGUIDialogOK::ShowAndGetInput(18100,18103,0,0);
+  }
+
+  return false;
+}
+
+int CPVRManager::GetTotalTime()
+{
+  if (m_client)
+  {
+    time_t time_s;
+
+    if (m_isPlayingTV)
+    {
+      time_s =  m_channels_tv[m_CurrentTVChannel-1].m_duration.GetDays()*60*60*24;
+      time_s += m_channels_tv[m_CurrentTVChannel-1].m_duration.GetHours()*60*60;
+      time_s += m_channels_tv[m_CurrentTVChannel-1].m_duration.GetMinutes()*60;
+      time_s += m_channels_tv[m_CurrentTVChannel-1].m_duration.GetSeconds();
+    }
+    else if (m_isPlayingRadio)
+    {
+      time_s =  m_channels_radio[m_CurrentRadioChannel-1].m_duration.GetDays()*60*60*24;
+      time_s += m_channels_radio[m_CurrentRadioChannel-1].m_duration.GetHours()*60*60;
+      time_s += m_channels_radio[m_CurrentRadioChannel-1].m_duration.GetMinutes()*60;
+      time_s += m_channels_radio[m_CurrentRadioChannel-1].m_duration.GetSeconds();
+    }
+
+    time_s *= 1000;
+
+    return time_s;
+  }
+
+  return -1;
+}
+
+int CPVRManager::GetStartTime()
+{
+  if (m_client)
+  {
+    CTVEPGInfoTag epgnow;
+    time_t time_c, time_s;
+    CDateTime endtime;
+
+    if (m_isPlayingTV)
+    {
+      endtime = m_channels_tv[m_CurrentTVChannel-1].m_endTime;
+    }
+    else if (m_isPlayingRadio)
+    {
+      endtime = m_channels_radio[m_CurrentRadioChannel-1].m_endTime;
+    }
+
+    if (endtime < CDateTime::GetCurrentDateTime())
+    {
+      SetCurrentPlayingProgram();
+
+      CFileItem item(g_application.CurrentFileItem());
+
+      if (UpdateItem(item))
+      {
+        g_application.CurrentFileItem() = item;
+        g_infoManager.SetCurrentItem(item);
+      }
+    }
+
+    CDateTime::GetCurrentDateTime().GetAsTime(time_c);
+
+    if (m_isPlayingTV)
+    {
+      m_channels_tv[m_CurrentTVChannel-1].m_startTime.GetAsTime(time_s);
+    }
+    else if (m_isPlayingRadio)
+    {
+      m_channels_radio[m_CurrentRadioChannel-1].m_startTime.GetAsTime(time_s);
+    }
+
+    return (time_s - time_c) * 1000;
+  }
+
+  return 0;
+}
+
+bool CPVRManager::UpdateItem(CFileItem& item)
+{
+  if (!item.IsTVChannel())
+  {
+    CLog::Log(LOGERROR, "CPVRManager: UpdateItem no TVChannelTag given!");
+    return false;
+  }
+
+  CTVChannelInfoTag* tag = item.GetTVChannelInfoTag();
+
+  if (m_isPlayingTV)
+  {
+    CTVEPGInfoTag epgnext(NULL);
+    m_channels_tv[m_CurrentTVChannel-1].GetEPGNextInfo(&epgnext);
+
+    tag->m_strAlbum         = m_channels_tv[m_CurrentTVChannel-1].m_strChannel;
+    tag->m_strTitle         = m_channels_tv[m_CurrentTVChannel-1].m_strTitle;
+    tag->m_strOriginalTitle = m_channels_tv[m_CurrentTVChannel-1].m_strTitle;
+    tag->m_strPlotOutline   = m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline;
+    tag->m_strPlot          = m_channels_tv[m_CurrentTVChannel-1].m_strPlot;
+    tag->m_strGenre         = m_channels_tv[m_CurrentTVChannel-1].m_strGenre;
+    tag->m_strShowTitle.Format("%i", m_channels_tv[m_CurrentTVChannel-1].m_iChannelNum);
+    tag->m_strNextTitle     = epgnext.m_strTitle;
+    tag->m_strPath          = m_channels_tv[m_CurrentTVChannel-1].m_strFileNameAndPath;
+    tag->m_strFileNameAndPath = m_channels_tv[m_CurrentTVChannel-1].m_strFileNameAndPath;
+
+    item.m_strTitle = m_channels_tv[m_CurrentTVChannel-1].m_strChannel;
+    item.m_dateTime = m_channels_tv[m_CurrentTVChannel-1].m_startTime;
+
+    CDateTimeSpan span = m_channels_tv[m_CurrentTVChannel-1].m_startTime - m_channels_tv[m_CurrentTVChannel-1].m_endTime;
+    StringUtils::SecondsToTimeString(span.GetSeconds() + span.GetMinutes() * 60 + span.GetHours() * 3600,
+                                     tag->m_strRuntime,
+                                     TIME_FORMAT_GUESS);
+
+    if (m_channels_tv[m_CurrentTVChannel-1].m_IconPath != "")
+    {
+      item.SetThumbnailImage(m_channels_tv[m_CurrentTVChannel-1].m_IconPath);
+    }
+    else
+    {
+      item.SetThumbnailImage("");
+      item.FillInDefaultIcon();
+    }
+  }
+  else if (m_isPlayingRadio)
+  {
+    CTVEPGInfoTag epgnext(NULL);
+    m_channels_tv[m_CurrentRadioChannel-1].GetEPGNextInfo(&epgnext);
+
+    tag->m_strAlbum         = m_channels_radio[m_CurrentRadioChannel-1].m_strChannel;
+    tag->m_strTitle         = m_channels_radio[m_CurrentRadioChannel-1].m_strTitle;
+    tag->m_strOriginalTitle = m_channels_radio[m_CurrentRadioChannel-1].m_strTitle;
+    tag->m_strPlotOutline   = m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline;
+    tag->m_strPlot          = m_channels_radio[m_CurrentRadioChannel-1].m_strPlot;
+    tag->m_strGenre         = m_channels_radio[m_CurrentRadioChannel-1].m_strGenre;
+    tag->m_strShowTitle.Format("%i", m_channels_radio[m_CurrentRadioChannel-1].m_iChannelNum);
+    tag->m_strNextTitle     = epgnext.m_strTitle;
+    tag->m_strPath          = m_channels_radio[m_CurrentRadioChannel-1].m_strFileNameAndPath;
+    tag->m_strFileNameAndPath = m_channels_radio[m_CurrentRadioChannel-1].m_strFileNameAndPath;
+
+    item.m_strTitle = m_channels_radio[m_CurrentRadioChannel-1].m_strChannel;
+    item.m_dateTime = m_channels_radio[m_CurrentRadioChannel-1].m_startTime;
+
+    CDateTimeSpan span = m_channels_radio[m_CurrentRadioChannel-1].m_startTime - m_channels_radio[m_CurrentRadioChannel-1].m_endTime;
+    StringUtils::SecondsToTimeString(span.GetSeconds() + span.GetMinutes() * 60 + span.GetHours() * 3600,
+                                     tag->m_strRuntime,
+                                     TIME_FORMAT_GUESS);
+
+    if (m_channels_radio[m_CurrentRadioChannel-1].m_IconPath != "")
+    {
+      item.SetThumbnailImage(m_channels_radio[m_CurrentRadioChannel-1].m_IconPath);
+    }
+    else
+    {
+      item.SetThumbnailImage("");
+      item.FillInDefaultIcon();
+    }
+  }
+
+  if ((tag->m_strPlot.Left(tag->m_strPlotOutline.length()) != tag->m_strPlotOutline) && (!tag->m_strPlotOutline.IsEmpty()))
+  {
+    tag->m_strPlot = tag->m_strPlotOutline + '\n' + tag->m_strPlot;
+  }
+
+  tag->m_iSeason      = 0; /* set this so xbmc knows it's a tv show */
+
+  tag->m_iEpisode     = 0;
+  tag->m_strStatus    = "livetv";
+
+  g_infoManager.SetCurrentItem(item);
+  return true;
+}
+
+void CPVRManager::SetPlayingGroup(int GroupId)
+{
+  m_CurrentGroupID = GroupId;
+}
+
+int CPVRManager::GetPlayingGroup() {
+  return m_CurrentGroupID;
+}
+
+
+/************************************************************/
+/** Recorded stream handling **/
+
+bool CPVRManager::OpenRecordedStream(unsigned int record)
+{
+  EnterCriticalSection(&m_critSection);
+
+  if (m_client)
+  {
+    if (m_client->OpenRecordedStream(m_recordings[record-1]))
+    {
+      m_isPlayingRecording    = true;
+      m_isPlayingTV           = false;
+      m_isPlayingRadio        = false;
+      LeaveCriticalSection(&m_critSection);
+      return true;
+    }
+  }
+
+  LeaveCriticalSection(&m_critSection);
+  return false;
+}
+
+void CPVRManager::CloseRecordedStream(void)
+{
+  if (m_client)
+  {
+    EnterCriticalSection(&m_critSection);
+    m_client->CloseRecordedStream();
+    m_isPlayingRecording    = false;
+    m_isPlayingTV           = false;
+    m_isPlayingRadio        = false;
+    LeaveCriticalSection(&m_critSection);
+  }
+  return;
+}
+
+int CPVRManager::ReadRecordedStream(BYTE* buf, int buf_size)
+{
+  if (m_client)
+  {
+    return m_client->ReadRecordedStream(buf, buf_size);
+  }
+
+  return 0;
+}
+
+__int64 CPVRManager::SeekRecordedStream(__int64 pos, int whence)
+{
+  if (m_client)
+  {
+    return m_client->SeekRecordedStream(pos, whence);
+  }
+
+  return -1;
+}
+
+__int64 CPVRManager::LengthRecordedStream(void)
+{
+  if (m_client)
+  {
+    return m_client->LengthRecordedStream();
+  }
+
+  return -1;
+}
+
+bool CPVRManager::IsRecording(unsigned int channel, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      return m_channels_tv[channel-1].m_isRecording;
+    }
+    else
+    {
+      return m_channels_radio[channel-1].m_isRecording;
+    }
+  }
+
+  return false;
+}
+
+bool CPVRManager::RecordChannel(unsigned int channel, bool bOnOff, bool radio)
+{
+  if (m_client)
+  {
+    if (!radio)
+    {
+      if (bOnOff && m_channels_tv[channel-1].m_isRecording == false)
+      {
+        CTVTimerInfoTag newtimer(true);
+        CFileItem *item = new CFileItem(newtimer);
+
+        if (!AddTimer(*item))
+        {
+          CGUIDialogOK::ShowAndGetInput(18100,0,18053,0);
+          return true;
+        }
+
+        m_channels_tv[channel-1].m_isRecording = true;
+      }
+      else if (m_channels_tv[channel-1].m_isRecording == true)
+      {
+        for (unsigned int i = 0; i < m_timers.size(); ++i)
+        {
+          if ((m_timers[i].m_strChannel == m_channels_tv[channel-1].m_strChannel) &&
+              (m_timers[i].m_StartTime  <= CDateTime::GetCurrentDateTime()) &&
+              (m_timers[i].m_StopTime   >= CDateTime::GetCurrentDateTime()) &&
+              (m_timers[i].m_Repeat != true) && (m_timers[i].m_Active == true))
+          {
+            DeleteTimer(m_timers[i].m_Index, true);
+          }
+        }
+
+        m_channels_tv[channel-1].m_isRecording = false;
+      }
+    }
+    else
+    {
+      if (bOnOff && m_channels_radio[channel-1].m_isRecording == false)
+      {
+        CTVTimerInfoTag newtimer(true);
+        CFileItem *item = new CFileItem(newtimer);
+
+        if (!AddTimer(*item))
+        {
+          CGUIDialogOK::ShowAndGetInput(18100,0,18053,0);
+          return true;
+        }
+
+        m_channels_radio[channel-1].m_isRecording = true;
+      }
+      else if (m_channels_radio[channel-1].m_isRecording == true)
+      {
+        for (unsigned int i = 0; i < m_timers.size(); ++i)
+        {
+          if ((m_timers[i].m_strChannel == m_channels_tv[channel-1].m_strChannel) &&
+              (m_timers[i].m_StartTime  <= CDateTime::GetCurrentDateTime()) &&
+              (m_timers[i].m_StopTime   >= CDateTime::GetCurrentDateTime()) &&
+              (m_timers[i].m_Repeat != true) && (m_timers[i].m_Active == true))
+          {
+            DeleteTimer(m_timers[i].m_Index, true);
+          }
+        }
+
+        m_channels_radio[channel-1].m_isRecording = false;
+      }
+    }
+  }
+  return false;
+}
+
+
+/************************************************************/
+/** Internal handling **/
+
+void CPVRManager::GetChannels()
+{
+  VECCHANNELS m_channels_tv_tmp;
+  VECCHANNELS m_channels_radio_tmp;
+
+  EnterCriticalSection(&m_critSection);
+  m_database.Open();
+
+  m_client->GetChannelList(m_channels_tv_tmp, false);
+  m_client->GetChannelList(m_channels_radio_tmp, true);
+
+  /*
+   * First whe look for moved channels on backend (other backend number)
+   * and delete no more present channels inside database.
+   * Problem:
+   * If a channel on client is renamed, it is deleted from Database
+   * and later added as new channel and loose his Group Information
+   */
+  for (unsigned int i = 0; i < m_channels_tv.size(); i++)
+  {
+    bool found = false;
+
+    for (unsigned int j = 0; j < m_channels_tv_tmp.size(); j++)
+    {
+	  if (m_channels_tv[i].m_strChannel == m_channels_tv_tmp[j].m_strChannel)
+	  {
+	    if (m_channels_tv[i].m_iClientNum != m_channels_tv_tmp[j].m_iClientNum)
+		{
+		  m_channels_tv[i].m_iClientNum = m_channels_tv_tmp[j].m_iClientNum;
+		  m_database.UpdateChannel(m_currentClientID, m_channels_tv[i]);
+		  CLog::Log(LOGINFO,"PVRManager: Updated TV channel %s", m_channels_tv[i].m_strChannel.c_str());
+		}
+
+	    found = true;
+		m_channels_tv_tmp.erase(m_channels_tv_tmp.begin()+j);
+		break;
+	  }
+	}
+
+	if (!found)
+	{
+	  CLog::Log(LOGINFO,"PVRManager: Removing TV channel %s (no more present)", m_channels_tv[i].m_strChannel.c_str());
+      m_database.RemoveChannel(m_currentClientID, m_channels_tv[i]);
+	  m_channels_tv.erase(m_channels_tv.begin()+i);
+	  i--;
+	}
+  }
+
+  for (unsigned int i = 0; i < m_channels_radio.size(); i++)
+  {
+    bool found = false;
+
+    for (unsigned int j = 0; j < m_channels_radio_tmp.size(); j++)
+    {
+	  if (m_channels_radio[i].m_strChannel == m_channels_radio_tmp[j].m_strChannel)
+	  {
+	    if (m_channels_radio[i].m_iClientNum != m_channels_radio_tmp[j].m_iClientNum)
+		{
+		  m_channels_radio[i].m_iClientNum = m_channels_radio_tmp[j].m_iClientNum;
+		  m_database.UpdateChannel(m_currentClientID, m_channels_radio[i]);
+		  CLog::Log(LOGINFO,"PVRManager: Updated Radio channel %s", m_channels_radio[i].m_strChannel.c_str());
+		}
+
+	    found = true;
+		m_channels_radio_tmp.erase(m_channels_radio_tmp.begin()+j);
+		break;
+	  }
+	}
+
+	if (!found)
+	{
+	  CLog::Log(LOGINFO,"PVRManager: Removing Radio channel %s (no more present)", m_channels_radio[i].m_strChannel.c_str());
+      m_database.RemoveChannel(m_currentClientID, m_channels_radio[i]);
+	  m_channels_radio.erase(m_channels_radio.begin()+i);
+	  i--;
+	}
+  }
+
+  /*
+   * Now whe add new channels to frontend
+   * All entries now present in the temp lists, are new entries
+   */
+  for (unsigned int i = 0; i < m_channels_tv_tmp.size(); i++)
+  {
+    m_channels_tv_tmp[i].m_strStatus = "livetv";
+    m_channels_tv_tmp[i].m_iIdChannel = m_database.AddChannel(m_currentClientID, m_channels_tv_tmp[i]);
+	m_channels_tv.push_back(m_channels_tv_tmp[i]);
+	CLog::Log(LOGINFO,"PVRManager: Added TV channel %s", m_channels_tv_tmp[i].m_strChannel.c_str());
+  }
+
+  for (unsigned int i = 0; i < m_channels_radio_tmp.size(); i++)
+  {
+    m_channels_radio_tmp[i].m_strStatus = "livetv";
+    m_channels_radio_tmp[i].m_iIdChannel = m_database.AddChannel(m_currentClientID, m_channels_radio_tmp[i]);
+	m_channels_radio.push_back(m_channels_radio_tmp[i]);
+	CLog::Log(LOGINFO,"PVRManager: Added Radio channel %s", m_channels_radio_tmp[i].m_strChannel.c_str());
+  }
+
+
+  m_database.Close();
+  LeaveCriticalSection(&m_critSection);
+  return;
+}
+
+void CPVRManager::GetTimers()
+{
+  if (m_client)
+  {
+    EnterCriticalSection(&m_critSection);
+    m_timers.erase(m_timers.begin(), m_timers.end());
+
+    if (m_client->GetNumTimers() > 0)
+    {
+      m_client->GetAllTimers(&m_timers);
+
+      for (unsigned int i = 0; i < m_timers.size(); i++)
+      {
+        GetFrontendChannelNumber(m_timers[i].m_clientNum, &m_timers[i].m_channelNum, &m_timers[i].m_Radio);
+        m_timers[i].m_strChannel = GetNameForChannel(m_timers[i].m_channelNum, m_timers[i].m_Radio);
+      }
+    }
+
+    LeaveCriticalSection(&m_critSection);
+  }
+
+  return;
+}
+
+void CPVRManager::GetRecordings()
+{
+  if (m_client)
+  {
+    EnterCriticalSection(&m_critSection);
+    m_recordings.erase(m_recordings.begin(), m_recordings.end());
+
+    if (m_client->GetNumRecordings() > 0)
+    {
+      m_client->GetAllRecordings(&m_recordings);
+    }
+
+    LeaveCriticalSection(&m_critSection);
+  }
+
+  return;
+}
+
+void CPVRManager::SyncInfo()
+{
+  m_client->GetNumRecordings() > 0 ? m_hasRecordings = true : m_hasRecordings = false;
+  m_client->GetNumTimers()     > 0 ? m_hasTimers     = true : m_hasTimers = false;
+  m_isRecording = false;
+
+  if (m_hasTimers && m_clientProps.SupportTimers)
+  {
+    CDateTime nextRec;
+
+    for (unsigned int i = 0; i < m_timers.size(); ++i)
+    {
+      if (nextRec > m_timers[i].m_StartTime)
+      {
+        nextRec = m_timers[i].m_StartTime;
+
+        m_nextRecordingTitle    = m_timers[i].m_strTitle;
+        m_nextRecordingChannel  = GetNameForChannel(m_timers[i].m_channelNum);
+        m_nextRecordingDateTime = nextRec.GetAsLocalizedDateTime(false, false);
+
+        if (m_timers[i].m_recStatus == true)
+        {
+          m_isRecording = true;
+        }
+        else
+        {
+          m_isRecording = false;
+        }
+      }
+    }
+  }
+
+  if (m_isRecording && m_clientProps.SupportRecordings)
+  {
+    m_nowRecordingTitle = m_nextRecordingTitle;
+    m_nowRecordingDateTime = m_nextRecordingDateTime;
+    m_nowRecordingChannel = m_nextRecordingChannel;
+  }
+  else
+  {
+    m_nowRecordingTitle.clear();
+    m_nowRecordingDateTime.clear();
+    m_nowRecordingChannel.clear();
+  }
+}
+
+void CPVRManager::LostConnection()
+{
+  /* Set lost flag */
+  m_bConnectionLost = true;
+
+  /* And inform the user about the lost connection */
+  CGUIDialogOK::ShowAndGetInput(18090,0,18093,0);
+  return;
+}
+
+CTVChannelInfoTag *CPVRManager::GetChannelByNumber(int Number, bool radio, int SkipGap)
+{
+  CTVChannelInfoTag *previous = NULL;
+
+  if (!radio)
+  {
+    for (unsigned int channel = 0; channel < m_channels_tv.size(); channel++)
+    {
+      if (m_channels_tv[channel].m_radio != radio)
+        continue;
+
+      if (m_channels_tv[channel].m_iChannelNum == Number)
+      {
+        return &m_channels_tv[channel];
+      }
+      else if (SkipGap && m_channels_tv[channel].m_iChannelNum > Number)
+      {
+        return SkipGap > 0 ? &m_channels_tv[channel] : previous;
+      }
+
+      previous = &m_channels_tv[channel];
+    }
+  }
+  else
+  {
+    for (unsigned int channel = 0; channel < m_channels_radio.size(); channel++)
+    {
+      if (m_channels_radio[channel].m_radio != radio)
+        continue;
+
+      if (m_channels_radio[channel].m_iChannelNum == Number)
+      {
+        return &m_channels_radio[channel];
+      }
+      else if (SkipGap && m_channels_radio[channel].m_iChannelNum > Number)
+      {
+        return SkipGap > 0 ? &m_channels_radio[channel] : previous;
+      }
+
+      previous = &m_channels_radio[channel];
+    }
+  }
+
+  return NULL;
+}
+
+CTVChannelInfoTag *CPVRManager::GetChannelByID(int Id, bool radio, int SkipGap)
+{
+  CTVChannelInfoTag *previous = NULL;
+
+  if (!radio)
+  {
+    for (unsigned int channel = 0; channel < m_channels_tv.size(); channel++)
+    {
+
+      if (m_channels_tv[channel].m_radio != radio)
+        continue;
+
+      if (m_channels_tv[channel].m_iIdChannel == Id)
+      {
+        return &m_channels_tv[channel];
+      }
+      else if (SkipGap && m_channels_tv[channel].m_iIdChannel > Id)
+      {
+        return SkipGap > 0 ? &m_channels_tv[channel] : previous;
+      }
+
+      previous = &m_channels_tv[channel];
+    }
+  }
+  else
+  {
+    for (unsigned int channel = 0; channel < m_channels_radio.size(); channel++)
+    {
+
+      if (m_channels_radio[channel].m_radio != radio)
+        continue;
+
+      if (m_channels_radio[channel].m_iIdChannel == Id)
+      {
+        return &m_channels_radio[channel];
+      }
+      else if (SkipGap && m_channels_radio[channel].m_iIdChannel > Id)
+      {
+        return SkipGap > 0 ? &m_channels_radio[channel] : previous;
+      }
+
+      previous = &m_channels_radio[channel];
+    }
+  }
+
+  return NULL;
+}
+
+void CPVRManager::SetMusicInfoTag(CFileItem& item, unsigned int channel)
+{
+  int duration;
+  channel--;
+  duration =  m_channels_radio[channel].m_duration.GetDays()*60*60*24;
+  duration += m_channels_radio[channel].m_duration.GetHours()*60*60;
+  duration += m_channels_radio[channel].m_duration.GetMinutes()*60;
+  duration += m_channels_radio[channel].m_duration.GetSeconds();
+
+  item.GetMusicInfoTag()->SetURL(m_channels_radio[channel].m_strFileNameAndPath);
+  item.GetMusicInfoTag()->SetTitle(m_channels_radio[channel].m_strTitle);
+  item.GetMusicInfoTag()->SetArtist(m_channels_radio[channel].m_strChannel);
+//    item.GetMusicInfoTag()->SetAlbum(m_channels_radio[channel].m_strBouquet);
+  item.GetMusicInfoTag()->SetAlbumArtist(m_channels_radio[channel].m_strChannel);
+  item.GetMusicInfoTag()->SetGenre(m_channels_radio[channel].m_strGenre);
+  item.GetMusicInfoTag()->SetDuration(duration);
+  item.GetMusicInfoTag()->SetLoaded(true);
+  item.GetMusicInfoTag()->SetComment("");
+  item.GetMusicInfoTag()->SetLyrics("");
+  return;
+}
+
+void CPVRManager::SetCurrentPlayingProgram()
+{
+  if (m_isPlayingTV)
+  {
+    if (m_channels_tv[m_CurrentTVChannel-1].m_EPG.size() > 0 && m_clientProps.SupportEPG)
+    {
+      CTVEPGInfoTag epgnow(NULL);
+      CTVEPGInfoTag epgnext(NULL);
+      m_channels_tv[m_CurrentTVChannel-1].GetEPGNextInfo(&epgnext);
+
+      if (m_channels_tv[m_CurrentTVChannel-1].GetEPGNowInfo(&epgnow))
+      {
+        m_channels_tv[m_CurrentTVChannel-1].m_strTitle          = epgnow.m_strTitle;
+        m_channels_tv[m_CurrentTVChannel-1].m_strOriginalTitle  = epgnow.m_strTitle;
+        m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline    = epgnow.m_strPlotOutline;
+        m_channels_tv[m_CurrentTVChannel-1].m_strPlot           = epgnow.m_strPlot;
+        m_channels_tv[m_CurrentTVChannel-1].m_strGenre          = epgnow.m_strGenre;
+        m_channels_tv[m_CurrentTVChannel-1].m_startTime         = epgnow.m_startTime;
+        m_channels_tv[m_CurrentTVChannel-1].m_endTime           = epgnow.m_endTime;
+        m_channels_tv[m_CurrentTVChannel-1].m_duration          = epgnow.m_duration;
+        m_channels_tv[m_CurrentTVChannel-1].m_strNextTitle      = epgnext.m_strTitle;
+
+        if (m_channels_tv[m_CurrentTVChannel-1].m_strPlot.Left(m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline.length()) != m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline && !m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline.IsEmpty())
+          m_channels_tv[m_CurrentTVChannel-1].m_strPlot = m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline + '\n' + m_channels_tv[m_CurrentTVChannel-1].m_strPlot;
+
+        CDateTimeSpan span = m_channels_tv[m_CurrentTVChannel-1].m_startTime - m_channels_tv[m_CurrentTVChannel-1].m_endTime;
+
+        StringUtils::SecondsToTimeString(span.GetSeconds()
+                                         + span.GetMinutes() * 60.
+                                         + span.GetHours() * 3600, m_channels_tv[m_CurrentTVChannel-1].m_strRuntime, TIME_FORMAT_GUESS);
+      }
+      else
+      {
+        m_channels_tv[m_CurrentTVChannel-1].m_strTitle          = g_localizeStrings.Get(18074);
+        m_channels_tv[m_CurrentTVChannel-1].m_strOriginalTitle  = g_localizeStrings.Get(18074);
+        m_channels_tv[m_CurrentTVChannel-1].m_strPlotOutline    = "";
+        m_channels_tv[m_CurrentTVChannel-1].m_strPlot           = "";
+        m_channels_tv[m_CurrentTVChannel-1].m_strGenre          = "";
+        m_channels_tv[m_CurrentTVChannel-1].m_startTime         = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 0, 0, 0)-CDateTimeSpan(0, 1, 0, 0);
+        m_channels_tv[m_CurrentTVChannel-1].m_endTime           = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 23, 0, 0);
+        m_channels_tv[m_CurrentTVChannel-1].m_duration          = CDateTimeSpan(0, 1, 0, 0);
+      }
+
+      m_channels_tv[m_CurrentTVChannel-1].m_strAlbum = m_channels_tv[m_CurrentTVChannel-1].m_strChannel;
+
+      m_channels_tv[m_CurrentTVChannel-1].m_iSeason  = 0; /* set this so xbmc knows it's a tv show */
+      m_channels_tv[m_CurrentTVChannel-1].m_iEpisode = 0;
+      m_channels_tv[m_CurrentTVChannel-1].m_strShowTitle.Format("%i", m_channels_tv[m_CurrentTVChannel-1].m_iChannelNum);
+    }
+  }
+  else if (m_isPlayingRadio)
+  {
+    if (m_channels_radio[m_CurrentRadioChannel-1].m_EPG.size() > 0 && m_clientProps.SupportEPG)
+    {
+      CTVEPGInfoTag epgnow(NULL);
+      CTVEPGInfoTag epgnext(NULL);
+      m_channels_tv[m_CurrentRadioChannel-1].GetEPGNextInfo(&epgnext);
+
+      if (m_channels_radio[m_CurrentRadioChannel-1].GetEPGNowInfo(&epgnow))
+      {
+        m_channels_radio[m_CurrentRadioChannel-1].m_strTitle          = epgnow.m_strTitle;
+        m_channels_radio[m_CurrentRadioChannel-1].m_strOriginalTitle  = epgnow.m_strTitle;
+        m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline    = epgnow.m_strPlotOutline;
+        m_channels_radio[m_CurrentRadioChannel-1].m_strPlot           = epgnow.m_strPlot;
+        m_channels_radio[m_CurrentRadioChannel-1].m_strGenre          = epgnow.m_strGenre;
+        m_channels_radio[m_CurrentRadioChannel-1].m_startTime         = epgnow.m_startTime;
+        m_channels_radio[m_CurrentRadioChannel-1].m_endTime           = epgnow.m_endTime;
+        m_channels_radio[m_CurrentRadioChannel-1].m_duration          = epgnow.m_duration;
+        m_channels_radio[m_CurrentRadioChannel-1].m_strNextTitle      = epgnext.m_strTitle;
+
+        if (m_channels_radio[m_CurrentRadioChannel-1].m_strPlot.Left(m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline.length()) != m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline && !m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline.IsEmpty())
+          m_channels_radio[m_CurrentRadioChannel-1].m_strPlot = m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline + '\n' + m_channels_radio[m_CurrentRadioChannel-1].m_strPlot;
+
+        CDateTimeSpan span = m_channels_radio[m_CurrentRadioChannel-1].m_startTime - m_channels_radio[m_CurrentRadioChannel-1].m_endTime;
+
+        StringUtils::SecondsToTimeString(span.GetSeconds()
+                                         + span.GetMinutes() * 60.
+                                         + span.GetHours() * 3600, m_channels_radio[m_CurrentRadioChannel-1].m_strRuntime, TIME_FORMAT_GUESS);
+      }
+      else
+      {
+        m_channels_radio[m_CurrentRadioChannel-1].m_strTitle          = g_localizeStrings.Get(18074);
+        m_channels_radio[m_CurrentRadioChannel-1].m_strOriginalTitle  = g_localizeStrings.Get(18074);
+        m_channels_radio[m_CurrentRadioChannel-1].m_strPlotOutline    = "";
+        m_channels_radio[m_CurrentRadioChannel-1].m_strPlot           = "";
+        m_channels_radio[m_CurrentRadioChannel-1].m_strGenre          = "";
+        m_channels_radio[m_CurrentRadioChannel-1].m_startTime         = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 0, 0, 0)-CDateTimeSpan(0, 1, 0, 0);
+        m_channels_radio[m_CurrentRadioChannel-1].m_endTime           = CDateTime::GetCurrentDateTime()+CDateTimeSpan(0, 23, 0, 0);
+        m_channels_radio[m_CurrentRadioChannel-1].m_duration          = CDateTimeSpan(0, 1, 0, 0);
+      }
+
+      m_channels_radio[m_CurrentRadioChannel-1].m_strAlbum = m_channels_radio[m_CurrentRadioChannel-1].m_strChannel;
+
+      m_channels_radio[m_CurrentRadioChannel-1].m_iSeason  = 0; /* set this so xbmc knows it's a tv show */
+      m_channels_radio[m_CurrentRadioChannel-1].m_iEpisode = 0;
+      m_channels_radio[m_CurrentRadioChannel-1].m_strShowTitle.Format("%i", m_channels_radio[m_CurrentRadioChannel-1].m_iChannelNum);
+    }
+  }
+}
+
+void CPVRManager::SaveVideoSettings(unsigned int channel_id)
+{
+  if (g_stSettings.m_currentVideoSettings != g_stSettings.m_defaultVideoSettings)
+  {
+    CTVDatabase dbs;
+    dbs.Open();
+    dbs.SetChannelSettings(m_currentClientID, channel_id, g_stSettings.m_currentVideoSettings);
+    dbs.Close();
+  }
+}
+
+void CPVRManager::LoadVideoSettings(unsigned int channel_id, bool update)
+{
+  CTVDatabase dbs;
+  dbs.Open();
+
+  if (update)
+  {
+    CVideoSettings m_savedVideoSettings;
+
+    if (dbs.GetChannelSettings(m_currentClientID, channel_id, m_savedVideoSettings))
+    {
+
+      if (m_savedVideoSettings.m_AudioDelay != g_stSettings.m_currentVideoSettings.m_AudioDelay)
+      {
+        g_stSettings.m_currentVideoSettings.m_AudioDelay = m_savedVideoSettings.m_AudioDelay;
+
+        if (g_application.m_pPlayer)
+          g_application.m_pPlayer->SetAVDelay(g_stSettings.m_currentVideoSettings.m_AudioDelay);
+      }
+
+      if (m_savedVideoSettings.m_AudioStream != g_stSettings.m_currentVideoSettings.m_AudioStream)
+      {
+        g_stSettings.m_currentVideoSettings.m_AudioStream = m_savedVideoSettings.m_AudioStream;
+
+        // only change the audio stream if a different one has been asked for
+        if (g_application.m_pPlayer->GetAudioStream() != g_stSettings.m_currentVideoSettings.m_AudioStream)
+        {
+          g_application.m_pPlayer->SetAudioStream(g_stSettings.m_currentVideoSettings.m_AudioStream);    // Set the audio stream to the one selected
+        }
+      }
+
+      if (m_savedVideoSettings.m_Brightness != g_stSettings.m_currentVideoSettings.m_Brightness ||
+          m_savedVideoSettings.m_Contrast != g_stSettings.m_currentVideoSettings.m_Contrast ||
+          m_savedVideoSettings.m_Gamma != g_stSettings.m_currentVideoSettings.m_Gamma)
+      {
+
+        g_stSettings.m_currentVideoSettings.m_AudioStream = m_savedVideoSettings.m_AudioStream;
+        g_stSettings.m_currentVideoSettings.m_Contrast = m_savedVideoSettings.m_Contrast;
+        g_stSettings.m_currentVideoSettings.m_Gamma = m_savedVideoSettings.m_Gamma;
+
+        CUtil::SetBrightnessContrastGammaPercent(g_stSettings.m_currentVideoSettings.m_Brightness, g_stSettings.m_currentVideoSettings.m_Contrast, g_stSettings.m_currentVideoSettings.m_Gamma, true);
+      }
+
+      if (m_savedVideoSettings.m_NonInterleaved != g_stSettings.m_currentVideoSettings.m_NonInterleaved)
+      {
+        g_stSettings.m_currentVideoSettings.m_NonInterleaved = m_savedVideoSettings.m_NonInterleaved;
+      }
+
+      if (m_savedVideoSettings.m_NoCache != g_stSettings.m_currentVideoSettings.m_NoCache)
+      {
+        g_stSettings.m_currentVideoSettings.m_NoCache = m_savedVideoSettings.m_NoCache;
+      }
+
+      if (m_savedVideoSettings.m_Crop != g_stSettings.m_currentVideoSettings.m_Crop)
+      {
+        g_stSettings.m_currentVideoSettings.m_Crop = m_savedVideoSettings.m_Crop;
+        g_renderManager.AutoCrop(g_stSettings.m_currentVideoSettings.m_Crop);
+      }
+
+      if (m_savedVideoSettings.m_CropLeft != g_stSettings.m_currentVideoSettings.m_CropLeft)
+      {
+        g_stSettings.m_currentVideoSettings.m_CropLeft = m_savedVideoSettings.m_CropLeft;
+      }
+
+      if (m_savedVideoSettings.m_CropRight != g_stSettings.m_currentVideoSettings.m_CropRight)
+      {
+        g_stSettings.m_currentVideoSettings.m_CropRight = m_savedVideoSettings.m_CropRight;
+      }
+
+      if (m_savedVideoSettings.m_CropTop != g_stSettings.m_currentVideoSettings.m_CropTop)
+      {
+        g_stSettings.m_currentVideoSettings.m_CropTop = m_savedVideoSettings.m_CropTop;
+      }
+
+      if (m_savedVideoSettings.m_CropBottom != g_stSettings.m_currentVideoSettings.m_CropBottom)
+      {
+        g_stSettings.m_currentVideoSettings.m_CropBottom = m_savedVideoSettings.m_CropBottom;
+      }
+
+      if (m_savedVideoSettings.m_InterlaceMethod != g_stSettings.m_currentVideoSettings.m_InterlaceMethod)
+      {
+        g_stSettings.m_currentVideoSettings.m_InterlaceMethod = m_savedVideoSettings.m_InterlaceMethod;
+      }
+
+      if (m_savedVideoSettings.m_VolumeAmplification != g_stSettings.m_currentVideoSettings.m_VolumeAmplification)
+      {
+        g_stSettings.m_currentVideoSettings.m_VolumeAmplification = m_savedVideoSettings.m_VolumeAmplification;
+
+        if (g_application.m_pPlayer)
+          g_application.m_pPlayer->SetDynamicRangeCompression((long)(g_stSettings.m_currentVideoSettings.m_VolumeAmplification * 100));
+      }
+
+      if (m_savedVideoSettings.m_OutputToAllSpeakers != g_stSettings.m_currentVideoSettings.m_OutputToAllSpeakers)
+      {
+        g_stSettings.m_currentVideoSettings.m_OutputToAllSpeakers = m_savedVideoSettings.m_OutputToAllSpeakers;
+      }
+
+      if (m_savedVideoSettings.m_CustomZoomAmount != g_stSettings.m_currentVideoSettings.m_CustomZoomAmount)
+      {
+        g_stSettings.m_currentVideoSettings.m_CustomZoomAmount = m_savedVideoSettings.m_CustomZoomAmount;
+      }
+
+      if (m_savedVideoSettings.m_CustomPixelRatio != g_stSettings.m_currentVideoSettings.m_CustomPixelRatio)
+      {
+        g_stSettings.m_currentVideoSettings.m_CustomPixelRatio = m_savedVideoSettings.m_CustomPixelRatio;
+      }
+
+      if (m_savedVideoSettings.m_ViewMode != g_stSettings.m_currentVideoSettings.m_ViewMode)
+      {
+        g_stSettings.m_currentVideoSettings.m_ViewMode = m_savedVideoSettings.m_ViewMode;
+
+        g_renderManager.SetViewMode(g_stSettings.m_currentVideoSettings.m_ViewMode);
+        g_stSettings.m_currentVideoSettings.m_CustomZoomAmount = g_stSettings.m_fZoomAmount;
+        g_stSettings.m_currentVideoSettings.m_CustomPixelRatio = g_stSettings.m_fPixelRatio;
+      }
+
+      if (m_savedVideoSettings.m_SubtitleDelay != g_stSettings.m_currentVideoSettings.m_SubtitleDelay)
+      {
+        g_stSettings.m_currentVideoSettings.m_SubtitleDelay = m_savedVideoSettings.m_SubtitleDelay;
+
+        g_application.m_pPlayer->SetSubTitleDelay(g_stSettings.m_currentVideoSettings.m_SubtitleDelay);
+      }
+
+      if (m_savedVideoSettings.m_SubtitleOn != g_stSettings.m_currentVideoSettings.m_SubtitleOn)
+      {
+        g_stSettings.m_currentVideoSettings.m_SubtitleOn = m_savedVideoSettings.m_SubtitleOn;
+
+        g_application.m_pPlayer->SetSubtitleVisible(g_stSettings.m_currentVideoSettings.m_SubtitleOn);
+      }
+
+      if (m_savedVideoSettings.m_SubtitleStream != g_stSettings.m_currentVideoSettings.m_SubtitleStream)
+      {
+        g_stSettings.m_currentVideoSettings.m_SubtitleStream = m_savedVideoSettings.m_SubtitleStream;
+
+        g_application.m_pPlayer->SetSubtitle(g_stSettings.m_currentVideoSettings.m_SubtitleStream);
+      }
+    }
+  }
+  else
+  {
+    dbs.GetChannelSettings(m_currentClientID, channel_id, g_stSettings.m_currentVideoSettings);
+  }
+
+  dbs.Close();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/PVRManager.h XBMC/xbmc/PVRManager.h
--- XBMC-unpatched/xbmc/PVRManager.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/PVRManager.h	2009-04-16 18:36:18.000000000 +0200
@@ -0,0 +1,213 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "utils/Thread.h"
+#include "FileItem.h"
+#include "TVDatabase.h"
+#include "pvrclients/IPVRClient.h"
+#include "utils/TVChannelInfoTag.h"
+#include "utils/TVRecordInfoTag.h"
+#include "utils/TVTimerInfoTag.h"
+
+#include <vector>
+
+class CPVRManager : IPVRClientCallback
+                  , private CThread
+{
+public:
+  CPVRManager();
+  ~CPVRManager();
+
+  void Start();
+  void Stop();
+  IPVRClient *LoadClient();
+
+  /* Synchronize Thread */
+  virtual void Process();
+
+  /* Manager access */
+  static void RemoveInstance();
+  static void ReleaseInstance();
+  static bool IsInstantiated() { return m_instance != NULL; }
+
+  static CPVRManager* GetInstance();
+  unsigned long GetCurrentClientID() { return m_currentClientID; }
+
+  /* Server handling */
+  bool IsConnected();
+  bool IsSynchronized() { return m_synchronized; }
+  CURL GetConnString();
+
+  /* Feature flags */
+  bool SupportEPG();
+  bool SupportRecording();
+  bool SupportRadio();
+  bool SupportTimers();
+  bool SupportChannelSettings();
+  bool SupportTeletext();
+  bool SupportDirector();
+
+  /* Event handling */
+  void        ConnectionLost() { LostConnection(); }
+  void	      OnClientMessage(const long clientID, const PVR_EVENT clientEvent, const char* msg);
+  const char* TranslateInfo(DWORD dwInfo);
+  static bool HasTimer() { return m_hasTimers;  }
+  static bool IsRecording() { return m_isRecording; }
+  bool        IsRecording(unsigned int channel, bool radio = false);
+  static bool IsPlayingTV() { return m_isPlayingTV; }
+  static bool IsPlayingRadio() { return m_isPlayingRadio; }
+
+  /* General handling */
+  CStdString GetBackendName();
+  CStdString GetBackendVersion();
+  bool GetDriveSpace(long long *total, long long *used, int *percent);
+
+  bool GetEPGInfo(unsigned int number, CFileItem& now, CFileItem& next, bool radio = false);
+  int GetEPGAll(CFileItemList* results, bool radio = false);
+  int GetEPGNow(CFileItemList* results, bool radio = false);
+  int GetEPGNext(CFileItemList* results, bool radio = false);
+  int GetEPGChannel(unsigned int number, CFileItemList* results, bool radio = false);
+
+  /* Channel handling */
+  int GetNumChannels();
+  int GetNumHiddenChannels();
+  int GetTVChannels(CFileItemList* results, int group_id = -1, bool hidden = false);
+  int GetRadioChannels(CFileItemList* results, int group_id = -1, bool hidden = false);
+  void MoveChannel(unsigned int oldindex, unsigned int newindex, bool radio = false);
+  void HideChannel(unsigned int number, bool radio);
+  void SetChannelIcon(unsigned int number, CStdString icon, bool radio = false);
+  CStdString GetChannelIcon(unsigned int number, bool radio = false);
+  CStdString GetNameForChannel(unsigned int number, bool radio = false);
+  bool GetFrontendChannelNumber(unsigned int client_no, int *frontend_no, bool *isRadio);
+  int GetClientChannelNumber(unsigned int frontend_no, bool radio = false);
+  int GetChannelID(unsigned int frontend_no, bool radio = false);
+  int GetGroupList(CFileItemList* results);
+  void AddGroup(const CStdString &newname);
+  bool RenameGroup(unsigned int GroupId, const CStdString &newname);
+  bool DeleteGroup(unsigned int GroupId);
+  bool ChannelToGroup(unsigned int number, unsigned int GroupId, bool radio = false);
+  int GetPrevGroupID(int current_group_id);
+  int GetNextGroupID(int current_group_id);
+  CStdString GetGroupName(int GroupId);
+  int GetFirstChannelForGroupID(int GroupId, bool radio = false);
+
+  /* Backend Channel handling */
+  bool AddBackendChannel(const CFileItem &item);
+  bool DeleteBackendChannel(unsigned int index);
+  bool RenameBackendChannel(unsigned int index, CStdString &newname);
+  bool MoveBackendChannel(unsigned int index, unsigned int newindex);
+  bool UpdateBackendChannel(const CFileItem &item);
+
+  /* Record handling **/
+  int GetNumRecordings();
+  int GetAllRecordings(CFileItemList* results);
+  bool DeleteRecording(unsigned int index);
+  bool RenameRecording(unsigned int index, CStdString &newname);
+
+  /* Timer handling */
+  int GetNumTimers();
+  int GetAllTimers(CFileItemList* results);
+  bool AddTimer(const CFileItem &item);
+  bool DeleteTimer(unsigned int index, bool force = false);
+  bool RenameTimer(unsigned int index, CStdString &newname);
+  bool UpdateTimer(const CFileItem &item);
+  CDateTime NextTimerDate(void);
+
+  /* Live stream handling */
+  bool OpenLiveStream(unsigned int channel, bool radio = false);
+  void CloseLiveStream();
+  void PauseLiveStream(bool OnOff);
+  int ReadLiveStream(BYTE* buf, int buf_size);
+  __int64 SeekLiveStream(__int64 pos, int whence=SEEK_SET);
+  int GetCurrentChannel(bool radio = false);
+  bool ChannelSwitch(unsigned int channel);
+  bool ChannelUp(unsigned int *newchannel);
+  bool ChannelDown(unsigned int *newchannel);
+  int GetTotalTime();
+  int GetStartTime();
+  bool UpdateItem(CFileItem& item);
+  void SetPlayingGroup(int GroupId);
+  int GetPlayingGroup();
+
+  /* Recorded stream handling */
+  bool OpenRecordedStream(unsigned int record);
+  void CloseRecordedStream(void);
+  int ReadRecordedStream(BYTE* buf, int buf_size);
+  __int64 SeekRecordedStream(__int64 pos, int whence=SEEK_SET);
+  __int64 LengthRecordedStream(void);
+  bool RecordChannel(unsigned int channel, bool bOnOff, bool radio = false);
+
+protected:
+  bool ConnectClient();
+  void DisconnectClient();
+  void LostConnection();
+
+private:
+  static CPVRManager   *m_instance;
+  IPVRClient*           m_client;       // pointer to enabled client interface
+  PVR_SERVERPROPS       m_clientProps;  // store the properties of each client locally
+  CTVDatabase           m_database;
+  unsigned long         m_currentClientID;
+  bool                  m_bConnectionLost;
+  bool                  m_synchronized;
+
+  static bool         m_isPlayingTV;
+  static bool         m_isPlayingRadio;
+  static bool         m_isPlayingRecording;
+  static bool         m_isRecording;
+  static bool         m_hasRecordings;
+  static bool         m_hasTimers;
+
+  CStdString          m_nextRecordingDateTime;
+  CStdString          m_nextRecordingChannel;
+  CStdString          m_nextRecordingTitle;
+  CStdString          m_nowRecordingDateTime;
+  CStdString          m_nowRecordingChannel;
+  CStdString          m_nowRecordingTitle;
+
+  int                 m_CurrentRadioChannel;
+  int                 m_CurrentTVChannel;
+  int                 m_CurrentChannelID;
+  int                 m_CurrentGroupID;
+  unsigned int        m_HiddenChannels;
+
+  VECCHANNELS         m_channels_tv;
+  VECCHANNELS         m_channels_radio;
+  VECRECORDINGS       m_recordings;
+  VECTVTIMERS         m_timers;
+  CHANNELGROUPS_DATA  m_channel_group;
+
+  CRITICAL_SECTION    m_critSection;
+
+  DWORD               m_scanStart;
+
+  void                SyncInfo(); // synchronize InfoManager related stuff
+  void                GetChannels();
+  void                GetTimers();
+  void                GetRecordings();
+  CTVChannelInfoTag  *GetChannelByNumber(int Number, bool radio, int SkipGap = 0);
+  CTVChannelInfoTag  *GetChannelByID(int Id, bool radio, int SkipGap = 0);
+  void                SetMusicInfoTag(CFileItem& item, unsigned int channel);
+  void                SetCurrentPlayingProgram();
+  void                LoadVideoSettings(unsigned int channel_id, bool update = true);
+  void                SaveVideoSettings(unsigned int channel_id);
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/ScraperSettings.cpp XBMC/xbmc/ScraperSettings.cpp
--- XBMC-unpatched/xbmc/ScraperSettings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/ScraperSettings.cpp	2009-04-05 19:57:12.000000000 +0200
@@ -68,7 +68,7 @@
     return false;
 
   if (!url && strFunction.Equals("GetSettings")) // entry point
-    m_pluginXmlDoc.Clear();
+    m_addonXmlDoc.Clear();
 
   vector<CStdString> strHTML;
   if (url)
@@ -108,17 +108,17 @@
   }
 
   // check our document
-  if (!m_pluginXmlDoc.RootElement())
+  if (!m_addonXmlDoc.RootElement())
   {
     TiXmlElement xmlRootElement("settings");
-    m_pluginXmlDoc.InsertEndChild(xmlRootElement);
+    m_addonXmlDoc.InsertEndChild(xmlRootElement);
   }
 
   // loop over all tags and append any setting tags
   TiXmlElement* pElement = doc.RootElement()->FirstChildElement("setting");
   while (pElement)
   {
-    m_pluginXmlDoc.RootElement()->InsertEndChild(*pElement);
+    m_addonXmlDoc.RootElement()->InsertEndChild(*pElement);
     pElement = pElement->NextSiblingElement("setting");
   }
 
@@ -136,7 +136,7 @@
     xurl = xurl->NextSiblingElement("url");
   }
 
-  return m_pluginXmlDoc.RootElement()?true:false;
+  return m_addonXmlDoc.RootElement()?true:false;
 }
 
 CStdString CScraperSettings::GetSettings() const
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/ScraperSettings.h XBMC/xbmc/ScraperSettings.h
--- XBMC-unpatched/xbmc/ScraperSettings.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/ScraperSettings.h	2009-04-05 20:23:37.000000000 +0200
@@ -21,11 +21,11 @@
  *
  */
 
-#include "PluginSettings.h"
+#include "settings/AddonSettings.h"
 
 class CScraperUrl;
 
-class CScraperSettings : public CBasicSettings
+class CScraperSettings : public CAddonSettings
 {
 public:
   CScraperSettings();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/settings/AddonSettings.cpp XBMC/xbmc/settings/AddonSettings.cpp
--- XBMC-unpatched/xbmc/settings/AddonSettings.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/settings/AddonSettings.cpp	2009-04-05 20:16:10.000000000 +0200
@@ -0,0 +1,247 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#include "stdafx.h"
+#include "AddonSettings.h"
+#include "Util.h"
+#include "FileSystem/File.h"
+#include "FileSystem/Directory.h"
+
+
+bool CAddonSettings::SaveFromDefault(void)
+{
+  if (!GetAddonRoot()) //if scraper has no settings return false
+    return false;
+
+  TiXmlElement *setting = GetAddonRoot()->FirstChildElement("setting");
+  while (setting)
+  {
+    CStdString id;
+    if (setting->Attribute("id"))
+      id = setting->Attribute("id");
+    CStdString value;
+    if (setting->Attribute("default"))
+      value = setting->Attribute("default");
+    Set(id,value);
+    setting = setting->NextSiblingElement("setting");
+  }
+  return true;
+}
+
+void CAddonSettings::Clear()
+{
+  m_addonXmlDoc.Clear();
+  m_userXmlDoc.Clear();
+}
+
+void CAddonSettings::Set(const CStdString& key, const CStdString& value)
+{
+  if (key == "") return;
+
+  // Try to find the setting and change its value
+  if (!m_userXmlDoc.RootElement())
+  {
+    TiXmlElement node("settings");
+    m_userXmlDoc.InsertEndChild(node);
+  }
+  TiXmlElement *setting = m_userXmlDoc.RootElement()->FirstChildElement("setting");
+  while (setting)
+  {
+    const char *id = setting->Attribute("id");
+    if (id && strcmpi(id, key) == 0)
+    {
+      setting->SetAttribute("value", value.c_str());
+      return;
+    }
+
+    setting = setting->NextSiblingElement("setting");
+  }
+
+  // Setting not found, add it
+  TiXmlElement nodeSetting("setting");
+  nodeSetting.SetAttribute("id", key.c_str());
+  nodeSetting.SetAttribute("value", value.c_str());
+  m_userXmlDoc.RootElement()->InsertEndChild(nodeSetting);
+}
+
+CStdString CAddonSettings::Get(const CStdString& key)
+{
+  if (m_userXmlDoc.RootElement())
+  {
+    // Try to find the setting and return its value
+    TiXmlElement *setting = m_userXmlDoc.RootElement()->FirstChildElement("setting");
+    while (setting)
+    {
+      const char *id = setting->Attribute("id");
+      if (id && strcmpi(id, key) == 0)
+        return setting->Attribute("value");
+
+      setting = setting->NextSiblingElement("setting");
+    }
+  }
+
+  if (m_addonXmlDoc.RootElement())
+  {
+    // Try to find the setting in the addon and return its default value
+    TiXmlElement* setting = m_addonXmlDoc.RootElement()->FirstChildElement("setting");
+    while (setting)
+    {
+      const char *id = setting->Attribute("id");
+      if (id && strcmpi(id, key) == 0 && setting->Attribute("default"))
+        return setting->Attribute("default");
+
+      setting = setting->NextSiblingElement("setting");
+    }
+  }
+
+  // Otherwise return empty string
+  return "";
+}
+
+bool CAddonSettings::Load(const CURL& url)
+{
+  m_url = url;
+
+  // create the users filepath  
+  //TODO remove this specialization
+  CStdString addonData;
+  if (url.GetProtocol() == "plugin")
+    addonData = "plugin_data";
+  else if (url.GetProtocol() == "addon")
+    addonData = "addon_data";
+  else
+    return false;
+
+  m_userFileName.Format("special://profile/%s/%s/%s", addonData.c_str(), url.GetHostName().c_str(), url.GetFileName().c_str());
+  CUtil::RemoveSlashAtEnd(m_userFileName);
+  CUtil::AddFileToFolder(m_userFileName, "settings.xml", m_userFileName);
+
+  // Create our final path
+  //TODO remove this specialization
+  CStdString addonFileName;
+  if (url.GetProtocol() == "plugin")
+    addonFileName = "special://home/plugins/";
+  else if (url.GetProtocol() == "addon")
+    addonFileName = "special://xbmc/";
+  else
+    return false;
+
+  CUtil::AddFileToFolder(addonFileName, url.GetHostName(), addonFileName);
+  CUtil::AddFileToFolder(addonFileName, url.GetFileName(), addonFileName);
+
+  CUtil::AddFileToFolder(addonFileName, "resources", addonFileName);
+  CUtil::AddFileToFolder(addonFileName, "settings.xml", addonFileName);
+
+  addonFileName = addonFileName;
+
+  if (!m_addonXmlDoc.LoadFile(addonFileName))
+  {
+    CLog::Log(LOGERROR, "Unable to load: %s, Line %d\n%s", addonFileName.c_str(), m_addonXmlDoc.ErrorRow(), m_addonXmlDoc.ErrorDesc());
+    return false;
+  }
+
+  // Make sure that the addon XML has the settings element
+  TiXmlElement *setting = m_addonXmlDoc.RootElement();
+  if (!setting || strcmpi(setting->Value(), "settings") != 0)
+  {
+    CLog::Log(LOGERROR, "Error loading Settings %s: cannot find root element 'settings'", addonFileName.c_str());
+    return false;
+  }
+
+  // Load the user saved settings. If it does not exist, create it
+  if (!m_userXmlDoc.LoadFile(m_userFileName))
+  {
+    TiXmlDocument doc;
+    TiXmlDeclaration decl("1.0", "UTF-8", "yes");
+    doc.InsertEndChild(decl);
+
+    TiXmlElement xmlRootElement("settings");
+    doc.InsertEndChild(xmlRootElement);
+
+    m_userXmlDoc = doc;
+
+    // Don't worry about the actual settings, they will be set when the user clicks "Ok"
+    // in the settings dialog
+  }
+
+  return true;
+}
+
+bool CAddonSettings::Save(void)
+{
+  // break down the path into directories
+  CStdString strRoot, strType, strAddon;
+  CUtil::GetDirectory(m_userFileName, strAddon);
+  CUtil::RemoveSlashAtEnd(strAddon);
+  CUtil::GetDirectory(strAddon, strType);
+  CUtil::RemoveSlashAtEnd(strType);
+  CUtil::GetDirectory(strType, strRoot);
+  CUtil::RemoveSlashAtEnd(strRoot);
+
+  // create the individual folders
+  if (!DIRECTORY::CDirectory::Exists(strRoot))
+    DIRECTORY::CDirectory::Create(strRoot);
+  if (!DIRECTORY::CDirectory::Exists(strType))
+    DIRECTORY::CDirectory::Create(strType);
+  if (!DIRECTORY::CDirectory::Exists(strAddon))
+    DIRECTORY::CDirectory::Create(strAddon);
+
+  return m_userXmlDoc.SaveFile(m_userFileName);
+}
+
+TiXmlElement* CAddonSettings::GetAddonRoot()
+{
+  return m_addonXmlDoc.RootElement();
+}
+
+bool CAddonSettings::SettingsExist(const CStdString& strPath)
+{
+  CURL url(strPath);
+
+  //TODO fix all Addon paths
+  CStdString addonFileName;
+  if (url.GetProtocol() == "plugin")
+    addonFileName = "special://home/plugins/";
+  else if (url.GetProtocol() == "addon")
+    addonFileName = "special://xbmc/";
+  else
+    return false;
+
+  // Create our final path
+  CUtil::AddFileToFolder(addonFileName, url.GetHostName(), addonFileName);
+  CUtil::AddFileToFolder(addonFileName, url.GetFileName(), addonFileName);
+
+  CUtil::AddFileToFolder(addonFileName, "resources", addonFileName);
+  CUtil::AddFileToFolder(addonFileName, "settings.xml", addonFileName);
+
+  // Load the settings file to verify it's valid
+  TiXmlDocument xmlDoc;
+  if (!xmlDoc.LoadFile(addonFileName))
+    return false;
+
+  // Make sure that the addon XML has the settings element
+  TiXmlElement *setting = xmlDoc.RootElement();
+  if (!setting || strcmpi(setting->Value(), "settings") != 0)
+    return false;
+
+  return true;
+}
+
+CAddonSettings g_currentAddonSettings;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/settings/AddonSettings.h XBMC/xbmc/settings/AddonSettings.h
--- XBMC-unpatched/xbmc/settings/AddonSettings.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/settings/AddonSettings.h	2009-04-05 20:21:38.000000000 +0200
@@ -0,0 +1,58 @@
+#ifndef ADDONSETTINGS_H_
+#define ADDONSETTINGS_H_
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "tinyXML/tinyxml.h"
+#include "URL.h"
+#include "Settings.h"
+
+class CAddonSettings
+{
+public:
+  CAddonSettings() {}
+  virtual ~CAddonSettings() {}
+
+  static bool SettingsExist(const CStdString &strPath);
+
+  bool SaveFromDefault(void);
+  virtual bool Load(const CURL& url);
+  virtual bool Save(void);
+  void Clear();
+
+  void Set(const CStdString& key, const CStdString& value);
+  CStdString Get(const CStdString& key);
+
+  TiXmlElement* GetAddonRoot();
+
+protected:
+  TiXmlDocument   m_userXmlDoc;
+  TiXmlDocument   m_addonXmlDoc;
+
+private:
+  CStdString      m_id;
+  CURL            m_url;
+  CStdString      m_userFileName;
+};
+
+extern CAddonSettings g_currentAddonSettings;
+
+#endif
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/settings/DllAddonSettings.h XBMC/xbmc/settings/DllAddonSettings.h
--- XBMC-unpatched/xbmc/settings/DllAddonSettings.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/settings/DllAddonSettings.h	2009-04-05 20:06:16.000000000 +0200
@@ -0,0 +1,191 @@
+#pragma once
+/*
+*      Copyright (C) 2005-2009 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+typedef struct
+{
+public:
+  int           type;
+  char*         name;
+  int           current;
+  char**        entry;
+  unsigned int  entry_elements;
+} DllSettingStruct;
+
+////////////////////////////////////////////////////////////////////
+// The DllSetting class for GUI settings for addons.
+////////////////////////////////////////////////////////////////////
+class DllSetting
+{
+public:
+  enum SETTING_TYPE {
+    NONE=0, 
+    CHECK, 
+    SPIN,
+
+  };
+
+  DllSetting(SETTING_TYPE t, const char *label)
+  {
+    name = NULL;
+    if (label)
+    {
+      name = new char[strlen(label)+1];
+      strcpy(name, label);
+    }
+    current = 0;
+    type = t;
+  }
+
+  DllSetting(const DllSetting &rhs) // copy constructor
+  {
+    name = NULL;
+    if (rhs.name)
+    {
+      name = new char[strlen(rhs.name)+1];
+      strcpy(name, rhs.name);
+    }
+    current = rhs.current;
+    type = rhs.type;
+    for (unsigned int i = 0; i < rhs.entry.size(); i++)
+    {
+      char *lab = new char[strlen(rhs.entry[i]) + 1];
+      strcpy(lab, rhs.entry[i]);
+      entry.push_back(lab);
+    }
+  }
+
+  ~DllSetting()
+  {
+    if (name)
+      delete[] name;
+    for (unsigned int i=0; i < entry.size(); i++)
+      delete[] entry[i];
+  }
+
+  void AddEntry(const char *label)
+  {
+    if (!label || type != SPIN) return;
+    char *lab = new char[strlen(label) + 1];
+    strcpy(lab, label);
+    entry.push_back(lab);
+  }
+
+  // data members
+  SETTING_TYPE type;
+  char*        name;
+  int          current;
+  std::vector<const char *> entry;
+};
+
+class DllUtils
+{
+public:
+
+  static unsigned int VecToStruct(std::vector<DllSetting> &vecSet, DllSettingStruct*** sSet) 
+  {
+    *sSet = NULL;
+    if(vecSet.size() == 0)
+      return 0;
+
+    unsigned int uiElements=0;
+
+    *sSet = (DllSettingStruct**)malloc(vecSet.size()*sizeof(DllSettingStruct*));
+    for(unsigned int i=0;i<vecSet.size();i++)
+    {
+      (*sSet)[i] = NULL;
+      (*sSet)[i] = (DllSettingStruct*)malloc(sizeof(DllSettingStruct));
+      (*sSet)[i]->name = NULL;
+      uiElements++;
+
+      if (vecSet[i].name)
+      {
+        (*sSet)[i]->name = (char*)malloc(strlen(vecSet[i].name)*sizeof(char*)+1);
+        strcpy((*sSet)[i]->name, vecSet[i].name);
+        (*sSet)[i]->type = vecSet[i].type;
+        (*sSet)[i]->current = vecSet[i].current;
+        if(vecSet[i].type == DllSetting::SPIN && vecSet[i].entry.size() > 0)
+        {
+          (*sSet)[i]->entry = (char**)malloc(vecSet[i].entry.size()*sizeof(char**));
+          (*sSet)[i]->entry_elements = 0;
+          for(unsigned int j=0;j<vecSet[i].entry.size();j++)
+          {
+            (*sSet)[i]->entry[j] = NULL;
+            if(strlen(vecSet[i].entry[j]) > 0)
+            {
+              (*sSet)[i]->entry[j] = (char*)malloc(strlen(vecSet[i].entry[j])*sizeof(char*)+1);
+              strcpy((*sSet)[i]->entry[j], vecSet[i].entry[j]);
+              (*sSet)[i]->entry_elements++;
+            }
+          }
+        }
+      }
+    }
+    return uiElements;
+  }
+
+  static void StructToVec(unsigned int iElements, DllSettingStruct*** sSet, std::vector<DllSetting> *vecSet) 
+  {
+    if(iElements == 0)
+      return;
+
+    vecSet->clear();
+    for(unsigned int i=0;i<iElements;i++)
+    {
+      DllSetting vSet((DllSetting::SETTING_TYPE)(*sSet)[i]->type, (*sSet)[i]->name);
+      if((*sSet)[i]->type == DllSetting::SPIN)
+      {
+        for(unsigned int j=0;j<(*sSet)[i]->entry_elements;j++)
+        {
+          vSet.AddEntry((*sSet)[i]->entry[j]);
+        }
+      }
+      vSet.current = (*sSet)[i]->current;
+      vecSet->push_back(vSet);
+    }
+  }
+
+  static void FreeStruct(unsigned int iElements, DllSettingStruct*** sSet)
+  {
+    if(iElements == 0)
+      return;
+
+    for(unsigned int i=0;i<iElements;i++)
+    {
+      if((*sSet)[i]->type == DllSetting::SPIN)
+      {
+        for(unsigned int j=0;j<(*sSet)[i]->entry_elements;j++)
+        {
+          if((*sSet)[i]->entry[j])
+            free((*sSet)[i]->entry[j]);
+        }
+        if((*sSet)[i]->entry)
+          free((*sSet)[i]->entry);
+      }
+      if((*sSet)[i]->name)
+        free((*sSet)[i]->name);
+      if((*sSet)[i])
+        free((*sSet)[i]);
+    }
+    if(*sSet)
+      free(*sSet);
+  }
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/settings/Makefile XBMC/xbmc/settings/Makefile
--- XBMC-unpatched/xbmc/settings/Makefile	2009-04-22 19:10:25.000000000 +0200
+++ XBMC/xbmc/settings/Makefile	2009-04-05 20:06:48.000000000 +0200
@@ -1,6 +1,6 @@
 INCLUDES=-I../ -I../../guilib -I../linux
 
-SRCS=VideoSettings.cpp
+SRCS=VideoSettings.cpp AddonSettings.cpp
 
 LIB=settings.a
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Settings.cpp XBMC/xbmc/Settings.cpp
--- XBMC-unpatched/xbmc/Settings.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Settings.cpp	2009-04-13 21:49:00.000000000 +0200
@@ -32,6 +32,7 @@
 #include "LangCodeExpander.h"
 #include "ButtonTranslator.h"
 #include "XMLUtils.h"
+#include "utils/RegExp.h"
 #include "GUIPassword.h"
 #include "GUIAudioManager.h"
 #include "AudioContext.h"
@@ -57,6 +58,7 @@
 using namespace XFILE;
 using namespace DIRECTORY;
 using namespace MEDIA_DETECT;
+using namespace ADDON;
 
 struct CSettings::stSettings g_stSettings;
 struct CSettings::AdvancedSettings g_advancedSettings;
@@ -365,6 +367,8 @@
   }
 
   // clear sources, then load xml file...
+  TiXmlDocument xmlDoc;
+  TiXmlElement *pRootElement = NULL;
   m_fileSources.clear();
   m_musicSources.clear();
   m_pictureSources.clear();
@@ -372,8 +376,6 @@
   m_videoSources.clear();
   CStdString strXMLFile = GetSourcesFile();
   CLog::Log(LOGNOTICE, "%s", strXMLFile.c_str());
-  TiXmlDocument xmlDoc;
-  TiXmlElement *pRootElement = NULL;
   if ( xmlDoc.LoadFile( strXMLFile ) )
   {
     pRootElement = xmlDoc.RootElement();
@@ -424,6 +426,9 @@
     GetSources(pRootElement, "video", m_videoSources, m_defaultVideoSource);
   }
 
+  // Load addons.xml and populate m_(...)Addons;
+  LoadAddons();
+
   bXboxMediacenter = true;
 
   LoadRSSFeeds();
@@ -497,6 +502,56 @@
   return defaultShare;
 }
 
+VECADDONS *CSettings::GetAddonsFromType(const AddonType &type)
+{
+  switch (type)
+  {
+  case ADDON_PVRDLL:
+    return &g_settings.m_pvrAddons;
+  default:
+    return NULL;
+  }
+}
+
+void CSettings::LoadAddons()
+{
+  CStdString strXMLFile;
+  TiXmlDocument xmlDoc;
+  TiXmlElement *pRootElement;
+  strXMLFile = GetAddonsFile();
+  CLog::Log(LOGNOTICE, "%s", strXMLFile.c_str());
+  if ( xmlDoc.LoadFile( strXMLFile ) )
+  {
+    pRootElement = xmlDoc.RootElement();
+    CStdString strValue;
+    if (pRootElement)
+      strValue = pRootElement->Value();
+    if ( strValue != "addons")
+      CLog::Log(LOGERROR, "%s addons.xml file does not contain <addons>", __FUNCTION__);
+  }
+  else if (CFile::Exists(strXMLFile))
+    CLog::Log(LOGERROR, "%s Error loading %s: Line %d, %s", __FUNCTION__, strXMLFile.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+
+  if (pRootElement)
+  { // parse addons...
+    GetAddons(pRootElement, ADDON_PVRDLL);
+    // and so on
+  }
+}
+bool CSettings::GetAddonFromGUID(const CStdString &guid, CAddon &addon)
+{
+  /* iterate through alladdons vec and return matched Addon */
+  for (int i = 0; i < m_allAddons.size(); i++)
+  {
+    if (m_allAddons[i].m_guid = guid)
+    {
+      addon = m_allAddons[i];
+      return true;
+    }
+  }
+  return false;
+}
+
 void CSettings::GetSources(const TiXmlElement* pRootElement, const CStdString& strTagName, VECSOURCES& items, CStdString& strDefault)
 {
   //CLog::Log(LOGDEBUG, "  Parsing <%s> tag", strTagName.c_str());
@@ -684,6 +739,91 @@
   return false;
 }
 
+void CSettings::GetAddons(const TiXmlElement* pRootElement, const AddonType &type)
+{
+  CStdString strTagName;
+  switch (type)
+  {
+  case ADDON_PVRDLL:
+      strTagName = "pvr";
+      break;
+
+  default:
+    return;
+  }
+
+  VECADDONS *addons = GetAddonsFromType(type);
+  addons->clear();
+
+  const TiXmlNode *pChild = pRootElement->FirstChild(strTagName.c_str());
+  if (pChild)
+  {
+    pChild = pChild->FirstChild();
+    while (pChild > 0)
+    {
+      CStdString strValue = pChild->Value();
+      if (strValue == "addon")
+      {
+        CAddon addon;
+        if (GetAddon(type, pChild, addon))
+        {
+          addons->push_back(addon);
+        }
+      }
+      pChild = pChild->NextSibling();
+    }
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "  <%s> tag is missing or addons.xml is malformed", strTagName.c_str());
+  }
+}
+
+bool CSettings::GetAddon(const AddonType &type, const TiXmlNode *node, CAddon &addon)
+{
+  // name
+  const TiXmlNode *pNodeName = node->FirstChild("name");
+  CStdString strName;
+  if (pNodeName && pNodeName->FirstChild())
+  {
+    strName = pNodeName->FirstChild()->Value();
+  }
+  else
+    return false;
+
+  // path
+  const TiXmlNode *pNodePath = node->FirstChild("path");
+  if (pNodePath && pNodePath->FirstChild())
+  {
+    addon.m_strPath = pNodePath->FirstChild()->Value();
+  }
+  else
+    return false;
+
+  // validate path and addon package
+  if (!AddonFromInfoXML(addon.m_strPath, addon))
+    return false;
+
+  if (addon.m_addonType != type)
+  {
+    // something really weird happened
+    return false;
+  }
+
+  // get custom thumbnail
+  const TiXmlNode *pThumbnailNode = node->FirstChild("thumbnail");
+  if (pThumbnailNode && pThumbnailNode->FirstChild())
+  {
+    addon.m_icon = pThumbnailNode->FirstChild()->Value();
+  }
+
+  // get custom name
+  if (strName != addon.m_strName)
+    addon.m_strName = strName;
+
+  return true;
+}
+
 bool CSettings::GetString(const TiXmlElement* pRootElement, const char *tagName, CStdString &strValue)
 {
   CStdString defaultValue = strValue;
@@ -1350,6 +1490,13 @@
 
   }
 
+  // PVRClient
+  pElement = pRootElement->FirstChildElement("pvr");
+  if (pElement)
+  {
+    GetInteger(pElement, "epgblocksize", g_advancedSettings.m_iPVREPGBlockSize, 5, 5, 10);
+  }
+
   // picture exclude regexps
   TiXmlElement* pPictureExcludes = pRootElement->FirstChildElement("pictureexcludes");
   if (pPictureExcludes)
@@ -2281,6 +2428,24 @@
   return SaveSources();
 }
 
+bool CSettings::DisableAddon(const CStdString &guid, const AddonType &type)
+{
+  VECADDONS *addons = GetAddonsFromType(type);
+  if (!addons) return false;
+
+  for (IVECADDONS it = addons->begin(); it != addons->end(); it++)
+  {
+    if ((*it).m_guid == guid)
+    {
+      CLog::Log(LOGDEBUG,"found addon, disabling!");
+      addons->erase(it);
+      break;
+    }
+  }
+
+  return SaveAddons();
+}
+
 bool CSettings::AddShare(const CStdString &type, const CMediaSource &share)
 {
   VECSOURCES *pShares = GetSourcesFromType(type);
@@ -2334,6 +2499,253 @@
   return doc.SaveFile(g_settings.GetSourcesFile());
 }
 
+bool CSettings::SaveAddons()
+{
+  // TODO: Should we be specifying utf8 here??
+  TiXmlDocument doc;
+  TiXmlElement xmlRootElement("addons");
+  TiXmlNode *pRoot = doc.InsertEndChild(xmlRootElement);
+  if (!pRoot) return false;
+
+  // ok, now run through and save each addons section
+  SetAddons(pRoot, ADDON_PVRDLL, g_settings.m_pvrAddons);
+  return doc.SaveFile(g_settings.GetAddonsFile());
+}
+
+void CSettings::GetAllAddons()
+{
+  //TODO only currently scans for pvr dlls & only caches packaged icon thumbnail
+  m_allAddons.clear();
+
+  CFileItemList items;
+  if (!CDirectory::GetDirectory("special://xbmc/pvrclients/", items, ADDON_PVRDLL_EXT, false))
+    return;
+
+  items.m_strPath.Replace("special://xbmc/", "addon://");
+
+  // for each folder found
+  for (int i = 0; i < items.Size(); ++i)
+  {
+    CFileItemPtr item = items[i];
+
+    // read info.xml and generate the addon
+    CAddon addon;
+    if (!AddonFromInfoXML(item->m_strPath, addon))
+    {
+      CLog::Log(LOGERROR, "PVR: Error reading %s/info.xml, bypassing package", item->m_strPath.c_str());
+      continue;
+    }
+
+    // check for/cache icon thumbnail
+    item->SetThumbnailImage("");
+    item->SetCachedProgramThumb();
+    if (!item->HasThumbnail())
+      item->SetUserProgramThumb();
+    if (!item->HasThumbnail())
+    {
+      CFileItem item2(item->m_strPath);
+      CUtil::AddFileToFolder(item->m_strPath, "default" + ADDON_PVRDLL_EXT, item2.m_strPath);
+      item2.m_bIsFolder = false;
+      item2.SetCachedProgramThumb();
+      if (!item2.HasThumbnail())
+        item2.SetUserProgramThumb();
+      if (item2.HasThumbnail())
+      {
+        XFILE::CFile::Cache(item2.GetThumbnailImage(), item->GetCachedProgramThumb());
+      }
+    }
+
+    //TODO fix all addon paths
+    item->m_strPath.Replace("special://xbmc/", "addon://");
+    addon.m_strPath = item->m_strPath;
+
+    // everything ok, add to available addons
+    m_allAddons.push_back(addon);
+  }
+}
+
+bool CSettings::AddonFromInfoXML(const CStdString &path, CAddon &addon)
+{
+  // First check that we can load info.xml
+  CStdString strPath(path);
+  CUtil::AddFileToFolder(strPath, "info.xml", strPath);
+
+  //TODO fix all Addon paths
+  strPath.Replace("addon://", "special://xbmc/");
+
+  TiXmlDocument xmlDoc;
+  if (!xmlDoc.LoadFile(strPath))
+  {
+    CLog::Log(LOGERROR, "Unable to load: %s, Line %d\n%s", strPath.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    return false;
+  }
+
+  TiXmlElement *element = xmlDoc.RootElement();
+  if (!element || strcmpi(element->Value(), "addoninfo") != 0)
+  {
+    CLog::Log(LOGERROR, "Addon: Error loading %s: cannot find root element 'addon'", strPath.c_str());
+    return false;
+  }
+
+  /* Steps required to meet package requirements
+   * 1. guid exists and is valid
+   * 2. type exists and is valid
+   * 3. version exists
+   * 4. operating system matches ours //TODO
+   * 5. summary exists */
+
+  /* Read guid */
+  CStdString guid;
+  element = xmlDoc.RootElement()->FirstChildElement("guid");
+  if (!element)
+  {
+    CLog::Log(LOGERROR, "Addon: %s does not contain the <guid> element, ignoring", strPath.c_str());
+    return false;
+  }
+  guid = element->GetText(); // grab guid
+
+  /* Validate guid*/
+  CRegExp guidRE;
+  guidRE.RegComp(ADDON_GUID_RE.c_str());
+  if (guidRE.RegFind(guid.c_str()) != 0)
+  {
+    CLog::Log(LOGERROR, "Addon: %s has invalid <guid> element, ignoring", strPath.c_str());
+    return false;
+  }
+  addon.m_guid = guid; // guid was validated
+
+  /* Validate type */
+  element = xmlDoc.RootElement()->FirstChildElement("type");
+  int type = atoi(element->GetText());
+  if (type != 3)
+  {
+    CLog::Log(LOGERROR, "Addon: %s has invalid type identifier: %d", strPath.c_str(), type);
+    return false;
+  }
+  addon.m_addonType = (AddonType) type; // type was validated //TODO this cast to AddonType
+
+  /* Retrieve Name */
+  CStdString name;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("name");
+  if (!element)
+  {
+    CLog::Log(LOGERROR, "Addon: %s missing <name> element, ignoring", strPath.c_str());
+    return false;
+  }
+  addon.m_strName = element->GetText();
+
+  /* Retrieve version */
+  CStdString version;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("version");
+  if (!element)
+  {
+    CLog::Log(LOGERROR, "Addon: %s missing <version> element, ignoring", strPath.c_str());
+    return false;
+  }
+  /* Validate version */
+  version = element->GetText();
+  CRegExp versionRE;
+  versionRE.RegComp(ADDON_VERSION_RE.c_str());
+  if (versionRE.RegFind(version.c_str()) != 0)
+  {
+    CLog::Log(LOGERROR, "Addon: %s has invalid <version> element, ignoring", strPath.c_str());
+    return false;
+  }
+  addon.m_strVersion = version; // guid was validated
+
+  /* Retrieve summary */
+  CStdString summary;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("summary");
+  if (!element)
+  {
+    CLog::Log(LOGERROR, "Addon: %s missing <summary> element, ignoring", strPath.c_str());
+    return false;
+  }
+  addon.m_summary = element->GetText(); // summary was present
+
+  /*** Beginning of optional fields ***/
+  /* Retrieve description */
+  CStdString description;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("description");
+  if (element)
+    addon.m_strDesc = element->GetText();
+
+  /* Retrieve creator */
+  CStdString creator;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("creator");
+  if (element)
+    addon.m_strCreator = element->GetText();
+
+  /* Retrieve disclaimer */
+  CStdString disclaimer;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("disclaimer");
+  if (element)
+    addon.m_disclaimer = element->GetText();
+
+  /* Retrieve library file name */
+  CStdString library;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("library");
+  if (element)
+    addon.m_strLibName = element->GetText();
+
+  /* Retrieve library file name */
+  CStdString icon;
+  element = NULL;
+  element = xmlDoc.RootElement()->FirstChildElement("icon");
+  if (element)
+    addon.m_icon = path + element->GetText();
+
+  /*** end of optional fields ***/
+
+  /* Everything's valid */
+
+  CLog::Log(LOGINFO, "Addon: %s retrieved. Name: %s, GUID: %s, Version: %s",
+            strPath.c_str(), addon.m_strName.c_str(), addon.m_guid.c_str(), addon.m_strVersion.c_str());
+
+  return true;
+}
+
+bool CSettings::SetAddons(TiXmlNode *root, const AddonType &type, const VECADDONS &addons)
+{
+  CStdString strType;
+  switch (type)
+  {
+  case ADDON_PVRDLL: {
+      strType = "pvr";
+      break;
+    }
+  default:
+    return false;
+  }
+
+  TiXmlElement sectionElement(strType);
+  TiXmlNode *sectionNode = root->InsertEndChild(sectionElement);
+  if (sectionNode)
+  {
+    for (unsigned int i = 0; i < addons.size(); i++)
+    {
+      const CAddon &addon = addons[i];
+      TiXmlElement element("addon");
+
+      XMLUtils::SetString(&element, "name", addon.m_strName);
+      XMLUtils::SetPath(&element, "path", addon.m_strPath);
+
+      if (!addon.m_icon.IsEmpty())
+        XMLUtils::SetPath(&element, "thumbnail", addon.m_icon);
+
+      sectionNode->InsertEndChild(element);
+    }
+  }
+  return true;
+}
+
 bool CSettings::SetSources(TiXmlNode *root, const char *section, const VECSOURCES &shares, const char *defaultPath)
 {
   TiXmlElement sectionElement(section);
@@ -2780,6 +3192,17 @@
   return folder;
 }
 
+CStdString CSettings::GetAddonsFile() const
+{
+  CStdString folder;
+  if (m_vecProfiles[m_iLastLoadedProfileIndex].hasAddons())
+    CUtil::AddFileToFolder(GetProfileUserDataFolder(),"addons.xml",folder);
+  else
+    CUtil::AddFileToFolder(GetUserDataFolder(),"addons.xml",folder);
+
+  return folder;
+}
+
 CStdString CSettings::GetSkinFolder() const
 {
   CStdString folder;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/Settings.h XBMC/xbmc/Settings.h
--- XBMC-unpatched/xbmc/Settings.h	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/Settings.h	2009-04-16 16:58:14.000000000 +0200
@@ -37,6 +37,7 @@
 #include "GUISettings.h"
 #include "Profile.h"
 #include "MediaSource.h"
+#include "utils/Addon.h"
 #include "XBVideoConfig.h"
 #include "ViewState.h"
 
@@ -120,6 +121,10 @@
   bool UpdateShare(const CStdString &type, const CStdString oldName, const CMediaSource &share);
   bool AddShare(const CStdString &type, const CMediaSource &share);
 
+  bool GetAddonFromGUID(const CStdString &guid, ADDON::CAddon &addon);
+  ADDON::VECADDONS *GetAddonsFromType(const ADDON::AddonType &type);
+  bool DisableAddon(const CStdString &addon, const ADDON::AddonType &type);
+
   int TranslateSkinString(const CStdString &setting);
   const CStdString &GetSkinString(int setting) const;
   void SetSkinString(int setting, const CStdString &label);
@@ -259,6 +264,8 @@
     int m_curlconnecttimeout;
     int m_curllowspeedtime;
 
+    int m_iPVREPGBlockSize;
+
 #ifdef HAS_SDL
     bool m_fullScreen;
     bool m_startFullScreen;
@@ -377,6 +384,9 @@
   VECSOURCES m_musicSources;
   VECSOURCES m_videoSources;
 
+  ADDON::VECADDONS  m_allAddons;
+  ADDON::VECADDONS  m_pvrAddons;
+
   CStdString m_defaultProgramSource;
   CStdString m_defaultMusicSource;
   CStdString m_defaultPictureSource;
@@ -419,6 +429,7 @@
   CStdString GetGameSaveThumbFolder() const;
   CStdString GetProfilesThumbFolder() const;
   CStdString GetSourcesFile() const;
+  CStdString GetAddonsFile() const;
   CStdString GetSkinFolder() const;
   CStdString GetSkinFolder(const CStdString& skinName) const;
   CStdString GetScriptsFolder() const;
@@ -435,7 +446,11 @@
 
   bool SaveSettings(const CStdString& strSettingsFile, CGUISettings *localSettings = NULL) const;
 
+  void LoadAddons();
   bool SaveSources();
+  bool SaveAddons();
+
+  void GetAllAddons();
 
 protected:
   // these 3 don't have a default - used for advancedsettings.xml
@@ -455,6 +470,9 @@
   bool GetSource(const CStdString &category, const TiXmlNode *source, CMediaSource &share);
   void GetSources(const TiXmlElement* pRootElement, const CStdString& strTagName, VECSOURCES& items, CStdString& strDefault);
   bool SetSources(TiXmlNode *root, const char *section, const VECSOURCES &shares, const char *defaultPath);
+  bool SetAddons(TiXmlNode *root, const ADDON::AddonType &type, const ADDON::VECADDONS &addons);
+  void GetAddons(const TiXmlElement* pRootElement, const ADDON::AddonType &type);
+  bool GetAddon(const ADDON::AddonType &type, const TiXmlNode *node, ADDON::CAddon &addon);
   void GetViewState(const TiXmlElement* pRootElement, const CStdString& strTagName, CViewState &viewState, SORT_METHOD defaultSort = SORT_METHOD_LABEL, int defaultView = DEFAULT_VIEW_LIST);
 
   // functions for writing xml files
@@ -470,6 +488,8 @@
   void LoadSkinSettings(const TiXmlElement* pElement);
   void SaveSkinSettings(TiXmlNode *pElement) const;
 
+  bool AddonFromInfoXML(const CStdString &path, ADDON::CAddon &addon);
+
   // Advanced settings
   void LoadAdvancedSettings();
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/TVDatabase.cpp XBMC/xbmc/TVDatabase.cpp
--- XBMC-unpatched/xbmc/TVDatabase.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/TVDatabase.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,1061 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+#include "stdafx.h"
+#include "TVDatabase.h"
+#include "utils/GUIInfoManager.h"
+
+using namespace std;
+
+using namespace dbiplus;
+
+#define TV_DATABASE_VERSION 3
+#define TV_DATABASE_OLD_VERSION 2
+#define TV_DATABASE_NAME "MyTV1.db"
+
+CTVDatabase::CTVDatabase(void)
+{
+  m_preV2version      = TV_DATABASE_OLD_VERSION;
+  m_version           = TV_DATABASE_VERSION;
+  m_strDatabaseFile   = TV_DATABASE_NAME;
+}
+
+CTVDatabase::~CTVDatabase(void)
+{
+}
+
+bool CTVDatabase::CreateTables()
+{
+  try
+  {
+    CDatabase::CreateTables();
+
+    CLog::Log(LOGINFO, "TV: Creating tables");
+
+    CLog::Log(LOGINFO, "TV: Creating Clients table");
+    m_pDS->exec("CREATE TABLE Clients (idClient integer primary key, Name text)\n");
+
+    CLog::Log(LOGINFO, "TV: Creating Last Channel table");
+    m_pDS->exec("CREATE TABLE LastChannel (idClient integer, idChannel integer primary key, Number integer, Name text)\n");
+
+    CLog::Log(LOGINFO, "TV: Creating Channels table");
+    m_pDS->exec("CREATE TABLE Channels (idClient integer, idChannel integer primary key, Name text, "
+                "ClientNumber integer, XBMCNumber integer, IconPath text, GroupID integer,"
+                "encrypted bool, radio bool, hide bool, strFileNameAndPath text)\n");
+
+    CLog::Log(LOGINFO, "TV: Creating GuideData table");
+    m_pDS->exec("CREATE TABLE GuideData (idClient integer, idBouquet integer, idChannel integer, strChannel text, "
+                "idProgramme integer, strTitle text, strOriginalTitle text, strPlotOutline text, "
+                "strPlot text, strGenre text, StartTime datetime, EndTime datetime, strExtra text, "
+                "strFileNameAndPath text, commFree bool, isRecording bool, "
+                "GenreType integer, GenreSubType integer, firstAired datetime, "
+                "repeat bool, AutoSwitch integer, idUniqueBroadcast integer primary key)\n");
+    m_pDS->exec("CREATE UNIQUE INDEX idx_UniqueBroadcast on GuideData(idProgramme, idChannel, idBouquet, StartTime desc)\n"); /// pointless?
+
+    CLog::Log(LOGINFO, "TV: Creating ChannelSettings table");
+    m_pDS->exec("CREATE TABLE ChannelSettings ( idClient integer, idChannel integer primary key, Interleaved bool, NoCache bool, Deinterlace bool, FilmGrain integer, "
+                "ViewMode integer, ZoomAmount float, PixelRatio float, AudioStream integer, SubtitleStream integer, "
+                "SubtitleDelay float, SubtitlesOn bool, Brightness integer, Contrast integer, Gamma integer, "
+                "VolumeAmplification float, AudioDelay float, OutputToAllSpeakers bool, ResumeTime integer, Crop bool, CropLeft integer, "
+                "CropRight integer, CropTop integer, CropBottom integer)\n");
+    m_pDS->exec("CREATE UNIQUE INDEX ix_ChannelSettings ON ChannelSettings (idChannel)\n");
+
+    CLog::Log(LOGINFO, "TV: Creating Groups table");
+    m_pDS->exec("CREATE TABLE Groups (idGroup integer primary key, idClient integer, Name text)\n");
+    m_pDS->exec("CREATE UNIQUE INDEX ix_grouplinkClient ON Groups (idGroup, idClient)\n");
+
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to create TV tables:%i", __FUNCTION__, (int)GetLastError());
+    return false;
+  }
+
+  return true;
+}
+
+bool CTVDatabase::CommitTransaction()
+{
+  if (CDatabase::CommitTransaction())
+  {
+    // number of items in the db has likely changed, so reset the infomanager cache
+    g_infoManager.ResetPersistentCache(); /// what is this
+    return true;
+  }
+
+  return false;
+}
+
+int CTVDatabase::GetLastChannel(DWORD clientID)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    CStdString SQL=FormatSQL("select * from LastChannel WHERE LastChannel.idClient = '%u'", clientID);
+
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      int channelId = m_pDS->fv("idChannel").get_asInteger();
+
+      m_pDS->close();
+      return channelId;
+    }
+    else
+    {
+      m_pDS->close();
+      return -1;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+  }
+
+  return -1;
+}
+
+bool CTVDatabase::UpdateLastChannel(DWORD clientID, unsigned int channelID, CStdString m_strChannel)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    if (channelID < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL=FormatSQL("select * from LastChannel WHERE LastChannel.idChannel = '%u' AND LastChannel.idClient = '%u'", channelID, clientID);
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      CStdString SQL=FormatSQL("update LastChannel set idClient=%i,Number=%i,Name='%s' where idChannel=%i",
+                               clientID, channelID, m_strChannel.c_str(), channelID);
+
+      m_pDS->exec(SQL.c_str());
+      return true;
+    }
+    else   // add the items
+    {
+      m_pDS->close();
+      SQL=FormatSQL("insert into LastChannel ( idClient,idChannel,Number,Name)"
+                    " values ('%i','%i','%i','%s')\n",
+                    clientID, channelID, channelID, m_strChannel.c_str());
+      m_pDS->exec(SQL.c_str());
+      return true;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%i) failed", __FUNCTION__, channelID);
+    return false;
+  }
+}
+
+long CTVDatabase::AddClient(const CStdString &client)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    long clientId;
+
+    clientId = GetClientId(client);
+
+    if (clientId < 0)
+    {
+      CStdString SQL=FormatSQL("insert into Clients (idClient, Name) values (NULL, '%s')\n", client.c_str());
+      m_pDS->exec(SQL.c_str());
+      clientId = (long)sqlite3_last_insert_rowid(m_pDB->getHandle());
+    }
+
+    return clientId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, client.c_str());
+  }
+
+  return -1;
+}
+
+long CTVDatabase::AddEPG(DWORD clientID, const CTVEPGInfoTag &info)
+{
+  try
+  {
+    if (clientID < 0) return -1;
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    long epgId = info.m_idEPG;
+
+    if (epgId < 0)
+    {
+      CStdString SQL1=FormatSQL("insert into GuideData (idClient, idBouquet, idChannel, strChannel, "
+                                "strTitle, strOriginalTitle, strPlotOutline, "
+                                "strPlot, strGenre, StartTime, EndTime, strExtra, "
+                                "strFileNameAndPath, commFree, "
+                                "isRecording, GenreType, GenreSubType, firstAired, "
+                                "repeat, AutoSwitch, idUniqueBroadcast) ");
+
+      CStdString SQL2=FormatSQL("values ('%u', '%u', '%u', '%s', '%s', '%s', '%s', '%s', "
+                                "'%s', '%s', '%s', '%s', '%s', '%u', '%u', '%u', "
+                                "'%u', '%u', '%u', '%u', NULL)",
+                                clientID, info.m_bouquetNum, info.m_idChannel, info.m_strChannel.c_str(),
+                                info.m_strTitle.c_str(), info.m_strOriginalTitle.c_str(), info.m_strPlotOutline.c_str(),
+                                info.m_strPlot.c_str(), info.m_strGenre.c_str(), info.m_startTime.GetAsDBDateTime().c_str(),
+                                info.m_endTime.GetAsDBDateTime().c_str(), info.m_strExtra.c_str(), info.m_strFileNameAndPath.c_str(),
+                                info.m_commFree, info.m_isRecording, info.m_GenreType, info.m_GenreSubType, info.m_firstAired.GetAsDBDateTime().c_str(),
+                                info.m_repeat, info.m_bAutoSwitch);
+
+      SQL1 += SQL2;
+      m_pDS->exec(SQL1.c_str());
+      epgId = (long)sqlite3_last_insert_rowid(m_pDB->getHandle());
+    }
+
+    return epgId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, info.m_strChannel.c_str());
+  }
+
+  return -1;
+}
+
+bool CTVDatabase::UpdateEPG(DWORD clientID, const CTVEPGInfoTag &info)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    long channelId = info.m_idChannel;
+
+    if (channelId < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL=FormatSQL("select * from GuideData WHERE GuideData.idChannel = '%u' AND GuideData.idClient = '%u' AND GuideData.StartTime = '%s' AND GuideData.EndTime = '%s'", channelId, clientID, info.m_startTime.GetAsDBDateTime().c_str(), info.m_endTime.GetAsDBDateTime().c_str());
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      CStdString SQL1=FormatSQL("update GuideData set idClient=%i,idBouquet=%i,strChannel='%s',"
+                                "strTitle='%s',strOriginalTitle='%s',strPlotOutline='%s',"
+                                "strPlot='%s',strGenre='%s',StartTime='%s',EndTime='%s',strExtra='%s',",
+                                clientID, info.m_bouquetNum, info.m_strChannel.c_str(),
+                                info.m_strTitle.c_str(), info.m_strOriginalTitle.c_str(), info.m_strPlotOutline.c_str(),
+                                info.m_strPlot.c_str(), info.m_strGenre.c_str(), info.m_startTime.GetAsDBDateTime().c_str(),
+                                info.m_endTime.GetAsDBDateTime().c_str(), info.m_strExtra.c_str());
+
+      CStdString SQL2=FormatSQL("strFileNameAndPath='%s',commFree=%i,idChannel=%i,"
+                                "isRecording=%i,GenreType=%i,GenreSubType=%i,firstAired=%i,"
+                                "repeat=%i,AutoSwitch=%i where StartTime='%s'",
+                                info.m_strFileNameAndPath.c_str(), info.m_commFree, info.m_idChannel,
+                                info.m_isRecording, info.m_GenreType, info.m_GenreSubType,
+                                info.m_firstAired.GetAsDBDateTime().c_str(),
+                                info.m_repeat, info.m_bAutoSwitch, info.m_startTime.GetAsDBDateTime().c_str());
+
+      SQL1 += SQL2;
+
+      m_pDS->exec(SQL1.c_str());
+      return true;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, info.m_strChannel.c_str());
+    return false;
+  }
+}
+
+bool CTVDatabase::UpdateEPGRecordingState(DWORD clientID, unsigned int channelID, const CDateTime &start, const CDateTime &end, bool OnOff)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    long channelId = channelID;
+
+    if (channelId < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL=FormatSQL("select * from GuideData WHERE GuideData.idChannel = '%u' AND GuideData.idClient = '%u' AND GuideData.StartTime < '%s' AND GuideData.EndTime > '%s'", channelId, clientID, start.GetAsDBDateTime().c_str(), end.GetAsDBDateTime().c_str());
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      CStdString SQL1=FormatSQL("update GuideData set isRecording=%i where StartTime='%s'",
+                                OnOff, start.GetAsDBDateTime().c_str());
+
+      m_pDS->exec(SQL1.c_str());
+      return true;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%i) failed", __FUNCTION__, channelID);
+    return false;
+  }
+}
+
+bool CTVDatabase::RemoveEPGEntries(DWORD clientID, unsigned int channelID, const CDateTime &start, const CDateTime &end)
+{
+  try
+  {
+    CStdString strSQL;
+
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    if (channelID < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    if (start == NULL)
+    {
+      strSQL=FormatSQL("delete from GuideData WHERE GuideData.idChannel = '%u' "
+                                "AND GuideData.idClient = '%u'", channelID, clientID);
+    }
+    else
+    {
+      strSQL=FormatSQL("delete from GuideData WHERE GuideData.idChannel = '%u' "
+                                "AND GuideData.idClient = '%u' AND GuideData.StartTime < '%s' "
+                                "AND GuideData.EndTime > '%s'", channelID, clientID,
+                                start.GetAsDBDateTime().c_str(), end.GetAsDBDateTime().c_str());
+    }
+    m_pDS->exec(strSQL.c_str());
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (ID=%i) failed", __FUNCTION__, channelID);
+    return false;
+  }
+}
+
+bool CTVDatabase::GetEPGForChannel(DWORD clientID, unsigned int channelID, EPG_DATA &epg, const CDateTime &start, const CDateTime &end)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString SQL=FormatSQL("select * from GuideData WHERE GuideData.idClient = '%u' "
+                             "AND GuideData.idChannel = '%u' AND GuideData.EndTime > '%s' "
+                             "AND GuideData.StartTime < '%s' ORDER BY GuideData.StartTime;",
+                             clientID, channelID, start.GetAsDBDateTime().c_str(), end.GetAsDBDateTime().c_str());
+
+    m_pDS->query(SQL.c_str());
+
+    while (!m_pDS->eof())
+    {
+      TVEPGData broadcast;
+
+      broadcast.m_strTitle            = m_pDS->fv("strTitle").get_asString();
+      broadcast.m_strPlotOutline      = m_pDS->fv("strPlotOutline").get_asString();
+      broadcast.m_strPlot             = m_pDS->fv("strPlot").get_asString();
+      broadcast.m_GenreType           = m_pDS->fv("GenreType").get_asInteger();
+      broadcast.m_GenreSubType        = m_pDS->fv("GenreSubType").get_asInteger();
+      broadcast.m_strGenre            = m_pDS->fv("strGenre").get_asString();
+      broadcast.m_startTime.SetFromDBDateTime(m_pDS->fv("StartTime").get_asString());
+      broadcast.m_endTime.SetFromDBDateTime(m_pDS->fv("EndTime").get_asString());
+      broadcast.m_duration            = broadcast.m_endTime - broadcast.m_startTime;
+
+      epg.push_back(broadcast);
+
+      m_pDS->next();
+    }
+
+    m_pDS->close();
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return false;
+  }
+
+  return false;
+}
+
+CDateTime CTVDatabase::GetEPGDataStart(DWORD clientID, unsigned int channelID)
+{
+  CDateTime lastProgramme;
+
+  try
+  {
+    CStdString SQL;
+
+    if (NULL == m_pDB.get()) return lastProgramme;
+    if (NULL == m_pDS.get()) return lastProgramme;
+
+    if (channelID != -1)
+    {
+      SQL=FormatSQL("SELECT GuideData.StartTime FROM GuideData "
+                    "WHERE GuideData.idClient = '%u' AND GuideData.idChannel = '%u' "
+                    "ORDER BY Guidedata.StartTime DESC;", clientID, channelID);
+    }
+    else
+    {
+      SQL=FormatSQL("SELECT GuideData.StartTime FROM GuideData "
+                    "WHERE GuideData.idClient = '%u' "
+                    "ORDER BY Guidedata.StartTime DESC;", clientID);
+    }
+
+    m_pDS->query(SQL.c_str());
+
+    if (!m_pDS->eof())
+    {
+      lastProgramme.SetFromDBDateTime(m_pDS->fv("StartTime").get_asString());
+    }
+
+    m_pDS->close();
+
+    if (!lastProgramme.IsValid())
+      return CDateTime::GetCurrentDateTime();
+    else
+      return lastProgramme;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return lastProgramme;
+  }
+}
+
+CDateTime CTVDatabase::GetEPGDataEnd(DWORD clientID, unsigned int channelID)
+{
+  CDateTime lastProgramme;
+
+  try
+  {
+    CStdString SQL;
+
+    if (NULL == m_pDB.get()) return lastProgramme;
+    if (NULL == m_pDS.get()) return lastProgramme;
+
+    if (channelID != -1)
+    {
+      SQL=FormatSQL("SELECT GuideData.EndTime FROM GuideData "
+                    "WHERE GuideData.idClient = '%u' AND GuideData.idChannel = '%u' "
+                    "ORDER BY Guidedata.EndTime DESC;", clientID, channelID);
+    }
+    else
+    {
+      SQL=FormatSQL("SELECT GuideData.EndTime FROM GuideData "
+                    "WHERE GuideData.idClient = '%u' "
+                    "ORDER BY Guidedata.EndTime DESC;", clientID);
+    }
+
+    m_pDS->query(SQL.c_str());
+
+    if (!m_pDS->eof())
+    {
+      lastProgramme.SetFromDBDateTime(m_pDS->fv("EndTime").get_asString());
+    }
+
+    m_pDS->close();
+
+    if (!lastProgramme.IsValid())
+      return CDateTime::GetCurrentDateTime();
+    else
+      return lastProgramme;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return lastProgramme;
+  }
+}
+
+long CTVDatabase::AddChannel(DWORD clientID, const CTVChannelInfoTag &info)
+{
+  try
+  {
+    if (clientID < 0) return -1;
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    long channelId = info.m_iIdChannel;
+
+    if (channelId < 0)
+    {
+      CStdString SQL = FormatSQL("insert into Channels (idClient, idChannel, Name, ClientNumber, XBMCNumber, "
+                                 "GroupID, IconPath, encrypted, radio, hide, strFileNameAndPath) "
+                                 "values ('%i', NULL, '%s', '%i', '%i', '%i', '%s', '%i', '%i', '%i', '%s')\n",
+                                 clientID, info.m_strChannel.c_str(), info.m_iClientNum, info.m_iChannelNum, info.m_iGroupID,
+                                 info.m_IconPath.c_str(), info.m_encrypted, info.m_radio, info.m_hide, info.m_strFileNameAndPath.c_str());
+
+      m_pDS->exec(SQL.c_str());
+      channelId = (long)sqlite3_last_insert_rowid(m_pDB->getHandle());
+    }
+
+    return channelId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, info.m_strChannel.c_str());
+  }
+
+  return -1;
+}
+
+bool CTVDatabase::RemoveAllChannels(DWORD clientID)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString strSQL=FormatSQL("delete from Channels WHERE Channels.idClient = '%u'", clientID);
+
+    m_pDS->exec(strSQL.c_str());
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return false;
+  }
+}
+
+bool CTVDatabase::RemoveChannel(DWORD clientID, const CTVChannelInfoTag &info)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    long channelId = info.m_iIdChannel;
+
+    if (channelId < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString strSQL=FormatSQL("delete from Channels WHERE Channels.idChannel = '%u' AND Channels.idClient = '%u'", channelId, clientID);
+
+    m_pDS->exec(strSQL.c_str());
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, info.m_strChannel.c_str());
+    return false;
+  }
+}
+
+long CTVDatabase::UpdateChannel(DWORD clientID, const CTVChannelInfoTag &info)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    long channelId = info.m_iIdChannel;
+
+    if (channelId < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL=FormatSQL("select * from Channels WHERE Channels.idChannel = '%u' AND Channels.idClient = '%u'", channelId, clientID);
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      CStdString SQL = FormatSQL("update Channels set idClient=%i,Name='%s', idChannel=%i, ClientNumber=%i, XBMCNumber=%i,GroupID=%i,"
+                                 "IconPath='%s',encrypted=%i,radio=%i,hide=%i,strFileNameAndPath='%s' where idChannel=%i",
+                                 clientID, info.m_strChannel.c_str(), channelId, info.m_iClientNum, info.m_iChannelNum, info.m_iGroupID,
+                                 info.m_IconPath.c_str(), info.m_encrypted, info.m_radio, info.m_hide, info.m_strFileNameAndPath.c_str(),
+                                 channelId);
+
+      m_pDS->exec(SQL.c_str());
+      return channelId;
+    }
+    else   // add the items
+    {
+      m_pDS->close();
+      CStdString SQL = FormatSQL("insert into Channels (idClient, idChannel, Name, ClientNumber, XBMCNumber, "
+                                 "GroupID, IconPath, encrypted, radio, hide, strFileNameAndPath) "
+                                 "values ('%i', NULL, '%s', '%i', '%i', '%s', '%i', '%i', '%i', '%s')\n",
+                                 clientID, info.m_strChannel.c_str(), info.m_iClientNum, info.m_iChannelNum, info.m_iGroupID,
+                                 info.m_IconPath.c_str(), info.m_encrypted, info.m_radio, info.m_hide, info.m_strFileNameAndPath.c_str());
+
+      m_pDS->exec(SQL.c_str());
+      channelId = (long)sqlite3_last_insert_rowid(m_pDB->getHandle());
+      return channelId;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, info.m_strChannel.c_str());
+    return false;
+  }
+}
+
+bool CTVDatabase::HasChannel(DWORD clientID, const CTVChannelInfoTag &info)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString SQL=FormatSQL("select * from Channels WHERE Channels.Name = '%s' AND Channels.ClientNumber = '%i' AND Channels.idClient = '%u'", info.m_strChannel.c_str(), info.m_iClientNum, clientID);
+
+    m_pDS->query(SQL.c_str());
+
+    int num = 0;
+
+    num = m_pDS->num_rows();
+
+    m_pDS->close();
+
+    if (num != 0)
+      return true;
+    else
+      return false;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return false;
+  }
+}
+
+int CTVDatabase::GetNumChannels(DWORD clientID)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return 0;
+    if (NULL == m_pDS.get()) return 0;
+
+    CStdString SQL=FormatSQL("select * from Channels WHERE Channels.idClient=%u", clientID);
+
+    m_pDS->query(SQL.c_str());
+
+    int num = m_pDS->num_rows();
+
+    m_pDS->close();
+
+    return num;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return 0;
+  }
+}
+
+int CTVDatabase::GetNumHiddenChannels(DWORD clientID)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return 0;
+    if (NULL == m_pDS.get()) return 0;
+
+    CStdString SQL=FormatSQL("select * from Channels WHERE Channels.idClient=%u AND Channels.hide=%u", clientID, true);
+
+    m_pDS->query(SQL.c_str());
+
+    int num = m_pDS->num_rows();
+
+    m_pDS->close();
+
+    return num;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return 0;
+  }
+}
+
+bool CTVDatabase::GetChannelList(DWORD clientID, VECCHANNELS* results, bool radio)
+{
+  results->erase(results->begin(), results->end());
+
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString SQL=FormatSQL("select * from Channels WHERE Channels.idClient=%u AND Channels.radio=%u ORDER BY Channels.XBMCNumber", clientID, radio);
+
+    m_pDS->query(SQL.c_str());
+
+    while (!m_pDS->eof())
+    {
+      CTVChannelInfoTag broadcast;
+
+      broadcast.m_iIdChannel          = m_pDS->fv("idChannel").get_asInteger();
+      broadcast.m_IconPath            = m_pDS->fv("IconPath").get_asString();
+      broadcast.m_iChannelNum         = m_pDS->fv("XBMCNumber").get_asInteger();
+      broadcast.m_iClientNum          = m_pDS->fv("ClientNumber").get_asInteger();
+      broadcast.m_strChannel          = m_pDS->fv("Name").get_asString();
+      broadcast.m_strFileNameAndPath  = m_pDS->fv("strFileNameAndPath").get_asString();
+      broadcast.m_encrypted           = m_pDS->fv("encrypted").get_asBool();
+      broadcast.m_radio               = m_pDS->fv("radio").get_asBool();
+      broadcast.m_hide                = m_pDS->fv("hide").get_asBool();
+      broadcast.m_iGroupID            = m_pDS->fv("GroupID").get_asInteger();
+      broadcast.m_strStatus           = "livetv";
+
+      results->push_back(broadcast);
+      m_pDS->next();
+    }
+
+    m_pDS->close();
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return false;
+  }
+
+  return false;
+}
+
+bool CTVDatabase::GetChannelSettings(DWORD clientID, unsigned int channelID, CVideoSettings &settings)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+    if (channelID < 0) return false;
+
+    CStdString SQL=FormatSQL("select * from ChannelSettings where idChannel like '%u'", channelID);
+
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      // get the channel settings info
+      settings.m_AudioDelay           = m_pDS->fv("AudioDelay").get_asFloat();
+      settings.m_AudioStream          = m_pDS->fv("AudioStream").get_asInteger();
+      settings.m_Brightness           = m_pDS->fv("Brightness").get_asInteger();
+      settings.m_Contrast             = m_pDS->fv("Contrast").get_asInteger();
+      settings.m_CustomPixelRatio     = m_pDS->fv("PixelRatio").get_asFloat();
+      settings.m_CustomZoomAmount     = m_pDS->fv("ZoomAmount").get_asFloat();
+      settings.m_Gamma                = m_pDS->fv("Gamma").get_asInteger();
+      settings.m_NonInterleaved       = m_pDS->fv("Interleaved").get_asBool();
+      settings.m_NoCache              = m_pDS->fv("NoCache").get_asBool();
+      settings.m_SubtitleDelay        = m_pDS->fv("SubtitleDelay").get_asFloat();
+      settings.m_SubtitleOn           = m_pDS->fv("SubtitlesOn").get_asBool();
+      settings.m_SubtitleStream       = m_pDS->fv("SubtitleStream").get_asInteger();
+      settings.m_ViewMode             = m_pDS->fv("ViewMode").get_asInteger();
+      settings.m_ResumeTime           = m_pDS->fv("ResumeTime").get_asInteger();
+      settings.m_Crop                 = m_pDS->fv("Crop").get_asBool();
+      settings.m_CropLeft             = m_pDS->fv("CropLeft").get_asInteger();
+      settings.m_CropRight            = m_pDS->fv("CropRight").get_asInteger();
+      settings.m_CropTop              = m_pDS->fv("CropTop").get_asInteger();
+      settings.m_CropBottom           = m_pDS->fv("CropBottom").get_asInteger();
+      settings.m_InterlaceMethod      = (EINTERLACEMETHOD)m_pDS->fv("Deinterlace").get_asInteger();
+      settings.m_VolumeAmplification  = m_pDS->fv("VolumeAmplification").get_asFloat();
+      settings.m_OutputToAllSpeakers  = m_pDS->fv("OutputToAllSpeakers").get_asBool();
+      settings.m_SubtitleCached       = false;
+      m_pDS->close();
+      return true;
+    }
+    else
+    {
+      m_pDS->close();
+      return false;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+  }
+
+  return false;
+}
+
+bool CTVDatabase::SetChannelSettings(DWORD clientID, unsigned int channelID, const CVideoSettings &settings)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    if (channelID < 0)
+    {
+      // no match found, update required
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL.Format("select * from ChannelSettings where idChannel=%i", channelID);
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      SQL=FormatSQL("update ChannelSettings set Interleaved=%i,NoCache=%i,Deinterlace=%i,FilmGrain=%i,ViewMode=%i,ZoomAmount=%f,PixelRatio=%f,"
+                    "AudioStream=%i,SubtitleStream=%i,SubtitleDelay=%f,SubtitlesOn=%i,Brightness=%i,Contrast=%i,Gamma=%i,"
+                    "VolumeAmplification=%f,AudioDelay=%f,OutputToAllSpeakers=%i,",
+                    settings.m_NonInterleaved, settings.m_NoCache, settings.m_InterlaceMethod, settings.m_FilmGrain, settings.m_ViewMode,
+                    settings.m_CustomZoomAmount, settings.m_CustomPixelRatio, settings.m_AudioStream, settings.m_SubtitleStream, settings.m_SubtitleDelay,
+                    settings.m_SubtitleOn, settings.m_Brightness, settings.m_Contrast, settings.m_Gamma, settings.m_VolumeAmplification, settings.m_AudioDelay,
+                    settings.m_OutputToAllSpeakers);
+      CStdString SQL2;
+      SQL2=FormatSQL("ResumeTime=%i,Crop=%i,CropLeft=%i,CropRight=%i,CropTop=%i,CropBottom=%i where idChannel=%i\n", settings.m_ResumeTime,
+                     settings.m_Crop, settings.m_CropLeft, settings.m_CropRight, settings.m_CropTop, settings.m_CropBottom, channelID);
+      SQL += SQL2;
+      m_pDS->exec(SQL.c_str());
+      return true;
+    }
+    else
+    {
+      // add the items
+      m_pDS->close();
+      SQL=FormatSQL("insert into ChannelSettings ( idChannel,Interleaved,NoCache,Deinterlace,FilmGrain,ViewMode,ZoomAmount,PixelRatio,"
+                    "AudioStream,SubtitleStream,SubtitleDelay,SubtitlesOn,Brightness,Contrast,Gamma,"
+                    "VolumeAmplification,AudioDelay,OutputToAllSpeakers,ResumeTime,Crop,CropLeft,CropRight,CropTop,CropBottom)"
+                    " values (%i,%i,%i,%i,%i,%i,%f,%f,%i,%i,%f,%i,%i,%i,%i,%f,%f,",
+                    channelID, settings.m_NonInterleaved, settings.m_NoCache, settings.m_InterlaceMethod, settings.m_FilmGrain, settings.m_ViewMode,
+                    settings.m_CustomZoomAmount, settings.m_CustomPixelRatio, settings.m_AudioStream, settings.m_SubtitleStream, settings.m_SubtitleDelay,
+                    settings.m_SubtitleOn, settings.m_Brightness, settings.m_Contrast, settings.m_Gamma, settings.m_VolumeAmplification, settings.m_AudioDelay);
+      CStdString SQL2;
+      SQL2=FormatSQL("%i,%i,%i,%i,%i,%i,%i)\n", settings.m_OutputToAllSpeakers, settings.m_ResumeTime, settings.m_Crop, settings.m_CropLeft, settings.m_CropRight,
+                     settings.m_CropTop, settings.m_CropBottom);
+      SQL += SQL2;
+      m_pDS->exec(SQL.c_str());
+      return true;
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (ID=%i) failed", __FUNCTION__, channelID);
+    return false;
+  }
+}
+
+long CTVDatabase::AddGroup(DWORD clientID, const CStdString &groupname)
+{
+  try
+  {
+    if (groupname == "") return -1;
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    long groupId;
+    groupId = GetGroupId(groupname);
+    if (groupId < 0)
+    {
+      CStdString SQL=FormatSQL("insert into Groups (idClient, idGroup, Name) values ('%i', NULL, '%s')", clientID, groupname.c_str());
+      m_pDS->exec(SQL.c_str());
+      groupId = (long)sqlite3_last_insert_rowid(m_pDB->getHandle());
+    }
+
+    return groupId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, groupname.c_str());
+  }
+  return -1;
+}
+
+bool CTVDatabase::DeleteGroup(DWORD clientID, unsigned int groupID)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    if (groupID < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString strSQL=FormatSQL("delete from Groups WHERE Groups.idGroup = '%u' AND Groups.idClient = '%u'", groupID, clientID);
+
+    m_pDS->exec(strSQL.c_str());
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%i) failed", __FUNCTION__, groupID);
+    return false;
+  }
+}
+
+bool CTVDatabase::RenameGroup(DWORD clientID, unsigned int GroupId, const CStdString &newname)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    if (GroupId < 0)   // no match found, update required
+    {
+      return false;
+    }
+
+    CStdString SQL;
+
+    SQL=FormatSQL("select * from Groups WHERE Groups.idGroup = '%u' AND Groups.idClient = '%u'", GroupId, clientID);
+    m_pDS->query(SQL.c_str());
+
+    if (m_pDS->num_rows() > 0)
+    {
+      m_pDS->close();
+      // update the item
+      CStdString SQL = FormatSQL("update Groups set idClient=%i,Name='%s' where idGroup=%i",
+                                 clientID, newname.c_str(), GroupId);
+      m_pDS->exec(SQL.c_str());
+      return true;
+    }
+    return false;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s (%i) failed", __FUNCTION__, GroupId);
+    return false;
+  }
+}
+
+bool CTVDatabase::GetGroupList(DWORD clientID, CHANNELGROUPS_DATA* results)
+{
+  results->erase(results->begin(), results->end());
+
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS.get()) return false;
+
+    CStdString SQL=FormatSQL("select * from Groups WHERE Groups.idClient=%u ORDER BY Groups.Name", clientID);
+
+    m_pDS->query(SQL.c_str());
+
+    while (!m_pDS->eof())
+    {
+      TVGroupData data;
+
+      data.m_ID     = m_pDS->fv("idGroup").get_asLong();
+      data.m_Title  = m_pDS->fv("Name").get_asString();
+
+      results->push_back(data);
+      m_pDS->next();
+    }
+
+    m_pDS->close();
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
+    return false;
+  }
+
+  return false;
+}
+
+long CTVDatabase::GetClientId(const CStdString& client)
+{
+  CStdString SQL;
+
+  try
+  {
+    long clientId=-1;
+
+    if (NULL == m_pDB.get()) return -1;
+    if (NULL == m_pDS.get()) return -1;
+
+    SQL=FormatSQL("select idClient from Clients where Name like '%s'", client.c_str());
+
+    m_pDS->query(SQL.c_str());
+
+    if (!m_pDS->eof())
+      clientId = m_pDS->fv("Clients.idClient").get_asLong();
+
+    m_pDS->close();
+
+    return clientId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to get ClientId (%s)", __FUNCTION__, SQL.c_str());
+  }
+
+  return -1;
+}
+
+long CTVDatabase::GetGroupId(const CStdString &groupname)
+{
+  CStdString SQL;
+
+  try
+  {
+    long lGroupId=-1;
+    if (NULL == m_pDB.get()) return lGroupId;
+    if (NULL == m_pDS.get()) return lGroupId;
+
+    SQL=FormatSQL("select idGroup from Groups where Name like '%s'", groupname.c_str());
+    m_pDS->query(SQL.c_str());
+    if (!m_pDS->eof())
+      lGroupId = m_pDS->fv("Groups.idGroup").get_asLong();
+
+    m_pDS->close();
+    return lGroupId;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s unable to get GroupId (%s)", __FUNCTION__, SQL.c_str());
+  }
+  return -1;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/TVDatabase.h XBMC/xbmc/TVDatabase.h
--- XBMC-unpatched/xbmc/TVDatabase.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/TVDatabase.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,75 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Database.h"
+#include "DateTime.h"
+#include "FileItem.h"
+#include "settings/VideoSettings.h"
+#include "utils/TVEPGInfoTag.h"
+#include "utils/TVChannelInfoTag.h"
+
+class CTVDatabase : public CDatabase
+{
+public:
+  CTVDatabase(void);
+  virtual ~CTVDatabase(void);
+
+  virtual bool CommitTransaction();
+
+  long AddClient(const CStdString &client);
+  int GetLastChannel(DWORD clientID);
+  bool UpdateLastChannel(DWORD clientID, unsigned int channelID, CStdString m_strChannel);
+
+  /* Database EPG handling */
+  long AddEPG(DWORD clientID, const CTVEPGInfoTag &info);
+  bool UpdateEPG(DWORD clientID, const CTVEPGInfoTag &info);
+  bool UpdateEPGRecordingState(DWORD clientID, unsigned int channelID, const CDateTime &start, const CDateTime &end, bool OnOff);
+  bool RemoveEPGEntries(DWORD clientID, unsigned int channelID, const CDateTime &start, const CDateTime &end);
+  bool GetEPGForChannel(DWORD clientID, unsigned int channelID, EPG_DATA &epg, const CDateTime &start, const CDateTime &end);
+  CDateTime GetEPGDataStart(DWORD clientID, unsigned int channelID);
+  CDateTime GetEPGDataEnd(DWORD clientID, unsigned int channelID);
+
+  /* Database Channel handling */
+  long AddChannel(DWORD clientID, const CTVChannelInfoTag &info);
+  bool RemoveAllChannels(DWORD clientID);
+  bool RemoveChannel(DWORD clientID, const CTVChannelInfoTag &info);
+  long UpdateChannel(DWORD clientID, const CTVChannelInfoTag &info);
+  int  GetNumChannels(DWORD clientID);
+  int  GetNumHiddenChannels(DWORD clientID);
+  bool HasChannel(DWORD clientID, const CTVChannelInfoTag &info);
+  bool GetChannelList(DWORD clientID, VECCHANNELS* results, bool radio);
+  bool GetChannelSettings(DWORD clientID, unsigned int channelID, CVideoSettings &settings);
+  bool SetChannelSettings(DWORD clientID, unsigned int channelID, const CVideoSettings &settings);
+
+  /* Database Channel Group handling */
+  long AddGroup(DWORD clientID, const CStdString &groupname);
+  bool DeleteGroup(DWORD clientID, unsigned int groupID);
+  bool RenameGroup(DWORD clientID, unsigned int GroupId, const CStdString &newname);
+  bool GetGroupList(DWORD clientID, CHANNELGROUPS_DATA* results);
+
+protected:
+  long GetClientId(const CStdString &client);
+  long GetGroupId(const CStdString &groupname);
+
+private:
+  virtual bool CreateTables();
+};
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/URL.cpp XBMC/xbmc/URL.cpp
--- XBMC-unpatched/xbmc/URL.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/URL.cpp	2009-04-22 18:25:41.000000000 +0200
@@ -164,12 +164,14 @@
   int iEnd = strURL.length();
   const char* sep = NULL;
 
+  //TODO fix all Addon paths
   if(m_strProtocol.Equals("http")
     || m_strProtocol.Equals("https")
     || m_strProtocol.Equals("shout")
     || m_strProtocol.Equals("tuxbox")
     || m_strProtocol.Equals("daap")
     || m_strProtocol.Equals("plugin")
+    || m_strProtocol.Equals("addon")
     || m_strProtocol.Equals("hdhomerun")
     || m_strProtocol.Equals("rtsp")
     || m_strProtocol.Equals("zip"))
@@ -287,6 +289,10 @@
     || m_strProtocol.CompareNoCase("musicdb") == 0
     || m_strProtocol.CompareNoCase("videodb") == 0
     || m_strProtocol.CompareNoCase("lastfm") == 0
+    || m_strProtocol.CompareNoCase("tv") == 0
+    || m_strProtocol.CompareNoCase("radio") == 0
+    || m_strProtocol.CompareNoCase("record") == 0
+    || m_strProtocol.CompareNoCase("timer") == 0
     || m_strProtocol.Left(3).CompareNoCase("mem") == 0)
   {
     if (m_strHostName != "" && m_strFileName != "")
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/Addon.cpp XBMC/xbmc/utils/Addon.cpp
--- XBMC-unpatched/xbmc/utils/Addon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/Addon.cpp	2009-04-08 20:29:27.000000000 +0200
@@ -0,0 +1,88 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "stdafx.h"
+#include "Addon.h"
+#include "Settings.h"
+#include "Util.h"
+#include "URL.h"
+
+namespace ADDON
+{
+
+CAddon::CAddon()
+{
+  m_guid = "";
+  m_addonType = ADDON_UNKNOWN;
+  m_strPath = "";
+  m_disabled = false;
+  m_stars = -1;
+  m_strVersion = "";
+  m_strName = "";
+  m_summary = "";
+  m_strDesc = "";
+  m_disclaimer = "";
+  m_strLibName = "";
+}
+
+bool CAddon::operator==(const CAddon &rhs) const {
+  return (m_guid == rhs.m_guid);
+}
+
+void CAddon::LoadAddonStrings(const CURL &url)
+{
+  // Path where the addon resides
+  CStdString pathToAddon;
+
+  //TODO fix all Addon paths
+  if (url.GetProtocol() == "plugin")
+    pathToAddon = "special://home/plugins/";
+  else
+    pathToAddon = "special://xbmc/";
+
+  // Build the addon's path
+  CUtil::AddFileToFolder(pathToAddon, url.GetHostName(), pathToAddon);
+  CUtil::AddFileToFolder(pathToAddon, url.GetFileName(), pathToAddon);
+
+  // Path where the language strings reside
+  CStdString pathToLanguageFile = pathToAddon;
+  CStdString pathToFallbackLanguageFile = pathToAddon;
+  CUtil::AddFileToFolder(pathToLanguageFile, "resources", pathToLanguageFile);
+  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "resources", pathToFallbackLanguageFile);
+  CUtil::AddFileToFolder(pathToLanguageFile, "language", pathToLanguageFile);
+  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "language", pathToFallbackLanguageFile);
+  CUtil::AddFileToFolder(pathToLanguageFile, g_guiSettings.GetString("locale.language"), pathToLanguageFile);
+  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "english", pathToFallbackLanguageFile);
+  CUtil::AddFileToFolder(pathToLanguageFile, "strings.xml", pathToLanguageFile);
+  CUtil::AddFileToFolder(pathToFallbackLanguageFile, "strings.xml", pathToFallbackLanguageFile);
+
+  // Load language strings temporarily
+  g_localizeStringsTemp.Load(pathToLanguageFile, pathToFallbackLanguageFile);
+}
+
+void CAddon::ClearAddonStrings()
+{
+  // Unload temporary language strings
+  g_localizeStringsTemp.Clear();
+}
+
+} /* namespace ADDON */
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/Addon.h XBMC/xbmc/utils/Addon.h
--- XBMC-unpatched/xbmc/utils/Addon.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/Addon.h	2009-04-08 20:29:12.000000000 +0200
@@ -0,0 +1,102 @@
+#pragma once
+/*
+*      Copyright (C) 2005-2009 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "StdString.h"
+#include "FileSystem/Directory.h"
+#include <vector>
+
+class CURL;
+
+namespace ADDON
+{
+
+enum AddonType
+{
+  ADDON_UNKNOWN           = -1,
+  ADDON_MULTITYPE         = 0,
+  ADDON_VIZ               = 1,
+  ADDON_SKIN              = 2,
+  ADDON_PVRDLL            = 3,
+  ADDON_SCRIPT            = 4,
+  ADDON_SCRAPER           = 5,
+  ADDON_SCREENSAVER       = 6,
+  ADDON_PLUGIN_PVR        = 7,
+  ADDON_PLUGIN_MUSIC      = 8,
+  ADDON_PLUGIN_VIDEO      = 9,
+  ADDON_PLUGIN_PROGRAM    = 10,
+  ADDON_PLUGIN_PICTURES   = 11
+};
+
+const CStdString ADDON_PVRDLL_EXT = "*.pvr";
+const CStdString ADDON_GUID_RE = "^(\\{){0,1}[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}(\\}){0,1}$";
+const CStdString ADDON_VERSION_RE = "(?<Major>\\d*)\\.?(?<Minor>\\d*)?\\.?(?<Build>\\d*)?\\.?(?<Revision>\\d*)?";
+
+
+/*!
+\ingroup windows
+\brief Represents an Addon.
+\sa VECAddon, IVECADDONS
+*/
+class CAddon
+{
+public:
+  CAddon(void);
+  ~CAddon() {};
+  bool operator==(const CAddon &rhs) const;
+
+  static void LoadAddonStrings(const CURL &url);
+  static void ClearAddonStrings();
+
+  CStdString m_guid;       ///< Unique identifier for this addon, chosen by developer
+  CStdString m_strName;    ///< Name of the addon, can be chosen freely.
+  CStdString m_strVersion; ///< Version of the addon, must be in form
+  CStdString m_summary;    ///< Short summary of addon
+  CStdString m_strDesc;    ///< Description of addon
+  CStdString m_strPath;    ///< Path to the addon
+  CStdString m_strLibName; ///< Name of the library
+  CStdString m_strCreator; ///< Author(s) of the addon
+  CStdString m_icon;       ///< Path to icon for the addon, or blank by default
+  int        m_stars;      ///< Rating
+  CStdString m_disclaimer; ///< if exists, user needs to confirm before installation
+  bool       m_disabled;   ///< Is this addon disabled?
+
+  AddonType m_addonType;
+
+
+};
+
+/*!
+\ingroup windows
+\brief A vector to hold CAddon objects.
+\sa CAddon, IVECADDONS
+*/
+typedef std::vector<CAddon> VECADDONS;
+
+/*!
+\ingroup windows
+\brief Iterator of VECADDONS.
+\sa CAddon, VECADDONS
+*/
+typedef std::vector<CAddon>::iterator IVECADDONS;
+
+}; /* namespace ADDON */
+
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/GUIInfoManager.cpp XBMC/xbmc/utils/GUIInfoManager.cpp
--- XBMC-unpatched/xbmc/utils/GUIInfoManager.cpp	2009-04-22 19:13:47.000000000 +0200
+++ XBMC/xbmc/utils/GUIInfoManager.cpp	2009-04-14 18:25:05.000000000 +0200
@@ -29,6 +29,7 @@
 #include "Util.h"
 #include "lib/libscrobbler/scrobbler.h"
 #include "Weather.h"
+#include "PVRManager.h"
 #include "PlayListPlayer.h"
 #include "PartyModeManager.h"
 #include "visualizations/Visualisation.h"
@@ -48,6 +49,8 @@
 #include "LastFmManager.h"
 #include "PictureInfoTag.h"
 #include "MusicInfoTag.h"
+#include "TVEPGInfoTag.h"
+#include "TVChannelInfoTag.h"
 #include "VideoDatabase.h"
 #include "GUIDialogMusicScan.h"
 #include "GUIDialogVideoScan.h"
@@ -221,6 +224,25 @@
     else if (strTest.Equals("weather.isfetched")) ret = WEATHER_IS_FETCHED;
     else if (strTest.Equals("weather.fanartcode")) ret = WEATHER_FANART_CODE;
   }
+  else if (strCategory.Equals("pvr"))
+  {
+    if (strTest.Equals("pvr.isconnected")) ret = PVR_IS_CONNECTED;
+    else if (strTest.Equals("pvr.isrecording")) ret = PVR_IS_RECORDING;
+    else if (strTest.Equals("pvr.hastimer")) ret = PVR_HAS_TIMER;
+    else if (strTest.Equals("pvr.nowrecordingtitle")) ret = PVR_NOW_RECORDING_TITLE;
+    else if (strTest.Equals("pvr.nowrecordingdatetime")) ret = PVR_NOW_RECORDING_DATETIME;
+    else if (strTest.Equals("pvr.nowrecordingchannel")) ret = PVR_NOW_RECORDING_CHANNEL;
+    else if (strTest.Equals("pvr.nextrecordingtitle")) ret = PVR_NEXT_RECORDING_TITLE;
+    else if (strTest.Equals("pvr.nextrecordingdatetime")) ret = PVR_NEXT_RECORDING_DATETIME;
+    else if (strTest.Equals("pvr.nextrecordingchannel")) ret = PVR_NEXT_RECORDING_CHANNEL;
+    else if (strTest.Equals("pvr.hasepg")) ret = PVR_HAS_EPG;
+    else if (strTest.Equals("pvr.hastxt")) ret = PVR_HAS_TXT;
+    else if (strTest.Equals("pvr.hasdirector")) ret = PVR_HAS_DIRECTOR;
+  }
+  else if (strCategory.Equals("addon"))
+  {
+    if (strTest.Equals("addon.rating")) ret = ADDON_STAR_RATING;
+  }
   else if (strCategory.Equals("bar"))
   {
     if (strTest.Equals("bar.gputemperature")) ret = SYSTEM_GPU_TEMPERATURE;
@@ -513,6 +535,8 @@
     else if (strTest.Equals("videoplayer.tagline")) return VIDEOPLAYER_TAGLINE;
     else if (strTest.Equals("videoplayer.hasinfo")) return VIDEOPLAYER_HAS_INFO;
     else if (strTest.Equals("videoplayer.trailer")) return VIDEOPLAYER_TRAILER;
+    else if (strTest.Equals("videoplayer.next")) return VIDEOPLAYER_NEXT;
+    else if (strTest.Equals("videoplayer.group")) return VIDEOPLAYER_GROUP;
   }
   else if (strCategory.Equals("playlist"))
   {
@@ -928,6 +952,14 @@
 
   switch (info)
   {
+  case PVR_NOW_RECORDING_CHANNEL:
+  case PVR_NOW_RECORDING_DATETIME:
+  case PVR_NOW_RECORDING_TITLE:
+  case PVR_NEXT_RECORDING_CHANNEL:
+  case PVR_NEXT_RECORDING_DATETIME:
+  case PVR_NEXT_RECORDING_TITLE:
+    strLabel = CPVRManager::GetInstance()->TranslateInfo(info);
+    break;
   case WEATHER_CONDITIONS:
     strLabel = g_weatherManager.GetInfo(WEATHER_LABEL_CURRENT_COND);
     strLabel = strLabel.Trim();
@@ -1017,6 +1049,8 @@
   case VIDEOPLAYER_WRITER:
   case VIDEOPLAYER_TAGLINE:
   case VIDEOPLAYER_TRAILER:
+  case VIDEOPLAYER_NEXT:
+  case VIDEOPLAYER_GROUP:
     strLabel = GetVideoLabel(info);
   break;
   case PLAYLIST_LENGTH:
@@ -1710,6 +1744,18 @@
     bReturn = g_settings.bUseLoginScreen;
   else if (condition == WEATHER_IS_FETCHED)
     bReturn = g_weatherManager.IsFetched();
+  else if (condition == PVR_IS_CONNECTED)
+    bReturn = CPVRManager::GetInstance()->IsConnected();
+  else if (condition == PVR_IS_RECORDING)
+    bReturn = CPVRManager::GetInstance()->IsRecording();
+  else if (condition == PVR_HAS_TIMER)
+    bReturn = CPVRManager::GetInstance()->HasTimer();
+  else if (condition == PVR_HAS_EPG)
+    bReturn = CPVRManager::GetInstance()->SupportEPG();
+  else if (condition == PVR_HAS_TXT)
+    bReturn = CPVRManager::GetInstance()->SupportTeletext();
+  else if (condition == PVR_HAS_DIRECTOR)
+    bReturn = CPVRManager::GetInstance()->SupportDirector();
   else if (condition == SYSTEM_INTERNET_STATE)
   {
     g_sysinfo.GetInfo(condition);
@@ -2172,6 +2218,8 @@
             strContent = "musicvideos";
           if (m_currentFile->HasVideoInfoTag() && m_currentFile->GetVideoInfoTag()->m_strStatus == "livetv")
             strContent = "livetv";
+          if (m_currentFile->HasTVChannelInfoTag())
+            strContent = "livetv";
           bReturn = m_stringParameters[info.GetData1()].Equals(strContent);
         }
         break;
@@ -2848,6 +2896,8 @@
 
   if (item == VIDEOPLAYER_TITLE)
   {
+    if (m_currentFile->HasTVChannelInfoTag() && !m_currentFile->GetTVChannelInfoTag()->m_strTitle.IsEmpty())
+      return m_currentFile->GetTVChannelInfoTag()->m_strTitle;
     if (m_currentFile->HasVideoInfoTag() && !m_currentFile->GetVideoInfoTag()->m_strTitle.IsEmpty())
       return m_currentFile->GetVideoInfoTag()->m_strTitle;
     // don't have the title, so use label, or drop down to title from path
@@ -2865,6 +2915,52 @@
     if (g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_VIDEO)
       return GetPlaylistLabel(PLAYLIST_POSITION);
   }
+  else if (m_currentFile->HasTVChannelInfoTag())
+  {
+    switch (item)
+    {
+    case VIDEOPLAYER_ORIGINALTITLE:
+      return m_currentFile->GetTVChannelInfoTag()->m_strOriginalTitle;
+      break;
+    case VIDEOPLAYER_GENRE:
+      return m_currentFile->GetTVChannelInfoTag()->m_strGenre;
+      break;
+    case VIDEOPLAYER_PLOT:
+      return m_currentFile->GetTVChannelInfoTag()->m_strPlot;
+    case VIDEOPLAYER_PLOT_OUTLINE:
+      return m_currentFile->GetTVChannelInfoTag()->m_strPlotOutline;
+    case VIDEOPLAYER_EPISODE:
+      if (m_currentFile->GetTVChannelInfoTag()->m_iEpisode > 0)
+      {
+        CStdString strYear;
+        if (m_currentFile->GetTVChannelInfoTag()->m_iSpecialSortEpisode > 0)
+          strYear.Format("S%i", m_currentFile->GetTVChannelInfoTag()->m_iEpisode);
+        else
+          strYear.Format("%i", m_currentFile->GetTVChannelInfoTag()->m_iEpisode);
+        return strYear;
+      }
+      break;
+    case VIDEOPLAYER_SEASON:
+      if (m_currentFile->GetTVChannelInfoTag()->m_iSeason > -1)
+      {
+        CStdString strYear;
+        if (m_currentFile->GetTVChannelInfoTag()->m_iSpecialSortSeason > 0)
+          strYear.Format("%i", m_currentFile->GetTVChannelInfoTag()->m_iSpecialSortSeason);
+        else
+          strYear.Format("%i", m_currentFile->GetTVChannelInfoTag()->m_iSeason);
+        return strYear;
+      }
+      break;
+    case VIDEOPLAYER_TVSHOW:
+      return m_currentFile->GetTVChannelInfoTag()->m_strShowTitle;
+    case VIDEOPLAYER_ALBUM:
+      return m_currentFile->GetTVChannelInfoTag()->m_strAlbum;
+    case VIDEOPLAYER_NEXT:
+      return m_currentFile->GetTVChannelInfoTag()->m_strNextTitle;
+    case VIDEOPLAYER_GROUP:
+      return CPVRManager::GetInstance()->GetGroupName(CPVRManager::GetInstance()->GetPlayingGroup());
+    }
+  }
   else if (m_currentFile->HasVideoInfoTag())
   {
     switch (item)
@@ -3772,6 +3868,13 @@
     }
     return rating;
   }
+  else if (info == ADDON_STAR_RATING)
+  {
+    CStdString rating;
+    //TODO need to check item is an addon
+    rating.Format("rating%d.png", item->GetPropertyInt("Addon.Rating"));
+    return rating;
+  }
   return GetItemLabel(item, info);
 }
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/GUIInfoManager.h XBMC/xbmc/utils/GUIInfoManager.h
--- XBMC-unpatched/xbmc/utils/GUIInfoManager.h	2009-04-22 19:13:47.000000000 +0200
+++ XBMC/xbmc/utils/GUIInfoManager.h	2009-04-22 18:25:41.000000000 +0200
@@ -239,6 +239,8 @@
 #define VIDEOPLAYER_TOP250            283
 #define VIDEOPLAYER_RATING_AND_VOTES  284
 #define VIDEOPLAYER_TRAILER           285
+#define VIDEOPLAYER_NEXT              286
+#define VIDEOPLAYER_GROUP             287
 
 #define AUDIOSCROBBLER_ENABLED      300
 #define AUDIOSCROBBLER_CONN_STATE   301
@@ -388,6 +390,21 @@
 #define FANART_COLOR3               1002
 #define FANART_IMAGE                1003
 
+#define PVR_IS_CONNECTED            1100
+#define PVR_IS_RECORDING            1101
+#define PVR_HAS_TIMER               1102
+#define PVR_NEXT_RECORDING_CHANNEL  1103
+#define PVR_NEXT_RECORDING_DATETIME 1104
+#define PVR_NEXT_RECORDING_TITLE    1105
+#define PVR_NOW_RECORDING_CHANNEL   1106
+#define PVR_NOW_RECORDING_DATETIME  1107
+#define PVR_NOW_RECORDING_TITLE     1108
+#define PVR_HAS_EPG                 1109
+#define PVR_HAS_TXT                 1110
+#define PVR_HAS_DIRECTOR            1111
+
+#define ADDON_STAR_RATING           1200
+
 #define WINDOW_PROPERTY             9993
 #define WINDOW_IS_TOPMOST           9994
 #define WINDOW_IS_VISIBLE           9995
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/Makefile XBMC/xbmc/utils/Makefile
--- XBMC-unpatched/xbmc/utils/Makefile	2009-04-22 19:13:47.000000000 +0200
+++ XBMC/xbmc/utils/Makefile	2009-04-05 20:50:04.000000000 +0200
@@ -1,6 +1,7 @@
 INCLUDES=-I. -I.. -I../linux -I../../guilib
 
-SRCS=AlarmClock.cpp \
+SRCS=Addon.cpp \
+     AlarmClock.cpp \
      Archive.cpp \
      CharsetConverter.cpp \
      CriticalSection.cpp \
@@ -52,7 +53,11 @@
      ArabicShaping.cpp \
      AsyncFileCopy.cpp \
      DbusServer.cpp \
-     Atomics.cpp
+     Atomics.cpp \
+     TVEPGInfoTag.cpp \
+     TVTimerInfoTag.cpp \
+     TVChannelInfoTag.cpp \
+     TVRecordInfoTag.cpp \
 
 LIB=utils.a
 
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/MusicInfoScraper.cpp XBMC/xbmc/utils/MusicInfoScraper.cpp
--- XBMC-unpatched/xbmc/utils/MusicInfoScraper.cpp	2009-04-22 19:13:47.000000000 +0200
+++ XBMC/xbmc/utils/MusicInfoScraper.cpp	2009-04-05 19:53:26.000000000 +0200
@@ -90,7 +90,7 @@
   if (!parser.Load("special://xbmc/system/scrapers/music/" + m_info.strPath))
     return;
 
-  if (!m_info.settings.GetPluginRoot() || m_info.settings.GetSettings().IsEmpty())
+  if (!m_info.settings.GetAddonRoot() || m_info.settings.GetSettings().IsEmpty())
   {
     m_info.settings.LoadSettingsXML("special://xbmc/system/scrapers/music/" + m_info.strPath);
     m_info.settings.SaveFromDefault();
@@ -196,7 +196,7 @@
   if (!parser.Load("special://xbmc/system/scrapers/music/" + m_info.strPath))
     return;
 
-  if (!m_info.settings.GetPluginRoot() || m_info.settings.GetSettings().IsEmpty())
+  if (!m_info.settings.GetAddonRoot() || m_info.settings.GetSettings().IsEmpty())
   {
     m_info.settings.LoadSettingsXML("special://xbmc/system/scrapers/music/" + m_info.strPath);
     m_info.settings.SaveFromDefault();
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVChannelInfoTag.cpp XBMC/xbmc/utils/TVChannelInfoTag.cpp
--- XBMC-unpatched/xbmc/utils/TVChannelInfoTag.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVChannelInfoTag.cpp	2009-04-14 18:32:10.000000000 +0200
@@ -0,0 +1,218 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * DESCRIPTION:
+ *
+ */
+
+#include "stdafx.h"
+#include "TVEPGInfoTag.h"
+#include "TVChannelInfoTag.h"
+#include "GUISettings.h"
+
+/**
+ * Create a blank unmodified channel tag
+ */
+CTVChannelInfoTag::CTVChannelInfoTag()
+{
+  Reset();
+}
+
+bool CTVChannelInfoTag::operator==(const CTVChannelInfoTag& right) const
+{
+  if (this == &right) return true;
+
+  return (m_iIdChannel            == right.m_iIdChannel &&
+          m_iChannelNum           == right.m_iChannelNum &&
+          m_iClientNum            == right.m_iClientNum &&
+          m_strChannel            == right.m_strChannel &&
+          m_IconPath              == right.m_IconPath &&
+          m_encrypted             == right.m_encrypted &&
+          m_radio                 == right.m_radio &&
+          m_hide                  == right.m_hide &&
+          m_isRecording           == right.m_isRecording &&
+          m_strFileNameAndPath    == right.m_strFileNameAndPath);
+}
+
+bool CTVChannelInfoTag::operator!=(const CTVChannelInfoTag &right) const
+{
+  if (m_iIdChannel            != right.m_iIdChannel) return true;
+  if (m_iChannelNum           != right.m_iChannelNum) return true;
+  if (m_iClientNum            != right.m_iClientNum) return true;
+  if (m_strChannel            != right.m_strChannel) return true;
+  if (m_IconPath              != right.m_IconPath) return true;
+  if (m_encrypted             != right.m_encrypted) return true;
+  if (m_radio                 != right.m_radio) return true;
+  if (m_hide                  != right.m_hide) return true;
+  if (m_isRecording           != right.m_isRecording) return true;
+  if (m_strFileNameAndPath    != right.m_strFileNameAndPath) return true;
+
+  return false;
+}
+
+
+/**
+ * Initialize blank CTVChannelInfoTag
+ */
+void CTVChannelInfoTag::Reset()
+{
+  m_iIdChannel            = -1;
+  m_iChannelNum           = -1;
+  m_iClientNum            = -1;
+  m_iGroupID              = 0;
+  m_strChannel            = "";
+  m_IconPath              = "";
+  m_radio                 = false;
+  m_encrypted             = false;
+  m_hide                  = false;
+  m_isRecording           = false;
+  m_bTeletext             = false;
+  m_startTime             = NULL;
+  m_endTime               = NULL;
+  m_strFileNameAndPath    = "";
+  m_strNextTitle          = "";
+
+  m_EPG.clear();
+
+  CVideoInfoTag::Reset();
+}
+
+bool CTVChannelInfoTag::GetEPGNowInfo(CTVEPGInfoTag *result)
+{
+  CDateTime now = CDateTime::GetCurrentDateTime();
+
+  if (m_EPG.size() == 0)
+    return false;
+
+  for (int i = 0; i < m_EPG.size(); i++)
+  {
+    if ((m_EPG[i].m_startTime <= now) && (m_EPG[i].m_endTime > now))
+    {
+      result->m_strChannel        = m_strChannel;
+      result->m_strTitle          = m_EPG[i].m_strTitle;
+      result->m_strPlotOutline    = m_EPG[i].m_strPlotOutline;
+      result->m_strPlot           = m_EPG[i].m_strPlot;
+      result->m_GenreType         = m_EPG[i].m_GenreType;
+      result->m_GenreSubType      = m_EPG[i].m_GenreSubType;
+      result->m_strGenre          = m_EPG[i].m_strGenre;
+      result->m_startTime         = m_EPG[i].m_startTime;
+      result->m_endTime           = m_EPG[i].m_endTime;
+      result->m_duration          = m_EPG[i].m_duration;
+      result->m_channelNum        = m_iChannelNum;
+      result->m_idChannel         = m_iIdChannel;
+      result->m_isRadio           = m_radio;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+bool CTVChannelInfoTag::GetEPGNextInfo(CTVEPGInfoTag *result)
+{
+  CDateTime now = CDateTime::GetCurrentDateTime();
+
+  if (m_EPG.size() == 0)
+    return false;
+
+  for (int i = 0; i < m_EPG.size(); i++)
+  {
+    if ((m_EPG[i].m_startTime <= now) && (m_EPG[i].m_endTime > now))
+    {
+      CDateTime next = m_EPG[i].m_endTime;
+
+      for (int j = 0; j < m_EPG.size(); j++)
+      {
+        if (m_EPG[j].m_startTime >= next)
+        {
+          result->m_strChannel        = m_strChannel;
+          result->m_strTitle          = m_EPG[j].m_strTitle;
+          result->m_strPlotOutline    = m_EPG[j].m_strPlotOutline;
+          result->m_strPlot           = m_EPG[j].m_strPlot;
+          result->m_GenreType         = m_EPG[j].m_GenreType;
+          result->m_GenreSubType      = m_EPG[j].m_GenreSubType;
+          result->m_strGenre          = m_EPG[j].m_strGenre;
+          result->m_startTime         = m_EPG[j].m_startTime;
+          result->m_endTime           = m_EPG[j].m_endTime;
+          result->m_duration          = m_EPG[j].m_duration;
+          result->m_channelNum        = m_iChannelNum;
+          result->m_idChannel         = m_iIdChannel;
+          result->m_isRadio           = m_radio;
+          break;
+        }
+      }
+    }
+  }
+
+  return true;
+}
+
+bool CTVChannelInfoTag::GetEPGLastEntry(CTVEPGInfoTag *result)
+{
+  CDateTime last = CDateTime::GetCurrentDateTime();
+
+  for (int i = m_EPG.size()-1; i >= 0; i--)
+  {
+    if (m_EPG[i].m_endTime >= last)
+    {
+      result->m_strChannel        = m_strChannel;
+      result->m_strTitle          = m_EPG[i].m_strTitle;
+      result->m_strPlotOutline    = m_EPG[i].m_strPlotOutline;
+      result->m_strPlot           = m_EPG[i].m_strPlot;
+      result->m_GenreType         = m_EPG[i].m_GenreType;
+      result->m_GenreSubType      = m_EPG[i].m_GenreSubType;
+      result->m_strGenre          = m_EPG[i].m_strGenre;
+      result->m_startTime         = m_EPG[i].m_startTime;
+      result->m_endTime           = m_EPG[i].m_endTime;
+      result->m_duration          = m_EPG[i].m_duration;
+      result->m_channelNum        = m_iChannelNum;
+      result->m_idChannel         = m_iIdChannel;
+      result->m_isRadio           = m_radio;
+      last = m_EPG[i].m_endTime;
+    }
+  }
+
+  return false;
+}
+
+void CTVChannelInfoTag::CleanupEPG()
+{
+  CDateTime m_start = CDateTime::GetCurrentDateTime()-CDateTimeSpan(0, g_guiSettings.GetInt("pvrmenu.lingertime") / 60, g_guiSettings.GetInt("pvrmenu.lingertime") % 60, 0);
+
+  for (int i = 0; i < m_EPG.size(); i++)
+  {
+    /* If entry end time is lower as epg data start time remove it from list */
+    if (m_EPG[i].m_endTime <= m_start)
+    {
+      m_EPG.erase(m_EPG.begin()+i);
+    }
+    else
+    {
+      /* The items are sorted by date inside list, if the end date is above the epg data
+         start date cancel cleanup */
+      break;
+    }
+  }
+
+  return;
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVChannelInfoTag.h XBMC/xbmc/utils/TVChannelInfoTag.h
--- XBMC-unpatched/xbmc/utils/TVChannelInfoTag.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVChannelInfoTag.h	2009-04-14 18:32:03.000000000 +0200
@@ -0,0 +1,243 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * for DESCRIPTION see 'TVChannelInfoTag.cpp'
+ */
+
+#include "VideoInfoTag.h"
+#include "DateTime.h"
+
+enum chSrcType
+{
+  srcNone,
+  src_DVBC,
+  src_DVBT,
+  src_DVBH,
+  src_DVBS,
+  src_DVBS2,
+  srcAnalog
+};
+
+enum chInvValues
+{
+  InvOff,
+  InvOn,
+  InvAuto
+};
+
+enum chCoderate
+{
+  Coderate_None,
+  Coderate_1_2,
+  Coderate_2_3,
+  Coderate_3_4,
+  Coderate_4_5,
+  Coderate_5_6,
+  Coderate_6_7,
+  Coderate_7_8,
+  Coderate_8_9,
+  Coderate_9_10,
+  Coderate_Auto
+};
+
+enum chModTypes
+{
+  modNone = 0,
+  modQAM4 = 1,
+  modQAM16 = 2,
+  modQAM32 = 3,
+  modQAM64 = 4,
+  modQAM128 = 5,
+  modQAM256 = 6,
+  modQAM512 = 7,
+  modQAM1024 = 8,
+  modQAMAuto = 9,
+  modBPSK = 10,
+  modQPSK = 11,
+  modOQPSK = 12,
+  mod8PSK = 13,
+  mod16APSK = 14,
+  mod32APSK = 15,
+  modOFDM = 16,
+  modCOFDM = 17,
+  modVSB8 = 18,
+  modVSB16 = 19
+};
+
+enum chPolTypes
+{
+  pol_H,
+  pol_V,
+  pol_L,
+  pol_R
+};
+
+enum chBandwidth
+{
+  bw_5MHz,
+  bw_6MHz,
+  bw_7MHz,
+  bw_8MHz,
+  bw_Auto
+};
+
+enum chAlpha
+{
+  alpha_0,
+  alpha_1,
+  alpha_2,
+  alpha_4
+};
+
+enum chGuard
+{
+  guard_1_4,
+  guard_1_8,
+  guard_1_16,
+  guard_1_32,
+  guard_Auto
+};
+
+enum chTransm
+{
+  transmission_2K,
+  transmission_4K,
+  transmission_8K,
+  transmission_Auto
+};
+
+enum chRolloff
+{
+  rolloff_Unknown,
+  rolloff_20,
+  rolloff_25,
+  rolloff_35
+};
+
+typedef struct
+{
+  CStdString  m_strProvider;          /// Provider name
+  CStdString  m_satellite;            /// Satellite name
+  chSrcType   m_SourceType;           /// Source type
+  chCoderate  m_CoderateH;            ///
+  chCoderate  m_CoderateL;            ///
+  chInvValues m_Inversion;            /// DVB-C/S Inversion values
+  chModTypes  m_Modulation;           ///
+  chPolTypes  m_Polarization;
+  chBandwidth m_Bandwidth;
+  chAlpha     m_Alpha;
+  chGuard     m_Guard;
+  chTransm    m_Transmission;
+  chRolloff   m_Rolloff;
+  bool        m_Priority;
+  bool        m_Hierarchie;
+  int         m_Freq;                 /// Channel frequency
+  int         m_Symbolrate;           /// Channel symbolrate
+  int         m_VPID;                 /// Video program Id
+  int         m_APID1;                /// First analog audio Id
+  int         m_APID2;                /// Second analog audio Id
+  int         m_DPID1;                /// First digital auido Id
+  int         m_DPID2;                /// Second digital audio Id
+  int         m_CAID;                 /// Conditional access Id (!= 0 = encrypted channel)
+  int         m_TPID;                 /// Teletext Id
+  int         m_SID;                  /// Service Id
+  int         m_NID;                  /// Network Id
+  int         m_TID;                  /// Trandport Id
+  int         m_RID;                  /// Radio Id
+
+  CStdString  m_parameter;            /// Individual parameter string
+
+} TVChannelSettings;
+
+typedef struct
+{
+  unsigned int  m_uniqueID;
+
+  CStdString    m_strTitle;
+  CStdString    m_strPlotOutline;
+  CStdString    m_strPlot;
+
+  CDateTime     m_startTime;
+  CDateTime     m_endTime;
+  CDateTimeSpan m_duration;
+
+  CStdString    m_strGenre;
+  int           m_GenreType;
+  int           m_GenreSubType;
+
+} TVEPGData;
+
+typedef std::vector<TVEPGData> EPG_DATA;
+
+typedef struct
+{
+  unsigned long m_ID;
+  CStdString    m_Title;
+
+} TVGroupData;
+
+typedef std::vector<TVGroupData> CHANNELGROUPS_DATA;
+
+
+class CTVChannelInfoTag : public CVideoInfoTag
+{
+public:
+  CTVChannelInfoTag();
+  void Reset();
+
+  bool GetEPGNowInfo(CTVEPGInfoTag *result);
+  bool GetEPGNextInfo(CTVEPGInfoTag *result);
+  bool GetEPGLastEntry(CTVEPGInfoTag *result);
+  void CleanupEPG();
+
+  bool operator ==(const CTVChannelInfoTag &right) const;
+  bool operator !=(const CTVChannelInfoTag &right) const;
+
+  int                 m_iIdChannel;           /// Database number
+  int                 m_iChannelNum;          /// Channel number for channels on XBMC
+  int                 m_iClientNum;           /// Channel number on client
+  int                 m_iGroupID;             /// Channel group identfier
+
+  CStdString          m_strChannel;           /// Channel name
+
+  CStdString          m_IconPath;             /// Path to the logo image
+
+  bool                m_encrypted;            /// Encrypted channel
+  bool                m_bTeletext;            ///
+  bool                m_radio;                /// Radio channel
+  bool                m_hide;                 /// Channel is hide inside filelists
+  bool                m_isRecording;
+
+  CStdString          m_strNextTitle;
+
+  CDateTime           m_startTime;            /// Start time
+  CDateTime           m_endTime;              /// End time
+  CDateTimeSpan       m_duration;             /// Duration
+
+  CStdString          m_strFileNameAndPath;   /// Filename for PVRManager to open and read stream
+
+  EPG_DATA            m_EPG;                  /// EPG Data for Channel
+  TVChannelSettings   m_Settings;             /// Channel settings must be received manually
+};
+
+typedef std::vector<CTVChannelInfoTag> VECCHANNELS;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVEPGInfoTag.cpp XBMC/xbmc/utils/TVEPGInfoTag.cpp
--- XBMC-unpatched/xbmc/utils/TVEPGInfoTag.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVEPGInfoTag.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,55 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "stdafx.h"
+#include "TVEPGInfoTag.h"
+
+CTVEPGInfoTag::CTVEPGInfoTag(long uniqueBroadcastID)
+{
+  Reset();
+  m_uniqueBroadcastID = uniqueBroadcastID;
+}
+
+void CTVEPGInfoTag::Reset()
+{
+  m_idEPG = -1;
+  m_idChannel = -1;
+  m_IconPath = "";
+  m_strSource = "";
+  m_strBouquet = "";
+  m_strChannel = "";
+  m_strExtra = "";
+  m_seriesID = "";
+  m_episodeID = "";
+  m_strFileNameAndPath = "";
+  m_repeat = false;
+  m_videoProps.clear();
+  m_audioProps.clear();
+  m_subTypes.clear();
+  m_commFree = false;
+  m_isRecording = false;
+  m_recStatus = rsUnknown;
+  m_availableStatus = asAvailable;
+  m_bAutoSwitch = false;
+  m_isRadio = false;
+
+  CVideoInfoTag::Reset();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVEPGInfoTag.h XBMC/xbmc/utils/TVEPGInfoTag.h
--- XBMC-unpatched/xbmc/utils/TVEPGInfoTag.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVEPGInfoTag.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,212 @@
+#pragma once
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "VideoInfoTag.h"
+#include "DateTime.h"
+
+#define EVCONTENTMASK_MOVIEDRAMA               0x10
+#define EVCONTENTMASK_NEWSCURRENTAFFAIRS       0x20
+#define EVCONTENTMASK_SHOW                     0x30
+#define EVCONTENTMASK_SPORTS                   0x40
+#define EVCONTENTMASK_CHILDRENYOUTH            0x50
+#define EVCONTENTMASK_MUSICBALLETDANCE         0x60
+#define EVCONTENTMASK_ARTSCULTURE              0x70
+#define EVCONTENTMASK_SOCIALPOLITICALECONOMICS 0x80
+#define EVCONTENTMASK_EDUCATIONALSCIENCE       0x90
+#define EVCONTENTMASK_LEISUREHOBBIES           0xA0
+#define EVCONTENTMASK_SPECIAL                  0xB0
+#define EVCONTENTMASK_USERDEFINED              0xF0
+
+/* Enums from mythTV & libcmyth source code */
+
+enum RecordingType
+{
+  kNotRecording = 0,
+  kSingleRecord = 1,
+  kTimeslotRecord,
+  kChannelRecord,
+  kAllRecord,
+  kWeekslotRecord,
+  kFindOneRecord,
+  kOverrideRecord,
+  kDontRecord,
+  kFindDailyRecord,
+  kFindWeeklyRecord
+};
+
+enum RecordingDupInType
+{
+  kDupsInRecorded     = 0x01,
+  kDupsInOldRecorded  = 0x02,
+  kDupsInAll          = 0x0F,
+  kDupsNewEpi         = 0x10,
+  kDupsExRepeats      = 0x20,
+  kDupsExGeneric      = 0x40,
+  kDupsFirstNew       = 0x80
+};
+
+enum RecordingDupMethodType
+{
+  kDupCheckNone     = 0x01,
+  kDupCheckSub      = 0x02,
+  kDupCheckDesc     = 0x04,
+  kDupCheckSubDesc  = 0x06,
+  kDupCheckSubThenDesc = 0x08
+};
+
+enum RecSearchType
+{
+  kNoSearch = 0,
+  kPowerSearch,
+  kTitleSearch,
+  kKeywordSearch,
+  kPeopleSearch,
+  kManualSearch
+};
+
+enum RecStatus
+{
+  rsDeleted = -5,
+  rsStopped = -4,
+  rsRecorded = -3,
+  rsRecording = -2,
+  rsWillRecord = -1,
+  rsUnknown = 0,
+  rsDontRecord = 1,
+  rsPrevRecording = 2,
+  rsCurrentRecording = 3,
+  rsEarlierRecording = 4,
+  rsTooManyRecordings = 5,
+  rsCancelled = 6,
+  rsConflict = 7,
+  rsLaterShowing = 8,
+  rsRepeat = 9,
+  rsLowDiskspace = 11,
+  rsTunerBusy = 12
+};
+
+enum CommFlagStatus
+{
+  COMM_FLAG_NOT_FLAGGED = 0,
+  COMM_FLAG_DONE        = 1,
+  COMM_FLAG_PROCESSING  = 2,
+  COMM_FLAG_COMMFREE    = 3
+};
+
+enum TranscodingStatus
+{
+  TRANSCODING_NOT_TRANSCODED = 0,
+  TRANSCODING_COMPLETE       = 1,
+  TRANSCODING_RUNNING        = 2
+};
+
+enum AvailableStatus
+{
+  asAvailable = 0,
+  asNotYetAvailable,
+  asPendingDelete,
+  asFileNotFound,
+  asZeroByte,
+  asDeleted
+};
+
+enum AudioProps_t
+{
+  AUD_UNKNOWN       = 0x00,
+  AUD_STEREO        = 0x01,
+  AUD_MONO          = 0x02,
+  AUD_SURROUND      = 0x04,
+  AUD_DOLBY         = 0x08,
+  AUD_HARDHEAR      = 0x10,
+  AUD_VISUALIMPAIR  = 0x20
+}; typedef std::vector< AudioProps_t > AudioProps;
+
+enum VideoProps_t
+{
+  VID_UNKNOWN       = 0x00,
+  VID_HDTV          = 0x01,
+  VID_WIDESCREEN    = 0x02,
+  VID_AVC           = 0x04
+}; typedef std::vector< VideoProps_t > VideoProps;
+
+enum SubtitleTypes_t
+{
+  SUB_UNKNOWN       = 0x00,
+  SUB_HARDHEAR      = 0x01,
+  SUB_NORMAL        = 0x02,
+  SUB_ONSCREEN      = 0x04,
+  SUB_SIGNED        = 0x08
+}; typedef std::vector< SubtitleTypes_t > SubtitleTypes;
+
+class CTVEPGInfoTag : public CVideoInfoTag
+{
+public:
+  CTVEPGInfoTag(long uniqueBroadcastID);
+  CTVEPGInfoTag() { Reset(); };
+
+  void Reset();
+  const long GetDbID() const { return m_uniqueBroadcastID; };
+
+  int           m_idEPG;
+  int           m_idChannel;
+  CStdString    m_strSource;
+  CStdString    m_strBouquet;
+  int           m_bouquetNum;
+  CStdString    m_strChannel;
+  int           m_channelNum;
+  CStdString    m_IconPath;
+
+  CStdString    m_strExtra;
+
+  CStdString    m_strFileNameAndPath;
+
+  CStdString    m_seriesID;
+  CStdString    m_episodeID;
+
+  CDateTime     m_startTime;
+  CDateTime     m_endTime;
+  CDateTimeSpan m_duration;
+  CDateTime     m_firstAired;
+  bool          m_repeat;
+
+  VideoProps    m_videoProps;
+  AudioProps    m_audioProps;
+  SubtitleTypes m_subTypes;
+
+  bool          m_isRadio;
+  bool          m_commFree;
+  bool          m_isRecording;
+  bool          m_bAutoSwitch;
+  int           m_GenreType;
+  int           m_GenreSubType;
+
+  RecStatus         m_recStatus;
+  CommFlagStatus    m_commFlagStatus;
+  TranscodingStatus m_transCodeStatus;
+  AvailableStatus   m_availableStatus;
+
+private:
+  long m_uniqueBroadcastID; // db's unique identifier for this tag
+
+};
+
+typedef std::vector<CTVEPGInfoTag> VECPROGRAMMES;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVRecordInfoTag.cpp XBMC/xbmc/utils/TVRecordInfoTag.cpp
--- XBMC-unpatched/xbmc/utils/TVRecordInfoTag.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVRecordInfoTag.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,237 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * DESCRIPTION:
+ *
+ * CTVRecordingInfoTag is part of the PVRManager to support recording entrys.
+ *
+ * The recording information tag holds data about name, length, recording time
+ * and so on of recorded stream stored on the backend.
+ *
+ * The filename string is used to by the PVRManager and passed to DVDPlayer
+ * to stream data from the backend to XBMC.
+ *
+ * It is a also CVideoInfoTag and some of his variables must be set!
+ *
+ * TODO:
+ * Nothing in the moment. Any ideas?
+ *
+ */
+
+#include "stdafx.h"
+#include "TVRecordInfoTag.h"
+
+
+/**
+ * Create a blank unmodified recording tag
+ */
+CTVRecordingInfoTag::CTVRecordingInfoTag()
+{
+  Reset();
+}
+
+bool CTVRecordingInfoTag::operator ==(const CTVRecordingInfoTag& right) const
+{
+
+  if (this == &right) return true;
+
+  return (m_Index         == right.m_Index &&
+          m_channelNum    == right.m_channelNum &&
+          m_strChannel    == right.m_strChannel &&
+          m_startTime     == right.m_startTime &&
+          m_endTime       == right.m_endTime &&
+          m_duration      == right.m_duration &&
+          m_seriesID      == right.m_seriesID &&
+          m_episodeID     == right.m_episodeID &&
+          m_commFree      == right.m_commFree &&
+          m_strPlotOutline== right.m_strPlotOutline &&
+          m_strPlot       == right.m_strPlot &&
+          m_strFileNameAndPath == right.m_strFileNameAndPath &&
+          m_strClient     == right.m_strClient &&
+          m_resumePoint   == right.m_resumePoint &&
+          m_strTitle      == right.m_strTitle);
+}
+
+bool CTVRecordingInfoTag::operator !=(const CTVRecordingInfoTag& right) const
+{
+
+  if (this == &right) return false;
+
+  if (m_Index         != right.m_Index) return true;
+  if (m_channelNum    != right.m_channelNum) return true;
+  if (m_strChannel    != right.m_strChannel) return true;
+  if (m_startTime     != right.m_startTime) return true;
+  if (m_endTime       != right.m_endTime) return true;
+  if (m_duration      != right.m_duration) return true;
+  if (m_seriesID      != right.m_seriesID) return true;
+  if (m_episodeID     != right.m_episodeID) return true;
+  if (m_commFree      != right.m_commFree) return true;
+  if (m_strPlotOutline!= right.m_strPlotOutline) return true;
+  if (m_strPlot       != right.m_strPlot) return true;
+  if (m_strFileNameAndPath != right.m_strFileNameAndPath) return true;
+  if (m_strTitle      != right.m_strTitle) return true;
+  if (m_strClient     != right.m_strClient) return true;
+  if (m_resumePoint   != right.m_resumePoint) return true;
+
+  return false;
+}
+
+/**
+ * Add a cut mark to info tag
+ * \param int position              = Cut mark position
+ * \param const CStdString &comment = Comment string
+ */
+void CTVRecordingInfoTag::AddMark(int position, const CStdString &comment)
+{
+  CutMark_t mark;
+  mark.m_comment = comment;
+  mark.m_position = position;
+  m_cutMarks.push_back(mark);
+  SortMarks();
+}
+
+/**
+ * Delete cut mark on given position
+ * \param int position              = Cut mark to delete
+ * \return bool                     = true if deletet, false if not found
+ */
+bool CTVRecordingInfoTag::DeleteMark(int position)
+{
+  std::vector<CutMark_t>::iterator it;
+
+  for (it = m_cutMarks.begin(); it != m_cutMarks.end(); ++it)
+  {
+    if ((*it).m_position == position)
+    {
+      m_cutMarks.erase(it);
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/**
+ * Delete all cut marks
+ */
+void CTVRecordingInfoTag::DeleteAllMarks(void)
+{
+  m_cutMarks.clear();
+  return;
+}
+
+/**
+ * Get cut mark in front of given position
+ * \param int position              = current mark
+ * \return int                      = previous mark or -1 if current is first
+ */
+int CTVRecordingInfoTag::GetMarkPrev(int position)
+{
+  std::vector<CutMark_t>::iterator it;
+
+  for (it = m_cutMarks.end(); it != m_cutMarks.begin(); --it)
+  {
+    if ((*it).m_position < position)
+    {
+      return (*it).m_position;
+    }
+  }
+
+  return -1;
+}
+
+/**
+ * Get cut mark behind given position
+ * \param int position              = current mark
+ * \return int                      = next mark or -1 if current is last
+ */
+int CTVRecordingInfoTag::GetMarkNext(int position)
+{
+  std::vector<CutMark_t>::iterator it;
+
+  for (it = m_cutMarks.begin(); it != m_cutMarks.end(); ++it)
+  {
+    if ((*it).m_position > position)
+    {
+      return (*it).m_position;
+    }
+  }
+
+  return -1;
+}
+
+/**
+ * Sort recording cut marks array (lowest position first)
+ */
+void CTVRecordingInfoTag::SortMarks(void)
+{
+  std::vector<CutMark_t>::iterator it1;
+  std::vector<CutMark_t>::iterator it2;
+
+  for (it1 = m_cutMarks.begin(); it1 != m_cutMarks.end(); ++it1)
+  {
+    for (it2 = m_cutMarks.end(); it2 != m_cutMarks.begin(); --it2)
+    {
+      if ((*it2).m_position < (*it1).m_position)
+      {
+        /* Swap position */
+        int tmp_i           = (*it1).m_position;
+        (*it1).m_position   = (*it2).m_position ;
+        (*it2).m_position   = tmp_i;
+        /* Swap comment */
+        CStdString tmp_s    = (*it1).m_comment;
+        (*it1).m_comment    = (*it2).m_comment;
+        (*it2).m_comment    = tmp_s;
+      }
+    }
+  }
+
+  return;
+}
+
+/**
+ * Initialize blank CTVRecordingInfoTag
+ */
+void CTVRecordingInfoTag::Reset(void)
+{
+  m_Index                 = -1;
+  m_channelNum            = -1;
+  m_strChannel            = "";
+  m_seriesID              = "";
+  m_episodeID             = "";
+
+  m_Summary               = "";
+
+  m_strFileNameAndPath    = "";
+  m_strClient             = "";
+  m_resumePoint           = 0;
+
+  m_videoProps.clear();
+  m_audioProps.clear();
+  m_subTypes.clear();
+
+  m_cutMarks.clear();
+
+  m_commFree              = false;
+
+  CVideoInfoTag::Reset();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVRecordInfoTag.h XBMC/xbmc/utils/TVRecordInfoTag.h
--- XBMC-unpatched/xbmc/utils/TVRecordInfoTag.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVRecordInfoTag.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,95 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * for DESCRIPTION see 'TVRecordInfoTag.cpp'
+ */
+
+#include "VideoInfoTag.h"
+#include "TVEPGInfoTag.h"
+#include "settings/VideoSettings.h"
+#include "DateTime.h"
+
+struct CutMark_t
+{
+  CStdString  m_comment;              /// Comment string
+  int         m_position;             /// Offset time from beginning in millisecond
+}; typedef std::vector< CutMark_t > CutMarks;
+
+class CTVRecordingInfoTag : public CVideoInfoTag
+{
+public:
+  CTVRecordingInfoTag();
+  //CTVRecordingInfoTag(long uniqueRecordingID);
+
+  bool operator ==(const CTVRecordingInfoTag& right) const;
+  bool operator !=(const CTVRecordingInfoTag& right) const;
+
+  const long GetDbID(void) const { return m_uniqueRecordingID; };
+
+  void Reset(void);
+
+  bool HaveMarks(void) { return m_cutMarks.size() > 0 ? true : false; }
+
+  void AddMark(int position, const CStdString &comment);
+  void DeleteAllMarks(void);
+  bool DeleteMark(int position);
+  int GetMarkPrev(int position);
+  int GetMarkNext(int position);
+
+  int           m_Index;              /// Index number of the tag, given by the backend, -1 for unknown
+  int           m_channelNum;         /// Channel number where recording from
+  CStdString    m_strChannel;         /// Channel name where recording from
+  CStdString    m_strFileNameAndPath; /// Filename for PVRManager to open and read stream
+
+  CStdString    m_Summary;            /// Summary string with the time to show inside a GUI list
+  /// see PVRManager.cpp for format.
+
+  CStdString    m_seriesID;           /// Series ID (used?)
+  CStdString    m_episodeID;          /// Episiode ID (used?)
+
+  CDateTime     m_startTime;          /// Recording start time
+  CDateTime     m_endTime;            /// Recording end time
+  CDateTimeSpan m_duration;           /// Duration
+
+  VideoProps    m_videoProps;         /// Types of video inside stream
+  AudioProps    m_audioProps;         /// Types of audio inside stream
+  SubtitleTypes m_subTypes;           /// Types of subtitles inside stream
+
+  CutMarks      m_cutMarks;           /// Data array of cutting marks
+
+  bool          m_commFree;           /// Any commercials inside stream (how detect it?)
+  CStdString    m_strClient;
+  uint64_t      m_resumePoint;
+
+  /**
+   * Following values are for individual video settings
+   **/
+  CVideoSettings m_defaultVideoSettings;
+
+private:
+  void SortMarks(void);
+
+  long          m_uniqueRecordingID;  /// db's unique identifier for this tag
+};
+
+typedef std::vector<CTVRecordingInfoTag> VECRECORDINGS;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVTimerInfoTag.cpp XBMC/xbmc/utils/TVTimerInfoTag.cpp
--- XBMC-unpatched/xbmc/utils/TVTimerInfoTag.cpp	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVTimerInfoTag.cpp	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,352 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * DESCRIPTION:
+ *
+ * CTVTimerInfoTag is part of the PVRManager to support sheduled recordings.
+ *
+ * The timer information tag holds data about current programmed timers for
+ * the PVRManager. It is possible to create timers directly based upon
+ * a EPG entry by giving the EPG information tag or as instant timer
+ * on currently tuned channel, or give a blank tag to modify later.
+ *
+ * With exception of the blank one, the tag can easily and unmodified added
+ * by the PVRManager function "bool AddTimer(const CFileItem &item)" to
+ * the backend server.
+ *
+ * It is a also CVideoInfoTag but only used for information usage, the
+ * filename inside the tag is for reference only and gives the index number
+ * of the tag reported by the PVR backend and can not be played!
+ *
+ *
+ * USED SETUP VARIABLES:
+ *
+ * ------------- Name -------------|---Type--|-default-|--Description-----
+ * pvrmanager.instantrecordtime    = Integer = 180     = Length of a instant timer in minutes
+ * pvrmanager.defaultpriority      = Integer = 50      = Default Priority
+ * pvrmanager.defaultlifetime      = Integer = 99      = Liftime of the timer in days
+ * pvrmanager.marginstart          = Integer = 2       = Minutes to start record earlier
+ * pvrmanager.marginstop           = Integer = 10      = Minutes to stop record later
+ *
+ *
+ * TODO:
+ * Nothing in the moment. Any ideas?
+ *
+ */
+
+#include "stdafx.h"
+#include "TVTimerInfoTag.h"
+#include "TVEPGInfoTag.h"
+#include "GUISettings.h"
+#include "PVRManager.h"
+#include "Util.h"
+
+
+/**
+ * Create a blank unmodified timer tag
+ */
+CTVTimerInfoTag::CTVTimerInfoTag()
+{
+  Reset();
+}
+
+/**
+ * Creates a instant timer on current date and channel if "bool Init"
+ * is set one hour later as now otherwise a blank CTVTimerInfoTag is
+ * given.
+ * \param bool Init             = Initialize as instant timer if set
+ *
+ * Note:
+ * Check active flag "m_Active" is set, after creating the tag. If it
+ * is false something goes wrong during initialization!
+ * See Log for errors.
+ */
+CTVTimerInfoTag::CTVTimerInfoTag(bool Init)
+{
+  Reset();
+
+  /* Check if instant flag is set otherwise return */
+  if (!Init)
+  {
+    CLog::Log(LOGERROR, "CTVTimerInfoTag: Can't initialize tag, Init flag not set!");
+    return;
+  }
+
+  /* Get setup variables */
+  int rectime     = g_guiSettings.GetInt("pvrrecord.instantrecordtime");
+  int defprio     = g_guiSettings.GetInt("pvrrecord.defaultpriority");
+  int deflifetime = g_guiSettings.GetInt("pvrrecord.defaultlifetime");
+
+  if (!rectime)
+  {
+    rectime     = 180; /* Default 180 minutes */
+  }
+
+  if (!defprio)
+  {
+    defprio     = 50;  /* Default */
+  }
+
+  if (!deflifetime)
+  {
+    deflifetime = 99;  /* Default 99 days */
+  }
+
+  /* Set default timer */
+  m_Index         = -1;
+  m_Active        = true;
+
+  if (CPVRManager::GetInstance()->IsPlayingTV())
+  {
+    m_Radio = false;
+    m_channelNum = CPVRManager::GetInstance()->GetCurrentChannel(false);
+    m_clientNum = CPVRManager::GetInstance()->GetClientChannelNumber(m_channelNum, false);
+  }
+  else if (CPVRManager::GetInstance()->IsPlayingRadio())
+  {
+    m_Radio = true;
+    m_channelNum = CPVRManager::GetInstance()->GetCurrentChannel(true);
+    m_clientNum = CPVRManager::GetInstance()->GetClientChannelNumber(m_channelNum, true);
+  }
+  else
+  {
+    m_Radio = false;
+    m_channelNum = 1;
+    m_clientNum = CPVRManager::GetInstance()->GetClientChannelNumber(m_channelNum, false);
+  }
+
+  if (m_channelNum == -1) m_channelNum = 1;
+
+  m_strChannel    = CPVRManager::GetInstance()->GetNameForChannel(m_channelNum, m_Radio);
+  m_strTitle      = m_strChannel;
+
+  /* Calculate start/stop times */
+  CDateTime time  = CDateTime::GetCurrentDateTime();
+  m_StartTime     = time;
+  m_StopTime      = time + CDateTimeSpan(0, rectime / 60, rectime % 60, 0);   /* Add recording time */
+
+  /* Set priority and lifetime */
+  m_Priority      = defprio;
+  m_Lifetime      = deflifetime;
+
+  /* Generate summary string */
+  m_Summary.Format("%s %s %s %s %s", m_StartTime.GetAsLocalizedDate()
+                   , g_localizeStrings.Get(18078)
+                   , m_StartTime.GetAsLocalizedTime("",false)
+                   , g_localizeStrings.Get(18079)
+                   , m_StopTime.GetAsLocalizedTime("",false));
+
+  m_strFileNameAndPath = "timer://new"; /* Unused only for reference */
+
+  return;
+}
+
+/**
+ * Create Timer based upon an TVEPGInfoTag
+ * \param const CFileItem& item = reference to CTVEPGInfoTag class
+ *
+ * Note:
+ * Check active flag "m_Active" is set, after creating the tag. If it
+ * is false something goes wrong during initialization!
+ * See Log for errors.
+ */
+CTVTimerInfoTag::CTVTimerInfoTag(const CFileItem& item)
+{
+
+  Reset();
+
+  /* Is file item a CTVEPGInfoTag ? */
+
+  if (!item.IsTVEPG())
+  {
+    CLog::Log(LOGERROR, "CTVTimerInfoTag: Can't initialize tag, no EPGInfoTag given!");
+    return;
+  }
+
+  const CTVEPGInfoTag* tag = item.GetTVEPGInfoTag();
+
+  /* Check epg end date is in the future */
+  if (tag->m_endTime < CDateTime::GetCurrentDateTime())
+  {
+    CLog::Log(LOGERROR, "CTVTimerInfoTag: Can't initialize tag, EPGInfoTag is in the past!");
+    return;
+  }
+
+  /* Get setup variables */
+  int defprio     = g_guiSettings.GetInt("pvrrecord.defaultpriority");
+  int deflifetime = g_guiSettings.GetInt("pvrrecord.defaultlifetime");
+  int marginstart = g_guiSettings.GetInt("pvrrecord.marginstart");
+  int marginstop  = g_guiSettings.GetInt("pvrrecord.marginstop");
+
+  if (!defprio)
+  {
+    defprio     = 50;  /* Default */
+  }
+
+  if (!deflifetime)
+  {
+    deflifetime = 99;  /* Default 99 days */
+  }
+
+  if (!deflifetime)
+  {
+    marginstart = 2;   /* Default start 2 minutes earlier */
+  }
+
+  if (!deflifetime)
+  {
+    marginstop  = 10;  /* Default stop 10 minutes later */
+  }
+
+  /* Set timer based on EPG entry */
+  m_Index         = -1;
+  m_Active        = true;
+  m_channelNum    = tag->m_channelNum;
+  m_clientNum     = CPVRManager::GetInstance()->GetClientChannelNumber(m_channelNum, tag->m_isRadio);
+  m_strChannel    = CPVRManager::GetInstance()->GetNameForChannel(m_channelNum, tag->m_isRadio);
+  m_strTitle      = tag->m_strTitle;
+
+  if (m_strTitle.IsEmpty())
+  {
+    m_strTitle  = m_strChannel;
+  }
+
+  /* Calculate start/stop times */
+  m_StartTime     = tag->m_startTime - CDateTimeSpan(0, marginstart / 60, marginstart % 60, 0);
+  m_StopTime      = tag->m_endTime  + CDateTimeSpan(0, marginstop / 60, marginstop % 60, 0);
+
+  /* Set priority and lifetime */
+  m_Priority      = defprio;
+  m_Lifetime      = deflifetime;
+
+  /* Generate summary string */
+  m_Summary.Format("%s %s %s %s %s", m_StartTime.GetAsLocalizedDate()
+                   , g_localizeStrings.Get(18078)
+                   , m_StartTime.GetAsLocalizedTime("",false)
+                   , g_localizeStrings.Get(18079)
+                   , m_StopTime.GetAsLocalizedTime("",false));
+
+  m_strFileNameAndPath = "timer://new"; /* Unused only for reference */
+
+  return;
+}
+
+bool CTVTimerInfoTag::operator ==(const CTVTimerInfoTag& right) const
+{
+
+  if (this == &right) return true;
+
+  return (m_Index                 == right.m_Index &&
+          m_Active                == right.m_Active &&
+          m_Summary               == right.m_Summary &&
+          m_channelNum            == right.m_channelNum &&
+          m_clientNum             == right.m_clientNum &&
+          m_Radio                 == right.m_Radio &&
+          m_strChannel            == right.m_strChannel &&
+          m_Repeat                == right.m_Repeat &&
+          m_StartTime             == right.m_StartTime &&
+          m_StopTime              == right.m_StopTime &&
+          m_FirstDay              == right.m_FirstDay &&
+          m_Repeat_Mon            == right.m_Repeat_Mon &&
+          m_Repeat_Tue            == right.m_Repeat_Tue &&
+          m_Repeat_Wed            == right.m_Repeat_Wed &&
+          m_Repeat_Thu            == right.m_Repeat_Thu &&
+          m_Repeat_Fri            == right.m_Repeat_Fri &&
+          m_Repeat_Sat            == right.m_Repeat_Sat &&
+          m_Repeat_Sun            == right.m_Repeat_Sun &&
+          m_recStatus             == right.m_recStatus &&
+          m_Priority              == right.m_Priority &&
+          m_Lifetime              == right.m_Lifetime &&
+          m_strFileNameAndPath    == right.m_strFileNameAndPath &&
+          m_strTitle              == right.m_strTitle);
+}
+
+bool CTVTimerInfoTag::operator !=(const CTVTimerInfoTag& right) const
+{
+
+  if (this == &right) return false;
+
+  return (m_Index                 != right.m_Index &&
+          m_Active                != right.m_Active &&
+          m_Summary               != right.m_Summary &&
+          m_channelNum            != right.m_channelNum &&
+          m_clientNum             != right.m_clientNum &&
+          m_Radio                 != right.m_Radio &&
+          m_strChannel            != right.m_strChannel &&
+          m_Repeat                != right.m_Repeat &&
+          m_StartTime             != right.m_StartTime &&
+          m_StopTime              != right.m_StopTime &&
+          m_FirstDay              != right.m_FirstDay &&
+          m_Repeat_Mon            != right.m_Repeat_Mon &&
+          m_Repeat_Tue            != right.m_Repeat_Tue &&
+          m_Repeat_Wed            != right.m_Repeat_Wed &&
+          m_Repeat_Thu            != right.m_Repeat_Thu &&
+          m_Repeat_Fri            != right.m_Repeat_Fri &&
+          m_Repeat_Sat            != right.m_Repeat_Sat &&
+          m_Repeat_Sun            != right.m_Repeat_Sun &&
+          m_recStatus             != right.m_recStatus &&
+          m_Priority              != right.m_Priority &&
+          m_Lifetime              != right.m_Lifetime &&
+          m_strFileNameAndPath    != right.m_strFileNameAndPath &&
+          m_strTitle              != right.m_strTitle);
+}
+
+/**
+ * Initialize blank CTVTimerInfoTag
+ */
+void CTVTimerInfoTag::Reset()
+{
+
+  m_Index         = -1;
+  m_Active        = false;
+
+  m_Summary       = "";
+
+  m_channelNum    = -1;
+  m_clientNum     = -1;
+  m_Radio         = false;
+  m_strChannel    = "";
+
+  m_Repeat        = false;
+  m_StartTime     = NULL;
+  m_StopTime      = NULL;
+  m_FirstDay      = NULL;
+  m_iStartTime    = NULL;
+  m_iStopTime     = NULL;
+  m_iFirstDay     = NULL;
+  m_Repeat_Mon    = false;
+  m_Repeat_Tue    = false;
+  m_Repeat_Wed    = false;
+  m_Repeat_Thu    = false;
+  m_Repeat_Fri    = false;
+  m_Repeat_Sat    = false;
+  m_Repeat_Sun    = false;
+
+  m_recStatus     = false;
+
+  m_Priority      = -1;
+  m_Lifetime      = -1;
+
+  m_strFileNameAndPath = "";
+
+  CVideoInfoTag::Reset();
+}
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/utils/TVTimerInfoTag.h XBMC/xbmc/utils/TVTimerInfoTag.h
--- XBMC-unpatched/xbmc/utils/TVTimerInfoTag.h	1970-01-01 01:00:00.000000000 +0100
+++ XBMC/xbmc/utils/TVTimerInfoTag.h	2009-04-04 20:52:44.000000000 +0200
@@ -0,0 +1,78 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * for DESCRIPTION see 'TVTimerInfoTag.cpp'
+ */
+
+#include "VideoInfoTag.h"
+#include "DateTime.h"
+#include "FileItem.h"
+
+class CTVTimerInfoTag : public CVideoInfoTag
+{
+public:
+  CTVTimerInfoTag();
+  CTVTimerInfoTag(const CFileItem& item);
+  CTVTimerInfoTag(bool Init);
+
+  bool operator ==(const CTVTimerInfoTag& right) const;
+  bool operator !=(const CTVTimerInfoTag& right) const;
+
+  void Reset();
+
+  int             m_Index;                /// Index number of the tag, given by the backend, -1 for new
+  bool            m_Active;               /// Active flag, if it is false backend ignore the timer
+
+  CStdString      m_Summary;              /// Summary string with the time to show inside a GUI list
+  /// see PVRManager.cpp for format.
+
+  int             m_channelNum;           /// Integer value of the channel number
+  int             m_clientNum;            /// Integer value of the client number
+  CStdString      m_strChannel;           /// String name of the channel
+  bool            m_Radio;                /// Is Radio channel if set
+
+  bool            m_Repeat;               /// Repeating timer if true, use the m_FirstDay and repeat flags
+  CDateTime       m_StartTime;            /// Start time
+  time_t          m_iStartTime;           /// as time_t (if you get time_t from CDateTime it is always different)
+  CDateTime       m_StopTime;             /// Stop time
+  time_t          m_iStopTime;            /// as time_t (if you get time_t from CDateTime it is always different)
+  CDateTime       m_FirstDay;             /// If it is a repeating timer the first date it starts
+  time_t          m_iFirstDay;            ///
+  bool            m_Repeat_Mon;           /// Repeat sheduled recording every monday
+  bool            m_Repeat_Tue;           /// Repeat sheduled recording every tuesday
+  bool            m_Repeat_Wed;           /// Repeat sheduled recording every wednesday
+  bool            m_Repeat_Thu;           /// Repeat sheduled recording every thursday
+  bool            m_Repeat_Fri;           /// Repeat sheduled recording every friday
+  bool            m_Repeat_Sat;           /// Repeat sheduled recording every saturday
+  bool            m_Repeat_Sun;           /// Repeat sheduled recording every sunday
+
+  bool            m_recStatus;
+
+  int             m_Priority;             /// Priority of the timer
+  int             m_Lifetime;             /// Lifetime of the timer in days
+
+  CStdString      m_strFileNameAndPath;   /// Filename is only for reference
+
+};
+
+typedef std::vector<CTVTimerInfoTag> VECTVTIMERS;
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/VideoInfoScanner.cpp XBMC/xbmc/VideoInfoScanner.cpp
--- XBMC-unpatched/xbmc/VideoInfoScanner.cpp	2009-04-22 19:13:48.000000000 +0200
+++ XBMC/xbmc/VideoInfoScanner.cpp	2009-04-13 21:49:00.000000000 +0200
@@ -296,7 +296,7 @@
     CLog::Log(LOGDEBUG,"Hash[%s,%s]:DB=[%s],Computed=[%s]",
       m_info.strContent.c_str(),strDirectory.c_str(),dbHash.c_str(),hash.c_str());
 
-    if (!m_info.settings.GetPluginRoot() && m_info.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
+    if (!m_info.settings.GetAddonRoot() && m_info.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
     {
       CScraperParser parser;
       CStdString strPath;
@@ -411,7 +411,7 @@
       if (info2.strContent.Equals("None")) // skip
         continue;
 
-    if (!info2.settings.GetPluginRoot() && info2.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
+    if (!info2.settings.GetAddonRoot() && info2.settings.GetSettings().IsEmpty()) // check for settings, if they are around load defaults - to workaround the nastyness
     {
       CScraperParser parser;
       if (parser.Load("special://xbmc/system/scrapers/video/"+info2.strPath) && parser.HasFunction("GetSettings"))
diff -NaurwB --exclude-from=diff-excludes XBMC-unpatched/xbmc/cores/DllLoader/DllLoaderContainer.cpp XBMC/xbmc/cores/DllLoader/DllLoaderContainer.cpp
--- XBMC-unpatched/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2009-04-22 19:10:50.000000000 +0200
+++ XBMC/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2009-04-08 20:02:46.000000000 +0200
@@ -278,7 +278,7 @@
   LibraryLoader* pLoader;
 #ifdef _LINUX
   if (strstr(sName, ".so") != NULL || strstr(sName, ".vis") != NULL || strstr(sName, ".xbs") != NULL
-      || strstr(sName, ".mvis") != NULL)
+      || strstr(sName, ".mvis") != NULL || strstr(sName, ".pvr") != NULL)
     pLoader = new SoLoader(sName, bLoadSymbols);
   else
 #elif defined(_WIN32PC)
